[
    {
        "func_name": "meth_QMutexLocker___enter__",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid meth_QMutexLocker___enter__(int *param_1,undefined4 param_2)\n{\n  int iVar1;\n  int *piVar2;\n  int *local_24 [2];\n  undefined4 local_1c;\n  undefined auStack_18 [4];\n  int local_14;\n  local_14 = __stack_chk_guard;\n  local_1c = 0;\n  local_24[0] = param_1;\n  iVar1 = (**(code **)(DAT_0028fe00 + 0x140))\n                    (&local_1c,param_2,&DAT_00222c60,local_24,DAT_0028c910,auStack_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_0028fe00 + 0x150))\n              (local_1c,\"QMutexLocker\",\"__enter__\",\"__enter__(self) -> object\");\n    piVar2 = (int *)0x0;\n  }\n  else {\n    *local_24[0] = *local_24[0] + 1;\n    piVar2 = local_24[0];\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(piVar2);\n}",
        "output": "```c\nvoid mutexLockerEnter(int *mutex, undefined4 param) {\n    int result;\n    int *mutexPointer;\n    int *mutexArray[2];\n    undefined4 lockStatus;\n    undefined stackBuffer[4];\n    int stackGuard;\n\n    stackGuard = __stack_chk_guard;\n    lockStatus = 0;\n    mutexArray[0] = mutex;\n\n    result = (*(code *)(DAT_0028fe00 + 0x140))(&lockStatus, param, &DAT_00222c60, mutexArray, DAT_0028c910, stackBuffer);\n    \n    if (result == 0) {\n        (*(code *)(DAT_0028fe00 + 0x150))(lockStatus, \"QMutexLocker\", \"__enter__\", \"__enter__(self) -> object\");\n        mutexPointer = NULL;\n    } else {\n        *mutexArray[0] += 1;\n        mutexPointer = mutexArray[0];\n    }\n\n    if (stackGuard == __stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail(mutexPointer);\n}\n```",
        "normed_func_sha256": "8d84728ebb9bcb2866951b1edf4427363fa90ccb07f1f16e1981d2c04137e495",
        "source_code": "static PyObject *meth_QMutexLocker___enter__(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n\n    {\n         ::QMutexLocker *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_QMutexLocker, &sipCpp))\n        {\n            PyObject * sipRes = SIP_NULLPTR;\n\n#line 37 \"/builddir/build/BUILD/PyQt5-5.13.2/armv7hl-redhat-linux-gnueabi-python3/sip/QtCore/qmutex.sip\"\n        // Just return a reference to self.\n        sipRes = sipSelf;\n        Py_INCREF(sipRes);\n#line 139 \"/builddir/build/BUILD/PyQt5-5.13.2/armv7hl-redhat-linux-gnueabi-python3/QtCore/sipQtCoreQMutexLocker.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QMutexLocker, sipName___enter__, doc_QMutexLocker___enter__);\n\n    return SIP_NULLPTR;\n}",
        "parsed_output": "void mutexLockerEnter(int *mutex, undefined4 param) {\n    int result;\n    int *mutexPointer;\n    int *mutexArray[2];\n    undefined4 lockStatus;\n    undefined stackBuffer[4];\n    int stackGuard;\n\n    stackGuard = __stack_chk_guard;\n    lockStatus = 0;\n    mutexArray[0] = mutex;\n\n    result = (*(code *)(DAT_0028fe00 + 0x140))(&lockStatus, param, &DAT_00222c60, mutexArray, DAT_0028c910, stackBuffer);\n    \n    if (result == 0) {\n        (*(code *)(DAT_0028fe00 + 0x150))(lockStatus, \"QMutexLocker\", \"__enter__\", \"__enter__(self) -> object\");\n        mutexPointer = NULL;\n    } else {\n        *mutexArray[0] += 1;\n        mutexPointer = mutexArray[0];\n    }\n\n    if (stackGuard == __stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail(mutexPointer);\n}",
        "baseline_code_stripped": "void meth_QMutexLocker___enter__(int *param_1,undefined4 param_2)\n{\n  int iVar1;\n  int *piVar2;\n  int *local_24 [2];\n  undefined4 local_1c;\n  undefined auStack_18 [4];\n  int local_14;\n  local_14 = __stack_chk_guard;\n  local_1c = 0;\n  local_24[0] = param_1;\n  iVar1 = (**(code **)(DAT_0028fe00 + 0x140))\n                    (&local_1c,param_2,&DAT_00222c60,local_24,DAT_0028c910,auStack_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_0028fe00 + 0x150))\n              (local_1c,\"QMutexLocker\",\"__enter__\",\"__enter__(self) -> object\");\n    piVar2 = (int *)0x0;\n  }\n  else {\n    *local_24[0] = *local_24[0] + 1;\n    piVar2 = local_24[0];\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(piVar2);\n}",
        "similarity_score_unixcoder": 0.5909597873687744,
        "similarity_score_baseline_stripped": 0.5935357809066772
    },
    {
        "func_name": "Bwd::exec",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00278250(void)\n{\n  long in_stack_00000038;\n  long in_stack_00000090;\n  long in_stack_00000098;\n  long in_stack_000000a0;\n  long in_stack_000000a8;\n  void *in_stack_00000140;\n  __cxa_guard_abort();\n  if (in_stack_00000140 != (void *)0x0) {\n    operator_delete(in_stack_00000140);\n  }\n  in_stack_000000a0 = in_stack_00000038 + 0x10;\n  if (in_stack_000000a8 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x000000a0);\n  }\n  in_stack_00000090 = in_stack_00000038 + 0x10;\n  if (in_stack_00000098 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x00000090);\n    FUN_0027820b();\n    return;\n  }\n  FUN_005f9e00();\n  _Unwind_Resume();\n}",
        "output": "```c\nvoid cleanup_function(void)\n{\n    long stack_var_38;\n    long stack_var_90;\n    long stack_var_98;\n    long stack_var_a0;\n    long stack_var_a8;\n    void *object_to_delete;\n    \n    __cxa_guard_abort();\n    \n    if (object_to_delete != NULL) {\n        operator_delete(object_to_delete);\n    }\n    \n    stack_var_a0 = stack_var_38 + 0x10;\n    \n    if (stack_var_a8 != 0) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack_var_a0);\n    }\n    \n    stack_var_90 = stack_var_38 + 0x10;\n    \n    if (stack_var_98 != 0) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack_var_90);\n        FUN_0027820b();\n        return;\n    }\n    \n    FUN_005f9e00();\n    _Unwind_Resume();\n}\n```",
        "normed_func_sha256": "bb57c5b030ae8b75e8aaf13ac5a79bc437f43836efc7e7ddef812955a7247cc1",
        "source_code": "void Bwd::exec(\n        _megdnn_tensor_in data, _megdnn_tensor_in rois, _megdnn_tensor_in trans,\n        _megdnn_tensor_in out_diff, _megdnn_tensor_in out_count,\n        _megdnn_tensor_out data_diff, _megdnn_tensor_out trans_diff,\n        _megdnn_workspace workspace) {\n    check_exec(\n            data.layout, rois.layout, trans.layout, out_diff.layout, out_count.layout,\n            data_diff.layout, trans_diff.layout, workspace.size);\n    auto kern = [data, rois, trans, out_diff, out_count, data_diff,\n                 trans_diff](const DeformablePSROIPoolingBase::Param& param) {\n        bool no_trans = param.no_trans;\n        size_t pool_h = param.pooled_h, pool_w = param.pooled_w;\n        size_t part_sz = param.part_size, sample_per_part = param.sample_per_part;\n        float trans_std = param.trans_std, scale = param.spatial_scale;\n        size_t nr_bbox = rois.layout[0];\n        size_t nr_cls = no_trans ? 1 : trans.layout[1] / 2;\n        size_t IC = data.layout[1], IH = data.layout[2], IW = data.layout[3];\n        const float* data_ptr = data.ptr<float>();\n        const float* rois_ptr = rois.ptr<float>();\n        const float* trans_ptr = trans.ptr<float>();\n        const float* out_diff_ptr = out_diff.ptr<float>();\n        const float* out_count_ptr = out_count.ptr<float>();\n        float* data_diff_ptr = data_diff.ptr<float>();\n        float* trans_diff_ptr = trans_diff.ptr<float>();\n        auto&& data_diff_elems = data_diff.layout.total_nr_elems();\n        auto&& trans_diff_elems = trans_diff.layout.total_nr_elems();\n        size_t data_diff_bytes = sizeof(float[data_diff_elems]);\n        size_t trans_diff_bytes = sizeof(float[trans_diff_elems]);\n        memset(data_diff_ptr, 0, data_diff_bytes);\n        memset(trans_diff_ptr, 0, trans_diff_bytes);\n        deformable_ps_roi_pool_backward_acc_kernel(\n                data_ptr, rois_ptr, trans_ptr, out_diff_ptr, out_count_ptr,\n                data_diff_ptr, trans_diff_ptr, IC, IH, IW, no_trans, nr_bbox, nr_cls,\n                pool_h, pool_w, part_sz, sample_per_part, trans_std, scale);\n    };\n    MEGDNN_DISPATCH_CPU_KERN_OPR(kern(param()));\n    return;\n}",
        "parsed_output": "void cleanup_function(void)\n{\n    long stack_var_38;\n    long stack_var_90;\n    long stack_var_98;\n    long stack_var_a0;\n    long stack_var_a8;\n    void *object_to_delete;\n    \n    __cxa_guard_abort();\n    \n    if (object_to_delete != NULL) {\n        operator_delete(object_to_delete);\n    }\n    \n    stack_var_a0 = stack_var_38 + 0x10;\n    \n    if (stack_var_a8 != 0) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack_var_a0);\n    }\n    \n    stack_var_90 = stack_var_38 + 0x10;\n    \n    if (stack_var_98 != 0) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack_var_90);\n        FUN_0027820b();\n        return;\n    }\n    \n    FUN_005f9e00();\n    _Unwind_Resume();\n}",
        "baseline_code_stripped": "void FUN_00278250(void)\n{\n  long in_stack_00000038;\n  long in_stack_00000090;\n  long in_stack_00000098;\n  long in_stack_000000a0;\n  long in_stack_000000a8;\n  void *in_stack_00000140;\n  __cxa_guard_abort();\n  if (in_stack_00000140 != (void *)0x0) {\n    operator_delete(in_stack_00000140);\n  }\n  in_stack_000000a0 = in_stack_00000038 + 0x10;\n  if (in_stack_000000a8 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x000000a0);\n  }\n  in_stack_00000090 = in_stack_00000038 + 0x10;\n  if (in_stack_00000098 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x00000090);\n    FUN_0027820b();\n    return;\n  }\n  FUN_005f9e00();\n  _Unwind_Resume();\n}",
        "similarity_score_unixcoder": 0.3934735357761383,
        "similarity_score_baseline_stripped": 0.41310906410217285
    },
    {
        "func_name": "ComponentAction::createWidget",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nQComboBox * FUN_002adc00(char *param_1,QWidget *param_2)\n{\n  QComboBox *this;\n  undefined8 uVar1;\n  int *local_28 [2];\n  this = (QComboBox *)operator_new(0x30);\n  QComboBox::QComboBox(this,param_2);\n  QWidget::setMinimumWidth((int)this);\n  QMetaObject::tr((char *)local_28,(char *)&PTR_staticMetaObject_006071e0,0x368dc0);\n  QWidget::setToolTip((QString *)this);\n  if (*local_28[0] != 0) {\n    if (*local_28[0] == -1) goto LAB_002adc7c;\n    LOCK();\n    *local_28[0] = *local_28[0] + -1;\n    UNLOCK();\n    if (*local_28[0] != 0) goto LAB_002adc7c;\n  }\n  QArrayData::deallocate((QArrayData *)local_28[0],2,8);\nLAB_002adc7c:\n  uVar1 = 0;\n  if ((*(long *)(param_1 + 0x10) != 0) && (*(int *)(*(long *)(param_1 + 0x10) + 4) != 0)) {\n    uVar1 = *(undefined8 *)(param_1 + 0x18);\n  }\n  FUN_002ae0f0(uVar1);\n  QComboBox::setModel((QAbstractItemModel *)this);\n  QComboBox::setCurrentIndex((int)this);\n  QObject::connect((QObject *)local_28,(char *)this,(QObject *)\"2activated(int)\",param_1,0x368df0);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  QObject::connect((QObject *)local_28,param_1,(QObject *)\"2currentIndexChanged(int)\",(char *)this,\n                   0x368e22);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  return this;\n}",
        "output": "```c\nQComboBox * createComboBox(char *param_1, QWidget *parentWidget) {\n    QComboBox *comboBox = (QComboBox *)operator_new(0x30);\n    QComboBox::QComboBox(comboBox, parentWidget);\n    QWidget::setMinimumWidth((int)comboBox);\n    \n    int *referenceCount[2];\n    QMetaObject::tr((char *)referenceCount, (char *)&PTR_staticMetaObject_006071e0, 0x368dc0);\n    QWidget::setToolTip((QString *)comboBox);\n    \n    if (*referenceCount[0] != 0) {\n        if (*referenceCount[0] == -1) {\n            goto cleanup;\n        }\n        LOCK();\n        *referenceCount[0] -= 1;\n        UNLOCK();\n        if (*referenceCount[0] != 0) {\n            goto cleanup;\n        }\n    }\n    QArrayData::deallocate((QArrayData *)referenceCount[0], 2, 8);\n    \ncleanup:\n    undefined8 modelData = 0;\n    if ((*(long *)(param_1 + 0x10) != 0) && (*(int *)(*(long *)(param_1 + 0x10) + 4) != 0)) {\n        modelData = *(undefined8 *)(param_1 + 0x18);\n    }\n    FUN_002ae0f0(modelData);\n    \n    QComboBox::setModel((QAbstractItemModel *)comboBox);\n    QComboBox::setCurrentIndex((int)comboBox);\n    \n    QObject::connect((QObject *)referenceCount, (char *)comboBox, (QObject *)\"2activated(int)\", param_1, 0x368df0);\n    QMetaObject::Connection::_Connection((Connection *)referenceCount);\n    \n    QObject::connect((QObject *)referenceCount, param_1, (QObject *)\"2currentIndexChanged(int)\", (char *)comboBox, 0x368e22);\n    QMetaObject::Connection::_Connection((Connection *)referenceCount);\n    \n    return comboBox;\n}\n```",
        "normed_func_sha256": "20cfc8978db3889b40b1b6f2ce20b86bd2c0fa4953543fc07d3890bbb64e0f62",
        "source_code": "QWidget  *ComponentAction::createWidget(QWidget *parent)\n{\n    QComboBox *comboBox = new QComboBox(parent);\n    comboBox->setMinimumWidth(120);\n    comboBox->setToolTip(tr(\"Edit sub components defined in this file.\"));\n    comboBox->setModel(m_componentView->standardItemModel());\n    comboBox->setCurrentIndex(-1);\n    connect(comboBox, SIGNAL(activated(int)), SLOT(emitCurrentComponentChanged(int)));\n    connect(this, SIGNAL(currentIndexChanged(int)), comboBox, SLOT(setCurrentIndex(int)));\n\n    return comboBox;\n}",
        "parsed_output": "QComboBox * createComboBox(char *param_1, QWidget *parentWidget) {\n    QComboBox *comboBox = (QComboBox *)operator_new(0x30);\n    QComboBox::QComboBox(comboBox, parentWidget);\n    QWidget::setMinimumWidth((int)comboBox);\n    \n    int *referenceCount[2];\n    QMetaObject::tr((char *)referenceCount, (char *)&PTR_staticMetaObject_006071e0, 0x368dc0);\n    QWidget::setToolTip((QString *)comboBox);\n    \n    if (*referenceCount[0] != 0) {\n        if (*referenceCount[0] == -1) {\n            goto cleanup;\n        }\n        LOCK();\n        *referenceCount[0] -= 1;\n        UNLOCK();\n        if (*referenceCount[0] != 0) {\n            goto cleanup;\n        }\n    }\n    QArrayData::deallocate((QArrayData *)referenceCount[0], 2, 8);\n    \ncleanup:\n    undefined8 modelData = 0;\n    if ((*(long *)(param_1 + 0x10) != 0) && (*(int *)(*(long *)(param_1 + 0x10) + 4) != 0)) {\n        modelData = *(undefined8 *)(param_1 + 0x18);\n    }\n    FUN_002ae0f0(modelData);\n    \n    QComboBox::setModel((QAbstractItemModel *)comboBox);\n    QComboBox::setCurrentIndex((int)comboBox);\n    \n    QObject::connect((QObject *)referenceCount, (char *)comboBox, (QObject *)\"2activated(int)\", param_1, 0x368df0);\n    QMetaObject::Connection::_Connection((Connection *)referenceCount);\n    \n    QObject::connect((QObject *)referenceCount, param_1, (QObject *)\"2currentIndexChanged(int)\", (char *)comboBox, 0x368e22);\n    QMetaObject::Connection::_Connection((Connection *)referenceCount);\n    \n    return comboBox;\n}",
        "baseline_code_stripped": "QComboBox * FUN_002adc00(char *param_1,QWidget *param_2)\n{\n  QComboBox *this;\n  undefined8 uVar1;\n  int *local_28 [2];\n  this = (QComboBox *)operator_new(0x30);\n  QComboBox::QComboBox(this,param_2);\n  QWidget::setMinimumWidth((int)this);\n  QMetaObject::tr((char *)local_28,(char *)&PTR_staticMetaObject_006071e0,0x368dc0);\n  QWidget::setToolTip((QString *)this);\n  if (*local_28[0] != 0) {\n    if (*local_28[0] == -1) goto LAB_002adc7c;\n    LOCK();\n    *local_28[0] = *local_28[0] + -1;\n    UNLOCK();\n    if (*local_28[0] != 0) goto LAB_002adc7c;\n  }\n  QArrayData::deallocate((QArrayData *)local_28[0],2,8);\nLAB_002adc7c:\n  uVar1 = 0;\n  if ((*(long *)(param_1 + 0x10) != 0) && (*(int *)(*(long *)(param_1 + 0x10) + 4) != 0)) {\n    uVar1 = *(undefined8 *)(param_1 + 0x18);\n  }\n  FUN_002ae0f0(uVar1);\n  QComboBox::setModel((QAbstractItemModel *)this);\n  QComboBox::setCurrentIndex((int)this);\n  QObject::connect((QObject *)local_28,(char *)this,(QObject *)\"2activated(int)\",param_1,0x368df0);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  QObject::connect((QObject *)local_28,param_1,(QObject *)\"2currentIndexChanged(int)\",(char *)this,\n                   0x368e22);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  return this;\n}",
        "similarity_score_unixcoder": 0.6720224022865295,
        "similarity_score_baseline_stripped": 0.6004320979118347
    },
    {
        "func_name": "sipQgsCalloutWidget::sipProtectVirt_event",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sipQgsCalloutWidget::sipProtectVirt_event(bool param_1,QEvent *param_2)\n{\n  undefined3 in_stack_00000005;\n  if ((char)param_2 == '\\0') {\n    (**(code **)(*_param_1 + 0x14))();\n    return;\n  }\n  QWidget::event((QEvent *)_param_1);\n  return;\n}",
        "output": "```c\nvoid sipQgsCalloutWidget::sipProtectVirt_event(bool isEventNull, QEvent *event)\n{\n    if (isEventNull) {\n        (*(code **)(*_param_1 + 0x14))();\n        return;\n    }\n    QWidget::event(event);\n    return;\n}\n```",
        "normed_func_sha256": "ac69765da0ed4cf3151c8fbe35de79ff95d20beabfe09e2e7d72ebc0a4eb9190",
        "source_code": "bool sipQgsCalloutWidget::sipProtectVirt_event(bool sipSelfWasArg, ::QEvent*a0)\n{\n    return (sipSelfWasArg ? ::QWidget::event(a0) : event(a0));\n}",
        "parsed_output": "void sipQgsCalloutWidget::sipProtectVirt_event(bool isEventNull, QEvent *event)\n{\n    if (isEventNull) {\n        (*(code **)(*_param_1 + 0x14))();\n        return;\n    }\n    QWidget::event(event);\n    return;\n}",
        "baseline_code_stripped": "void sipQgsCalloutWidget::sipProtectVirt_event(bool param_1,QEvent *param_2)\n{\n  undefined3 in_stack_00000005;\n  if ((char)param_2 == '\\0') {\n    (**(code **)(*_param_1 + 0x14))();\n    return;\n  }\n  QWidget::event((QEvent *)_param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.816746711730957,
        "similarity_score_baseline_stripped": 0.7690246105194092
    },
    {
        "func_name": "convertFrom_QList_0600QPair_0100QByteArray_0100QString",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint * convertFrom_QList_0600QPair_0100QByteArray_0100QString(int *param_1,undefined4 param_2)\n{\n  bool bVar1;\n  int *piVar2;\n  int **ppiVar3;\n  int **ppiVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int *piVar9;\n  int iVar10;\n  int **ppiVar11;\n  piVar2 = (int *)PyList_New(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8));\n  if (piVar2 != (int *)0x0) {\n    iVar7 = *param_1;\n    iVar8 = *(int *)(iVar7 + 8);\n    if (0 < *(int *)(iVar7 + 0xc) - iVar8) {\n      iVar10 = 0;\n      do {\n        ppiVar11 = *(int ***)(iVar7 + (iVar8 + iVar10) * 4 + 0x14);\n        ppiVar3 = (int **)operator_new(4);\n        piVar9 = *ppiVar11;\n        *ppiVar3 = piVar9;\n        do {\n          bVar1 = (bool)hasExclusiveAccess(piVar9);\n        } while (!bVar1);\n        *piVar9 = *piVar9 + 1;\n        ppiVar4 = (int **)operator_new(4);\n        piVar9 = ppiVar11[1];\n        *ppiVar4 = piVar9;\n        do {\n          bVar1 = (bool)hasExclusiveAccess(piVar9);\n        } while (!bVar1);\n        *piVar9 = *piVar9 + 1;\n        iVar5 = (**(code **)(sipAPI_phonon + 0x1c))\n                          (0,&DAT_00063480,ppiVar3,sipImportedTypes_phonon_QtCore._4_4_,param_2,\n                           ppiVar4,sipImportedTypes_phonon_QtCore._56_4_,param_2);\n        if (iVar5 == 0) {\n          iVar7 = *piVar2;\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            (**(code **)(piVar2[1] + 0x18))(piVar2);\n          }\n          piVar2 = *ppiVar3;\n          do {\n            iVar7 = *piVar2;\n            bVar1 = (bool)hasExclusiveAccess(piVar2);\n          } while (!bVar1);\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            qFree(*ppiVar3);\n          }\n          operator_delete(ppiVar3,4);\n          piVar2 = *ppiVar4;\n          do {\n            iVar7 = *piVar2;\n            bVar1 = (bool)hasExclusiveAccess(piVar2);\n          } while (!bVar1);\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            QString::free((Data *)*ppiVar4);\n          }\n          operator_delete(ppiVar4,4);\n          return (int *)0x0;\n        }\n        iVar7 = *param_1;\n        iVar8 = *(int *)(iVar7 + 8);\n        iVar6 = *(int *)(iVar7 + 0xc);\n        *(int *)(piVar2[3] + iVar10 * 4) = iVar5;\n        iVar10 = iVar10 + 1;\n      } while (iVar10 < iVar6 - iVar8);\n    }\n  }\n  return piVar2;\n}",
        "output": "```c\nint * convertFrom_QList_0600QPair_0100QByteArray_0100QString(int *param_1, undefined4 param_2) {\n    bool hasAccess;\n    int *resultList;\n    int **sourcePair;\n    int **tempPair;\n    int currentIndex;\n    int startIndex;\n    int endIndex;\n    int itemCount;\n    int *currentItem;\n    int itemValue;\n    int **itemPair;\n    \n    resultList = (int *)PyList_New(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8));\n    if (resultList != NULL) {\n        currentIndex = *param_1;\n        startIndex = *(int *)(currentIndex + 8);\n        endIndex = *(int *)(currentIndex + 0xc);\n        \n        if (0 < endIndex - startIndex) {\n            itemCount = 0;\n            do {\n                itemPair = *(int ***)(currentIndex + (startIndex + itemCount) * 4 + 0x14);\n                sourcePair = (int **)operator_new(4);\n                currentItem = *itemPair;\n                *sourcePair = currentItem;\n                \n                do {\n                    hasAccess = (bool)hasExclusiveAccess(currentItem);\n                } while (!hasAccess);\n                \n                *currentItem += 1;\n                tempPair = (int **)operator_new(4);\n                currentItem = itemPair[1];\n                *tempPair = currentItem;\n                \n                do {\n                    hasAccess = (bool)hasExclusiveAccess(currentItem);\n                } while (!hasAccess);\n                \n                *currentItem += 1;\n                itemValue = (**(code **)(sipAPI_phonon + 0x1c))(0, &DAT_00063480, sourcePair, sipImportedTypes_phonon_QtCore._4_4_, param_2, tempPair, sipImportedTypes_phonon_QtCore._56_4_, param_2);\n                \n                if (itemValue == 0) {\n                    int currentCount = *resultList;\n                    *resultList -= 1;\n                    \n                    if (currentCount - 1 == 0) {\n                        (**(code **)(resultList[1] + 0x18))(resultList);\n                    }\n                    \n                    resultList = *sourcePair;\n                    do {\n                        currentCount = *resultList;\n                        hasAccess = (bool)hasExclusiveAccess(resultList);\n                    } while (!hasAccess);\n                    \n                    *resultList -= 1;\n                    if (currentCount - 1 == 0) {\n                        qFree(*sourcePair);\n                    }\n                    \n                    operator_delete(sourcePair, 4);\n                    resultList = *tempPair;\n                    do {\n                        currentCount = *resultList;\n                        hasAccess = (bool)hasExclusiveAccess(resultList);\n                    } while (!hasAccess);\n                    \n                    *resultList -= 1;\n                    if (currentCount - 1 == 0) {\n                        QString::free((Data *)*tempPair);\n                    }\n                    \n                    operator_delete(tempPair, 4);\n                    return (int *)0x0;\n                }\n                \n                currentCount = *param_1;\n                startIndex = *(int *)(currentCount + 8);\n                endIndex = *(int *)(currentCount + 0xc);\n                *(int *)(resultList[3] + itemCount * 4) = itemValue;\n                itemCount += 1;\n            } while (itemCount < endIndex - startIndex);\n        }\n    }\n    return resultList;\n}\n```",
        "normed_func_sha256": "7a3ea3592ffa9eb9b27f12647e5fec6fa8dd1743e7790265f6ed06bc19915040",
        "source_code": "static PyObject *convertFrom_QList_0600QPair_0100QByteArray_0100QString(void *sipCppV, PyObject *sipTransferObj)\n{\n   QList<QPair<QByteArray,QString> > *sipCpp = reinterpret_cast<QList<QPair<QByteArray,QString> > *>(sipCppV);\n\n#line 201 \"/usr/share/python3-sip/PyQt4/QtCore/qlist.sip\"\n    // Create the list.\n    PyObject *l;\n\n    if ((l = PyList_New(sipCpp->size())) == NULL)\n        return NULL;\n\n    // Set the list elements.\n    for (int i = 0; i < sipCpp->size(); ++i)\n    {\n        const QPair<QByteArray, QString> &p = sipCpp->at(i);\n        QByteArray *s1 = new QByteArray(p.first);\n        QString *s2 = new QString(p.second);\n        PyObject *pobj;\n\n        if ((pobj = sipBuildResult(NULL, \"(NN)\", s1, sipType_QByteArray, sipTransferObj, s2, sipType_QString, sipTransferObj)) == NULL)\n        {\n            Py_DECREF(l);\n            delete s1;\n            delete s2;\n\n            return NULL;\n        }\n\n        PyList_SET_ITEM(l, i, pobj);\n    }\n\n    return l;\n#line 1135 \"/builddir/build/BUILD/pykde4-4.14.3/armv7hl-python3/sip/phonon/sipphononpart1.cpp\"\n}",
        "parsed_output": "int * convertFrom_QList_0600QPair_0100QByteArray_0100QString(int *param_1, undefined4 param_2) {\n    bool hasAccess;\n    int *resultList;\n    int **sourcePair;\n    int **tempPair;\n    int currentIndex;\n    int startIndex;\n    int endIndex;\n    int itemCount;\n    int *currentItem;\n    int itemValue;\n    int **itemPair;\n    \n    resultList = (int *)PyList_New(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8));\n    if (resultList != NULL) {\n        currentIndex = *param_1;\n        startIndex = *(int *)(currentIndex + 8);\n        endIndex = *(int *)(currentIndex + 0xc);\n        \n        if (0 < endIndex - startIndex) {\n            itemCount = 0;\n            do {\n                itemPair = *(int ***)(currentIndex + (startIndex + itemCount) * 4 + 0x14);\n                sourcePair = (int **)operator_new(4);\n                currentItem = *itemPair;\n                *sourcePair = currentItem;\n                \n                do {\n                    hasAccess = (bool)hasExclusiveAccess(currentItem);\n                } while (!hasAccess);\n                \n                *currentItem += 1;\n                tempPair = (int **)operator_new(4);\n                currentItem = itemPair[1];\n                *tempPair = currentItem;\n                \n                do {\n                    hasAccess = (bool)hasExclusiveAccess(currentItem);\n                } while (!hasAccess);\n                \n                *currentItem += 1;\n                itemValue = (**(code **)(sipAPI_phonon + 0x1c))(0, &DAT_00063480, sourcePair, sipImportedTypes_phonon_QtCore._4_4_, param_2, tempPair, sipImportedTypes_phonon_QtCore._56_4_, param_2);\n                \n                if (itemValue == 0) {\n                    int currentCount = *resultList;\n                    *resultList -= 1;\n                    \n                    if (currentCount - 1 == 0) {\n                        (**(code **)(resultList[1] + 0x18))(resultList);\n                    }\n                    \n                    resultList = *sourcePair;\n                    do {\n                        currentCount = *resultList;\n                        hasAccess = (bool)hasExclusiveAccess(resultList);\n                    } while (!hasAccess);\n                    \n                    *resultList -= 1;\n                    if (currentCount - 1 == 0) {\n                        qFree(*sourcePair);\n                    }\n                    \n                    operator_delete(sourcePair, 4);\n                    resultList = *tempPair;\n                    do {\n                        currentCount = *resultList;\n                        hasAccess = (bool)hasExclusiveAccess(resultList);\n                    } while (!hasAccess);\n                    \n                    *resultList -= 1;\n                    if (currentCount - 1 == 0) {\n                        QString::free((Data *)*tempPair);\n                    }\n                    \n                    operator_delete(tempPair, 4);\n                    return (int *)0x0;\n                }\n                \n                currentCount = *param_1;\n                startIndex = *(int *)(currentCount + 8);\n                endIndex = *(int *)(currentCount + 0xc);\n                *(int *)(resultList[3] + itemCount * 4) = itemValue;\n                itemCount += 1;\n            } while (itemCount < endIndex - startIndex);\n        }\n    }\n    return resultList;\n}",
        "baseline_code_stripped": "int * convertFrom_QList_0600QPair_0100QByteArray_0100QString(int *param_1,undefined4 param_2)\n{\n  bool bVar1;\n  int *piVar2;\n  int **ppiVar3;\n  int **ppiVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int *piVar9;\n  int iVar10;\n  int **ppiVar11;\n  piVar2 = (int *)PyList_New(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8));\n  if (piVar2 != (int *)0x0) {\n    iVar7 = *param_1;\n    iVar8 = *(int *)(iVar7 + 8);\n    if (0 < *(int *)(iVar7 + 0xc) - iVar8) {\n      iVar10 = 0;\n      do {\n        ppiVar11 = *(int ***)(iVar7 + (iVar8 + iVar10) * 4 + 0x14);\n        ppiVar3 = (int **)operator_new(4);\n        piVar9 = *ppiVar11;\n        *ppiVar3 = piVar9;\n        do {\n          bVar1 = (bool)hasExclusiveAccess(piVar9);\n        } while (!bVar1);\n        *piVar9 = *piVar9 + 1;\n        ppiVar4 = (int **)operator_new(4);\n        piVar9 = ppiVar11[1];\n        *ppiVar4 = piVar9;\n        do {\n          bVar1 = (bool)hasExclusiveAccess(piVar9);\n        } while (!bVar1);\n        *piVar9 = *piVar9 + 1;\n        iVar5 = (**(code **)(sipAPI_phonon + 0x1c))\n                          (0,&DAT_00063480,ppiVar3,sipImportedTypes_phonon_QtCore._4_4_,param_2,\n                           ppiVar4,sipImportedTypes_phonon_QtCore._56_4_,param_2);\n        if (iVar5 == 0) {\n          iVar7 = *piVar2;\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            (**(code **)(piVar2[1] + 0x18))(piVar2);\n          }\n          piVar2 = *ppiVar3;\n          do {\n            iVar7 = *piVar2;\n            bVar1 = (bool)hasExclusiveAccess(piVar2);\n          } while (!bVar1);\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            qFree(*ppiVar3);\n          }\n          operator_delete(ppiVar3,4);\n          piVar2 = *ppiVar4;\n          do {\n            iVar7 = *piVar2;\n            bVar1 = (bool)hasExclusiveAccess(piVar2);\n          } while (!bVar1);\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            QString::free((Data *)*ppiVar4);\n          }\n          operator_delete(ppiVar4,4);\n          return (int *)0x0;\n        }\n        iVar7 = *param_1;\n        iVar8 = *(int *)(iVar7 + 8);\n        iVar6 = *(int *)(iVar7 + 0xc);\n        *(int *)(piVar2[3] + iVar10 * 4) = iVar5;\n        iVar10 = iVar10 + 1;\n      } while (iVar10 < iVar6 - iVar8);\n    }\n  }\n  return piVar2;\n}",
        "similarity_score_unixcoder": 0.7482247948646545,
        "similarity_score_baseline_stripped": 0.6956297755241394
    },
    {
        "func_name": "deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(long param_1)\n{\n  int iVar1;\n  long lVar2;\n  lVar2 = 0;\n  do {\n    *(undefined8 *)(*(long *)(param_1 + 0x1c0) + lVar2) = 0;\n    lVar2 = lVar2 + 8;\n  } while (lVar2 != 0x2880);\n  iVar1 = *(int *)(param_1 + 0x33c);\n  if (0 < iVar1) {\n    lVar2 = param_1;\n    do {\n      deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq\n                (lVar2,*(undefined8 *)(param_1 + 0x1c0));\n      lVar2 = lVar2 + 0x340;\n    } while (lVar2 != ((ulong)(iVar1 - 1) + 1) * 0x340 + param_1);\n  }\n  lVar2 = *(long *)(param_1 + 0x1c0);\n  *(long *)(param_1 + 0x1d0) = lVar2 + 0x21c0;\n  *(long *)(param_1 + 0x1d8) = lVar2 + 0x1b00;\n  *(long *)(param_1 + 0x1e0) = lVar2 + 0x1440;\n  *(long *)(param_1 + 0x1e8) = lVar2 + 0xd80;\n  *(long *)(param_1 + 0x1f0) = lVar2 + 0x6c0;\n  *(long *)(param_1 + 0x1f8) = lVar2;\n  return;\n}",
        "output": "```c\nvoid initialize_memory(long param_1) {\n    long offset = 0;\n    long *memory_location = (long *)(param_1 + 0x1c0);\n    \n    // Clear memory in blocks of 8 bytes\n    while (offset < 0x2880) {\n        *(undefined8 *)(memory_location + offset) = 0;\n        offset += 8;\n    }\n}\n\nvoid process_derivatives(long param_1, int count) {\n    long current_position = param_1;\n    \n    for (int i = 0; i < count; i++) {\n        deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq(current_position, *(undefined8 *)(param_1 + 0x1c0));\n        current_position += 0x340;\n    }\n}\n\nvoid deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(long param_1) {\n    initialize_memory(param_1);\n    \n    int count = *(int *)(param_1 + 0x33c);\n    if (count > 0) {\n        process_derivatives(param_1, count);\n    }\n    \n    long base_address = *(long *)(param_1 + 0x1c0);\n    *(long *)(param_1 + 0x1d0) = base_address + 0x21c0;\n    *(long *)(param_1 + 0x1d8) = base_address + 0x1b00;\n    *(long *)(param_1 + 0x1e0) = base_address + 0x1440;\n    *(long *)(param_1 + 0x1e8) = base_address + 0xd80;\n    *(long *)(param_1 + 0x1f0) = base_address + 0x6c0;\n    *(long *)(param_1 + 0x1f8) = base_address;\n}\n```",
        "normed_func_sha256": "fe770ba5a4e665e092881b81fcb5444008a05e9be595e646a7286940b40a982e",
        "source_code": "void deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(const Libint_t* inteval) {\n\n_libint2_static_api_bzero_short_(inteval->stack+0*1,1296)\nconst int contrdepth = inteval->contrdepth;\n#ifdef __INTEL_COMPILER\n#pragma ivdep\n#endif\nfor(int c = 0; c<contrdepth; c++) {\nderiv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq(inteval+c, inteval->stack);\n}\n\nLIBINT2_REALTYPE*const  stack = inteval->stack;\n{\nconst int hsi = 0;\n{\nconst int lsi = 0;\n{\nconst int vi = 0;\n}\n}\n}\nconst int hsi = 0;\nconst int lsi = 0;\nconst int vi = 0;\ninteval->targets[0] = &(inteval->stack[((hsi*216+1080)*1+lsi)*1]);\ninteval->targets[1] = &(inteval->stack[((hsi*216+864)*1+lsi)*1]);\ninteval->targets[2] = &(inteval->stack[((hsi*216+648)*1+lsi)*1]);\ninteval->targets[3] = &(inteval->stack[((hsi*216+432)*1+lsi)*1]);\ninteval->targets[4] = &(inteval->stack[((hsi*216+216)*1+lsi)*1]);\ninteval->targets[5] = &(inteval->stack[((hsi*216+0)*1+lsi)*1]);\n/** Number of flops = 0 */\n}",
        "parsed_output": "void initialize_memory(long param_1) {\n    long offset = 0;\n    long *memory_location = (long *)(param_1 + 0x1c0);\n    \n    // Clear memory in blocks of 8 bytes\n    while (offset < 0x2880) {\n        *(undefined8 *)(memory_location + offset) = 0;\n        offset += 8;\n    }\n}\n\nvoid process_derivatives(long param_1, int count) {\n    long current_position = param_1;\n    \n    for (int i = 0; i < count; i++) {\n        deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq(current_position, *(undefined8 *)(param_1 + 0x1c0));\n        current_position += 0x340;\n    }\n}\n\nvoid deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(long param_1) {\n    initialize_memory(param_1);\n    \n    int count = *(int *)(param_1 + 0x33c);\n    if (count > 0) {\n        process_derivatives(param_1, count);\n    }\n    \n    long base_address = *(long *)(param_1 + 0x1c0);\n    *(long *)(param_1 + 0x1d0) = base_address + 0x21c0;\n    *(long *)(param_1 + 0x1d8) = base_address + 0x1b00;\n    *(long *)(param_1 + 0x1e0) = base_address + 0x1440;\n    *(long *)(param_1 + 0x1e8) = base_address + 0xd80;\n    *(long *)(param_1 + 0x1f0) = base_address + 0x6c0;\n    *(long *)(param_1 + 0x1f8) = base_address;\n}",
        "baseline_code_stripped": "void deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(long param_1)\n{\n  int iVar1;\n  long lVar2;\n  lVar2 = 0;\n  do {\n    *(undefined8 *)(*(long *)(param_1 + 0x1c0) + lVar2) = 0;\n    lVar2 = lVar2 + 8;\n  } while (lVar2 != 0x2880);\n  iVar1 = *(int *)(param_1 + 0x33c);\n  if (0 < iVar1) {\n    lVar2 = param_1;\n    do {\n      deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq\n                (lVar2,*(undefined8 *)(param_1 + 0x1c0));\n      lVar2 = lVar2 + 0x340;\n    } while (lVar2 != ((ulong)(iVar1 - 1) + 1) * 0x340 + param_1);\n  }\n  lVar2 = *(long *)(param_1 + 0x1c0);\n  *(long *)(param_1 + 0x1d0) = lVar2 + 0x21c0;\n  *(long *)(param_1 + 0x1d8) = lVar2 + 0x1b00;\n  *(long *)(param_1 + 0x1e0) = lVar2 + 0x1440;\n  *(long *)(param_1 + 0x1e8) = lVar2 + 0xd80;\n  *(long *)(param_1 + 0x1f0) = lVar2 + 0x6c0;\n  *(long *)(param_1 + 0x1f8) = lVar2;\n  return;\n}",
        "similarity_score_unixcoder": 0.6731321215629578,
        "similarity_score_baseline_stripped": 0.6332758665084839
    },
    {
        "func_name": "nestingLevelsPop",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_003cfbf8(long param_1)\n{\n  long lVar1;\n  lVar1 = FUN_003cfc54(param_1);\n  if (lVar1 == 0) {\n    FUN_003cd9b6(\"Assert(nl != NULL) failed!\");\n  }\n  FUN_003e6e64(*(undefined8 *)(lVar1 + 8));\n  *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + -1;\n  return;\n}",
        "output": "```c\nvoid processParameter(long param_1)\n{\n  long result = FUN_003cfc54(param_1);\n  \n  if (result == 0) {\n    FUN_003cd9b6(\"Assert(nl != NULL) failed!\");\n  }\n  \n  FUN_003e6e64(*(undefined8 *)(result + 8));\n  *(int *)(param_1 + 8) -= 1;\n  \n  return;\n}\n```",
        "normed_func_sha256": "fed6f55e68b006614df7e0874e422ccaab85dd29f146fcb432636f524f024aac",
        "source_code": "extern void nestingLevelsPop(NestingLevels *nls)\n{\n\tconst NestingLevel *nl = nestingLevelsGetCurrent(nls);\n\n\tAssert (nl != NULL);\n\tvStringClear(nl->name);\n\tnls->n--;\n}",
        "parsed_output": "void processParameter(long param_1)\n{\n  long result = FUN_003cfc54(param_1);\n  \n  if (result == 0) {\n    FUN_003cd9b6(\"Assert(nl != NULL) failed!\");\n  }\n  \n  FUN_003e6e64(*(undefined8 *)(result + 8));\n  *(int *)(param_1 + 8) -= 1;\n  \n  return;\n}",
        "baseline_code_stripped": "void FUN_003cfbf8(long param_1)\n{\n  long lVar1;\n  lVar1 = FUN_003cfc54(param_1);\n  if (lVar1 == 0) {\n    FUN_003cd9b6(\"Assert(nl != NULL) failed!\");\n  }\n  FUN_003e6e64(*(undefined8 *)(lVar1 + 8));\n  *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + -1;\n  return;\n}",
        "similarity_score_unixcoder": 0.4462299942970276,
        "similarity_score_baseline_stripped": 0.41622424125671387
    },
    {
        "func_name": "QHttpNetworkConnection::qt_metacall",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_00060360(Call param_1,int param_2,void **param_3,undefined4 param_4)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall(param_1,param_2,param_3);\n  if ((-1 < iVar1) && (param_2 == 0)) {\n    if (iVar1 == 0) {\n      FUN_00060330(param_1,0,0,param_4);\n    }\n    iVar1 = iVar1 + -1;\n  }\n  return iVar1;\n}",
        "output": "```c\nint processMetacall(Call param_1, int param_2, void **param_3, undefined4 param_4) {\n    int metacallResult;\n    metacallResult = QObject::qt_metacall(param_1, param_2, param_3);\n    \n    if (metacallResult >= 0 && param_2 == 0) {\n        if (metacallResult == 0) {\n            FUN_00060330(param_1, 0, 0, param_4);\n        }\n        metacallResult--;\n    }\n    \n    return metacallResult;\n}\n```",
        "normed_func_sha256": "9624e51b8d35c33a2f7d4c3d677f91eabbf69d0e44328b8e4af290b708d5287e",
        "source_code": "int QHttpNetworkConnection::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 1)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 1;\n    }\n    return _id;\n}",
        "parsed_output": "int processMetacall(Call param_1, int param_2, void **param_3, undefined4 param_4) {\n    int metacallResult;\n    metacallResult = QObject::qt_metacall(param_1, param_2, param_3);\n    \n    if (metacallResult >= 0 && param_2 == 0) {\n        if (metacallResult == 0) {\n            FUN_00060330(param_1, 0, 0, param_4);\n        }\n        metacallResult--;\n    }\n    \n    return metacallResult;\n}",
        "baseline_code_stripped": "int FUN_00060360(Call param_1,int param_2,void **param_3,undefined4 param_4)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall(param_1,param_2,param_3);\n  if ((-1 < iVar1) && (param_2 == 0)) {\n    if (iVar1 == 0) {\n      FUN_00060330(param_1,0,0,param_4);\n    }\n    iVar1 = iVar1 + -1;\n  }\n  return iVar1;\n}",
        "similarity_score_unixcoder": 0.663275420665741,
        "similarity_score_baseline_stripped": 0.5951101779937744
    },
    {
        "func_name": "PythonQtWrapper_QTextInlineObject::qt_metacast",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall\nPythonQtWrapper_QTextInlineObject::qt_metacast\n          (PythonQtWrapper_QTextInlineObject *this,char *param_1)\n{\n  int iVar1;\n  if (param_1 == (char *)0x0) {\n    return;\n  }\n  iVar1 = strcmp(param_1,\"PythonQtWrapper_QTextInlineObject\");\n  if (iVar1 == 0) {\n    return;\n  }\n  QObject::qt_metacast((char *)this);\n  return;\n}",
        "output": "```c\nvoid PythonQtWrapper_QTextInlineObject::qt_metacast(char *param_1) {\n    if (param_1 == nullptr) {\n        return;\n    }\n    \n    if (strcmp(param_1, \"PythonQtWrapper_QTextInlineObject\") == 0) {\n        return;\n    }\n    \n    QObject::qt_metacast(param_1);\n}\n```",
        "normed_func_sha256": "52e45914ccb46f45a5c8374254562585c526c97b54779133ec2d5b88a0b516be",
        "source_code": "void *PythonQtWrapper_QTextInlineObject::qt_metacast(const char *_clname)\n{\n    if (!_clname) return 0;\n    if (!strcmp(_clname, qt_meta_stringdata_PythonQtWrapper_QTextInlineObject))\n        return static_cast<void*>(const_cast< PythonQtWrapper_QTextInlineObject*>(this));\n    return QObject::qt_metacast(_clname);\n}",
        "parsed_output": "void PythonQtWrapper_QTextInlineObject::qt_metacast(char *param_1) {\n    if (param_1 == nullptr) {\n        return;\n    }\n    \n    if (strcmp(param_1, \"PythonQtWrapper_QTextInlineObject\") == 0) {\n        return;\n    }\n    \n    QObject::qt_metacast(param_1);\n}",
        "baseline_code_stripped": "void __thiscall\nPythonQtWrapper_QTextInlineObject::qt_metacast\n          (PythonQtWrapper_QTextInlineObject *this,char *param_1)\n{\n  int iVar1;\n  if (param_1 == (char *)0x0) {\n    return;\n  }\n  iVar1 = strcmp(param_1,\"PythonQtWrapper_QTextInlineObject\");\n  if (iVar1 == 0) {\n    return;\n  }\n  QObject::qt_metacast((char *)this);\n  return;\n}",
        "similarity_score_unixcoder": 0.869442343711853,
        "similarity_score_baseline_stripped": 0.8272057771682739
    },
    {
        "func_name": "visit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0046c108(undefined8 param_1,undefined8 param_2)\n{\n  longlong lVar1;\n  FUN_0032d060(param_2,param_1);\n  lVar1 = FUN_00460d10(param_1,param_2);\n  if (lVar1 == 0) {\n    FUN_00454ffc(param_1,param_2);\n  }\n  return;\n}",
        "output": "```c\nvoid processParameters(undefined8 firstParam, undefined8 secondParam)\n{\n  longlong result;\n  \n  initializeParameters(secondParam, firstParam);\n  result = computeResult(firstParam, secondParam);\n  \n  if (result == 0) {\n    handleZeroResult(firstParam, secondParam);\n  }\n  \n  return;\n}\n```",
        "normed_func_sha256": "ae88971c0f179255c3cfb93064a9d2d4bb4718c308e678b8275656461256d590",
        "source_code": "void visit(AstIsUnbounded* nodep) override {\n        iterateChildren(nodep);\n        if (match_NodeUniop_0(nodep)) return;\n        if (match_IsUnbounded_0(nodep)) return;\n    }",
        "parsed_output": "void processParameters(undefined8 firstParam, undefined8 secondParam)\n{\n  longlong result;\n  \n  initializeParameters(secondParam, firstParam);\n  result = computeResult(firstParam, secondParam);\n  \n  if (result == 0) {\n    handleZeroResult(firstParam, secondParam);\n  }\n  \n  return;\n}",
        "baseline_code_stripped": "void FUN_0046c108(undefined8 param_1,undefined8 param_2)\n{\n  longlong lVar1;\n  FUN_0032d060(param_2,param_1);\n  lVar1 = FUN_00460d10(param_1,param_2);\n  if (lVar1 == 0) {\n    FUN_00454ffc(param_1,param_2);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.47019633650779724,
        "similarity_score_baseline_stripped": 0.4774513840675354
    },
    {
        "func_name": "==",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_0011c4e0(long *param_1,long *param_2)\n{\n  byte bVar1;\n  long lVar2;\n  long lVar3;\n  int iVar4;\n  undefined8 uVar5;\n  undefined4 extraout_var;\n  size_t sVar6;\n  uint uVar7;\n  uint uVar8;\n  uVar5 = 1;\n  lVar2 = *param_1;\n  lVar3 = *param_2;\n  if (lVar2 != lVar3) {\n    uVar8 = (uint)*(byte *)(lVar2 + 1);\n    if (*(byte *)(lVar2 + 1) == 0xff) {\n      sVar6 = strlen((char *)(lVar2 + 0x101));\n      bVar1 = *(byte *)(lVar3 + 1);\n      uVar8 = (int)sVar6 + 0xff;\n    }\n    else {\n      bVar1 = *(byte *)(lVar3 + 1);\n    }\n    if (bVar1 == 0xff) {\n      sVar6 = strlen((char *)(lVar3 + 0x101));\n      uVar7 = (int)sVar6 + 0xff;\n    }\n    else {\n      uVar7 = (uint)bVar1;\n    }\n    uVar5 = 0;\n    if (uVar7 == uVar8) {\n      iVar4 = memcmp((void *)(lVar2 + 2),(void *)(lVar3 + 2),(long)(int)uVar7);\n      return CONCAT71((int7)(CONCAT44(extraout_var,iVar4) >> 8),iVar4 == 0);\n    }\n  }\n  return uVar5;\n}",
        "output": "```c\nundefined8 compare_long_pointers(long *ptr1, long *ptr2) {\n    byte byteValue1;\n    long value1;\n    long value2;\n    int comparisonResult;\n    undefined8 result = 1;\n    size_t stringLength;\n    uint length1;\n    uint length2;\n\n    value1 = *ptr1;\n    value2 = *ptr2;\n\n    if (value1 != value2) {\n        length1 = (uint)*(byte *)(value1 + 1);\n        if (*(byte *)(value1 + 1) == 0xff) {\n            stringLength = strlen((char *)(value1 + 0x101));\n            byteValue1 = *(byte *)(value2 + 1);\n            length1 = (int)stringLength + 0xff;\n        } else {\n            byteValue1 = *(byte *)(value2 + 1);\n        }\n\n        if (byteValue1 == 0xff) {\n            stringLength = strlen((char *)(value2 + 0x101));\n            length2 = (int)stringLength + 0xff;\n        } else {\n            length2 = (uint)byteValue1;\n        }\n\n        result = 0;\n        if (length2 == length1) {\n            comparisonResult = memcmp((void *)(value1 + 2), (void *)(value2 + 2), (long)(int)length2);\n            return CONCAT71((int7)(CONCAT44(extraout_var, comparisonResult) >> 8), comparisonResult == 0);\n        }\n    }\n    return result;\n}\n```",
        "normed_func_sha256": "c750e63b0f21814df967a9bf10ce086aa010dac239cf3c1392cefdf2b2e407f9",
        "source_code": "bool operator == (const c4_String &a, const c4_String &b) {\n  return a._value == b._value || a.GetLength() == b.GetLength() && memcmp\n    (a.Data(), b.Data(), a.GetLength()) == 0;\n}",
        "parsed_output": "undefined8 compare_long_pointers(long *ptr1, long *ptr2) {\n    byte byteValue1;\n    long value1;\n    long value2;\n    int comparisonResult;\n    undefined8 result = 1;\n    size_t stringLength;\n    uint length1;\n    uint length2;\n\n    value1 = *ptr1;\n    value2 = *ptr2;\n\n    if (value1 != value2) {\n        length1 = (uint)*(byte *)(value1 + 1);\n        if (*(byte *)(value1 + 1) == 0xff) {\n            stringLength = strlen((char *)(value1 + 0x101));\n            byteValue1 = *(byte *)(value2 + 1);\n            length1 = (int)stringLength + 0xff;\n        } else {\n            byteValue1 = *(byte *)(value2 + 1);\n        }\n\n        if (byteValue1 == 0xff) {\n            stringLength = strlen((char *)(value2 + 0x101));\n            length2 = (int)stringLength + 0xff;\n        } else {\n            length2 = (uint)byteValue1;\n        }\n\n        result = 0;\n        if (length2 == length1) {\n            comparisonResult = memcmp((void *)(value1 + 2), (void *)(value2 + 2), (long)(int)length2);\n            return CONCAT71((int7)(CONCAT44(extraout_var, comparisonResult) >> 8), comparisonResult == 0);\n        }\n    }\n    return result;\n}",
        "baseline_code_stripped": "undefined8 FUN_0011c4e0(long *param_1,long *param_2)\n{\n  byte bVar1;\n  long lVar2;\n  long lVar3;\n  int iVar4;\n  undefined8 uVar5;\n  undefined4 extraout_var;\n  size_t sVar6;\n  uint uVar7;\n  uint uVar8;\n  uVar5 = 1;\n  lVar2 = *param_1;\n  lVar3 = *param_2;\n  if (lVar2 != lVar3) {\n    uVar8 = (uint)*(byte *)(lVar2 + 1);\n    if (*(byte *)(lVar2 + 1) == 0xff) {\n      sVar6 = strlen((char *)(lVar2 + 0x101));\n      bVar1 = *(byte *)(lVar3 + 1);\n      uVar8 = (int)sVar6 + 0xff;\n    }\n    else {\n      bVar1 = *(byte *)(lVar3 + 1);\n    }\n    if (bVar1 == 0xff) {\n      sVar6 = strlen((char *)(lVar3 + 0x101));\n      uVar7 = (int)sVar6 + 0xff;\n    }\n    else {\n      uVar7 = (uint)bVar1;\n    }\n    uVar5 = 0;\n    if (uVar7 == uVar8) {\n      iVar4 = memcmp((void *)(lVar2 + 2),(void *)(lVar3 + 2),(long)(int)uVar7);\n      return CONCAT71((int7)(CONCAT44(extraout_var,iVar4) >> 8),iVar4 == 0);\n    }\n  }\n  return uVar5;\n}",
        "similarity_score_unixcoder": 0.6614657640457153,
        "similarity_score_baseline_stripped": 0.5299978852272034
    },
    {
        "func_name": "gen_vec_unpacks_hi_v8qi",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid gen_aarch64_addpv2si(rtx_def *param_1,rtx_def *param_2,rtx_def *param_3)\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  uVar1 = gen_rtvec(2);\n  iVar2 = rtx_alloc(0x14);\n  *(undefined *)(iVar2 + 2) = 0x42;\n  *(undefined4 *)(iVar2 + 8) = uVar1;\n  *(undefined4 *)(iVar2 + 0xc) = 0xd6;\n  iVar3 = rtx_alloc(0x19);\n  *(rtx_def **)(iVar3 + 8) = param_1;\n  *(undefined *)(iVar3 + 2) = 0;\n  *(int *)(iVar3 + 0xc) = iVar2;\n  return;\n}",
        "output": "```c\nvoid generate_aarch64_addpv2si(rtx_def *operand1, rtx_def *operand2, rtx_def *operand3) {\n    undefined4 vector;\n    int instructionNode;\n    int finalNode;\n\n    vector = gen_rtvec(2);\n    instructionNode = rtx_alloc(0x14);\n    \n    *(undefined *)(instructionNode + 2) = 0x42; // Set operation code\n    *(undefined4 *)(instructionNode + 8) = vector; // Assign vector\n    *(undefined4 *)(instructionNode + 0xc) = 0xd6; // Set additional parameter\n\n    finalNode = rtx_alloc(0x19);\n    *(rtx_def **)(finalNode + 8) = operand1; // Assign first operand\n    *(undefined *)(finalNode + 2) = 0; // Set flag\n    *(int *)(finalNode + 0xc) = instructionNode; // Link to instruction node\n\n    return;\n}\n```",
        "normed_func_sha256": "aae7a297ccb133c32b068d5715c4c0574804a336d54ae23be9812b4b81fb8e43",
        "source_code": "rtx\ngen_vec_unpacks_hi_v8qi (rtx operand0,\n\trtx operand1)\n{\n  rtx_insn *_val = 0;\n  start_sequence ();\n  {\n    rtx operands[2];\n    operands[0] = operand0;\n    operands[1] = operand1;\n#define FAIL return (end_sequence (), _val)\n#define DONE return (_val = get_insns (), end_sequence (), _val)\n#line 799 \"../../gcc-10.2.1-20200826/gcc/config/mips/loongson-mmi.md\"\n{\n  mips_expand_vec_unpack (operands, false, true);\n  DONE;\n}\n#undef DONE\n#undef FAIL\n    operand0 = operands[0];\n    (void) operand0;\n    operand1 = operands[1];\n    (void) operand1;\n  }\n  emit (operand0, true);\n  emit (operand1, false);\n  _val = get_insns ();\n  end_sequence ();\n  return _val;\n}",
        "parsed_output": "void generate_aarch64_addpv2si(rtx_def *operand1, rtx_def *operand2, rtx_def *operand3) {\n    undefined4 vector;\n    int instructionNode;\n    int finalNode;\n\n    vector = gen_rtvec(2);\n    instructionNode = rtx_alloc(0x14);\n    \n    *(undefined *)(instructionNode + 2) = 0x42; // Set operation code\n    *(undefined4 *)(instructionNode + 8) = vector; // Assign vector\n    *(undefined4 *)(instructionNode + 0xc) = 0xd6; // Set additional parameter\n\n    finalNode = rtx_alloc(0x19);\n    *(rtx_def **)(finalNode + 8) = operand1; // Assign first operand\n    *(undefined *)(finalNode + 2) = 0; // Set flag\n    *(int *)(finalNode + 0xc) = instructionNode; // Link to instruction node\n\n    return;\n}",
        "baseline_code_stripped": "void gen_aarch64_addpv2si(rtx_def *param_1,rtx_def *param_2,rtx_def *param_3)\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  uVar1 = gen_rtvec(2);\n  iVar2 = rtx_alloc(0x14);\n  *(undefined *)(iVar2 + 2) = 0x42;\n  *(undefined4 *)(iVar2 + 8) = uVar1;\n  *(undefined4 *)(iVar2 + 0xc) = 0xd6;\n  iVar3 = rtx_alloc(0x19);\n  *(rtx_def **)(iVar3 + 8) = param_1;\n  *(undefined *)(iVar3 + 2) = 0;\n  *(int *)(iVar3 + 0xc) = iVar2;\n  return;\n}",
        "similarity_score_unixcoder": 0.7116014361381531,
        "similarity_score_baseline_stripped": 0.6948696374893188
    },
    {
        "func_name": "DeliverPropertyEvent",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 DeliverPropertyEvent(long param_1,long param_2)\n{\n  long **local_20 [2];\n  dixLookupResourceByType(local_20,*(undefined4 *)(param_1 + 4),RREventType,serverClient,1);\n  if (local_20[0] != (long **)0x0) {\n    for (local_20[0] = (long **)*local_20[0]; local_20[0] != (long **)0x0;\n        local_20[0] = (long **)*local_20[0]) {\n      while ((*(byte *)((long)local_20[0] + 0x1c) & 8) == 0) {\n        local_20[0] = (long **)*local_20[0];\n        if (local_20[0] == (long **)0x0) {\n          return 1;\n        }\n      }\n      *(undefined4 *)(param_2 + 4) = *(undefined4 *)((long)local_20[0][2] + 4);\n      WriteEventsToClient(local_20[0][1],1,param_2);\n    }\n  }\n  return 1;\n}",
        "output": "```c\nundefined8 DeliverPropertyEvent(long param_1, long param_2) {\n    long **resourceList[2];\n    dixLookupResourceByType(resourceList, *(undefined4 *)(param_1 + 4), RREventType, serverClient, 1);\n    \n    if (resourceList[0] != NULL) {\n        resourceList[0] = (long **)*resourceList[0];\n        \n        while (resourceList[0] != NULL) {\n            while ((*(byte *)((long)resourceList[0] + 0x1c) & 8) == 0) {\n                resourceList[0] = (long **)*resourceList[0];\n                if (resourceList[0] == NULL) {\n                    return 1;\n                }\n            }\n            *(undefined4 *)(param_2 + 4) = *(undefined4 *)((long)resourceList[0][2] + 4);\n            WriteEventsToClient(resourceList[0][1], 1, param_2);\n        }\n    }\n    \n    return 1;\n}\n```",
        "normed_func_sha256": "77620ddfa3768dbe89e4a1ce0e236b9da0899c6d79acb7632114f778d747d4a8",
        "source_code": "static int\nDeliverPropertyEvent(WindowPtr pWin, void *value)\n{\n    xRROutputPropertyNotifyEvent *event = value;\n    RREventPtr *pHead, pRREvent;\n    dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,\n\t\t\t    RREventType, serverClient, DixReadAccess);\n    if (!pHead)\n\treturn WT_WALKCHILDREN;\n    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next)\n    {\n\tif (!(pRREvent->mask & RROutputPropertyNotifyMask))\n\t    continue;\n\tevent->window = pRREvent->window->drawable.id;\n\tWriteEventsToClient(pRREvent->client, 1, (xEvent *)event);\n    }\n    return WT_WALKCHILDREN;\n}",
        "parsed_output": "undefined8 DeliverPropertyEvent(long param_1, long param_2) {\n    long **resourceList[2];\n    dixLookupResourceByType(resourceList, *(undefined4 *)(param_1 + 4), RREventType, serverClient, 1);\n    \n    if (resourceList[0] != NULL) {\n        resourceList[0] = (long **)*resourceList[0];\n        \n        while (resourceList[0] != NULL) {\n            while ((*(byte *)((long)resourceList[0] + 0x1c) & 8) == 0) {\n                resourceList[0] = (long **)*resourceList[0];\n                if (resourceList[0] == NULL) {\n                    return 1;\n                }\n            }\n            *(undefined4 *)(param_2 + 4) = *(undefined4 *)((long)resourceList[0][2] + 4);\n            WriteEventsToClient(resourceList[0][1], 1, param_2);\n        }\n    }\n    \n    return 1;\n}",
        "baseline_code_stripped": "undefined8 DeliverPropertyEvent(long param_1,long param_2)\n{\n  long **local_20 [2];\n  dixLookupResourceByType(local_20,*(undefined4 *)(param_1 + 4),RREventType,serverClient,1);\n  if (local_20[0] != (long **)0x0) {\n    for (local_20[0] = (long **)*local_20[0]; local_20[0] != (long **)0x0;\n        local_20[0] = (long **)*local_20[0]) {\n      while ((*(byte *)((long)local_20[0] + 0x1c) & 8) == 0) {\n        local_20[0] = (long **)*local_20[0];\n        if (local_20[0] == (long **)0x0) {\n          return 1;\n        }\n      }\n      *(undefined4 *)(param_2 + 4) = *(undefined4 *)((long)local_20[0][2] + 4);\n      WriteEventsToClient(local_20[0][1],1,param_2);\n    }\n  }\n  return 1;\n}",
        "similarity_score_unixcoder": 0.6956324577331543,
        "similarity_score_baseline_stripped": 0.6649596691131592
    },
    {
        "func_name": "visit_log_not",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall WidthVisitor::visit(WidthVisitor *this,AstLogNot *param_1)\n{\n  basic_ostream *pbVar1;\n  if (*(int *)(param_1 + 0x10) != 0) {\n    V3Error::v3errorPrep(4);\n    std::__ostream_insert_char_std__char_traits_char__\n              ((basic_ostream *)&DAT_0064663c,\"../V3Width.cpp\",0xe);\n    std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c,\":\",1);\n    *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) =\n         *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) & 0xffffffb5 | 2;\n    pbVar1 = (basic_ostream *)\n             std::basic_ostream<char,std::char_traits<char>>::operator__\n                       ((basic_ostream_char_std__char_traits_char__ *)&DAT_0064663c,0xdd8);\n    std::__ostream_insert_char_std__char_traits_char__(pbVar1,\": \",2);\n    std::__ostream_insert_char_std__char_traits_char__(pbVar1,\"For unary ops only!\",0x13);\n    AstNode::v3errorEndFatal((basic_ostringstream *)param_1);\n  }\n  if ((*(uint *)(*(int *)(this + 0x20) + 4) & 1) == 0) {\n    return;\n  }\n  iterateCheckBool((AstNode *)this,(char *)param_1,(AstNode *)&DAT_0054410c,\n                   *(Stage *)(param_1 + 0xc));\n  AstNode::dtypeSetLogicBool((AstNode *)param_1);\n  return;\n}",
        "output": "```c\nvoid WidthVisitor::visit(AstLogNot *param_1) {\n    if (*(int *)(param_1 + 0x10) != 0) {\n        V3Error::v3errorPrep(4);\n        std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c, \"../V3Width.cpp\", 0xe);\n        std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c, \":\", 1);\n        *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c - 0xc)) =\n            *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c - 0xc)) & 0xffffffb5 | 2;\n        \n        basic_ostream *outputStream = (basic_ostream *)\n            std::basic_ostream<char, std::char_traits<char>>::operator__((basic_ostream_char_std__char_traits_char__ *)&DAT_0064663c, 0xdd8);\n        \n        std::__ostream_insert_char_std__char_traits_char__(outputStream, \": \", 2);\n        std::__ostream_insert_char_std__char_traits_char__(outputStream, \"For unary ops only!\", 0x13);\n        AstNode::v3errorEndFatal((basic_ostringstream *)param_1);\n    }\n    \n    if ((*(uint *)(*(int *)(this + 0x20) + 4) & 1) == 0) {\n        return;\n    }\n    \n    iterateCheckBool((AstNode *)this, (char *)param_1, (AstNode *)&DAT_0054410c, *(Stage *)(param_1 + 0xc));\n    AstNode::dtypeSetLogicBool((AstNode *)param_1);\n}\n```",
        "normed_func_sha256": "d3e5da4094df41f3d851e84818e97eff25511ef21ba31e2d4a46c387f5776cb3",
        "source_code": "void visit_log_not(AstNode* nodep) {\n        // CALLER: LogNot\n        // Width-check: lhs 1 bit\n        // Real: Allowed; implicitly compares with zero\n        // We calculate the width of the UNDER expression.\n        // We then check its width to see if it's legal, and edit if not\n        // We finally set the width of our output\n        // IEEE-2012: Table 11-21 and 11.8.1 (same as RedAnd):\n        //   LHS is self-determined\n        //   Width: 1 bit out\n        //   Sign: unsigned out (11.8.1)\n        UASSERT_OBJ(!nodep->op2p(), nodep, \"For unary ops only!\");\n        if (m_vup->prelim()) {\n            iterateCheckBool(nodep, \"LHS\", nodep->op1p(), BOTH);\n            nodep->dtypeSetLogicBool();\n        }\n    }",
        "parsed_output": "void WidthVisitor::visit(AstLogNot *param_1) {\n    if (*(int *)(param_1 + 0x10) != 0) {\n        V3Error::v3errorPrep(4);\n        std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c, \"../V3Width.cpp\", 0xe);\n        std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c, \":\", 1);\n        *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c - 0xc)) =\n            *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c - 0xc)) & 0xffffffb5 | 2;\n        \n        basic_ostream *outputStream = (basic_ostream *)\n            std::basic_ostream<char, std::char_traits<char>>::operator__((basic_ostream_char_std__char_traits_char__ *)&DAT_0064663c, 0xdd8);\n        \n        std::__ostream_insert_char_std__char_traits_char__(outputStream, \": \", 2);\n        std::__ostream_insert_char_std__char_traits_char__(outputStream, \"For unary ops only!\", 0x13);\n        AstNode::v3errorEndFatal((basic_ostringstream *)param_1);\n    }\n    \n    if ((*(uint *)(*(int *)(this + 0x20) + 4) & 1) == 0) {\n        return;\n    }\n    \n    iterateCheckBool((AstNode *)this, (char *)param_1, (AstNode *)&DAT_0054410c, *(Stage *)(param_1 + 0xc));\n    AstNode::dtypeSetLogicBool((AstNode *)param_1);\n}",
        "baseline_code_stripped": "void __thiscall WidthVisitor::visit(WidthVisitor *this,AstLogNot *param_1)\n{\n  basic_ostream *pbVar1;\n  if (*(int *)(param_1 + 0x10) != 0) {\n    V3Error::v3errorPrep(4);\n    std::__ostream_insert_char_std__char_traits_char__\n              ((basic_ostream *)&DAT_0064663c,\"../V3Width.cpp\",0xe);\n    std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c,\":\",1);\n    *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) =\n         *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) & 0xffffffb5 | 2;\n    pbVar1 = (basic_ostream *)\n             std::basic_ostream<char,std::char_traits<char>>::operator__\n                       ((basic_ostream_char_std__char_traits_char__ *)&DAT_0064663c,0xdd8);\n    std::__ostream_insert_char_std__char_traits_char__(pbVar1,\": \",2);\n    std::__ostream_insert_char_std__char_traits_char__(pbVar1,\"For unary ops only!\",0x13);\n    AstNode::v3errorEndFatal((basic_ostringstream *)param_1);\n  }\n  if ((*(uint *)(*(int *)(this + 0x20) + 4) & 1) == 0) {\n    return;\n  }\n  iterateCheckBool((AstNode *)this,(char *)param_1,(AstNode *)&DAT_0054410c,\n                   *(Stage *)(param_1 + 0xc));\n  AstNode::dtypeSetLogicBool((AstNode *)param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.679674506187439,
        "similarity_score_baseline_stripped": 0.6429859399795532
    },
    {
        "func_name": "zfs_path_order",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint zfs_path_order(char *param_1,int *param_2)\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s;\n  size_t sVar3;\n  long lVar4;\n  int iVar5;\n  pcVar2 = getenv(\"ZPOOL_IMPORT_PATH\");\n  if (pcVar2 == (char *)0x0) {\n    lVar4 = 0;\n    do {\n      pcVar2 = (&zpool_default_import_path)[lVar4];\n      sVar3 = strlen(pcVar2);\n      iVar5 = strncmp(param_1,pcVar2,sVar3);\n      if (iVar5 == 0) {\n        *param_2 = (int)lVar4;\n        return iVar5;\n      }\n      lVar4 = lVar4 + 1;\n    } while (lVar4 != 9);\n    return 2;\n  }\n  pcVar2 = strdup(pcVar2);\n  __s = strtok(pcVar2,\":\");\n  if (__s != (char *)0x0) {\n    iVar5 = 0;\n    do {\n      sVar3 = strlen(__s);\n      iVar1 = strncmp(param_1,__s,sVar3);\n      if (iVar1 == 0) {\n        *param_2 = iVar5;\n        iVar5 = 0;\n        goto LAB_00134212;\n      }\n      iVar5 = iVar5 + 1;\n      __s = strtok((char *)0x0,\":\");\n    } while (__s != (char *)0x0);\n  }\n  iVar5 = 2;\nLAB_00134212:\n  free(pcVar2);\n  return iVar5;\n}",
        "output": "```c\nint zfs_path_order(char *inputPath, int *pathIndex) {\n    int comparisonResult;\n    char *importPath;\n    char *token;\n    size_t tokenLength;\n    long index;\n    int resultIndex;\n\n    importPath = getenv(\"ZPOOL_IMPORT_PATH\");\n    if (importPath == NULL) {\n        index = 0;\n        do {\n            importPath = zpool_default_import_path[index];\n            tokenLength = strlen(importPath);\n            comparisonResult = strncmp(inputPath, importPath, tokenLength);\n            if (comparisonResult == 0) {\n                *pathIndex = (int)index;\n                return comparisonResult;\n            }\n            index++;\n        } while (index != 9);\n        return 2;\n    }\n\n    importPath = strdup(importPath);\n    token = strtok(importPath, \":\");\n    if (token != NULL) {\n        resultIndex = 0;\n        do {\n            tokenLength = strlen(token);\n            comparisonResult = strncmp(inputPath, token, tokenLength);\n            if (comparisonResult == 0) {\n                *pathIndex = resultIndex;\n                resultIndex = 0;\n                goto cleanup;\n            }\n            resultIndex++;\n            token = strtok(NULL, \":\");\n        } while (token != NULL);\n    }\n    resultIndex = 2;\n\ncleanup:\n    free(importPath);\n    return resultIndex;\n}\n```",
        "normed_func_sha256": "8ecc29eef5c51f652c6c1d1a65848dc597bfee0aac2cc16b6e9e41f47f5b3017",
        "source_code": "int\nzfs_path_order(char *name, int *order)\n{\n\tint i = 0, error = ENOENT;\n\tchar *dir, *env, *envdup;\n\n\tenv = getenv(\"ZPOOL_IMPORT_PATH\");\n\tif (env) {\n\t\tenvdup = strdup(env);\n\t\tdir = strtok(envdup, \":\");\n\t\twhile (dir) {\n\t\t\tif (strncmp(name, dir, strlen(dir)) == 0) {\n\t\t\t\t*order = i;\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdir = strtok(NULL, \":\");\n\t\t\ti++;\n\t\t}\n\t\tfree(envdup);\n\t} else {\n\t\tfor (i = 0; i < DEFAULT_IMPORT_PATH_SIZE; i++) {\n\t\t\tif (strncmp(name, zpool_default_import_path[i],\n\t\t\t    strlen(zpool_default_import_path[i])) == 0) {\n\t\t\t\t*order = i;\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (error);\n}",
        "parsed_output": "int zfs_path_order(char *inputPath, int *pathIndex) {\n    int comparisonResult;\n    char *importPath;\n    char *token;\n    size_t tokenLength;\n    long index;\n    int resultIndex;\n\n    importPath = getenv(\"ZPOOL_IMPORT_PATH\");\n    if (importPath == NULL) {\n        index = 0;\n        do {\n            importPath = zpool_default_import_path[index];\n            tokenLength = strlen(importPath);\n            comparisonResult = strncmp(inputPath, importPath, tokenLength);\n            if (comparisonResult == 0) {\n                *pathIndex = (int)index;\n                return comparisonResult;\n            }\n            index++;\n        } while (index != 9);\n        return 2;\n    }\n\n    importPath = strdup(importPath);\n    token = strtok(importPath, \":\");\n    if (token != NULL) {\n        resultIndex = 0;\n        do {\n            tokenLength = strlen(token);\n            comparisonResult = strncmp(inputPath, token, tokenLength);\n            if (comparisonResult == 0) {\n                *pathIndex = resultIndex;\n                resultIndex = 0;\n                goto cleanup;\n            }\n            resultIndex++;\n            token = strtok(NULL, \":\");\n        } while (token != NULL);\n    }\n    resultIndex = 2;\n\ncleanup:\n    free(importPath);\n    return resultIndex;\n}",
        "baseline_code_stripped": "int zfs_path_order(char *param_1,int *param_2)\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s;\n  size_t sVar3;\n  long lVar4;\n  int iVar5;\n  pcVar2 = getenv(\"ZPOOL_IMPORT_PATH\");\n  if (pcVar2 == (char *)0x0) {\n    lVar4 = 0;\n    do {\n      pcVar2 = (&zpool_default_import_path)[lVar4];\n      sVar3 = strlen(pcVar2);\n      iVar5 = strncmp(param_1,pcVar2,sVar3);\n      if (iVar5 == 0) {\n        *param_2 = (int)lVar4;\n        return iVar5;\n      }\n      lVar4 = lVar4 + 1;\n    } while (lVar4 != 9);\n    return 2;\n  }\n  pcVar2 = strdup(pcVar2);\n  __s = strtok(pcVar2,\":\");\n  if (__s != (char *)0x0) {\n    iVar5 = 0;\n    do {\n      sVar3 = strlen(__s);\n      iVar1 = strncmp(param_1,__s,sVar3);\n      if (iVar1 == 0) {\n        *param_2 = iVar5;\n        iVar5 = 0;\n        goto LAB_00134212;\n      }\n      iVar5 = iVar5 + 1;\n      __s = strtok((char *)0x0,\":\");\n    } while (__s != (char *)0x0);\n  }\n  iVar5 = 2;\nLAB_00134212:\n  free(pcVar2);\n  return iVar5;\n}",
        "similarity_score_unixcoder": 0.6868354678153992,
        "similarity_score_baseline_stripped": 0.7060284614562988
    },
    {
        "func_name": "clusapi_dissect_ExecuteBatch_request",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_016d95d0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 int param_5,undefined4 param_6)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  undefined local_24 [4];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x16d95d9;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  *(char **)(param_5 + 0x40) = \"ExecuteBatch\";\n  FUN_01c10c80(param_4,param_5,param_6,DAT_04aab91c,0);\n  uVar1 = FUN_00e603b0(param_5,param_6);\n  if (*(int *)(param_5 + 0x14) == 0) {\n    if ((*(int *)(param_5 + 0x18) == 0) && ((uVar1 & 3) != 0)) {\n      uVar1 = (uVar1 + 4) - (int)uVar1 % 4;\n    }\n    dissect_dcerpc_uint32(param_1,uVar1,param_3,param_4,param_6,DAT_04aab918,local_24);\n  }\n  FUN_00e603b0(param_5,param_6);\n  DAT_043ed2c4 = 1;\n  if (*(int *)(param_5 + 0x14) == 0) {\n    FUN_00e618e0(param_4,param_5,param_6,FUN_016c1630,1,\"Pointer to LpData (uint8)\",DAT_04aab928,0,0\n                );\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    FUN_00e603b0();\n    return;\n  }\n  FUN_01e4ff70();\n}",
        "output": "```c\nvoid ExecuteBatch(undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4,\n                  int param_5, undefined4 param_6)\n{\n    uint calculatedValue;\n    int stackGuard;\n    undefined localBuffer[4];\n    int originalStackValue;\n    undefined4 constantValue = 0x16d95d9;\n\n    originalStackValue = *(int *)(stackGuard + 0x14);\n    *(char **)(param_5 + 0x40) = \"ExecuteBatch\";\n\n    FUN_01c10c80(param_4, param_5, param_6, DAT_04aab91c, 0);\n    calculatedValue = FUN_00e603b0(param_5, param_6);\n\n    if (*(int *)(param_5 + 0x14) == 0) {\n        if ((*(int *)(param_5 + 0x18) == 0) && ((calculatedValue & 3) != 0)) {\n            calculatedValue = (calculatedValue + 4) - (int)calculatedValue % 4;\n        }\n        dissect_dcerpc_uint32(param_1, calculatedValue, param_3, param_4, param_6, DAT_04aab918, localBuffer);\n    }\n\n    FUN_00e603b0(param_5, param_6);\n    DAT_043ed2c4 = 1;\n\n    if (*(int *)(param_5 + 0x14) == 0) {\n        FUN_00e618e0(param_4, param_5, param_6, FUN_016c1630, 1, \"Pointer to LpData (uint8)\", DAT_04aab928, 0, 0);\n    }\n\n    if (originalStackValue == *(int *)(stackGuard + 0x14)) {\n        FUN_00e603b0();\n        return;\n    }\n\n    FUN_01e4ff70();\n}\n```",
        "normed_func_sha256": "55b0a3ad89538e6e87291546534ffaa4fa4c3d75ebfeac6a25c39903c0d8808d",
        "source_code": "static int\nclusapi_dissect_ExecuteBatch_request(tvbuff_t *tvb _U_, int offset _U_, packet_info *pinfo _U_, proto_tree *tree _U_, dcerpc_info* di _U_, guint8 *drep _U_)\n{\n\tdi->dcerpc_procedure_name=\"ExecuteBatch\";\n\toffset = clusapi_dissect_element_ExecuteBatch_hKey(tvb, offset, pinfo, tree, di, drep);\n\toffset = dissect_deferred_pointers(pinfo, tvb, offset, di, drep);\n\toffset = clusapi_dissect_element_ExecuteBatch_cbData(tvb, offset, pinfo, tree, di, drep);\n\toffset = dissect_deferred_pointers(pinfo, tvb, offset, di, drep);\n\toffset = clusapi_dissect_element_ExecuteBatch_lpData(tvb, offset, pinfo, tree, di, drep);\n\toffset = dissect_deferred_pointers(pinfo, tvb, offset, di, drep);\n\treturn offset;\n}",
        "parsed_output": "void ExecuteBatch(undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4,\n                  int param_5, undefined4 param_6)\n{\n    uint calculatedValue;\n    int stackGuard;\n    undefined localBuffer[4];\n    int originalStackValue;\n    undefined4 constantValue = 0x16d95d9;\n\n    originalStackValue = *(int *)(stackGuard + 0x14);\n    *(char **)(param_5 + 0x40) = \"ExecuteBatch\";\n\n    FUN_01c10c80(param_4, param_5, param_6, DAT_04aab91c, 0);\n    calculatedValue = FUN_00e603b0(param_5, param_6);\n\n    if (*(int *)(param_5 + 0x14) == 0) {\n        if ((*(int *)(param_5 + 0x18) == 0) && ((calculatedValue & 3) != 0)) {\n            calculatedValue = (calculatedValue + 4) - (int)calculatedValue % 4;\n        }\n        dissect_dcerpc_uint32(param_1, calculatedValue, param_3, param_4, param_6, DAT_04aab918, localBuffer);\n    }\n\n    FUN_00e603b0(param_5, param_6);\n    DAT_043ed2c4 = 1;\n\n    if (*(int *)(param_5 + 0x14) == 0) {\n        FUN_00e618e0(param_4, param_5, param_6, FUN_016c1630, 1, \"Pointer to LpData (uint8)\", DAT_04aab928, 0, 0);\n    }\n\n    if (originalStackValue == *(int *)(stackGuard + 0x14)) {\n        FUN_00e603b0();\n        return;\n    }\n\n    FUN_01e4ff70();\n}",
        "baseline_code_stripped": "void FUN_016d95d0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 int param_5,undefined4 param_6)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  undefined local_24 [4];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x16d95d9;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  *(char **)(param_5 + 0x40) = \"ExecuteBatch\";\n  FUN_01c10c80(param_4,param_5,param_6,DAT_04aab91c,0);\n  uVar1 = FUN_00e603b0(param_5,param_6);\n  if (*(int *)(param_5 + 0x14) == 0) {\n    if ((*(int *)(param_5 + 0x18) == 0) && ((uVar1 & 3) != 0)) {\n      uVar1 = (uVar1 + 4) - (int)uVar1 % 4;\n    }\n    dissect_dcerpc_uint32(param_1,uVar1,param_3,param_4,param_6,DAT_04aab918,local_24);\n  }\n  FUN_00e603b0(param_5,param_6);\n  DAT_043ed2c4 = 1;\n  if (*(int *)(param_5 + 0x14) == 0) {\n    FUN_00e618e0(param_4,param_5,param_6,FUN_016c1630,1,\"Pointer to LpData (uint8)\",DAT_04aab928,0,0\n                );\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    FUN_00e603b0();\n    return;\n  }\n  FUN_01e4ff70();\n}",
        "similarity_score_unixcoder": 0.5091552734375,
        "similarity_score_baseline_stripped": 0.5408616065979004
    },
    {
        "func_name": "i915_gem_get_caching_ioctl",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 i915_gem_get_caching_ioctl(void)\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  undefined8 uVar5;\n  uVar5 = __fentry__();\n  if ((*(byte *)((int)uVar5 + 0x1451) & 8) == 0) {\n    __rcu_read_lock();\n    iVar2 = idr_find();\n    if (iVar2 == 0) {\n      uVar4 = 0xfffffffe;\n    }\n    else {\n      bVar1 = *(byte *)(iVar2 + 0x150) & 7;\n      if (bVar1 < 3) {\n        uVar3 = (uint)(bVar1 != 0);\n      }\n      else {\n        uVar3 = (uint)(bVar1 == 3) * 2;\n      }\n      *(uint *)((int)((ulonglong)uVar5 >> 0x20) + 4) = uVar3;\n      uVar4 = 0;\n    }\n    __rcu_read_unlock();\n  }\n  else {\n    uVar4 = 0xffffffed;\n  }\n  return uVar4;\n}",
        "output": "```c\nuint32_t i915_gem_get_caching_ioctl(void) {\n    uint8_t caching_flag;\n    int resource_id;\n    uint32_t caching_value;\n    uint32_t return_value;\n    uint64_t entry_point = __fentry__();\n\n    if ((*(uint8_t *)((int)entry_point + 0x1451) & 8) == 0) {\n        __rcu_read_lock();\n        resource_id = idr_find();\n\n        if (resource_id == 0) {\n            return_value = 0xfffffffe; // Resource not found\n        } else {\n            caching_flag = *(uint8_t *)(resource_id + 0x150) & 7;\n\n            if (caching_flag < 3) {\n                caching_value = (uint32_t)(caching_flag != 0);\n            } else {\n                caching_value = (uint32_t)(caching_flag == 3) * 2;\n            }\n\n            *(uint32_t *)((int)((uint64_t)entry_point >> 0x20) + 4) = caching_value;\n            return_value = 0; // Success\n        }\n\n        __rcu_read_unlock();\n    } else {\n        return_value = 0xffffffed; // Invalid operation\n    }\n\n    return return_value;\n}\n```",
        "normed_func_sha256": "d7ca38517563582bcd295bdd7ad5d73df77006ef6d2006ea262eb5227919df61",
        "source_code": "int i915_gem_get_caching_ioctl(struct drm_device *dev, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct drm_i915_gem_caching *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tint err = 0;\n\n\tif (IS_DGFX(to_i915(dev)))\n\t\treturn -ENODEV;\n\n\trcu_read_lock();\n\tobj = i915_gem_object_lookup_rcu(file, args->handle);\n\tif (!obj) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tswitch (obj->cache_level) {\n\tcase I915_CACHE_LLC:\n\tcase I915_CACHE_L3_LLC:\n\t\targs->caching = I915_CACHING_CACHED;\n\t\tbreak;\n\n\tcase I915_CACHE_WT:\n\t\targs->caching = I915_CACHING_DISPLAY;\n\t\tbreak;\n\n\tdefault:\n\t\targs->caching = I915_CACHING_NONE;\n\t\tbreak;\n\t}\nout:\n\trcu_read_unlock();\n\treturn err;\n}",
        "parsed_output": "uint32_t i915_gem_get_caching_ioctl(void) {\n    uint8_t caching_flag;\n    int resource_id;\n    uint32_t caching_value;\n    uint32_t return_value;\n    uint64_t entry_point = __fentry__();\n\n    if ((*(uint8_t *)((int)entry_point + 0x1451) & 8) == 0) {\n        __rcu_read_lock();\n        resource_id = idr_find();\n\n        if (resource_id == 0) {\n            return_value = 0xfffffffe; // Resource not found\n        } else {\n            caching_flag = *(uint8_t *)(resource_id + 0x150) & 7;\n\n            if (caching_flag < 3) {\n                caching_value = (uint32_t)(caching_flag != 0);\n            } else {\n                caching_value = (uint32_t)(caching_flag == 3) * 2;\n            }\n\n            *(uint32_t *)((int)((uint64_t)entry_point >> 0x20) + 4) = caching_value;\n            return_value = 0; // Success\n        }\n\n        __rcu_read_unlock();\n    } else {\n        return_value = 0xffffffed; // Invalid operation\n    }\n\n    return return_value;\n}",
        "baseline_code_stripped": "undefined4 i915_gem_get_caching_ioctl(void)\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  undefined8 uVar5;\n  uVar5 = __fentry__();\n  if ((*(byte *)((int)uVar5 + 0x1451) & 8) == 0) {\n    __rcu_read_lock();\n    iVar2 = idr_find();\n    if (iVar2 == 0) {\n      uVar4 = 0xfffffffe;\n    }\n    else {\n      bVar1 = *(byte *)(iVar2 + 0x150) & 7;\n      if (bVar1 < 3) {\n        uVar3 = (uint)(bVar1 != 0);\n      }\n      else {\n        uVar3 = (uint)(bVar1 == 3) * 2;\n      }\n      *(uint *)((int)((ulonglong)uVar5 >> 0x20) + 4) = uVar3;\n      uVar4 = 0;\n    }\n    __rcu_read_unlock();\n  }\n  else {\n    uVar4 = 0xffffffed;\n  }\n  return uVar4;\n}",
        "similarity_score_unixcoder": 0.7098244428634644,
        "similarity_score_baseline_stripped": 0.561419665813446
    },
    {
        "func_name": "_wrap_SoSFInt32_getTypeId",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_0015fe10(undefined4 param_1,int param_2)\n{\n  int iVar1;\n  undefined2 *puVar2;\n  undefined4 uVar3;\n  undefined4 *puVar4;\n  int in_GS_OFFSET;\n  undefined4 uStack_30;\n  undefined auStack_2c [10];\n  undefined2 local_22;\n  undefined local_1e [10];\n  int *local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  local_14 = (int *)0x0;\n  if (param_2 != 0) {\n    iVar1 = FUN_004c32b0(0);\n    if (-1 < iVar1) {\n      (**(code **)(*local_14 + 8))(local_1e,local_14);\n      puVar2 = (undefined2 *)operator_new(2);\n      puVar4 = &uStack_30;\n      *puVar2 = local_22;\n      if (local_14 == *(int **)(in_GS_OFFSET + 0x14)) {\n        uVar3 = FUN_004c6e90();\n        return uVar3;\n      }\n      goto LAB_0015fee8;\n    }\n    uStack_30 = 0x15febf;\n    uVar3 = FUN_00107260();\n    PyErr_SetString(uVar3,\n                    \"in method \\'SoSFInt32_getTypeId\\', argument 1 of type \\'SoSFInt32 const *\\'\");\n  }\n  puVar4 = (undefined4 *)auStack_2c;\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return 0;\n  }\nLAB_0015fee8:\n  *(undefined **)((int)puVar4 + -4) = &UNK_0015feed;\n  FUN_004c9df0();\n}",
        "output": "```c\nundefined4 FUN_0015fe10(undefined4 param_1, int param_2) {\n    int stackGuard;\n    undefined2 *newPointer;\n    undefined4 returnValue;\n    undefined4 *stackPointer;\n    undefined4 errorCode;\n    undefined4 localReturnValue;\n    undefined auStack_2c[10];\n    undefined2 localTypeId;\n    undefined localBuffer[10];\n    int *localGuardPointer;\n    int localStackGuard;\n\n    stackGuard = *(int *)(in_GS_OFFSET + 0x14);\n    localGuardPointer = (int *)0x0;\n\n    if (param_2 != 0) {\n        int functionResult = FUN_004c32b0(0);\n        if (functionResult >= 0) {\n            (**(code **)(*localGuardPointer + 8))(localBuffer, localGuardPointer);\n            newPointer = (undefined2 *)operator_new(2);\n            stackPointer = &localReturnValue;\n            *newPointer = localTypeId;\n\n            if (localGuardPointer == *(int **)(in_GS_OFFSET + 0x14)) {\n                returnValue = FUN_004c6e90();\n                return returnValue;\n            }\n            goto returnValueLabel;\n        }\n\n        localReturnValue = 0x15febf;\n        returnValue = FUN_00107260();\n        PyErr_SetString(returnValue, \"in method 'SoSFInt32_getTypeId', argument 1 of type 'SoSFInt32 const *'\");\n    }\n\n    stackPointer = (undefined4 *)auStack_2c;\n    if (localStackGuard == *(int *)(in_GS_OFFSET + 0x14)) {\n        return 0;\n    }\n\nreturnValueLabel:\n    *(undefined **)((int)stackPointer - 4) = &UNK_0015feed;\n    FUN_004c9df0();\n}\n```",
        "normed_func_sha256": "b59dcfe1e26cd0492e75f1eed33c276b3a0a700cf0cdbdea1768cca02339f945",
        "source_code": "SWIGINTERN PyObject *_wrap_SoSFInt32_getTypeId(PyObject *self, PyObject *args) {\n  PyObject *resultobj = 0;\n  SoSFInt32 *arg1 = (SoSFInt32 *) 0 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  PyObject *swig_obj[1] ;\n  SoType result;\n  \n  if (!args) SWIG_fail;\n  swig_obj[0] = args;\n  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_SoSFInt32, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"SoSFInt32_getTypeId\" \"', argument \" \"1\"\" of type '\" \"SoSFInt32 const *\"\"'\"); \n  }\n  arg1 = reinterpret_cast< SoSFInt32 * >(argp1);\n  result = ((SoSFInt32 const *)arg1)->getTypeId();\n  resultobj = SWIG_NewPointerObj((new SoType(result)), SWIGTYPE_p_SoType, SWIG_POINTER_OWN |  0 );\n  return resultobj;\nfail:\n  return NULL;\n}",
        "parsed_output": "undefined4 FUN_0015fe10(undefined4 param_1, int param_2) {\n    int stackGuard;\n    undefined2 *newPointer;\n    undefined4 returnValue;\n    undefined4 *stackPointer;\n    undefined4 errorCode;\n    undefined4 localReturnValue;\n    undefined auStack_2c[10];\n    undefined2 localTypeId;\n    undefined localBuffer[10];\n    int *localGuardPointer;\n    int localStackGuard;\n\n    stackGuard = *(int *)(in_GS_OFFSET + 0x14);\n    localGuardPointer = (int *)0x0;\n\n    if (param_2 != 0) {\n        int functionResult = FUN_004c32b0(0);\n        if (functionResult >= 0) {\n            (**(code **)(*localGuardPointer + 8))(localBuffer, localGuardPointer);\n            newPointer = (undefined2 *)operator_new(2);\n            stackPointer = &localReturnValue;\n            *newPointer = localTypeId;\n\n            if (localGuardPointer == *(int **)(in_GS_OFFSET + 0x14)) {\n                returnValue = FUN_004c6e90();\n                return returnValue;\n            }\n            goto returnValueLabel;\n        }\n\n        localReturnValue = 0x15febf;\n        returnValue = FUN_00107260();\n        PyErr_SetString(returnValue, \"in method 'SoSFInt32_getTypeId', argument 1 of type 'SoSFInt32 const *'\");\n    }\n\n    stackPointer = (undefined4 *)auStack_2c;\n    if (localStackGuard == *(int *)(in_GS_OFFSET + 0x14)) {\n        return 0;\n    }\n\nreturnValueLabel:\n    *(undefined **)((int)stackPointer - 4) = &UNK_0015feed;\n    FUN_004c9df0();\n}",
        "baseline_code_stripped": "undefined4 FUN_0015fe10(undefined4 param_1,int param_2)\n{\n  int iVar1;\n  undefined2 *puVar2;\n  undefined4 uVar3;\n  undefined4 *puVar4;\n  int in_GS_OFFSET;\n  undefined4 uStack_30;\n  undefined auStack_2c [10];\n  undefined2 local_22;\n  undefined local_1e [10];\n  int *local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  local_14 = (int *)0x0;\n  if (param_2 != 0) {\n    iVar1 = FUN_004c32b0(0);\n    if (-1 < iVar1) {\n      (**(code **)(*local_14 + 8))(local_1e,local_14);\n      puVar2 = (undefined2 *)operator_new(2);\n      puVar4 = &uStack_30;\n      *puVar2 = local_22;\n      if (local_14 == *(int **)(in_GS_OFFSET + 0x14)) {\n        uVar3 = FUN_004c6e90();\n        return uVar3;\n      }\n      goto LAB_0015fee8;\n    }\n    uStack_30 = 0x15febf;\n    uVar3 = FUN_00107260();\n    PyErr_SetString(uVar3,\n                    \"in method \\'SoSFInt32_getTypeId\\', argument 1 of type \\'SoSFInt32 const *\\'\");\n  }\n  puVar4 = (undefined4 *)auStack_2c;\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return 0;\n  }\nLAB_0015fee8:\n  *(undefined **)((int)puVar4 + -4) = &UNK_0015feed;\n  FUN_004c9df0();\n}",
        "similarity_score_unixcoder": 0.656875729560852,
        "similarity_score_baseline_stripped": 0.6062556505203247
    },
    {
        "func_name": "AreaSelectionWidget::updateSelectedAreaOnDragBottom",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00122ca0(long param_1,long param_2)\n{\n  long lVar1;\n  double dVar2;\n  double dVar3;\n  double dVar4;\n  double dVar5;\n  lVar1 = *(long *)(param_1 + 0x38);\n  dVar4 = *(double *)(lVar1 + 0x110);\n  dVar3 = (double)*(int *)(param_2 + 4);\n  dVar5 = dVar4 + 6.0;\n  dVar2 = *(double *)(lVar1 + 0xe8) + *(double *)(lVar1 + 0xf8) + *(double *)(lVar1 + 0xb0);\n  if (dVar5 <= dVar3) {\n    if (dVar3 <= dVar2) {\n      dVar4 = dVar3 - dVar4;\n    }\n    else {\n      dVar4 = dVar2 - dVar4;\n    }\n  }\n  else {\n    dVar4 = dVar5 - dVar4;\n  }\n  if (*(char *)(lVar1 + 0x170) != '\\0') {\n    dVar3 = *(double *)(lVar1 + 0x168) * dVar4;\n    if ((dVar3 < dVar5) || (dVar2 < dVar3)) {\n      return;\n    }\n    *(double *)(lVar1 + 0x118) = dVar3;\n  }\n  *(double *)(lVar1 + 0x120) = dVar4;\n  FUN_00122ad0(param_1,1);\n  return;\n}",
        "output": "```c\nvoid processValues(long param_1, long param_2) {\n    long baseAddress = *(long *)(param_1 + 0x38);\n    double thresholdValue = *(double *)(baseAddress + 0x110);\n    double inputValue = (double)*(int *)(param_2 + 4);\n    double adjustedThreshold = thresholdValue + 6.0;\n    double sumValues = *(double *)(baseAddress + 0xe8) + \n                       *(double *)(baseAddress + 0xf8) + \n                       *(double *)(baseAddress + 0xb0);\n    \n    if (adjustedThreshold <= inputValue) {\n        if (inputValue <= sumValues) {\n            thresholdValue = inputValue - thresholdValue;\n        } else {\n            thresholdValue = sumValues - thresholdValue;\n        }\n    } else {\n        thresholdValue = adjustedThreshold - thresholdValue;\n    }\n    \n    if (*(char *)(baseAddress + 0x170) != '\\0') {\n        double scaledValue = *(double *)(baseAddress + 0x168) * thresholdValue;\n        if ((scaledValue < adjustedThreshold) || (sumValues < scaledValue)) {\n            return;\n        }\n        *(double *)(baseAddress + 0x118) = scaledValue;\n    }\n    \n    *(double *)(baseAddress + 0x120) = thresholdValue;\n    FUN_00122ad0(param_1, 1);\n    return;\n}\n```",
        "normed_func_sha256": "34bbb36a2808605e71cc2ffe83d99a5f5ca014df23c7ad1523eebb95714c8276",
        "source_code": "void AreaSelectionWidget::updateSelectedAreaOnDragBottom(const QPoint& mousePosition)\n{\n    Q_D (AreaSelectionWidget);\n\n    // the drag handle size in the bounds calculations ensure that the\n    // box does not get too small to reach the drag handles with the mouse\n    const qreal topBound    = d->rectSelectedArea.y() + d->DRAG_HANDLE_SIZE;\n    const qreal bottomBound = d->rectDisplayArea.y() + d->rectDisplayArea.height() + d->outOfBoundsDisplayAreaMargin;\n    const qreal mouseY      = mousePosition.y();\n    qreal       newHeight   = 0.;\n\n    if (mouseY < topBound) {\n        newHeight = topBound - d->rectSelectedArea.y();\n    } else if (mouseY > bottomBound) {\n        newHeight = bottomBound - d->rectSelectedArea.y();\n    } else {\n        newHeight = mouseY - d->rectSelectedArea.y();\n    }\n\n    if (d->proportionsLocked) {\n        const auto newWidth = newHeight * d->proportions;\n        if (newWidth < topBound || newWidth > bottomBound) return;\n        d->rectSelectedArea.setWidth(newWidth);\n    }\n    d->rectSelectedArea.setHeight(newHeight);\n\n    updateSelectedAreaSize(true);\n}",
        "parsed_output": "void processValues(long param_1, long param_2) {\n    long baseAddress = *(long *)(param_1 + 0x38);\n    double thresholdValue = *(double *)(baseAddress + 0x110);\n    double inputValue = (double)*(int *)(param_2 + 4);\n    double adjustedThreshold = thresholdValue + 6.0;\n    double sumValues = *(double *)(baseAddress + 0xe8) + \n                       *(double *)(baseAddress + 0xf8) + \n                       *(double *)(baseAddress + 0xb0);\n    \n    if (adjustedThreshold <= inputValue) {\n        if (inputValue <= sumValues) {\n            thresholdValue = inputValue - thresholdValue;\n        } else {\n            thresholdValue = sumValues - thresholdValue;\n        }\n    } else {\n        thresholdValue = adjustedThreshold - thresholdValue;\n    }\n    \n    if (*(char *)(baseAddress + 0x170) != '\\0') {\n        double scaledValue = *(double *)(baseAddress + 0x168) * thresholdValue;\n        if ((scaledValue < adjustedThreshold) || (sumValues < scaledValue)) {\n            return;\n        }\n        *(double *)(baseAddress + 0x118) = scaledValue;\n    }\n    \n    *(double *)(baseAddress + 0x120) = thresholdValue;\n    FUN_00122ad0(param_1, 1);\n    return;\n}",
        "baseline_code_stripped": "void FUN_00122ca0(long param_1,long param_2)\n{\n  long lVar1;\n  double dVar2;\n  double dVar3;\n  double dVar4;\n  double dVar5;\n  lVar1 = *(long *)(param_1 + 0x38);\n  dVar4 = *(double *)(lVar1 + 0x110);\n  dVar3 = (double)*(int *)(param_2 + 4);\n  dVar5 = dVar4 + 6.0;\n  dVar2 = *(double *)(lVar1 + 0xe8) + *(double *)(lVar1 + 0xf8) + *(double *)(lVar1 + 0xb0);\n  if (dVar5 <= dVar3) {\n    if (dVar3 <= dVar2) {\n      dVar4 = dVar3 - dVar4;\n    }\n    else {\n      dVar4 = dVar2 - dVar4;\n    }\n  }\n  else {\n    dVar4 = dVar5 - dVar4;\n  }\n  if (*(char *)(lVar1 + 0x170) != '\\0') {\n    dVar3 = *(double *)(lVar1 + 0x168) * dVar4;\n    if ((dVar3 < dVar5) || (dVar2 < dVar3)) {\n      return;\n    }\n    *(double *)(lVar1 + 0x118) = dVar3;\n  }\n  *(double *)(lVar1 + 0x120) = dVar4;\n  FUN_00122ad0(param_1,1);\n  return;\n}",
        "similarity_score_unixcoder": 0.5001455545425415,
        "similarity_score_baseline_stripped": 0.37720635533332825
    },
    {
        "func_name": "sipwxScrolledWindow::AcceptsFocusRecursively",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall sipwxScrolledWindow::AcceptsFocusRecursively(sipwxScrolledWindow *this)\n{\n  _object *p_Var1;\n  int iVar2;\n  PyGILState_STATE local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__core + 0x164))\n                     (&local_18,this + 0x223,*(undefined4 *)(this + 0x200),0,\n                      \"AcceptsFocusRecursively\");\n  if (p_Var1 == (_object *)0x0) {\n    iVar2 = wxControlContainerBase::AcceptsFocus();\n    if ((iVar2 == 0) && (this[0x19d] != (sipwxScrolledWindow)0x0)) {\n      wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n    }\n  }\n  else {\n    sipVH__core_5(local_18,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0,\n                  *(_sipSimpleWrapper **)(this + 0x200),p_Var1);\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nvoid sipwxScrolledWindow::AcceptsFocusRecursively(sipwxScrolledWindow *this)\n{\n    _object *focusObject;\n    int focusStatus;\n    PyGILState_STATE gilState;\n    int stackGuard = __stack_chk_guard;\n\n    focusObject = (_object *)(**(code **)(sipAPI__core + 0x164))(\n        &gilState, \n        this + 0x223, \n        *(undefined4 *)(this + 0x200), \n        0, \n        \"AcceptsFocusRecursively\"\n    );\n\n    if (focusObject == (_object *)0x0) {\n        focusStatus = wxControlContainerBase::AcceptsFocus();\n        if (focusStatus == 0 && this[0x19d] != (sipwxScrolledWindow)0x0) {\n            wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n        }\n    } else {\n        sipVH__core_5(\n            gilState, \n            (_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0, \n            *(_sipSimpleWrapper **)(this + 0x200), \n            focusObject\n        );\n    }\n\n    if (stackGuard == __stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}\n```",
        "normed_func_sha256": "fa24614a30142c5737effbb6f084ebc4d2f5db768ef04caf8f87f137e4ac80c8",
        "source_code": "bool sipwxScrolledWindow::AcceptsFocusRecursively() const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[31]),sipPySelf,SIP_NULLPTR,sipName_AcceptsFocusRecursively);\n\n    if (!sipMeth)\n        return  ::wxScrolledWindow::AcceptsFocusRecursively();\n\n    extern bool sipVH__core_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);\n\n    return sipVH__core_5(sipGILState, 0, sipPySelf, sipMeth);\n}",
        "parsed_output": "void sipwxScrolledWindow::AcceptsFocusRecursively(sipwxScrolledWindow *this)\n{\n    _object *focusObject;\n    int focusStatus;\n    PyGILState_STATE gilState;\n    int stackGuard = __stack_chk_guard;\n\n    focusObject = (_object *)(**(code **)(sipAPI__core + 0x164))(\n        &gilState, \n        this + 0x223, \n        *(undefined4 *)(this + 0x200), \n        0, \n        \"AcceptsFocusRecursively\"\n    );\n\n    if (focusObject == (_object *)0x0) {\n        focusStatus = wxControlContainerBase::AcceptsFocus();\n        if (focusStatus == 0 && this[0x19d] != (sipwxScrolledWindow)0x0) {\n            wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n        }\n    } else {\n        sipVH__core_5(\n            gilState, \n            (_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0, \n            *(_sipSimpleWrapper **)(this + 0x200), \n            focusObject\n        );\n    }\n\n    if (stackGuard == __stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "void __thiscall sipwxScrolledWindow::AcceptsFocusRecursively(sipwxScrolledWindow *this)\n{\n  _object *p_Var1;\n  int iVar2;\n  PyGILState_STATE local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__core + 0x164))\n                     (&local_18,this + 0x223,*(undefined4 *)(this + 0x200),0,\n                      \"AcceptsFocusRecursively\");\n  if (p_Var1 == (_object *)0x0) {\n    iVar2 = wxControlContainerBase::AcceptsFocus();\n    if ((iVar2 == 0) && (this[0x19d] != (sipwxScrolledWindow)0x0)) {\n      wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n    }\n  }\n  else {\n    sipVH__core_5(local_18,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0,\n                  *(_sipSimpleWrapper **)(this + 0x200),p_Var1);\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.7881447076797485,
        "similarity_score_baseline_stripped": 0.8062808513641357
    },
    {
        "func_name": "toBool",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 dart::utils::toBool(basic_string *param_1)\n{\n  int iVar1;\n  undefined8 uVar2;\n  basic_ostream *pbVar3;\n  long in_FS_OFFSET;\n  locale local_80 [8];\n  undefined *local_78 [2];\n  undefined local_68 [16];\n  undefined *local_58 [2];\n  undefined local_48 [24];\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  std::locale::locale(local_80);\n  local_58[0] = local_48;\n  FUN_00198f80(local_58,*(long *)param_1,local_80,*(long *)(param_1 + 8) + *(long *)param_1);\n  iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                    ((char *)local_58);\n  if (iVar1 != 0) {\n    iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                      ((char *)param_1);\n    if (iVar1 != 0) {\n      if (local_58[0] == local_48) {\n        std::locale::_locale(local_80);\n      }\n      else {\n        operator_delete(local_58[0]);\n        std::locale::_locale(local_80);\n      }\n      std::locale::locale(local_80);\n      local_58[0] = local_48;\n      FUN_00198f80(local_58,*(long *)param_1,local_80,*(long *)(param_1 + 8) + *(long *)param_1);\n      iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                        ((char *)local_58);\n      if (iVar1 == 0) {\nLAB_00177a71:\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n          std::locale::_locale(local_80);\n          uVar2 = 0;\n          goto LAB_001779dc;\n        }\n        std::locale::_locale(local_80);\n      }\n      else {\n        iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n                compare((char *)param_1);\n        if (iVar1 == 0) goto LAB_00177a71;\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n        }\n        std::locale::_locale(local_80);\n        FUN_00198c10(local_78,\"/home/abuild/rpmbuild/BUILD/dart-4.3.7/dart/utils/Parser.cpp\");\n        FUN_00198c10(local_58,\"Error\");\n        pbVar3 = (basic_ostream *)\n                 dart::common::colorErr((basic_string *)local_58,(basic_string *)local_78,0x7b,0x1f)\n        ;\n        std::__ostream_insert_char_std__char_traits_char__(pbVar3,\"value [\",7);\n        pbVar3 = std::__ostream_insert_char_std__char_traits_char__\n                           (pbVar3,*(char **)param_1,*(long *)(param_1 + 8));\n        std::__ostream_insert_char_std__char_traits_char__\n                  (pbVar3,\"] is not a valid boolean type. \",0x1f);\n        std::__ostream_insert_char_std__char_traits_char__(pbVar3,\"Retuning false.\",0xf);\n        std::endl_char_std__char_traits_char__(pbVar3);\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n        }\n        if (local_78[0] != local_68) {\n          operator_delete(local_78[0]);\n          uVar2 = 0;\n          goto LAB_001779dc;\n        }\n      }\n      uVar2 = 0;\n      goto LAB_001779dc;\n    }\n  }\n  if (local_58[0] == local_48) {\n    std::locale::_locale(local_80);\n    uVar2 = 1;\n  }\n  else {\n    operator_delete(local_58[0]);\n    std::locale::_locale(local_80);\n    uVar2 = 1;\n  }\nLAB_001779dc:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n  __stack_chk_fail();\n}",
        "output": "```cpp\nundefined8 dart::utils::toBool(basic_string *inputString) {\n    int comparisonResult;\n    undefined8 returnValue;\n    basic_ostream *outputStream;\n    long stackGuard;\n    locale localLocale[8];\n    undefined *errorMessageBuffer[2];\n    undefined localErrorBuffer[16];\n    undefined *localeBuffer[2];\n    undefined localLocaleBuffer[24];\n    long savedStackGuard;\n\n    savedStackGuard = *(long *)(stackGuard + 0x28);\n    std::locale::locale(localLocale);\n    localeBuffer[0] = localLocaleBuffer;\n\n    FUN_00198f80(localeBuffer, *(long *)inputString, localLocale, *(long *)(inputString + 8) + *(long *)inputString);\n    comparisonResult = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char *)localeBuffer);\n\n    if (comparisonResult != 0) {\n        comparisonResult = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char *)inputString);\n        \n        if (comparisonResult != 0) {\n            if (localeBuffer[0] == localLocaleBuffer) {\n                std::locale::_locale(localLocale);\n            } else {\n                operator_delete(localeBuffer[0]);\n                std::locale::_locale(localLocale);\n            }\n\n            std::locale::locale(localLocale);\n            localeBuffer[0] = localLocaleBuffer;\n            FUN_00198f80(localeBuffer, *(long *)inputString, localLocale, *(long *)(inputString + 8) + *(long *)inputString);\n            comparisonResult = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char *)localeBuffer);\n\n            if (comparisonResult == 0) {\n                if (localeBuffer[0] != localLocaleBuffer) {\n                    operator_delete(localeBuffer[0]);\n                    std::locale::_locale(localLocale);\n                    returnValue = 0;\n                    goto cleanup;\n                }\n                std::locale::_locale(localLocale);\n            } else {\n                comparisonResult = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char *)inputString);\n                if (comparisonResult == 0) goto cleanup;\n\n                if (localeBuffer[0] != localLocaleBuffer) {\n                    operator_delete(localeBuffer[0]);\n                }\n                std::locale::_locale(localLocale);\n                FUN_00198c10(errorMessageBuffer, \"/home/abuild/rpmbuild/BUILD/dart-4.3.7/dart/utils/Parser.cpp\");\n                FUN_00198c10(localeBuffer, \"Error\");\n                outputStream = (basic_ostream *)dart::common::colorErr((basic_string *)localeBuffer, (basic_string *)errorMessageBuffer, 0x7b, 0x1f);\n                std::__ostream_insert_char_std__char_traits_char__(outputStream, \"value [\", 7);\n                outputStream = std::__ostream_insert_char_std__char_traits_char__(outputStream, *(char **)inputString, *(long *)(inputString + 8));\n                std::__ostream_insert_char_std__char_traits_char__(outputStream, \"] is not a valid boolean type. \", 0x1f);\n                std::__ostream_insert_char_std__char_traits_char__(outputStream, \"Returning false.\", 0xf);\n                std::endl_char_std__char_traits_char__(outputStream);\n\n                if (localeBuffer[0] != localLocaleBuffer) {\n                    operator_delete(localeBuffer[0]);\n                }\n                if (errorMessageBuffer[0] != localErrorBuffer) {\n                    operator_delete(errorMessageBuffer[0]);\n                    returnValue = 0;\n                    goto cleanup;\n                }\n            }\n            returnValue = 0;\n            goto cleanup;\n        }\n    }\n\n    if (localeBuffer[0] == localLocaleBuffer) {\n        std::locale::_locale(localLocale);\n        returnValue = 1;\n    } else {\n        operator_delete(localeBuffer[0]);\n        std::locale::_locale(localLocale);\n        returnValue = 1;\n    }\n\ncleanup:\n    if (savedStackGuard == *(long *)(stackGuard + 0x28)) {\n        return returnValue;\n    }\n    __stack_chk_fail();\n}\n```",
        "normed_func_sha256": "7ec5d43968c90a4dc27df463804ea0459a2ee282096f73d2cbda4ec442f1c684",
        "source_code": "bool toBool(const std::string& _str)\n{\n    if (boost::to_upper_copy(_str) == \"TRUE\" || _str == \"1\")\n        return true;\n    else if (boost::to_upper_copy(_str) == \"FALSE\" || _str == \"0\")\n        return false;\n    else\n    {\n        dterr << \"value [\"\n              << _str\n              << \"] is not a valid boolean type. \"\n              << \"Retuning false.\"\n              << std::endl;\n        return false;\n        assert(0);\n    }\n}",
        "parsed_output": "pp\nundefined8 dart::utils::toBool(basic_string *inputString) {\n    int comparisonResult;\n    undefined8 returnValue;\n    basic_ostream *outputStream;\n    long stackGuard;\n    locale localLocale[8];\n    undefined *errorMessageBuffer[2];\n    undefined localErrorBuffer[16];\n    undefined *localeBuffer[2];\n    undefined localLocaleBuffer[24];\n    long savedStackGuard;\n\n    savedStackGuard = *(long *)(stackGuard + 0x28);\n    std::locale::locale(localLocale);\n    localeBuffer[0] = localLocaleBuffer;\n\n    FUN_00198f80(localeBuffer, *(long *)inputString, localLocale, *(long *)(inputString + 8) + *(long *)inputString);\n    comparisonResult = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char *)localeBuffer);\n\n    if (comparisonResult != 0) {\n        comparisonResult = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char *)inputString);\n        \n        if (comparisonResult != 0) {\n            if (localeBuffer[0] == localLocaleBuffer) {\n                std::locale::_locale(localLocale);\n            } else {\n                operator_delete(localeBuffer[0]);\n                std::locale::_locale(localLocale);\n            }\n\n            std::locale::locale(localLocale);\n            localeBuffer[0] = localLocaleBuffer;\n            FUN_00198f80(localeBuffer, *(long *)inputString, localLocale, *(long *)(inputString + 8) + *(long *)inputString);\n            comparisonResult = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char *)localeBuffer);\n\n            if (comparisonResult == 0) {\n                if (localeBuffer[0] != localLocaleBuffer) {\n                    operator_delete(localeBuffer[0]);\n                    std::locale::_locale(localLocale);\n                    returnValue = 0;\n                    goto cleanup;\n                }\n                std::locale::_locale(localLocale);\n            } else {\n                comparisonResult = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char *)inputString);\n                if (comparisonResult == 0) goto cleanup;\n\n                if (localeBuffer[0] != localLocaleBuffer) {\n                    operator_delete(localeBuffer[0]);\n                }\n                std::locale::_locale(localLocale);\n                FUN_00198c10(errorMessageBuffer, \"/home/abuild/rpmbuild/BUILD/dart-4.3.7/dart/utils/Parser.cpp\");\n                FUN_00198c10(localeBuffer, \"Error\");\n                outputStream = (basic_ostream *)dart::common::colorErr((basic_string *)localeBuffer, (basic_string *)errorMessageBuffer, 0x7b, 0x1f);\n                std::__ostream_insert_char_std__char_traits_char__(outputStream, \"value [\", 7);\n                outputStream = std::__ostream_insert_char_std__char_traits_char__(outputStream, *(char **)inputString, *(long *)(inputString + 8));\n                std::__ostream_insert_char_std__char_traits_char__(outputStream, \"] is not a valid boolean type. \", 0x1f);\n                std::__ostream_insert_char_std__char_traits_char__(outputStream, \"Returning false.\", 0xf);\n                std::endl_char_std__char_traits_char__(outputStream);\n\n                if (localeBuffer[0] != localLocaleBuffer) {\n                    operator_delete(localeBuffer[0]);\n                }\n                if (errorMessageBuffer[0] != localErrorBuffer) {\n                    operator_delete(errorMessageBuffer[0]);\n                    returnValue = 0;\n                    goto cleanup;\n                }\n            }\n            returnValue = 0;\n            goto cleanup;\n        }\n    }\n\n    if (localeBuffer[0] == localLocaleBuffer) {\n        std::locale::_locale(localLocale);\n        returnValue = 1;\n    } else {\n        operator_delete(localeBuffer[0]);\n        std::locale::_locale(localLocale);\n        returnValue = 1;\n    }\n\ncleanup:\n    if (savedStackGuard == *(long *)(stackGuard + 0x28)) {\n        return returnValue;\n    }\n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "undefined8 dart::utils::toBool(basic_string *param_1)\n{\n  int iVar1;\n  undefined8 uVar2;\n  basic_ostream *pbVar3;\n  long in_FS_OFFSET;\n  locale local_80 [8];\n  undefined *local_78 [2];\n  undefined local_68 [16];\n  undefined *local_58 [2];\n  undefined local_48 [24];\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  std::locale::locale(local_80);\n  local_58[0] = local_48;\n  FUN_00198f80(local_58,*(long *)param_1,local_80,*(long *)(param_1 + 8) + *(long *)param_1);\n  iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                    ((char *)local_58);\n  if (iVar1 != 0) {\n    iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                      ((char *)param_1);\n    if (iVar1 != 0) {\n      if (local_58[0] == local_48) {\n        std::locale::_locale(local_80);\n      }\n      else {\n        operator_delete(local_58[0]);\n        std::locale::_locale(local_80);\n      }\n      std::locale::locale(local_80);\n      local_58[0] = local_48;\n      FUN_00198f80(local_58,*(long *)param_1,local_80,*(long *)(param_1 + 8) + *(long *)param_1);\n      iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                        ((char *)local_58);\n      if (iVar1 == 0) {\nLAB_00177a71:\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n          std::locale::_locale(local_80);\n          uVar2 = 0;\n          goto LAB_001779dc;\n        }\n        std::locale::_locale(local_80);\n      }\n      else {\n        iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n                compare((char *)param_1);\n        if (iVar1 == 0) goto LAB_00177a71;\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n        }\n        std::locale::_locale(local_80);\n        FUN_00198c10(local_78,\"/home/abuild/rpmbuild/BUILD/dart-4.3.7/dart/utils/Parser.cpp\");\n        FUN_00198c10(local_58,\"Error\");\n        pbVar3 = (basic_ostream *)\n                 dart::common::colorErr((basic_string *)local_58,(basic_string *)local_78,0x7b,0x1f)\n        ;\n        std::__ostream_insert_char_std__char_traits_char__(pbVar3,\"value [\",7);\n        pbVar3 = std::__ostream_insert_char_std__char_traits_char__\n                           (pbVar3,*(char **)param_1,*(long *)(param_1 + 8));\n        std::__ostream_insert_char_std__char_traits_char__\n                  (pbVar3,\"] is not a valid boolean type. \",0x1f);\n        std::__ostream_insert_char_std__char_traits_char__(pbVar3,\"Retuning false.\",0xf);\n        std::endl_char_std__char_traits_char__(pbVar3);\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n        }\n        if (local_78[0] != local_68) {\n          operator_delete(local_78[0]);\n          uVar2 = 0;\n          goto LAB_001779dc;\n        }\n      }\n      uVar2 = 0;\n      goto LAB_001779dc;\n    }\n  }\n  if (local_58[0] == local_48) {\n    std::locale::_locale(local_80);\n    uVar2 = 1;\n  }\n  else {\n    operator_delete(local_58[0]);\n    std::locale::_locale(local_80);\n    uVar2 = 1;\n  }\nLAB_001779dc:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.591589093208313,
        "similarity_score_baseline_stripped": 0.6206889152526855
    },
    {
        "func_name": "list_proxy",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0010bf30(undefined8 param_1,undefined8 param_2,undefined8 *param_3)\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  char *pcVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  long in_FS_OFFSET;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  byte *local_28;\n  long local_20;\n  bVar9 = 0;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar4 = \"anonymous\";\n  if (DAT_0011ae88 != 0) {\n    pcVar4 = DAT_0011ae90;\n  }\n  lVar2 = FUN_001108f0(param_1,&PTR_DAT_0011a020,pcVar4,&DAT_0011a480,&DAT_0011a488,0,DAT_0011ae68);\n  if (lVar2 != 0) {\n    prot_printf(*(undefined8 *)(lVar2 + 0x960),\"LIST %s %s\\r\\n\",*param_3,param_3[1]);\n    iVar1 = FUN_0010bea0(lVar2,&local_28);\n    bVar7 = false;\n    bVar8 = iVar1 == 0;\n    if (bVar8) {\n      lVar3 = 4;\n      pbVar5 = local_28;\n      pbVar6 = &DAT_0011446a;\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar5 < *pbVar6;\n        bVar8 = *pbVar5 == *pbVar6;\n        pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n        pbVar6 = pbVar6 + (ulong)bVar9 * -2 + 1;\n      } while (bVar8);\n      if ((!bVar7 && !bVar8) == bVar7) {\n        iVar1 = FUN_0010bea0(lVar2,&local_28);\n        while ((iVar1 == 0 && (*local_28 != 0x2e))) {\n          prot_printf(DAT_0011ae70,\"%s\");\n          iVar1 = FUN_0010bea0(lVar2,&local_28);\n        }\n      }\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nvoid process_function(undefined8 param_1, undefined8 param_2, undefined8 *param_3) {\n    int result;\n    long stack_check_value;\n    long comparison_length;\n    char *name;\n    byte *current_byte;\n    byte *reference_byte;\n    long in_FS_OFFSET;\n    bool is_less;\n    bool is_equal;\n    byte unused_byte;\n    byte *local_buffer;\n    long saved_stack_value;\n\n    unused_byte = 0;\n    saved_stack_value = *(long *)(in_FS_OFFSET + 0x28);\n    name = \"anonymous\";\n\n    if (DAT_0011ae88 != 0) {\n        name = DAT_0011ae90;\n    }\n\n    comparison_length = FUN_001108f0(param_1, &PTR_DAT_0011a020, name, &DAT_0011a480, &DAT_0011a488, 0, DAT_0011ae68);\n    \n    if (comparison_length != 0) {\n        prot_printf(*(undefined8 *)(comparison_length + 0x960), \"LIST %s %s\\r\\n\", *param_3, param_3[1]);\n        result = FUN_0010bea0(comparison_length, &local_buffer);\n        is_less = false;\n        is_equal = (result == 0);\n\n        if (is_equal) {\n            comparison_length = 4;\n            current_byte = local_buffer;\n            reference_byte = &DAT_0011446a;\n\n            do {\n                if (comparison_length == 0) break;\n                comparison_length--;\n\n                is_less = *current_byte < *reference_byte;\n                is_equal = (*current_byte == *reference_byte);\n                current_byte += (ulong)unused_byte * -2 + 1;\n                reference_byte += (ulong)unused_byte * -2 + 1;\n            } while (is_equal);\n\n            if ((!is_less && !is_equal) == is_less) {\n                result = FUN_0010bea0(comparison_length, &local_buffer);\n                while ((result == 0 && (*local_buffer != 0x2e))) {\n                    prot_printf(DAT_0011ae70, \"%s\");\n                    result = FUN_0010bea0(comparison_length, &local_buffer);\n                }\n            }\n        }\n    }\n\n    if (saved_stack_value == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}\n```",
        "normed_func_sha256": "a8dcc98c790ab023e80287e34d6bada9230b6bc50b21ad8c3133ef0ea80b47d0",
        "source_code": "static void list_proxy(const char *server,\n                       void *data __attribute__((unused)), void *rock)\n{\n    struct enum_rock *erock = (struct enum_rock *) rock;\n    struct backend *be;\n    int r;\n    char *result;\n    be = proxy_findserver(server, &nntp_protocol,\n                          nntp_authstate ? nntp_userid : \"anonymous\",\n                          &backend_cached, &backend_current, NULL, nntp_in);\n    if (!be) return;\n    prot_printf(be->out, \"LIST %s %s\\r\\n\", erock->cmd, erock->wild);\n    r = read_response(be, 0, &result);\n    if (!r && !strncmp(result, \"215 \", 4)) {\n        while (!(r = read_response(be, 0, &result)) && result[0] != '.') {\n            prot_printf(nntp_out, \"%s\", result);\n        }\n    }\n}",
        "parsed_output": "void process_function(undefined8 param_1, undefined8 param_2, undefined8 *param_3) {\n    int result;\n    long stack_check_value;\n    long comparison_length;\n    char *name;\n    byte *current_byte;\n    byte *reference_byte;\n    long in_FS_OFFSET;\n    bool is_less;\n    bool is_equal;\n    byte unused_byte;\n    byte *local_buffer;\n    long saved_stack_value;\n\n    unused_byte = 0;\n    saved_stack_value = *(long *)(in_FS_OFFSET + 0x28);\n    name = \"anonymous\";\n\n    if (DAT_0011ae88 != 0) {\n        name = DAT_0011ae90;\n    }\n\n    comparison_length = FUN_001108f0(param_1, &PTR_DAT_0011a020, name, &DAT_0011a480, &DAT_0011a488, 0, DAT_0011ae68);\n    \n    if (comparison_length != 0) {\n        prot_printf(*(undefined8 *)(comparison_length + 0x960), \"LIST %s %s\\r\\n\", *param_3, param_3[1]);\n        result = FUN_0010bea0(comparison_length, &local_buffer);\n        is_less = false;\n        is_equal = (result == 0);\n\n        if (is_equal) {\n            comparison_length = 4;\n            current_byte = local_buffer;\n            reference_byte = &DAT_0011446a;\n\n            do {\n                if (comparison_length == 0) break;\n                comparison_length--;\n\n                is_less = *current_byte < *reference_byte;\n                is_equal = (*current_byte == *reference_byte);\n                current_byte += (ulong)unused_byte * -2 + 1;\n                reference_byte += (ulong)unused_byte * -2 + 1;\n            } while (is_equal);\n\n            if ((!is_less && !is_equal) == is_less) {\n                result = FUN_0010bea0(comparison_length, &local_buffer);\n                while ((result == 0 && (*local_buffer != 0x2e))) {\n                    prot_printf(DAT_0011ae70, \"%s\");\n                    result = FUN_0010bea0(comparison_length, &local_buffer);\n                }\n            }\n        }\n    }\n\n    if (saved_stack_value == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "void FUN_0010bf30(undefined8 param_1,undefined8 param_2,undefined8 *param_3)\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  char *pcVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  long in_FS_OFFSET;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  byte *local_28;\n  long local_20;\n  bVar9 = 0;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar4 = \"anonymous\";\n  if (DAT_0011ae88 != 0) {\n    pcVar4 = DAT_0011ae90;\n  }\n  lVar2 = FUN_001108f0(param_1,&PTR_DAT_0011a020,pcVar4,&DAT_0011a480,&DAT_0011a488,0,DAT_0011ae68);\n  if (lVar2 != 0) {\n    prot_printf(*(undefined8 *)(lVar2 + 0x960),\"LIST %s %s\\r\\n\",*param_3,param_3[1]);\n    iVar1 = FUN_0010bea0(lVar2,&local_28);\n    bVar7 = false;\n    bVar8 = iVar1 == 0;\n    if (bVar8) {\n      lVar3 = 4;\n      pbVar5 = local_28;\n      pbVar6 = &DAT_0011446a;\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar5 < *pbVar6;\n        bVar8 = *pbVar5 == *pbVar6;\n        pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n        pbVar6 = pbVar6 + (ulong)bVar9 * -2 + 1;\n      } while (bVar8);\n      if ((!bVar7 && !bVar8) == bVar7) {\n        iVar1 = FUN_0010bea0(lVar2,&local_28);\n        while ((iVar1 == 0 && (*local_28 != 0x2e))) {\n          prot_printf(DAT_0011ae70,\"%s\");\n          iVar1 = FUN_0010bea0(lVar2,&local_28);\n        }\n      }\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.5534663796424866,
        "similarity_score_baseline_stripped": 0.5603045225143433
    },
    {
        "func_name": "z_IU0UpdateEsRequest",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nulong z_IU0UpdateEsRequest(long param_1,long *param_2,undefined4 param_3,undefined8 param_4)\n{\n  int iVar1;\n  ulong uVar2;\n  iVar1 = odr_sequence_begin(param_1,param_2,0x10);\n  if (iVar1 == 0) {\n    uVar2 = odr_missing(param_1,param_3,param_4);\n    if ((int)uVar2 != 0) {\n      uVar2 = (ulong)(*(int *)(param_1 + 4) == 0);\n    }\n  }\n  else {\n    iVar1 = odr_constructed_begin(param_1,*param_2,2,1,0);\n    if (iVar1 == 0) {\n      uVar2 = odr_missing(param_1,0,\"toKeep\");\n      iVar1 = (int)uVar2;\n    }\n    else {\n      uVar2 = z_IU0OriginPartToKeep(param_1,*param_2,0,\"toKeep\");\n      if ((int)uVar2 == 0) {\n        return uVar2;\n      }\n      uVar2 = odr_constructed_end(param_1);\n      iVar1 = (int)uVar2;\n    }\n    if (iVar1 != 0) {\n      iVar1 = odr_constructed_begin(param_1,*param_2 + 8,2,2,0);\n      if (iVar1 == 0) {\n        uVar2 = odr_missing(param_1,0,\"notToKeep\");\n        iVar1 = (int)uVar2;\n      }\n      else {\n        uVar2 = z_IU0OriginPartNotToKeep(param_1,*param_2 + 8,0,\"notToKeep\");\n        if ((int)uVar2 == 0) {\n          return uVar2;\n        }\n        uVar2 = odr_constructed_end(param_1);\n        iVar1 = (int)uVar2;\n      }\n      if (iVar1 != 0) {\n        iVar1 = odr_sequence_end(param_1);\n        uVar2 = (ulong)(iVar1 != 0);\n      }\n    }\n  }\n  return uVar2;\n}",
        "output": "```c\nulong updateEsRequest(long param_1, long *param_2, undefined4 param_3, undefined8 param_4) {\n    int result;\n    ulong status;\n\n    result = odr_sequence_begin(param_1, param_2, 0x10);\n    if (result == 0) {\n        status = odr_missing(param_1, param_3, param_4);\n        if ((int)status != 0) {\n            status = (ulong)(*(int *)(param_1 + 4) == 0);\n        }\n    } else {\n        result = odr_constructed_begin(param_1, *param_2, 2, 1, 0);\n        if (result == 0) {\n            status = odr_missing(param_1, 0, \"toKeep\");\n            result = (int)status;\n        } else {\n            status = z_IU0OriginPartToKeep(param_1, *param_2, 0, \"toKeep\");\n            if ((int)status == 0) {\n                return status;\n            }\n            status = odr_constructed_end(param_1);\n            result = (int)status;\n        }\n\n        if (result != 0) {\n            result = odr_constructed_begin(param_1, *param_2 + 8, 2, 2, 0);\n            if (result == 0) {\n                status = odr_missing(param_1, 0, \"notToKeep\");\n                result = (int)status;\n            } else {\n                status = z_IU0OriginPartNotToKeep(param_1, *param_2 + 8, 0, \"notToKeep\");\n                if ((int)status == 0) {\n                    return status;\n                }\n                status = odr_constructed_end(param_1);\n                result = (int)status;\n            }\n\n            if (result != 0) {\n                result = odr_sequence_end(param_1);\n                status = (ulong)(result != 0);\n            }\n        }\n    }\n    return status;\n}\n```",
        "normed_func_sha256": "68d09c49886cae7e8e65ad55265ee18bd1804c387eecca61a19eda360ddaad4a",
        "source_code": "int z_IU0UpdateEsRequest (ODR o, Z_IU0UpdateEsRequest **p, int opt, const char *name)\n{\n\tif (!odr_sequence_begin (o, p, sizeof(**p), name))\n\t\treturn odr_missing(o, opt, name) && odr_ok (o);\n\treturn\n\t\todr_explicit_tag (o, z_IU0OriginPartToKeep,\n\t\t\t&(*p)->toKeep, ODR_CONTEXT, 1, 0, \"toKeep\") &&\n\t\todr_explicit_tag (o, z_IU0OriginPartNotToKeep,\n\t\t\t&(*p)->notToKeep, ODR_CONTEXT, 2, 0, \"notToKeep\") &&\n\t\todr_sequence_end (o);\n}",
        "parsed_output": "ulong updateEsRequest(long param_1, long *param_2, undefined4 param_3, undefined8 param_4) {\n    int result;\n    ulong status;\n\n    result = odr_sequence_begin(param_1, param_2, 0x10);\n    if (result == 0) {\n        status = odr_missing(param_1, param_3, param_4);\n        if ((int)status != 0) {\n            status = (ulong)(*(int *)(param_1 + 4) == 0);\n        }\n    } else {\n        result = odr_constructed_begin(param_1, *param_2, 2, 1, 0);\n        if (result == 0) {\n            status = odr_missing(param_1, 0, \"toKeep\");\n            result = (int)status;\n        } else {\n            status = z_IU0OriginPartToKeep(param_1, *param_2, 0, \"toKeep\");\n            if ((int)status == 0) {\n                return status;\n            }\n            status = odr_constructed_end(param_1);\n            result = (int)status;\n        }\n\n        if (result != 0) {\n            result = odr_constructed_begin(param_1, *param_2 + 8, 2, 2, 0);\n            if (result == 0) {\n                status = odr_missing(param_1, 0, \"notToKeep\");\n                result = (int)status;\n            } else {\n                status = z_IU0OriginPartNotToKeep(param_1, *param_2 + 8, 0, \"notToKeep\");\n                if ((int)status == 0) {\n                    return status;\n                }\n                status = odr_constructed_end(param_1);\n                result = (int)status;\n            }\n\n            if (result != 0) {\n                result = odr_sequence_end(param_1);\n                status = (ulong)(result != 0);\n            }\n        }\n    }\n    return status;\n}",
        "baseline_code_stripped": "ulong z_IU0UpdateEsRequest(long param_1,long *param_2,undefined4 param_3,undefined8 param_4)\n{\n  int iVar1;\n  ulong uVar2;\n  iVar1 = odr_sequence_begin(param_1,param_2,0x10);\n  if (iVar1 == 0) {\n    uVar2 = odr_missing(param_1,param_3,param_4);\n    if ((int)uVar2 != 0) {\n      uVar2 = (ulong)(*(int *)(param_1 + 4) == 0);\n    }\n  }\n  else {\n    iVar1 = odr_constructed_begin(param_1,*param_2,2,1,0);\n    if (iVar1 == 0) {\n      uVar2 = odr_missing(param_1,0,\"toKeep\");\n      iVar1 = (int)uVar2;\n    }\n    else {\n      uVar2 = z_IU0OriginPartToKeep(param_1,*param_2,0,\"toKeep\");\n      if ((int)uVar2 == 0) {\n        return uVar2;\n      }\n      uVar2 = odr_constructed_end(param_1);\n      iVar1 = (int)uVar2;\n    }\n    if (iVar1 != 0) {\n      iVar1 = odr_constructed_begin(param_1,*param_2 + 8,2,2,0);\n      if (iVar1 == 0) {\n        uVar2 = odr_missing(param_1,0,\"notToKeep\");\n        iVar1 = (int)uVar2;\n      }\n      else {\n        uVar2 = z_IU0OriginPartNotToKeep(param_1,*param_2 + 8,0,\"notToKeep\");\n        if ((int)uVar2 == 0) {\n          return uVar2;\n        }\n        uVar2 = odr_constructed_end(param_1);\n        iVar1 = (int)uVar2;\n      }\n      if (iVar1 != 0) {\n        iVar1 = odr_sequence_end(param_1);\n        uVar2 = (ulong)(iVar1 != 0);\n      }\n    }\n  }\n  return uVar2;\n}",
        "similarity_score_unixcoder": 0.7329675555229187,
        "similarity_score_baseline_stripped": 0.7265185713768005
    },
    {
        "func_name": "asctime",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar * p9asctime(Tm *t)\n{\n  int iVar1;\n  cbuf_0._24_2_ = 0x3931;\n  cbuf_0._28_2_ = 10;\n  cbuf_0[3] = 0x20;\n  cbuf_0._0_3_ = *(undefined3 *)(\"SunMonTueWedThuFriSat\" + t->wday * 3);\n  cbuf_0[7] = 0x20;\n  cbuf_0._4_3_ = *(undefined3 *)(\"JanFebMarAprMayJunJulAugSepOctNovDec\" + t->mon * 3);\n  iVar1 = t->mday;\n  if (iVar1 < 10) {\n    cbuf_0._8_4_ = 0x30203120;\n  }\n  else {\n    cbuf_0._9_3_ = 0x302031;\n    cbuf_0[8] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0._8_2_ = CONCAT11((char)iVar1 + (char)(iVar1 / 10) * -10 + '0',cbuf_0[8]);\n  iVar1 = t->hour + 100;\n  if (iVar1 < 10) {\n    cbuf_0[11] = 0x20;\n  }\n  else {\n    cbuf_0[11] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0._13_3_ = 0x30303a;\n  cbuf_0[12] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  iVar1 = t->min + 100;\n  if (iVar1 < 10) {\n    cbuf_0[14] = 0x20;\n  }\n  else {\n    cbuf_0[14] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0[15] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  iVar1 = t->sec + 100;\n  if (iVar1 < 10) {\n    cbuf_0._16_2_ = 0x203a;\n  }\n  else {\n    cbuf_0[17] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n    cbuf_0[16] = 0x3a;\n  }\n  cbuf_0._16_3_ = CONCAT12((char)iVar1 + (char)(iVar1 / 10) * -10 + '0',cbuf_0._16_2_);\n  cbuf_0._19_5_ = 0x20544d4720;\n  cbuf_0._16_6_ = CONCAT24(*(undefined2 *)t->zone,cbuf_0._16_4_);\n  cbuf_0._16_7_ = CONCAT16(t->zone[2],cbuf_0._16_6_);\n  cbuf_0[23] = 0x20;\n  iVar1 = t->year;\n  if (99 < iVar1) {\n    cbuf_0._24_2_ = 0x3032;\n    iVar1 = t->year;\n  }\n  iVar1 = iVar1 + 100;\n  if (iVar1 < 10) {\n    cbuf_0[26] = 0x20;\n  }\n  else {\n    cbuf_0[26] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0[27] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  return cbuf_0;\n}",
        "output": "```c\nchar * p9asctime(Tm *t)\n{\n    char cbuf[30]; // Buffer to hold the formatted time string\n    int dayOfWeek = t->wday;\n    int month = t->mon;\n    int day = t->mday;\n    int hour = t->hour;\n    int minute = t->min;\n    int second = t->sec;\n    int year = t->year;\n\n    // Set the initial part of the buffer\n    memcpy(cbuf, \"SunMonTueWedThuFriSat\" + dayOfWeek * 3, 3);\n    cbuf[3] = ' ';\n    memcpy(cbuf + 4, \"JanFebMarAprMayJunJulAugSepOctNovDec\" + month * 3, 3);\n    cbuf[7] = ' ';\n\n    // Format day\n    if (day < 10) {\n        sprintf(cbuf + 8, \" %d\", day);\n    } else {\n        sprintf(cbuf + 8, \"%d\", day);\n    }\n\n    // Format hour\n    sprintf(cbuf + 11, \"%02d:\", hour);\n\n    // Format minute\n    sprintf(cbuf + 14, \"%02d:\", minute);\n\n    // Format second\n    sprintf(cbuf + 17, \"%02d\", second);\n\n    // Add timezone\n    memcpy(cbuf + 20, t->zone, 3);\n    cbuf[23] = ' ';\n\n    // Format year\n    if (year > 99) {\n        year -= 1900; // Adjust year to 2-digit format\n    }\n    sprintf(cbuf + 26, \"%02d\", year);\n\n    return cbuf;\n}\n```",
        "normed_func_sha256": "47a2f0d4bb63f8a5ccab2fdabca313e0f4241a226c98e4f6b714ec58c505420e",
        "source_code": "char*\nasctime(Tm *t)\n{\n\tchar *ncp;\n\tstatic char cbuf[30];\n\tstrcpy(cbuf, \"Thu Jan 01 00:00:00 GMT 1970\\n\");\n\tncp = &\"SunMonTueWedThuFriSat\"[t->wday*3];\n\tcbuf[0] = *ncp++;\n\tcbuf[1] = *ncp++;\n\tcbuf[2] = *ncp;\n\tncp = &\"JanFebMarAprMayJunJulAugSepOctNovDec\"[t->mon*3];\n\tcbuf[4] = *ncp++;\n\tcbuf[5] = *ncp++;\n\tcbuf[6] = *ncp;\n\tct_numb(cbuf+8, t->mday);\n\tct_numb(cbuf+11, t->hour+100);\n\tct_numb(cbuf+14, t->min+100);\n\tct_numb(cbuf+17, t->sec+100);\n\tncp = t->zone;\n\tcbuf[20] = *ncp++;\n\tcbuf[21] = *ncp++;\n\tcbuf[22] = *ncp;\n\tif(t->year >= 100) {\n\t\tcbuf[24] = '2';\n\t\tcbuf[25] = '0';\n\t}\n\tct_numb(cbuf+26, t->year+100);\n\treturn cbuf;\n}",
        "parsed_output": "char * p9asctime(Tm *t)\n{\n    char cbuf[30]; // Buffer to hold the formatted time string\n    int dayOfWeek = t->wday;\n    int month = t->mon;\n    int day = t->mday;\n    int hour = t->hour;\n    int minute = t->min;\n    int second = t->sec;\n    int year = t->year;\n\n    // Set the initial part of the buffer\n    memcpy(cbuf, \"SunMonTueWedThuFriSat\" + dayOfWeek * 3, 3);\n    cbuf[3] = ' ';\n    memcpy(cbuf + 4, \"JanFebMarAprMayJunJulAugSepOctNovDec\" + month * 3, 3);\n    cbuf[7] = ' ';\n\n    // Format day\n    if (day < 10) {\n        sprintf(cbuf + 8, \" %d\", day);\n    } else {\n        sprintf(cbuf + 8, \"%d\", day);\n    }\n\n    // Format hour\n    sprintf(cbuf + 11, \"%02d:\", hour);\n\n    // Format minute\n    sprintf(cbuf + 14, \"%02d:\", minute);\n\n    // Format second\n    sprintf(cbuf + 17, \"%02d\", second);\n\n    // Add timezone\n    memcpy(cbuf + 20, t->zone, 3);\n    cbuf[23] = ' ';\n\n    // Format year\n    if (year > 99) {\n        year -= 1900; // Adjust year to 2-digit format\n    }\n    sprintf(cbuf + 26, \"%02d\", year);\n\n    return cbuf;\n}",
        "baseline_code_stripped": "char * p9asctime(Tm *t)\n{\n  int iVar1;\n  cbuf_0._24_2_ = 0x3931;\n  cbuf_0._28_2_ = 10;\n  cbuf_0[3] = 0x20;\n  cbuf_0._0_3_ = *(undefined3 *)(\"SunMonTueWedThuFriSat\" + t->wday * 3);\n  cbuf_0[7] = 0x20;\n  cbuf_0._4_3_ = *(undefined3 *)(\"JanFebMarAprMayJunJulAugSepOctNovDec\" + t->mon * 3);\n  iVar1 = t->mday;\n  if (iVar1 < 10) {\n    cbuf_0._8_4_ = 0x30203120;\n  }\n  else {\n    cbuf_0._9_3_ = 0x302031;\n    cbuf_0[8] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0._8_2_ = CONCAT11((char)iVar1 + (char)(iVar1 / 10) * -10 + '0',cbuf_0[8]);\n  iVar1 = t->hour + 100;\n  if (iVar1 < 10) {\n    cbuf_0[11] = 0x20;\n  }\n  else {\n    cbuf_0[11] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0._13_3_ = 0x30303a;\n  cbuf_0[12] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  iVar1 = t->min + 100;\n  if (iVar1 < 10) {\n    cbuf_0[14] = 0x20;\n  }\n  else {\n    cbuf_0[14] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0[15] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  iVar1 = t->sec + 100;\n  if (iVar1 < 10) {\n    cbuf_0._16_2_ = 0x203a;\n  }\n  else {\n    cbuf_0[17] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n    cbuf_0[16] = 0x3a;\n  }\n  cbuf_0._16_3_ = CONCAT12((char)iVar1 + (char)(iVar1 / 10) * -10 + '0',cbuf_0._16_2_);\n  cbuf_0._19_5_ = 0x20544d4720;\n  cbuf_0._16_6_ = CONCAT24(*(undefined2 *)t->zone,cbuf_0._16_4_);\n  cbuf_0._16_7_ = CONCAT16(t->zone[2],cbuf_0._16_6_);\n  cbuf_0[23] = 0x20;\n  iVar1 = t->year;\n  if (99 < iVar1) {\n    cbuf_0._24_2_ = 0x3032;\n    iVar1 = t->year;\n  }\n  iVar1 = iVar1 + 100;\n  if (iVar1 < 10) {\n    cbuf_0[26] = 0x20;\n  }\n  else {\n    cbuf_0[26] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0[27] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  return cbuf_0;\n}",
        "similarity_score_unixcoder": 0.9021093845367432,
        "similarity_score_baseline_stripped": 0.8135940432548523
    },
    {
        "func_name": "R_swig_FbcAnd_getAssociation__SWIG_1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 R_swig_FbcAnd_getAssociation__SWIG_1(undefined4 param_1,undefined4 param_2)\n{\n  FbcAnd *this;\n  undefined4 uVar1;\n  int iVar2;\n  uint uVar3;\n  SBase *pSVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  FbcAnd *local_40;\n  int *local_3c;\n  undefined4 local_38;\n  int local_34 [4];\n  int local_24;\n  local_24 = __stack_chk_guard;\n  local_40 = (FbcAnd *)0x0;\n  uVar1 = vmaxget();\n  iVar2 = SWIG_R_ConvertPtr_lto_priv_0(param_1,&local_40,DAT_00c20584,0);\n  this = local_40;\n  if (iVar2 < 0) {\n    if (iVar2 == -1) {\n      iVar2 = -5;\n    }\n    SWIG_Error_lto_priv_0\n              (iVar2,\"in method \\'FbcAnd_getAssociation\\', argument 1 of type \\'FbcAnd const *\\'\");\n    uVar1 = SWIG_ErrorType_lto_priv_0(DAT_00c20adc);\n    Rf_error(\"%s %s\",uVar1,&DAT_00c20ae0);\n  }\n  uVar3 = Rf_asInteger(param_2);\n  pSVar4 = (SBase *)FbcAnd::getAssociation(this,uVar3);\n  local_34[0] = 0x636266;\n  local_38 = 3;\n  local_3c = local_34;\n  uVar5 = GetDowncastSwigTypeForPackage(pSVar4,(basic_string *)&local_3c);\n  uVar6 = R_NilValue;\n  if (pSVar4 != (SBase *)0x0) {\n    uVar6 = R_MakeExternalPtr(uVar5,R_NilValue,R_NilValue);\n    uVar6 = R_MakeExternalPtr(pSVar4,uVar6,R_NilValue);\n    SET_S4_OBJECT();\n  }\n  if (local_3c != local_34) {\n    operator_delete(local_3c,local_34[0] + 1);\n  }\n  vmaxset(uVar1);\n  if (local_24 == __stack_chk_guard) {\n    return uVar6;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nundefined4 R_swig_FbcAnd_getAssociation__SWIG_1(undefined4 param_1, undefined4 param_2) {\n    FbcAnd *fbcAndInstance;\n    undefined4 returnValue;\n    int conversionResult;\n    uint integerValue;\n    SBase *association;\n    undefined4 swigType;\n    undefined4 externalPtr;\n    FbcAnd *localFbcAnd;\n    int *localMemory;\n    undefined4 localSwigType;\n    int localBuffer[4];\n    int stackGuard;\n\n    stackGuard = __stack_chk_guard;\n    localFbcAnd = NULL;\n    returnValue = vmaxget();\n\n    conversionResult = SWIG_R_ConvertPtr_lto_priv_0(param_1, &localFbcAnd, DAT_00c20584, 0);\n    fbcAndInstance = localFbcAnd;\n\n    if (conversionResult < 0) {\n        if (conversionResult == -1) {\n            conversionResult = -5;\n        }\n        SWIG_Error_lto_priv_0(conversionResult, \"in method 'FbcAnd_getAssociation', argument 1 of type 'FbcAnd const *'\");\n        returnValue = SWIG_ErrorType_lto_priv_0(DAT_00c20adc);\n        Rf_error(\"%s %s\", returnValue, &DAT_00c20ae0);\n    }\n\n    integerValue = Rf_asInteger(param_2);\n    association = (SBase *)FbcAnd::getAssociation(fbcAndInstance, integerValue);\n    localBuffer[0] = 0x636266;\n    localSwigType = 3;\n    localMemory = localBuffer;\n\n    swigType = GetDowncastSwigTypeForPackage(association, (basic_string *)&localMemory);\n    externalPtr = R_NilValue;\n\n    if (association != NULL) {\n        externalPtr = R_MakeExternalPtr(swigType, R_NilValue, R_NilValue);\n        externalPtr = R_MakeExternalPtr(association, externalPtr, R_NilValue);\n        SET_S4_OBJECT();\n    }\n\n    if (localMemory != localBuffer) {\n        operator_delete(localMemory, localBuffer[0] + 1);\n    }\n\n    vmaxset(returnValue);\n\n    if (stackGuard == __stack_chk_guard) {\n        return externalPtr;\n    }\n\n    __stack_chk_fail();\n}\n```",
        "normed_func_sha256": "163478e34f4a479021cd20133268322d1faaa79a581ed237cad4937ed8b97982",
        "source_code": "SWIGEXPORT SEXP\nR_swig_FbcAnd_getAssociation__SWIG_1 ( SEXP self, SEXP n)\n{\n  FbcAssociation *result = 0 ;\n  FbcAnd *arg1 = (FbcAnd *) 0 ;\n  unsigned int arg2 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  int val2 ;\n  int ecode2 = 0 ;\n  unsigned int r_nprotect = 0;\n  SEXP r_ans = R_NilValue ;\n  VMAXTYPE r_vmax = vmaxget() ;\n  \n  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_FbcAnd, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"FbcAnd_getAssociation\" \"', argument \" \"1\"\" of type '\" \"FbcAnd const *\"\"'\"); \n  }\n  arg1 = reinterpret_cast< FbcAnd * >(argp1);\n  ecode2 = SWIG_AsVal_int(n, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"FbcAnd_getAssociation\" \"', argument \" \"2\"\" of type '\" \"unsigned int\"\"'\");\n  } \n  arg2 = static_cast< unsigned int >(val2);\n  result = (FbcAssociation *)((FbcAnd const *)arg1)->getAssociation(arg2);\n  {\n    r_ans = SWIG_R_NewPointerObj(result, GetDowncastSwigTypeForPackage(result, \"fbc\"), 0 |  0 );\n  }\n  vmaxset(r_vmax);\n  if(r_nprotect)  Rf_unprotect(r_nprotect);\n  \n  return r_ans;\n  fail: SWIGUNUSED;\n  Rf_error(\"%s %s\", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);\n  return R_NilValue;\n}",
        "parsed_output": "undefined4 R_swig_FbcAnd_getAssociation__SWIG_1(undefined4 param_1, undefined4 param_2) {\n    FbcAnd *fbcAndInstance;\n    undefined4 returnValue;\n    int conversionResult;\n    uint integerValue;\n    SBase *association;\n    undefined4 swigType;\n    undefined4 externalPtr;\n    FbcAnd *localFbcAnd;\n    int *localMemory;\n    undefined4 localSwigType;\n    int localBuffer[4];\n    int stackGuard;\n\n    stackGuard = __stack_chk_guard;\n    localFbcAnd = NULL;\n    returnValue = vmaxget();\n\n    conversionResult = SWIG_R_ConvertPtr_lto_priv_0(param_1, &localFbcAnd, DAT_00c20584, 0);\n    fbcAndInstance = localFbcAnd;\n\n    if (conversionResult < 0) {\n        if (conversionResult == -1) {\n            conversionResult = -5;\n        }\n        SWIG_Error_lto_priv_0(conversionResult, \"in method 'FbcAnd_getAssociation', argument 1 of type 'FbcAnd const *'\");\n        returnValue = SWIG_ErrorType_lto_priv_0(DAT_00c20adc);\n        Rf_error(\"%s %s\", returnValue, &DAT_00c20ae0);\n    }\n\n    integerValue = Rf_asInteger(param_2);\n    association = (SBase *)FbcAnd::getAssociation(fbcAndInstance, integerValue);\n    localBuffer[0] = 0x636266;\n    localSwigType = 3;\n    localMemory = localBuffer;\n\n    swigType = GetDowncastSwigTypeForPackage(association, (basic_string *)&localMemory);\n    externalPtr = R_NilValue;\n\n    if (association != NULL) {\n        externalPtr = R_MakeExternalPtr(swigType, R_NilValue, R_NilValue);\n        externalPtr = R_MakeExternalPtr(association, externalPtr, R_NilValue);\n        SET_S4_OBJECT();\n    }\n\n    if (localMemory != localBuffer) {\n        operator_delete(localMemory, localBuffer[0] + 1);\n    }\n\n    vmaxset(returnValue);\n\n    if (stackGuard == __stack_chk_guard) {\n        return externalPtr;\n    }\n\n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "undefined4 R_swig_FbcAnd_getAssociation__SWIG_1(undefined4 param_1,undefined4 param_2)\n{\n  FbcAnd *this;\n  undefined4 uVar1;\n  int iVar2;\n  uint uVar3;\n  SBase *pSVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  FbcAnd *local_40;\n  int *local_3c;\n  undefined4 local_38;\n  int local_34 [4];\n  int local_24;\n  local_24 = __stack_chk_guard;\n  local_40 = (FbcAnd *)0x0;\n  uVar1 = vmaxget();\n  iVar2 = SWIG_R_ConvertPtr_lto_priv_0(param_1,&local_40,DAT_00c20584,0);\n  this = local_40;\n  if (iVar2 < 0) {\n    if (iVar2 == -1) {\n      iVar2 = -5;\n    }\n    SWIG_Error_lto_priv_0\n              (iVar2,\"in method \\'FbcAnd_getAssociation\\', argument 1 of type \\'FbcAnd const *\\'\");\n    uVar1 = SWIG_ErrorType_lto_priv_0(DAT_00c20adc);\n    Rf_error(\"%s %s\",uVar1,&DAT_00c20ae0);\n  }\n  uVar3 = Rf_asInteger(param_2);\n  pSVar4 = (SBase *)FbcAnd::getAssociation(this,uVar3);\n  local_34[0] = 0x636266;\n  local_38 = 3;\n  local_3c = local_34;\n  uVar5 = GetDowncastSwigTypeForPackage(pSVar4,(basic_string *)&local_3c);\n  uVar6 = R_NilValue;\n  if (pSVar4 != (SBase *)0x0) {\n    uVar6 = R_MakeExternalPtr(uVar5,R_NilValue,R_NilValue);\n    uVar6 = R_MakeExternalPtr(pSVar4,uVar6,R_NilValue);\n    SET_S4_OBJECT();\n  }\n  if (local_3c != local_34) {\n    operator_delete(local_3c,local_34[0] + 1);\n  }\n  vmaxset(uVar1);\n  if (local_24 == __stack_chk_guard) {\n    return uVar6;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.77510666847229,
        "similarity_score_baseline_stripped": 0.7560737133026123
    },
    {
        "func_name": "pyvte_register_classes",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid pyvte_register_classes(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  iVar1 = PyImport_ImportModule(&DAT_00019d94);\n  if (iVar1 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"could not import gtk\");\n    return;\n  }\n  uVar2 = PyModule_GetDict();\n  _DAT_0002b6b4 = PyDict_GetItemString(uVar2,\"MenuShell\");\n  if (_DAT_0002b6b4 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name MenuShell from gtk\");\n    return;\n  }\n  _DAT_0002b6b0 = PyDict_GetItemString(uVar2,\"Widget\");\n  if (_DAT_0002b6b0 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name Widget from gtk\");\n    return;\n  }\n  iVar1 = PyImport_ImportModule(\"gtk.gdk\");\n  if (iVar1 != 0) {\n    uVar2 = PyModule_GetDict();\n    _DAT_0002b6b8 = PyDict_GetItemString(uVar2,\"Pixbuf\");\n    if (_DAT_0002b6b8 == 0) {\n      PyErr_SetString(_PyExc_ImportError,\"cannot import name Pixbuf from gtk.gdk\");\n    }\n    else {\n      pcVar4 = *_PyGObject_API;\n      uVar2 = vte_terminal_get_type();\n      uVar3 = Py_BuildValue(&DAT_00019e64,_DAT_0002b6b0);\n      (*pcVar4)(param_1,\"VteTerminal\",uVar2,PyVteTerminal_Type,uVar3);\n    }\n    return;\n  }\n  PyErr_SetString(_PyExc_ImportError,\"could not import gtk.gdk\");\n  return;\n}",
        "output": "```c\nvoid pyvte_register_classes(undefined4 param_1)\n{\n    int importResult;\n    undefined4 moduleDict;\n    undefined4 menuShell;\n    undefined4 widget;\n    code *gObjectAPI;\n\n    importResult = PyImport_ImportModule(&DAT_00019d94);\n    if (importResult == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"could not import gtk\");\n        return;\n    }\n\n    moduleDict = PyModule_GetDict();\n    menuShell = PyDict_GetItemString(moduleDict, \"MenuShell\");\n    if (menuShell == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"cannot import name MenuShell from gtk\");\n        return;\n    }\n\n    widget = PyDict_GetItemString(moduleDict, \"Widget\");\n    if (widget == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"cannot import name Widget from gtk\");\n        return;\n    }\n\n    importResult = PyImport_ImportModule(\"gtk.gdk\");\n    if (importResult != 0) {\n        moduleDict = PyModule_GetDict();\n        undefined4 pixbuf = PyDict_GetItemString(moduleDict, \"Pixbuf\");\n        if (pixbuf == 0) {\n            PyErr_SetString(_PyExc_ImportError, \"cannot import name Pixbuf from gtk.gdk\");\n        } else {\n            gObjectAPI = *_PyGObject_API;\n            undefined4 terminalType = vte_terminal_get_type();\n            undefined4 terminalValue = Py_BuildValue(&DAT_00019e64, widget);\n            (*gObjectAPI)(param_1, \"VteTerminal\", terminalType, PyVteTerminal_Type, terminalValue);\n        }\n        return;\n    }\n\n    PyErr_SetString(_PyExc_ImportError, \"could not import gtk.gdk\");\n    return;\n}\n```",
        "normed_func_sha256": "4bd35d7a33e51270fa4b586a0ac2f1582f9738d197f34693497f65563c03b29e",
        "source_code": "void\npyvte_register_classes(PyObject *d)\n{\n    PyObject *module;\n\n    if ((module = PyImport_ImportModule(\"gtk\")) != NULL) {\n        PyObject *moddict = PyModule_GetDict(module);\n\n        _PyGtkMenuShell_Type = (PyTypeObject *)PyDict_GetItemString(moddict, \"MenuShell\");\n        if (_PyGtkMenuShell_Type == NULL) {\n            PyErr_SetString(PyExc_ImportError,\n                \"cannot import name MenuShell from gtk\");\n            return;\n        }\n        _PyGtkWidget_Type = (PyTypeObject *)PyDict_GetItemString(moddict, \"Widget\");\n        if (_PyGtkWidget_Type == NULL) {\n            PyErr_SetString(PyExc_ImportError,\n                \"cannot import name Widget from gtk\");\n            return;\n        }\n    } else {\n        PyErr_SetString(PyExc_ImportError,\n            \"could not import gtk\");\n        return;\n    }\n    if ((module = PyImport_ImportModule(\"gtk.gdk\")) != NULL) {\n        PyObject *moddict = PyModule_GetDict(module);\n\n        _PyGdkPixbuf_Type = (PyTypeObject *)PyDict_GetItemString(moddict, \"Pixbuf\");\n        if (_PyGdkPixbuf_Type == NULL) {\n            PyErr_SetString(PyExc_ImportError,\n                \"cannot import name Pixbuf from gtk.gdk\");\n            return;\n        }\n    } else {\n        PyErr_SetString(PyExc_ImportError,\n            \"could not import gtk.gdk\");\n        return;\n    }\n\n\n#line 1540 \"vte.c\"\n    pygobject_register_class(d, \"VteTerminal\", VTE_TYPE_TERMINAL, &PyVteTerminal_Type, Py_BuildValue(\"(O)\", &PyGtkWidget_Type));\n}",
        "parsed_output": "void pyvte_register_classes(undefined4 param_1)\n{\n    int importResult;\n    undefined4 moduleDict;\n    undefined4 menuShell;\n    undefined4 widget;\n    code *gObjectAPI;\n\n    importResult = PyImport_ImportModule(&DAT_00019d94);\n    if (importResult == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"could not import gtk\");\n        return;\n    }\n\n    moduleDict = PyModule_GetDict();\n    menuShell = PyDict_GetItemString(moduleDict, \"MenuShell\");\n    if (menuShell == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"cannot import name MenuShell from gtk\");\n        return;\n    }\n\n    widget = PyDict_GetItemString(moduleDict, \"Widget\");\n    if (widget == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"cannot import name Widget from gtk\");\n        return;\n    }\n\n    importResult = PyImport_ImportModule(\"gtk.gdk\");\n    if (importResult != 0) {\n        moduleDict = PyModule_GetDict();\n        undefined4 pixbuf = PyDict_GetItemString(moduleDict, \"Pixbuf\");\n        if (pixbuf == 0) {\n            PyErr_SetString(_PyExc_ImportError, \"cannot import name Pixbuf from gtk.gdk\");\n        } else {\n            gObjectAPI = *_PyGObject_API;\n            undefined4 terminalType = vte_terminal_get_type();\n            undefined4 terminalValue = Py_BuildValue(&DAT_00019e64, widget);\n            (*gObjectAPI)(param_1, \"VteTerminal\", terminalType, PyVteTerminal_Type, terminalValue);\n        }\n        return;\n    }\n\n    PyErr_SetString(_PyExc_ImportError, \"could not import gtk.gdk\");\n    return;\n}",
        "baseline_code_stripped": "void pyvte_register_classes(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  iVar1 = PyImport_ImportModule(&DAT_00019d94);\n  if (iVar1 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"could not import gtk\");\n    return;\n  }\n  uVar2 = PyModule_GetDict();\n  _DAT_0002b6b4 = PyDict_GetItemString(uVar2,\"MenuShell\");\n  if (_DAT_0002b6b4 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name MenuShell from gtk\");\n    return;\n  }\n  _DAT_0002b6b0 = PyDict_GetItemString(uVar2,\"Widget\");\n  if (_DAT_0002b6b0 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name Widget from gtk\");\n    return;\n  }\n  iVar1 = PyImport_ImportModule(\"gtk.gdk\");\n  if (iVar1 != 0) {\n    uVar2 = PyModule_GetDict();\n    _DAT_0002b6b8 = PyDict_GetItemString(uVar2,\"Pixbuf\");\n    if (_DAT_0002b6b8 == 0) {\n      PyErr_SetString(_PyExc_ImportError,\"cannot import name Pixbuf from gtk.gdk\");\n    }\n    else {\n      pcVar4 = *_PyGObject_API;\n      uVar2 = vte_terminal_get_type();\n      uVar3 = Py_BuildValue(&DAT_00019e64,_DAT_0002b6b0);\n      (*pcVar4)(param_1,\"VteTerminal\",uVar2,PyVteTerminal_Type,uVar3);\n    }\n    return;\n  }\n  PyErr_SetString(_PyExc_ImportError,\"could not import gtk.gdk\");\n  return;\n}",
        "similarity_score_unixcoder": 0.9077351689338684,
        "similarity_score_baseline_stripped": 0.75553959608078
    },
    {
        "func_name": "snd_emu10k1_free",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 snd_emu10k1_free(int *param_1)\n{\n  char cVar1;\n  if (*(long *)(param_1 + 2) == 0) {\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  else {\n    snd_emu10k1_fx8010_tram_setup(param_1,0);\n    snd_emu10k1_done(param_1);\n    snd_emu10k1_free_efx(param_1);\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  if (cVar1 == '\\x01') {\n    snd_emu1010_fpga_write(param_1,4,0);\n  }\n  cancel_delayed_work_sync(param_1 + 0x468);\n  release_firmware(*(undefined8 *)(param_1 + 2000));\n  release_firmware(*(undefined8 *)(param_1 + 0x7d2));\n  if (-1 < *param_1) {\n    free_irq(*param_1,param_1);\n  }\n  if (*(long *)(param_1 + 0x3e) != 0) {\n    snd_emu10k1_synth_free(param_1);\n    *(undefined8 *)(param_1 + 0x3e) = 0;\n  }\n  snd_util_memhdr_free(*(undefined8 *)(param_1 + 0x3c));\n  if (*(long *)(param_1 + 0x18) != 0) {\n    snd_dma_free_pages(param_1 + 0x14);\n  }\n  if (*(long *)(param_1 + 0x24) != 0) {\n    snd_dma_free_pages(param_1 + 0x20);\n  }\n  vfree(*(undefined8 *)(param_1 + 0x48));\n  vfree(*(undefined8 *)(param_1 + 0x4a));\n  vfree(*(undefined8 *)(param_1 + 0x7d4));\n  snd_emu10k1_efx_free_pm_buffer(param_1);\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free_pm_buffer(param_1);\n  }\n  if (*(long *)(param_1 + 2) != 0) {\n    pci_release_regions(*(undefined8 *)(param_1 + 0x19c));\n  }\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free(param_1);\n  }\n  pci_disable_device(*(undefined8 *)(param_1 + 0x19c));\n  kfree(param_1);\n  return 0;\n}",
        "output": "```c\nundefined8 snd_emu10k1_free(int *param_1)\n{\n    char statusFlag;\n    \n    if (*(long *)(param_1 + 2) == 0) {\n        statusFlag = *(char *)(*(long *)(param_1 + 6) + 0x18);\n    } else {\n        snd_emu10k1_fx8010_tram_setup(param_1, 0);\n        snd_emu10k1_done(param_1);\n        snd_emu10k1_free_efx(param_1);\n        statusFlag = *(char *)(*(long *)(param_1 + 6) + 0x18);\n    }\n    \n    if (statusFlag == '\\x01') {\n        snd_emu1010_fpga_write(param_1, 4, 0);\n    }\n    \n    cancel_delayed_work_sync(param_1 + 0x468);\n    release_firmware(*(undefined8 *)(param_1 + 2000));\n    release_firmware(*(undefined8 *)(param_1 + 0x7d2));\n    \n    if (*param_1 >= 0) {\n        free_irq(*param_1, param_1);\n    }\n    \n    if (*(long *)(param_1 + 0x3e) != 0) {\n        snd_emu10k1_synth_free(param_1);\n        *(undefined8 *)(param_1 + 0x3e) = 0;\n    }\n    \n    snd_util_memhdr_free(*(undefined8 *)(param_1 + 0x3c));\n    \n    if (*(long *)(param_1 + 0x18) != 0) {\n        snd_dma_free_pages(param_1 + 0x14);\n    }\n    \n    if (*(long *)(param_1 + 0x24) != 0) {\n        snd_dma_free_pages(param_1 + 0x20);\n    }\n    \n    vfree(*(undefined8 *)(param_1 + 0x48));\n    vfree(*(undefined8 *)(param_1 + 0x4a));\n    vfree(*(undefined8 *)(param_1 + 0x7d4));\n    \n    snd_emu10k1_efx_free_pm_buffer(param_1);\n    \n    if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n        snd_p16v_free_pm_buffer(param_1);\n    }\n    \n    if (*(long *)(param_1 + 2) != 0) {\n        pci_release_regions(*(undefined8 *)(param_1 + 0x19c));\n    }\n    \n    if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n        snd_p16v_free(param_1);\n    }\n    \n    pci_disable_device(*(undefined8 *)(param_1 + 0x19c));\n    kfree(param_1);\n    \n    return 0;\n}\n```",
        "normed_func_sha256": "7916cc23f04be8d9309dac74c5a2d12fe29e327d0cb85d34a8ecca374c1f4b56",
        "source_code": "static int snd_emu10k1_free(struct snd_emu10k1 *emu)\n{\n\tif (emu->port) {\t/* avoid access to already used hardware */\n\t\tsnd_emu10k1_fx8010_tram_setup(emu, 0);\n\t\tsnd_emu10k1_done(emu);\n\t\tsnd_emu10k1_free_efx(emu);\n\t}\n\tif (emu->card_capabilities->emu_model == EMU_MODEL_EMU1010) {\n\t\t/* Disable 48Volt power to Audio Dock */\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_PWR, 0);\n\t}\n\tcancel_delayed_work_sync(&emu->emu1010.firmware_work);\n\trelease_firmware(emu->firmware);\n\trelease_firmware(emu->dock_fw);\n\tif (emu->irq >= 0)\n\t\tfree_irq(emu->irq, emu);\n\t/* remove reserved page */\n\tif (emu->reserved_page) {\n\t\tsnd_emu10k1_synth_free(emu,\n\t\t\t(struct snd_util_memblk *)emu->reserved_page);\n\t\temu->reserved_page = NULL;\n\t}\n\tsnd_util_memhdr_free(emu->memhdr);\n\tif (emu->silent_page.area)\n\t\tsnd_dma_free_pages(&emu->silent_page);\n\tif (emu->ptb_pages.area)\n\t\tsnd_dma_free_pages(&emu->ptb_pages);\n\tvfree(emu->page_ptr_table);\n\tvfree(emu->page_addr_table);\n#ifdef CONFIG_PM_SLEEP\n\tfree_pm_buffer(emu);\n#endif\n\tif (emu->port)\n\t\tpci_release_regions(emu->pci);\n\tif (emu->card_capabilities->ca0151_chip) /* P16V */\n\t\tsnd_p16v_free(emu);\n\tpci_disable_device(emu->pci);\n\tkfree(emu);\n\treturn 0;\n}",
        "parsed_output": "undefined8 snd_emu10k1_free(int *param_1)\n{\n    char statusFlag;\n    \n    if (*(long *)(param_1 + 2) == 0) {\n        statusFlag = *(char *)(*(long *)(param_1 + 6) + 0x18);\n    } else {\n        snd_emu10k1_fx8010_tram_setup(param_1, 0);\n        snd_emu10k1_done(param_1);\n        snd_emu10k1_free_efx(param_1);\n        statusFlag = *(char *)(*(long *)(param_1 + 6) + 0x18);\n    }\n    \n    if (statusFlag == '\\x01') {\n        snd_emu1010_fpga_write(param_1, 4, 0);\n    }\n    \n    cancel_delayed_work_sync(param_1 + 0x468);\n    release_firmware(*(undefined8 *)(param_1 + 2000));\n    release_firmware(*(undefined8 *)(param_1 + 0x7d2));\n    \n    if (*param_1 >= 0) {\n        free_irq(*param_1, param_1);\n    }\n    \n    if (*(long *)(param_1 + 0x3e) != 0) {\n        snd_emu10k1_synth_free(param_1);\n        *(undefined8 *)(param_1 + 0x3e) = 0;\n    }\n    \n    snd_util_memhdr_free(*(undefined8 *)(param_1 + 0x3c));\n    \n    if (*(long *)(param_1 + 0x18) != 0) {\n        snd_dma_free_pages(param_1 + 0x14);\n    }\n    \n    if (*(long *)(param_1 + 0x24) != 0) {\n        snd_dma_free_pages(param_1 + 0x20);\n    }\n    \n    vfree(*(undefined8 *)(param_1 + 0x48));\n    vfree(*(undefined8 *)(param_1 + 0x4a));\n    vfree(*(undefined8 *)(param_1 + 0x7d4));\n    \n    snd_emu10k1_efx_free_pm_buffer(param_1);\n    \n    if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n        snd_p16v_free_pm_buffer(param_1);\n    }\n    \n    if (*(long *)(param_1 + 2) != 0) {\n        pci_release_regions(*(undefined8 *)(param_1 + 0x19c));\n    }\n    \n    if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n        snd_p16v_free(param_1);\n    }\n    \n    pci_disable_device(*(undefined8 *)(param_1 + 0x19c));\n    kfree(param_1);\n    \n    return 0;\n}",
        "baseline_code_stripped": "undefined8 snd_emu10k1_free(int *param_1)\n{\n  char cVar1;\n  if (*(long *)(param_1 + 2) == 0) {\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  else {\n    snd_emu10k1_fx8010_tram_setup(param_1,0);\n    snd_emu10k1_done(param_1);\n    snd_emu10k1_free_efx(param_1);\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  if (cVar1 == '\\x01') {\n    snd_emu1010_fpga_write(param_1,4,0);\n  }\n  cancel_delayed_work_sync(param_1 + 0x468);\n  release_firmware(*(undefined8 *)(param_1 + 2000));\n  release_firmware(*(undefined8 *)(param_1 + 0x7d2));\n  if (-1 < *param_1) {\n    free_irq(*param_1,param_1);\n  }\n  if (*(long *)(param_1 + 0x3e) != 0) {\n    snd_emu10k1_synth_free(param_1);\n    *(undefined8 *)(param_1 + 0x3e) = 0;\n  }\n  snd_util_memhdr_free(*(undefined8 *)(param_1 + 0x3c));\n  if (*(long *)(param_1 + 0x18) != 0) {\n    snd_dma_free_pages(param_1 + 0x14);\n  }\n  if (*(long *)(param_1 + 0x24) != 0) {\n    snd_dma_free_pages(param_1 + 0x20);\n  }\n  vfree(*(undefined8 *)(param_1 + 0x48));\n  vfree(*(undefined8 *)(param_1 + 0x4a));\n  vfree(*(undefined8 *)(param_1 + 0x7d4));\n  snd_emu10k1_efx_free_pm_buffer(param_1);\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free_pm_buffer(param_1);\n  }\n  if (*(long *)(param_1 + 2) != 0) {\n    pci_release_regions(*(undefined8 *)(param_1 + 0x19c));\n  }\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free(param_1);\n  }\n  pci_disable_device(*(undefined8 *)(param_1 + 0x19c));\n  kfree(param_1);\n  return 0;\n}",
        "similarity_score_unixcoder": 0.8416232466697693,
        "similarity_score_baseline_stripped": 0.8360657691955566
    },
    {
        "func_name": "convertFrom_QList_0100QDnsHostAddressRecord",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nlong * convertFrom_QList_0100QDnsHostAddressRecord(long *param_1,undefined8 param_2)\n{\n  int iVar1;\n  int iVar2;\n  long *plVar3;\n  QDnsHostAddressRecord *this;\n  long lVar4;\n  long lVar5;\n  plVar3 = (long *)PyList_New((long)(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8)));\n  if (plVar3 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  lVar4 = *param_1;\n  iVar1 = *(int *)(lVar4 + 8);\n  if (0 < *(int *)(lVar4 + 0xc) - iVar1) {\n    lVar5 = 0;\n    do {\n      this = (QDnsHostAddressRecord *)operator_new(8);\n      QDnsHostAddressRecord::QDnsHostAddressRecord\n                (this,(QDnsHostAddressRecord *)(lVar4 + 0x10 + (iVar1 + lVar5) * 8));\n      lVar4 = (**(code **)(DAT_003be900 + 0x88))\n                        (this,*(undefined8 *)(PTR_PTR_DAT_003acda0 + 0x68),param_2);\n      if (lVar4 == 0) {\n        QDnsHostAddressRecord::_QDnsHostAddressRecord(this);\n        operator_delete(this);\n        *plVar3 = *plVar3 + -1;\n        if (*plVar3 != 0) {\n          return (long *)0x0;\n        }\n        (**(code **)(plVar3[1] + 0x30))(plVar3);\n        return (long *)0x0;\n      }\n      iVar2 = (int)lVar5;\n      *(long *)(plVar3[3] + lVar5 * 8) = lVar4;\n      lVar4 = *param_1;\n      lVar5 = lVar5 + 1;\n      iVar1 = *(int *)(lVar4 + 8);\n    } while (iVar2 + 1 < *(int *)(lVar4 + 0xc) - iVar1);\n  }\n  return plVar3;\n}",
        "output": "```c\nlong * convertFrom_QList_0100QDnsHostAddressRecord(long *param_1, undefined8 param_2) {\n    int currentIndex;\n    int totalRecords;\n    long *resultList;\n    QDnsHostAddressRecord *record;\n    long recordAddress;\n    long resultAddress;\n    \n    totalRecords = *(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8);\n    resultList = (long *)PyList_New((long)totalRecords);\n    \n    if (resultList == NULL) {\n        return NULL;\n    }\n    \n    recordAddress = *param_1;\n    currentIndex = *(int *)(recordAddress + 8);\n    \n    if (totalRecords > currentIndex) {\n        long index = 0;\n        \n        do {\n            record = (QDnsHostAddressRecord *)operator_new(8);\n            QDnsHostAddressRecord::QDnsHostAddressRecord(record, (QDnsHostAddressRecord *)(recordAddress + 0x10 + (currentIndex + index) * 8));\n            \n            resultAddress = (**(code **)(DAT_003be900 + 0x88))(record, *(undefined8 *)(PTR_PTR_DAT_003acda0 + 0x68), param_2);\n            \n            if (resultAddress == 0) {\n                QDnsHostAddressRecord::_QDnsHostAddressRecord(record);\n                operator_delete(record);\n                *resultList = *resultList - 1;\n                \n                if (*resultList != 0) {\n                    return NULL;\n                }\n                \n                (**(code **)(resultList[1] + 0x30))(resultList);\n                return NULL;\n            }\n            \n            *(long *)(resultList[3] + index * 8) = resultAddress;\n            index++;\n            currentIndex = *(int *)(recordAddress + 8);\n        } while (index < totalRecords - currentIndex);\n    }\n    \n    return resultList;\n}\n```",
        "normed_func_sha256": "6cadc0caffb7273788f1974ca5bb6effe345d68f63efb69a004f9417d034c88f",
        "source_code": "static PyObject *convertFrom_QList_0100QDnsHostAddressRecord(void *sipCppV, PyObject *sipTransferObj)\n{\n   QList<QDnsHostAddressRecord> *sipCpp = reinterpret_cast<QList<QDnsHostAddressRecord> *>(sipCppV);\n\n#line 40 \"sip/QtCore/qpycore_qlist.sip\"\n    PyObject *l = PyList_New(sipCpp->size());\n\n    if (!l)\n        return 0;\n\n    for (int i = 0; i < sipCpp->size(); ++i)\n    {\n        QDnsHostAddressRecord *t = new QDnsHostAddressRecord(sipCpp->at(i));\n        PyObject *tobj = sipConvertFromNewType(t, sipType_QDnsHostAddressRecord,\n                sipTransferObj);\n\n        if (!tobj)\n        {\n            delete t;\n            Py_DECREF(l);\n\n            return 0;\n        }\n\n        PyList_SET_ITEM(l, i, tobj);\n    }\n\n    return l;\n#line 175 \"/builddir/build/BUILD/PyQt-gpl-5.4.1/QtNetwork/sipQtNetworkQList0100QDnsHostAddressRecord.cpp\"\n}",
        "parsed_output": "long * convertFrom_QList_0100QDnsHostAddressRecord(long *param_1, undefined8 param_2) {\n    int currentIndex;\n    int totalRecords;\n    long *resultList;\n    QDnsHostAddressRecord *record;\n    long recordAddress;\n    long resultAddress;\n    \n    totalRecords = *(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8);\n    resultList = (long *)PyList_New((long)totalRecords);\n    \n    if (resultList == NULL) {\n        return NULL;\n    }\n    \n    recordAddress = *param_1;\n    currentIndex = *(int *)(recordAddress + 8);\n    \n    if (totalRecords > currentIndex) {\n        long index = 0;\n        \n        do {\n            record = (QDnsHostAddressRecord *)operator_new(8);\n            QDnsHostAddressRecord::QDnsHostAddressRecord(record, (QDnsHostAddressRecord *)(recordAddress + 0x10 + (currentIndex + index) * 8));\n            \n            resultAddress = (**(code **)(DAT_003be900 + 0x88))(record, *(undefined8 *)(PTR_PTR_DAT_003acda0 + 0x68), param_2);\n            \n            if (resultAddress == 0) {\n                QDnsHostAddressRecord::_QDnsHostAddressRecord(record);\n                operator_delete(record);\n                *resultList = *resultList - 1;\n                \n                if (*resultList != 0) {\n                    return NULL;\n                }\n                \n                (**(code **)(resultList[1] + 0x30))(resultList);\n                return NULL;\n            }\n            \n            *(long *)(resultList[3] + index * 8) = resultAddress;\n            index++;\n            currentIndex = *(int *)(recordAddress + 8);\n        } while (index < totalRecords - currentIndex);\n    }\n    \n    return resultList;\n}",
        "baseline_code_stripped": "long * convertFrom_QList_0100QDnsHostAddressRecord(long *param_1,undefined8 param_2)\n{\n  int iVar1;\n  int iVar2;\n  long *plVar3;\n  QDnsHostAddressRecord *this;\n  long lVar4;\n  long lVar5;\n  plVar3 = (long *)PyList_New((long)(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8)));\n  if (plVar3 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  lVar4 = *param_1;\n  iVar1 = *(int *)(lVar4 + 8);\n  if (0 < *(int *)(lVar4 + 0xc) - iVar1) {\n    lVar5 = 0;\n    do {\n      this = (QDnsHostAddressRecord *)operator_new(8);\n      QDnsHostAddressRecord::QDnsHostAddressRecord\n                (this,(QDnsHostAddressRecord *)(lVar4 + 0x10 + (iVar1 + lVar5) * 8));\n      lVar4 = (**(code **)(DAT_003be900 + 0x88))\n                        (this,*(undefined8 *)(PTR_PTR_DAT_003acda0 + 0x68),param_2);\n      if (lVar4 == 0) {\n        QDnsHostAddressRecord::_QDnsHostAddressRecord(this);\n        operator_delete(this);\n        *plVar3 = *plVar3 + -1;\n        if (*plVar3 != 0) {\n          return (long *)0x0;\n        }\n        (**(code **)(plVar3[1] + 0x30))(plVar3);\n        return (long *)0x0;\n      }\n      iVar2 = (int)lVar5;\n      *(long *)(plVar3[3] + lVar5 * 8) = lVar4;\n      lVar4 = *param_1;\n      lVar5 = lVar5 + 1;\n      iVar1 = *(int *)(lVar4 + 8);\n    } while (iVar2 + 1 < *(int *)(lVar4 + 0xc) - iVar1);\n  }\n  return plVar3;\n}",
        "similarity_score_unixcoder": 0.6782819032669067,
        "similarity_score_baseline_stripped": 0.5882964134216309
    },
    {
        "func_name": "lanczos_sum",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_004b6e60(void)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 local_c4 [48];\n  puVar2 = local_c4;\n  for (iVar1 = 0x30; iVar1 != 0; iVar1 = iVar1 + -1) {\n    *puVar2 = 0xcccccccc;\n    puVar2 = puVar2 + 1;\n  }\n  return DAT_0067f96c;\n}",
        "output": "```c\nundefined4 initializeArrayAndReturnValue(void)\n{\n    int index;\n    undefined4 *arrayPointer;\n    undefined4 localArray[48];\n    \n    arrayPointer = localArray;\n    for (index = 48; index > 0; index--) {\n        *arrayPointer = 0xcccccccc;\n        arrayPointer++;\n    }\n    \n    return DAT_0067f96c;\n}\n```",
        "normed_func_sha256": "aa926806698568afe804827d3a7e0634e6e70b210e8b7d1b88bdb9f046cdbad7",
        "source_code": "static T lanczos_sum(const T& z)\n   {\n      lanczos_initializer<lanczos31UDT, T>::force_instantiate(); // Ensure our constants get initialized before main()\n      static const T num[31] = {\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.2579646553333513328235723061836959833277e46)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.2444796504337453845497419271639377138264e46)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.1119885499016017172212179730662673475329e46)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.3301983829072723658949204487793889113715e45)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.7041171040503851585152895336505379417066e44)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.1156687509001223855125097826246939403504e44)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1522559363393940883866575697565974893306000)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 164914363507650839510801418717701057005700)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 14978522943127593263654178827041568394060)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1156707153701375383907746879648168666774)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 76739431129980851159755403434593664173.2)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 4407916278928188620282281495575981079.306)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 220487883931812802092792125175269667.3004)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 9644828280794966468052381443992828.433924)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 369996467042247229310044531282837.6549068)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 12468380890717344610932904378961.13494291)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 369289245210898235894444657859.0529720075)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 9607992460262594951559461829.34885209022)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 219225935074853412540086410.981421315799)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 4374309943598658046326340.720767382079549)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 76008779092264509404014.10530947173485581)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1143503533822162444712.335663112617754987)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 14779233719977576920.37884890049671578409)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 162409028440678302.9992838032166348069916)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1496561553388385.733407609544964535634135)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 11347624460661.81008311053190661436107043)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 68944915931.32004991941950530448472223832)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 322701221.6391432296123937035480931903651)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1092364.213992634267819050120261755371294)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 2380.151399852411512711176940867823024864)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 2.506628274631000502415765284811045253007)),\n      };\n      static const T denom[31] = {\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.8841761993739701954543616e31)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.3502799997985980526649278464e32)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.622621928420356134910574592e32)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 66951000306085302338993639424000)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 49361465831621147825759587123200)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 26751280755793398822580822142976)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 11139316913434780466101123891200)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 3674201658710345201899117607040)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 981347603630155088295475765440)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 215760462268683520394805979744)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 39539238727270799376544542000)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 6097272817323042122728617800)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 796974693974455191377937300)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 88776380550648116217781890)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 8459574446076318147830625)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 691254538651580660999025)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 48487623689430693038025)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 2918939500751087661105)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 150566737512021319125)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 6634460278534540725)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 248526574856284725)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 7860403394108265)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 207912996295875)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 4539323721075)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 80328850875)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1122686019)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 11921175)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 90335)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 435)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1)),\n      };\n      return boost::math::tools::evaluate_rational(num, denom, z, 31);\n   }",
        "parsed_output": "undefined4 initializeArrayAndReturnValue(void)\n{\n    int index;\n    undefined4 *arrayPointer;\n    undefined4 localArray[48];\n    \n    arrayPointer = localArray;\n    for (index = 48; index > 0; index--) {\n        *arrayPointer = 0xcccccccc;\n        arrayPointer++;\n    }\n    \n    return DAT_0067f96c;\n}",
        "baseline_code_stripped": "undefined4 FUN_004b6e60(void)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 local_c4 [48];\n  puVar2 = local_c4;\n  for (iVar1 = 0x30; iVar1 != 0; iVar1 = iVar1 + -1) {\n    *puVar2 = 0xcccccccc;\n    puVar2 = puVar2 + 1;\n  }\n  return DAT_0067f96c;\n}",
        "similarity_score_unixcoder": 0.4055810272693634,
        "similarity_score_baseline_stripped": 0.44867292046546936
    },
    {
        "func_name": "f_13576",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid f_13576(int param_1,code *param_2,int param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  undefined4 local_58;\n  code *local_54;\n  undefined4 local_50;\n  code *pcStack_4c;\n  int local_48;\n  undefined4 local_44;\n  code *local_40;\n  undefined4 *local_3c;\n  undefined4 local_38;\n  undefined4 local_34;\n  undefined4 local_30;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  local_1c = __stack_chk_guard;\n  if ((int)&local_40 - C_stack_limit < 0x39) {\n    local_48 = param_3;\n    C_save_and_reclaim_args(trf_13576,3,param_1);\n  }\n  if (param_3 != 0xe) goto LAB_0009a088;\n  uVar2 = 2;\n  local_3c = (undefined4 *)&DAT_00000006;\n  pcVar1 = *(code **)(param_2 + 4);\n  local_40 = param_2;\n  do {\n    param_2 = pcVar1;\n    (*param_2)(uVar2,&local_40);\nLAB_0009a088:\n    local_58 = 0x24000005;\n    local_54 = f_13586;\n    local_50 = *(undefined4 *)(param_1 + 8);\n    local_44 = *(undefined4 *)(param_1 + 0xc);\n    pcStack_4c = param_2;\n    local_48 = param_3;\n    local_28 = C_i_caar(param_3);\n    local_38 = *(undefined4 *)(param_1 + 0x10);\n    local_24 = *(undefined4 *)(*(int *)(param_3 + 4) + 8);\n    local_40 = *(code **)(DAT_00214554 + 4);\n    local_34 = *(undefined4 *)(param_1 + 0x14);\n    local_30 = *(undefined4 *)(param_1 + 8);\n    local_20 = *(undefined4 *)(param_1 + 0x1c);\n    local_2c = *(undefined4 *)(param_1 + 0x18);\n    uVar2 = 9;\n    pcVar1 = *(code **)(local_40 + 4);\n    local_3c = &local_58;\n  } while( true );\n}",
        "output": "```c\nvoid improved_function(int param_1, code *param_2, int param_3) {\n    code *next_function;\n    undefined4 return_value;\n    undefined4 local_return_value;\n    code *local_function_pointer;\n    undefined4 local_param_50;\n    code *current_function;\n    int local_param_48;\n    undefined4 local_param_44;\n    code *local_param_40;\n    undefined4 *local_param_3c;\n    undefined4 local_param_38;\n    undefined4 local_param_34;\n    undefined4 local_param_30;\n    undefined4 local_param_2c;\n    undefined4 local_param_28;\n    undefined4 local_param_24;\n    undefined4 local_param_20;\n    undefined4 local_param_1c;\n    \n    local_param_1c = __stack_chk_guard;\n    \n    if ((int)&local_param_40 - C_stack_limit < 0x39) {\n        local_param_48 = param_3;\n        C_save_and_reclaim_args(trf_13576, 3, param_1);\n    }\n    \n    if (param_3 != 0xe) {\n        goto process_function;\n    }\n    \n    return_value = 2;\n    local_param_3c = (undefined4 *)&DAT_00000006;\n    next_function = *(code **)(param_2 + 4);\n    local_param_40 = param_2;\n    \n    do {\n        param_2 = next_function;\n        (*param_2)(return_value, &local_param_40);\n        \nprocess_function:\n        local_return_value = 0x24000005;\n        local_function_pointer = f_13586;\n        local_param_50 = *(undefined4 *)(param_1 + 8);\n        local_param_44 = *(undefined4 *)(param_1 + 0xc);\n        current_function = param_2;\n        local_param_48 = param_3;\n        local_param_28 = C_i_caar(param_3);\n        local_param_38 = *(undefined4 *)(param_1 + 0x10);\n        local_param_24 = *(undefined4 *)(*(int *)(param_3 + 4) + 8);\n        local_param_40 = *(code **)(DAT_00214554 + 4);\n        local_param_34 = *(undefined4 *)(param_1 + 0x14);\n        local_param_30 = *(undefined4 *)(param_1 + 8);\n        local_param_20 = *(undefined4 *)(param_1 + 0x1c);\n        local_param_2c = *(undefined4 *)(param_1 + 0x18);\n        \n        return_value = 9;\n        next_function = *(code **)(local_param_40 + 4);\n        local_param_3c = &local_return_value;\n    } while (true);\n}\n```",
        "normed_func_sha256": "f19258ac0f7d10f978bc48a10be9d2a0a304f0d67a4220eac22a7c83851526c7",
        "source_code": "static void C_fcall f_13576(C_word t0,C_word t1,C_word t2){\nC_word tmp;\nC_word t3;\nC_word t4;\nC_word t5;\nC_word t6;\nC_word t7;\nC_word t8;\nC_word *a;\nif(C_unlikely(!C_demand(C_calculate_demand(6,0,8)))){\nC_save_and_reclaim_args((void *)trf_13576,3,t0,t1,t2);}\na=C_alloc(6);\nif(C_truep(C_i_nullp(t2))){\nt3=t1;{\nC_word av2[2];\nav2[0]=t3;\nav2[1]=C_SCHEME_FALSE;\n((C_proc)(void*)(*((C_word*)t3+1)))(2,av2);}}\nelse{\nt3=(*a=C_CLOSURE_TYPE|5,a[1]=(C_word)f_13586,a[2]=((C_word*)t0)[2],a[3]=t1,a[4]=t2,a[5]=((C_word*)t0)[3],tmp=(C_word)a,a+=6,tmp);\nt4=C_i_caar(t2);\nt5=t2;\nt6=C_u_i_car(t5);\nt7=C_u_i_cdr(t6);\n/* optimizer.scm:614: simplify-named-call */\nt8=*((C_word*)lf[142]+1);{\nC_word av2[9];\nav2[0]=t8;\nav2[1]=t3;\nav2[2]=((C_word*)t0)[4];\nav2[3]=((C_word*)t0)[5];\nav2[4]=((C_word*)t0)[2];\nav2[5]=((C_word*)t0)[6];\nav2[6]=t4;\nav2[7]=t7;\nav2[8]=((C_word*)t0)[7];\n((C_proc)(void*)(*((C_word*)t8+1)))(9,av2);}}}",
        "parsed_output": "void improved_function(int param_1, code *param_2, int param_3) {\n    code *next_function;\n    undefined4 return_value;\n    undefined4 local_return_value;\n    code *local_function_pointer;\n    undefined4 local_param_50;\n    code *current_function;\n    int local_param_48;\n    undefined4 local_param_44;\n    code *local_param_40;\n    undefined4 *local_param_3c;\n    undefined4 local_param_38;\n    undefined4 local_param_34;\n    undefined4 local_param_30;\n    undefined4 local_param_2c;\n    undefined4 local_param_28;\n    undefined4 local_param_24;\n    undefined4 local_param_20;\n    undefined4 local_param_1c;\n    \n    local_param_1c = __stack_chk_guard;\n    \n    if ((int)&local_param_40 - C_stack_limit < 0x39) {\n        local_param_48 = param_3;\n        C_save_and_reclaim_args(trf_13576, 3, param_1);\n    }\n    \n    if (param_3 != 0xe) {\n        goto process_function;\n    }\n    \n    return_value = 2;\n    local_param_3c = (undefined4 *)&DAT_00000006;\n    next_function = *(code **)(param_2 + 4);\n    local_param_40 = param_2;\n    \n    do {\n        param_2 = next_function;\n        (*param_2)(return_value, &local_param_40);\n        \nprocess_function:\n        local_return_value = 0x24000005;\n        local_function_pointer = f_13586;\n        local_param_50 = *(undefined4 *)(param_1 + 8);\n        local_param_44 = *(undefined4 *)(param_1 + 0xc);\n        current_function = param_2;\n        local_param_48 = param_3;\n        local_param_28 = C_i_caar(param_3);\n        local_param_38 = *(undefined4 *)(param_1 + 0x10);\n        local_param_24 = *(undefined4 *)(*(int *)(param_3 + 4) + 8);\n        local_param_40 = *(code **)(DAT_00214554 + 4);\n        local_param_34 = *(undefined4 *)(param_1 + 0x14);\n        local_param_30 = *(undefined4 *)(param_1 + 8);\n        local_param_20 = *(undefined4 *)(param_1 + 0x1c);\n        local_param_2c = *(undefined4 *)(param_1 + 0x18);\n        \n        return_value = 9;\n        next_function = *(code **)(local_param_40 + 4);\n        local_param_3c = &local_return_value;\n    } while (true);\n}",
        "baseline_code_stripped": "void f_13576(int param_1,code *param_2,int param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  undefined4 local_58;\n  code *local_54;\n  undefined4 local_50;\n  code *pcStack_4c;\n  int local_48;\n  undefined4 local_44;\n  code *local_40;\n  undefined4 *local_3c;\n  undefined4 local_38;\n  undefined4 local_34;\n  undefined4 local_30;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  local_1c = __stack_chk_guard;\n  if ((int)&local_40 - C_stack_limit < 0x39) {\n    local_48 = param_3;\n    C_save_and_reclaim_args(trf_13576,3,param_1);\n  }\n  if (param_3 != 0xe) goto LAB_0009a088;\n  uVar2 = 2;\n  local_3c = (undefined4 *)&DAT_00000006;\n  pcVar1 = *(code **)(param_2 + 4);\n  local_40 = param_2;\n  do {\n    param_2 = pcVar1;\n    (*param_2)(uVar2,&local_40);\nLAB_0009a088:\n    local_58 = 0x24000005;\n    local_54 = f_13586;\n    local_50 = *(undefined4 *)(param_1 + 8);\n    local_44 = *(undefined4 *)(param_1 + 0xc);\n    pcStack_4c = param_2;\n    local_48 = param_3;\n    local_28 = C_i_caar(param_3);\n    local_38 = *(undefined4 *)(param_1 + 0x10);\n    local_24 = *(undefined4 *)(*(int *)(param_3 + 4) + 8);\n    local_40 = *(code **)(DAT_00214554 + 4);\n    local_34 = *(undefined4 *)(param_1 + 0x14);\n    local_30 = *(undefined4 *)(param_1 + 8);\n    local_20 = *(undefined4 *)(param_1 + 0x1c);\n    local_2c = *(undefined4 *)(param_1 + 0x18);\n    uVar2 = 9;\n    pcVar1 = *(code **)(local_40 + 4);\n    local_3c = &local_58;\n  } while( true );\n}",
        "similarity_score_unixcoder": 0.6667699217796326,
        "similarity_score_baseline_stripped": 0.7275699377059937
    },
    {
        "func_name": "_file_lock_resource",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_0026ef42(undefined8 param_1,long param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_1018 [4104];\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = is_orphan_vg(param_2);\n  if (iVar1 == 0) {\n    iVar1 = is_global_vg(param_2);\n    if (iVar1 != 0) goto LAB_0026efa1;\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/V_%s\",&DAT_003a8f80,param_2);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x37,0xffffffff,\"Too long locking filename %s/V_%s.\",\n                &DAT_003a8f80,param_2);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  else {\nLAB_0026efa1:\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/P_%s\",&DAT_003a8f80,param_2 + 1);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x32,0xffffffff,\"Too long locking filename %s/P_%s.\",\n                &DAT_003a8f80,param_2 + 1);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  iVar1 = lock_file(local_1018,param_3);\n  if (iVar1 == 0) {\n    print_log(7,\"locking/file_locking.c\",0x3c,0,\"<backtrace>\");\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 1;\n  }\nLAB_0026f0f0:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return uVar2;\n}",
        "output": "```c\nundefined8 lock_file_with_prefix(undefined8 param_1, long param_2, undefined4 param_3) {\n    int result;\n    undefined8 returnValue;\n    long stackCheck;\n    undefined local_buffer[4104];\n    \n    stackCheck = *(long *)(in_FS_OFFSET + 0x28);\n    \n    if (!is_orphan_vg(param_2)) {\n        if (is_global_vg(param_2)) {\n            goto create_global_lock_filename;\n        }\n        \n        result = dm_snprintf(local_buffer, 0x1000, \"%s/V_%s\", &DAT_003a8f80, param_2);\n        if (result < 0) {\n            print_log(3, \"locking/file_locking.c\", 0x37, 0xffffffff, \"Too long locking filename %s/V_%s.\", &DAT_003a8f80, param_2);\n            returnValue = 0;\n            goto cleanup;\n        }\n    } else {\ncreate_global_lock_filename:\n        result = dm_snprintf(local_buffer, 0x1000, \"%s/P_%s\", &DAT_003a8f80, param_2 + 1);\n        if (result < 0) {\n            print_log(3, \"locking/file_locking.c\", 0x32, 0xffffffff, \"Too long locking filename %s/P_%s.\", &DAT_003a8f80, param_2 + 1);\n            returnValue = 0;\n            goto cleanup;\n        }\n    }\n    \n    result = lock_file(local_buffer, param_3);\n    if (result == 0) {\n        print_log(7, \"locking/file_locking.c\", 0x3c, 0, \"<backtrace>\");\n        returnValue = 0;\n    } else {\n        returnValue = 1;\n    }\n\ncleanup:\n    if (stackCheck != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n    \n    return returnValue;\n}\n```",
        "normed_func_sha256": "d0fba9e85cb6773ff43f667f15fe8c48cfefc9fd71efc7d106be2fcc253667fa",
        "source_code": "static int _file_lock_resource(struct cmd_context *cmd, const char *resource,\n\t\t\t       uint32_t flags, const struct logical_volume *lv)\n{\n\tchar lockfile[PATH_MAX];\n\tif (is_orphan_vg(resource) || is_global_vg(resource)) {\n\t\tif (dm_snprintf(lockfile, sizeof(lockfile),\n\t\t\t\t\"%s/P_%s\", _lock_dir, resource + 1) < 0) {\n\t\t\tlog_error(\"Too long locking filename %s/P_%s.\", _lock_dir, resource + 1);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tif (dm_snprintf(lockfile, sizeof(lockfile), \"%s/V_%s\", _lock_dir, resource) < 0) {\n\t\t\tlog_error(\"Too long locking filename %s/V_%s.\", _lock_dir, resource);\n\t\t\treturn 0;\n\t\t}\n\tif (!lock_file(lockfile, flags))\n\t\treturn_0;\n\treturn 1;\n}",
        "parsed_output": "undefined8 lock_file_with_prefix(undefined8 param_1, long param_2, undefined4 param_3) {\n    int result;\n    undefined8 returnValue;\n    long stackCheck;\n    undefined local_buffer[4104];\n    \n    stackCheck = *(long *)(in_FS_OFFSET + 0x28);\n    \n    if (!is_orphan_vg(param_2)) {\n        if (is_global_vg(param_2)) {\n            goto create_global_lock_filename;\n        }\n        \n        result = dm_snprintf(local_buffer, 0x1000, \"%s/V_%s\", &DAT_003a8f80, param_2);\n        if (result < 0) {\n            print_log(3, \"locking/file_locking.c\", 0x37, 0xffffffff, \"Too long locking filename %s/V_%s.\", &DAT_003a8f80, param_2);\n            returnValue = 0;\n            goto cleanup;\n        }\n    } else {\ncreate_global_lock_filename:\n        result = dm_snprintf(local_buffer, 0x1000, \"%s/P_%s\", &DAT_003a8f80, param_2 + 1);\n        if (result < 0) {\n            print_log(3, \"locking/file_locking.c\", 0x32, 0xffffffff, \"Too long locking filename %s/P_%s.\", &DAT_003a8f80, param_2 + 1);\n            returnValue = 0;\n            goto cleanup;\n        }\n    }\n    \n    result = lock_file(local_buffer, param_3);\n    if (result == 0) {\n        print_log(7, \"locking/file_locking.c\", 0x3c, 0, \"<backtrace>\");\n        returnValue = 0;\n    } else {\n        returnValue = 1;\n    }\n\ncleanup:\n    if (stackCheck != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n    \n    return returnValue;\n}",
        "baseline_code_stripped": "undefined8 FUN_0026ef42(undefined8 param_1,long param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_1018 [4104];\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = is_orphan_vg(param_2);\n  if (iVar1 == 0) {\n    iVar1 = is_global_vg(param_2);\n    if (iVar1 != 0) goto LAB_0026efa1;\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/V_%s\",&DAT_003a8f80,param_2);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x37,0xffffffff,\"Too long locking filename %s/V_%s.\",\n                &DAT_003a8f80,param_2);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  else {\nLAB_0026efa1:\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/P_%s\",&DAT_003a8f80,param_2 + 1);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x32,0xffffffff,\"Too long locking filename %s/P_%s.\",\n                &DAT_003a8f80,param_2 + 1);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  iVar1 = lock_file(local_1018,param_3);\n  if (iVar1 == 0) {\n    print_log(7,\"locking/file_locking.c\",0x3c,0,\"<backtrace>\");\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 1;\n  }\nLAB_0026f0f0:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return uVar2;\n}",
        "similarity_score_unixcoder": 0.7420663833618164,
        "similarity_score_baseline_stripped": 0.6461787223815918
    },
    {
        "func_name": "cGuiSet::OnMouseDown",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_14019f6d0(longlong param_1,longlong param_2)\n{\n  longlong lVar1;\n  longlong *plVar2;\n  longlong *plVar3;\n  undefined8 *puVar4;\n  char cVar5;\n  uint uVar6;\n  longlong *plVar7;\n  longlong lVar8;\n  undefined auStack_a8 [32];\n  undefined local_88;\n  undefined4 local_78;\n  undefined4 local_74;\n  undefined4 local_70;\n  undefined4 local_6c;\n  undefined4 local_68;\n  undefined8 local_64;\n  undefined4 local_5c;\n  undefined4 local_58;\n  undefined4 uStack_54;\n  undefined4 uStack_50;\n  undefined4 uStack_4c;\n  undefined4 local_48;\n  undefined8 local_40;\n  undefined4 local_38;\n  ulonglong local_28;\n  local_28 = DAT_14062a040 ^ (ulonglong)auStack_a8;\n  uVar6 = FUN_1401ade30(*(undefined4 *)(param_2 + 0x10));\n  *(uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)uVar6 >> 5) * 4) =\n       *(uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)uVar6 >> 5) * 4) |\n       1 << (uVar6 & 0x1f);\n  local_68 = *(undefined4 *)(param_2 + 0x10);\n  local_70 = *(undefined4 *)(param_2 + 8);\n  local_6c = *(undefined4 *)(param_2 + 0xc);\n  lVar1 = *(longlong *)(param_1 + 0x68);\n  local_5c = *(undefined4 *)(param_2 + 0x1c);\n  local_64 = *(undefined8 *)(param_2 + 0x14);\n  local_40 = *(undefined8 *)(param_2 + 0x38);\n  local_58 = *(undefined4 *)(param_2 + 0x20);\n  uStack_54 = *(undefined4 *)(param_2 + 0x24);\n  uStack_50 = *(undefined4 *)(param_2 + 0x28);\n  uStack_4c = *(undefined4 *)(param_2 + 0x2c);\n  local_38 = *(undefined4 *)(param_2 + 0x40);\n  local_48 = *(undefined4 *)(param_2 + 0x30);\n  local_78 = *(undefined4 *)(param_1 + 0x160);\n  local_74 = *(undefined4 *)(param_1 + 0x164);\n  plVar7 = (longlong *)**(longlong **)(param_1 + 0x88);\n  if (plVar7 != *(longlong **)(param_1 + 0x88)) {\n    do {\n      plVar2 = (longlong *)plVar7[2];\n      lVar8 = plVar2[0x1c];\n      if (((((lVar8 == 0) || (cVar5 = FUN_1401d56a0(lVar8), cVar5 != '\\0')) &&\n           (*(char *)((longlong)plVar2 + 0xf9) != '\\0')) &&\n          (((plVar3 = *(longlong **)(param_1 + 0x50), plVar3 == (longlong *)0x0 ||\n            (plVar3 == plVar2)) ||\n           ((lVar8 != 0 && (cVar5 = FUN_1401d5ba0(lVar8,plVar3,0), cVar5 != '\\0')))))) &&\n         (*(char *)((longlong)plVar2 + 0x10c) != '\\0')) {\n        if ((*(longlong **)(param_1 + 0x68) != plVar2) &&\n           (cVar5 = (**(code **)(*plVar2 + 0xd0))(plVar2,&local_78), cVar5 != '\\0')) {\n          *(longlong **)(param_1 + 0x68) = plVar2;\n        }\n        local_88 = 0;\n        cVar5 = FUN_1401d4ea0(plVar2,1);\n        if (cVar5 != '\\0') goto LAB_14019f859;\n      }\n      plVar7 = (longlong *)*plVar7;\n    } while (plVar7 != (longlong *)*(longlong *)(param_1 + 0x88));\n  }\n  *(undefined8 *)(param_1 + 0x68) = 0;\nLAB_14019f859:\n  if ((*(longlong *)(param_1 + 0x68) != lVar1) && (lVar1 != 0)) {\n    for (puVar4 = (undefined8 *)**(undefined8 **)(param_1 + 0x88);\n        puVar4 != *(undefined8 **)(param_1 + 0x88); puVar4 = (undefined8 *)*puVar4) {\n      if (puVar4[2] == lVar1) {\n        local_88 = 1;\n        FUN_1401d4ea0(lVar1,8,&local_78,1);\n        break;\n      }\n    }\n  }\n  FUN_1404d6060(local_28 ^ (ulonglong)auStack_a8);\n  return;\n}",
        "output": "```c\nvoid UpdateFunction(longlong param_1, longlong param_2) {\n    longlong currentPointer;\n    longlong *currentElement;\n    longlong *nextElement;\n    undefined8 *functionPointer;\n    char conditionFlag;\n    uint index;\n    longlong *targetElement;\n    longlong previousPointer;\n    undefined stackBuffer[32];\n    undefined localData88;\n    undefined4 localData78;\n    undefined4 localData74;\n    undefined4 localData70;\n    undefined4 localData6c;\n    undefined4 localData68;\n    undefined8 localData64;\n    undefined4 localData5c;\n    undefined4 localData58;\n    undefined4 localData54;\n    undefined4 localData50;\n    undefined4 localData4c;\n    undefined4 localData48;\n    undefined8 localData40;\n    undefined4 localData38;\n    ulonglong stackProtection;\n\n    stackProtection = DAT_14062a040 ^ (ulonglong)stackBuffer;\n    index = FUN_1401ade30(*(undefined4 *)(param_2 + 0x10));\n    \n    *(uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)index >> 5) * 4) |= \n        1 << (index & 0x1f);\n    \n    localData68 = *(undefined4 *)(param_2 + 0x10);\n    localData70 = *(undefined4 *)(param_2 + 8);\n    localData6c = *(undefined4 *)(param_2 + 0xc);\n    currentPointer = *(longlong *)(param_1 + 0x68);\n    localData5c = *(undefined4 *)(param_2 + 0x1c);\n    localData64 = *(undefined8 *)(param_2 + 0x14);\n    localData40 = *(undefined8 *)(param_2 + 0x38);\n    localData58 = *(undefined4 *)(param_2 + 0x20);\n    localData54 = *(undefined4 *)(param_2 + 0x24);\n    localData50 = *(undefined4 *)(param_2 + 0x28);\n    localData4c = *(undefined4 *)(param_2 + 0x2c);\n    localData38 = *(undefined4 *)(param_2 + 0x40);\n    localData48 = *(undefined4 *)(param_2 + 0x30);\n    localData78 = *(undefined4 *)(param_1 + 0x160);\n    localData74 = *(undefined4 *)(param_1 + 0x164);\n    \n    targetElement = (longlong *)**(longlong **)(param_1 + 0x88);\n    \n    if (targetElement != *(longlong **)(param_1 + 0x88)) {\n        do {\n            currentElement = (longlong *)targetElement[2];\n            previousPointer = currentElement[0x1c];\n            \n            if (((((previousPointer == 0) || (conditionFlag = FUN_1401d56a0(previousPointer), conditionFlag != '\\0')) &&\n                (*(char *)((longlong)currentElement + 0xf9) != '\\0')) &&\n                (((nextElement = *(longlong **)(param_1 + 0x50), nextElement == (longlong *)0x0 ||\n                (nextElement == currentElement)) ||\n                ((previousPointer != 0 && (conditionFlag = FUN_1401d5ba0(previousPointer, nextElement, 0), conditionFlag != '\\0')))))) &&\n                (*(char *)((longlong)currentElement + 0x10c) != '\\0')) {\n                \n                if ((*(longlong **)(param_1 + 0x68) != currentElement) &&\n                    (conditionFlag = (**(code **)(*currentElement + 0xd0))(currentElement, &localData78), conditionFlag != '\\0')) {\n                    *(longlong **)(param_1 + 0x68) = currentElement;\n                }\n                \n                localData88 = 0;\n                conditionFlag = FUN_1401d4ea0(currentElement, 1);\n                if (conditionFlag != '\\0') goto UpdateEnd;\n            }\n            targetElement = (longlong *)*targetElement;\n        } while (targetElement != (longlong *)*(longlong *)(param_1 + 0x88));\n    }\n    \n    *(undefined8 *)(param_1 + 0x68) = 0;\nUpdateEnd:\n    if ((*(longlong *)(param_1 + 0x68) != currentPointer) && (currentPointer != 0)) {\n        for (functionPointer = (undefined8 *)**(undefined8 **)(param_1 + 0x88);\n            functionPointer != *(undefined8 **)(param_1 + 0x88); functionPointer = (undefined8 *)*functionPointer) {\n            if (functionPointer[2] == currentPointer) {\n                localData88 = 1;\n                FUN_1401d4ea0(currentPointer, 8, &localData78, 1);\n                break;\n            }\n        }\n    }\n    \n    FUN_1404d6060(stackProtection ^ (ulonglong)stackBuffer);\n    return;\n}\n```",
        "normed_func_sha256": "60ce5c70e10a015ca74b3b579492663bb3293a83f61e0be91776df7f6a0b4822",
        "source_code": "bool cGuiSet::OnMouseDown(cGuiMessageData &aData)\n\t{\n\t\t///////////////////////////\n\t\t//Set up variables\n\t\tmvMouseDown[cMath::Log2ToInt(aData.mlVal)] = true;\n\n\t\taData.mvPos = mvMousePos;\n\n\t\tiWidget *pOldFocus = mpFocusedWidget;\n\n\t\t///////////////////////////\n\t\t//Call widgets\n\t\tbool bRet = false;\n\t\ttWidgetListIt it = mlstWidgets.begin();\n\t\tfor(; it != mlstWidgets.end(); ++it)\n\t\t{\n\t\t\tiWidget *pWidget = *it;\n\n\t\t\t//If these is an attention set, do send clicks to any other widgets\n\t\t\tif(mpAttentionWidget && pWidget->IsConnectedTo(mpAttentionWidget)==false) \n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(pWidget->GetMouseIsOver())\n\t\t\t{\n\t\t\t\tif(mpFocusedWidget != pWidget)\n\t\t\t\t{\n\t\t\t\t\tif(pWidget->ProcessMessage(eGuiMessage_GotFocus, aData))\n\t\t\t\t\t{\n\t\t\t\t\t\tmpFocusedWidget = pWidget;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmpFocusedWidget = pWidget;\n\t\t\t\t}\n\n\t\t\t\t//Log(\"Got focus %d\\n\",pWidget);\n\n\t\t\t\tif(pWidget->ProcessMessage(eGuiMessage_MouseDown, aData))\n\t\t\t\t{\n\t\t\t\t\tbRet = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Se if anything was clicked\n\t\tif(bRet == false)\n\t\t{\n\t\t\tmpFocusedWidget = NULL;\n\t\t}\n\n\t\t//Lost focus callback\n\t\tif(mpFocusedWidget != pOldFocus)\n\t\t{\n\t\t\t//Log(\"Lost focus %d\\n\",pOldFocus);\n\t\t\tif(pOldFocus) pOldFocus->ProcessMessage(eGuiMessage_LostFocus, aData);\n\t\t\t\n\t\t}\n\n\t\treturn bRet;\n\t}",
        "parsed_output": "void UpdateFunction(longlong param_1, longlong param_2) {\n    longlong currentPointer;\n    longlong *currentElement;\n    longlong *nextElement;\n    undefined8 *functionPointer;\n    char conditionFlag;\n    uint index;\n    longlong *targetElement;\n    longlong previousPointer;\n    undefined stackBuffer[32];\n    undefined localData88;\n    undefined4 localData78;\n    undefined4 localData74;\n    undefined4 localData70;\n    undefined4 localData6c;\n    undefined4 localData68;\n    undefined8 localData64;\n    undefined4 localData5c;\n    undefined4 localData58;\n    undefined4 localData54;\n    undefined4 localData50;\n    undefined4 localData4c;\n    undefined4 localData48;\n    undefined8 localData40;\n    undefined4 localData38;\n    ulonglong stackProtection;\n\n    stackProtection = DAT_14062a040 ^ (ulonglong)stackBuffer;\n    index = FUN_1401ade30(*(undefined4 *)(param_2 + 0x10));\n    \n    *(uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)index >> 5) * 4) |= \n        1 << (index & 0x1f);\n    \n    localData68 = *(undefined4 *)(param_2 + 0x10);\n    localData70 = *(undefined4 *)(param_2 + 8);\n    localData6c = *(undefined4 *)(param_2 + 0xc);\n    currentPointer = *(longlong *)(param_1 + 0x68);\n    localData5c = *(undefined4 *)(param_2 + 0x1c);\n    localData64 = *(undefined8 *)(param_2 + 0x14);\n    localData40 = *(undefined8 *)(param_2 + 0x38);\n    localData58 = *(undefined4 *)(param_2 + 0x20);\n    localData54 = *(undefined4 *)(param_2 + 0x24);\n    localData50 = *(undefined4 *)(param_2 + 0x28);\n    localData4c = *(undefined4 *)(param_2 + 0x2c);\n    localData38 = *(undefined4 *)(param_2 + 0x40);\n    localData48 = *(undefined4 *)(param_2 + 0x30);\n    localData78 = *(undefined4 *)(param_1 + 0x160);\n    localData74 = *(undefined4 *)(param_1 + 0x164);\n    \n    targetElement = (longlong *)**(longlong **)(param_1 + 0x88);\n    \n    if (targetElement != *(longlong **)(param_1 + 0x88)) {\n        do {\n            currentElement = (longlong *)targetElement[2];\n            previousPointer = currentElement[0x1c];\n            \n            if (((((previousPointer == 0) || (conditionFlag = FUN_1401d56a0(previousPointer), conditionFlag != '\\0')) &&\n                (*(char *)((longlong)currentElement + 0xf9) != '\\0')) &&\n                (((nextElement = *(longlong **)(param_1 + 0x50), nextElement == (longlong *)0x0 ||\n                (nextElement == currentElement)) ||\n                ((previousPointer != 0 && (conditionFlag = FUN_1401d5ba0(previousPointer, nextElement, 0), conditionFlag != '\\0')))))) &&\n                (*(char *)((longlong)currentElement + 0x10c) != '\\0')) {\n                \n                if ((*(longlong **)(param_1 + 0x68) != currentElement) &&\n                    (conditionFlag = (**(code **)(*currentElement + 0xd0))(currentElement, &localData78), conditionFlag != '\\0')) {\n                    *(longlong **)(param_1 + 0x68) = currentElement;\n                }\n                \n                localData88 = 0;\n                conditionFlag = FUN_1401d4ea0(currentElement, 1);\n                if (conditionFlag != '\\0') goto UpdateEnd;\n            }\n            targetElement = (longlong *)*targetElement;\n        } while (targetElement != (longlong *)*(longlong *)(param_1 + 0x88));\n    }\n    \n    *(undefined8 *)(param_1 + 0x68) = 0;\nUpdateEnd:\n    if ((*(longlong *)(param_1 + 0x68) != currentPointer) && (currentPointer != 0)) {\n        for (functionPointer = (undefined8 *)**(undefined8 **)(param_1 + 0x88);\n            functionPointer != *(undefined8 **)(param_1 + 0x88); functionPointer = (undefined8 *)*functionPointer) {\n            if (functionPointer[2] == currentPointer) {\n                localData88 = 1;\n                FUN_1401d4ea0(currentPointer, 8, &localData78, 1);\n                break;\n            }\n        }\n    }\n    \n    FUN_1404d6060(stackProtection ^ (ulonglong)stackBuffer);\n    return;\n}",
        "baseline_code_stripped": "void FUN_14019f6d0(longlong param_1,longlong param_2)\n{\n  longlong lVar1;\n  longlong *plVar2;\n  longlong *plVar3;\n  undefined8 *puVar4;\n  char cVar5;\n  uint uVar6;\n  longlong *plVar7;\n  longlong lVar8;\n  undefined auStack_a8 [32];\n  undefined local_88;\n  undefined4 local_78;\n  undefined4 local_74;\n  undefined4 local_70;\n  undefined4 local_6c;\n  undefined4 local_68;\n  undefined8 local_64;\n  undefined4 local_5c;\n  undefined4 local_58;\n  undefined4 uStack_54;\n  undefined4 uStack_50;\n  undefined4 uStack_4c;\n  undefined4 local_48;\n  undefined8 local_40;\n  undefined4 local_38;\n  ulonglong local_28;\n  local_28 = DAT_14062a040 ^ (ulonglong)auStack_a8;\n  uVar6 = FUN_1401ade30(*(undefined4 *)(param_2 + 0x10));\n  *(uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)uVar6 >> 5) * 4) =\n       *(uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)uVar6 >> 5) * 4) |\n       1 << (uVar6 & 0x1f);\n  local_68 = *(undefined4 *)(param_2 + 0x10);\n  local_70 = *(undefined4 *)(param_2 + 8);\n  local_6c = *(undefined4 *)(param_2 + 0xc);\n  lVar1 = *(longlong *)(param_1 + 0x68);\n  local_5c = *(undefined4 *)(param_2 + 0x1c);\n  local_64 = *(undefined8 *)(param_2 + 0x14);\n  local_40 = *(undefined8 *)(param_2 + 0x38);\n  local_58 = *(undefined4 *)(param_2 + 0x20);\n  uStack_54 = *(undefined4 *)(param_2 + 0x24);\n  uStack_50 = *(undefined4 *)(param_2 + 0x28);\n  uStack_4c = *(undefined4 *)(param_2 + 0x2c);\n  local_38 = *(undefined4 *)(param_2 + 0x40);\n  local_48 = *(undefined4 *)(param_2 + 0x30);\n  local_78 = *(undefined4 *)(param_1 + 0x160);\n  local_74 = *(undefined4 *)(param_1 + 0x164);\n  plVar7 = (longlong *)**(longlong **)(param_1 + 0x88);\n  if (plVar7 != *(longlong **)(param_1 + 0x88)) {\n    do {\n      plVar2 = (longlong *)plVar7[2];\n      lVar8 = plVar2[0x1c];\n      if (((((lVar8 == 0) || (cVar5 = FUN_1401d56a0(lVar8), cVar5 != '\\0')) &&\n           (*(char *)((longlong)plVar2 + 0xf9) != '\\0')) &&\n          (((plVar3 = *(longlong **)(param_1 + 0x50), plVar3 == (longlong *)0x0 ||\n            (plVar3 == plVar2)) ||\n           ((lVar8 != 0 && (cVar5 = FUN_1401d5ba0(lVar8,plVar3,0), cVar5 != '\\0')))))) &&\n         (*(char *)((longlong)plVar2 + 0x10c) != '\\0')) {\n        if ((*(longlong **)(param_1 + 0x68) != plVar2) &&\n           (cVar5 = (**(code **)(*plVar2 + 0xd0))(plVar2,&local_78), cVar5 != '\\0')) {\n          *(longlong **)(param_1 + 0x68) = plVar2;\n        }\n        local_88 = 0;\n        cVar5 = FUN_1401d4ea0(plVar2,1);\n        if (cVar5 != '\\0') goto LAB_14019f859;\n      }\n      plVar7 = (longlong *)*plVar7;\n    } while (plVar7 != (longlong *)*(longlong *)(param_1 + 0x88));\n  }\n  *(undefined8 *)(param_1 + 0x68) = 0;\nLAB_14019f859:\n  if ((*(longlong *)(param_1 + 0x68) != lVar1) && (lVar1 != 0)) {\n    for (puVar4 = (undefined8 *)**(undefined8 **)(param_1 + 0x88);\n        puVar4 != *(undefined8 **)(param_1 + 0x88); puVar4 = (undefined8 *)*puVar4) {\n      if (puVar4[2] == lVar1) {\n        local_88 = 1;\n        FUN_1401d4ea0(lVar1,8,&local_78,1);\n        break;\n      }\n    }\n  }\n  FUN_1404d6060(local_28 ^ (ulonglong)auStack_a8);\n  return;\n}",
        "similarity_score_unixcoder": 0.20784202218055725,
        "similarity_score_baseline_stripped": 0.2520110011100769
    },
    {
        "func_name": "dealloc_KMJobManager_JobFilter",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00021390(int param_1)\n{\n  if ((*(byte *)(param_1 + 0x10) & 4) == 0) {\n    return;\n  }\n  FUN_00021360(*(undefined4 *)(param_1 + 0xc),0);\n  return;\n}",
        "output": "```c\nvoid processParameter(int param_1)\n{\n  if ((*(byte *)(param_1 + 0x10) & 4) == 0) {\n    return;\n  }\n  callFunction(*(undefined4 *)(param_1 + 0xc), 0);\n  return;\n}\n```",
        "normed_func_sha256": "5427e3fe5bc20e178b28086e6103e14e942871ba7b85af2009f0b13e6f84fe7e",
        "source_code": "static void dealloc_KMJobManager_JobFilter(sipWrapper *sipSelf)\n{\n    if (sipIsPyOwned(sipSelf))\n    {\n        release_KMJobManager_JobFilter(sipSelf->u.cppPtr,0);\n    }\n}",
        "parsed_output": "void processParameter(int param_1)\n{\n  if ((*(byte *)(param_1 + 0x10) & 4) == 0) {\n    return;\n  }\n  callFunction(*(undefined4 *)(param_1 + 0xc), 0);\n  return;\n}",
        "baseline_code_stripped": "void FUN_00021390(int param_1)\n{\n  if ((*(byte *)(param_1 + 0x10) & 4) == 0) {\n    return;\n  }\n  FUN_00021360(*(undefined4 *)(param_1 + 0xc),0);\n  return;\n}",
        "similarity_score_unixcoder": 0.36111700534820557,
        "similarity_score_baseline_stripped": 0.3705351948738098
    },
    {
        "func_name": "read_some_at",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nulong __thiscall\nCOleDropTarget::OnDragEnter\n          (COleDropTarget *this,CWnd *param_1,COleDataObject *param_2,ulong param_3,CPoint param_4)\n{\n  ulong uVar1;\n  uVar1 = OnDragEnter(this,param_1,param_2,param_3,param_4);\n  return uVar1;\n}",
        "output": "```c\nulong COleDropTarget::OnDragEnter(CWnd *window, COleDataObject *dataObject, ulong keyState, CPoint cursorPosition)\n{\n    return OnDragEnter(this, window, dataObject, keyState, cursorPosition);\n}\n```",
        "normed_func_sha256": "22876c97c441a52ff8f9c3a58ad5158f419a006f145da58c42f0cb8924fab1e4",
        "source_code": "size_t read_some_at(implementation_type& impl, uint64_t offset,\r\n      const MutableBufferSequence& buffers, boost::system::error_code& ec)\r\n  {\r\n    boost::asio::mutable_buffer buffer =\r\n      buffer_sequence_adapter<boost::asio::mutable_buffer,\r\n        MutableBufferSequence>::first(buffers);\r\n    return do_read(impl, offset, buffer, ec);\r\n  }",
        "parsed_output": "ulong COleDropTarget::OnDragEnter(CWnd *window, COleDataObject *dataObject, ulong keyState, CPoint cursorPosition)\n{\n    return OnDragEnter(this, window, dataObject, keyState, cursorPosition);\n}",
        "baseline_code_stripped": "ulong __thiscall\nCOleDropTarget::OnDragEnter\n          (COleDropTarget *this,CWnd *param_1,COleDataObject *param_2,ulong param_3,CPoint param_4)\n{\n  ulong uVar1;\n  uVar1 = OnDragEnter(this,param_1,param_2,param_3,param_4);\n  return uVar1;\n}",
        "similarity_score_unixcoder": 0.2305922657251358,
        "similarity_score_baseline_stripped": 0.2316918671131134
    },
    {
        "func_name": "StaticTextCtrl::StaticTextCtrl",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall\nlomse::StaticTextCtrl::StaticTextCtrl\n          (StaticTextCtrl *this,LibraryScope *param_1,Control *param_2,Document *param_3,\n          basic_string *param_4,float param_5,float param_6,ImoStyle *param_7)\n{\n  StaticTextCtrl *pSVar1;\n  IdAssigner *this_00;\n  _List_node_base *p_Var2;\n  *(undefined **)this = &DAT_00753518;\n  *(undefined **)(this + 8) = &DAT_007535a8;\n  pSVar1 = this + 0x60;\n  *(LibraryScope **)(this + 0x10) = param_1;\n  *(Document **)(this + 0x18) = param_3;\n  *(Control **)(this + 0x20) = param_2;\n  *(undefined4 *)(this + 0x28) = 0xffffffff;\n  *(StaticTextCtrl **)(this + 0x30) = this + 0x40;\n  *(undefined8 *)(this + 0x38) = 0;\n  this[0x40] = (StaticTextCtrl)0x0;\n  this_00 = *(IdAssigner **)(param_3 + 0x70);\n  *(undefined8 *)(this + 0x50) = 0;\n  *(undefined2 *)(this + 0x58) = 0x101;\n  *(undefined4 *)(this + 0x5c) = 0xffffffff;\n  *(StaticTextCtrl **)pSVar1 = pSVar1;\n  *(StaticTextCtrl **)(this + 0x68) = pSVar1;\n  *(undefined8 *)(this + 0x70) = 0;\n  IdAssigner::assign_id(this_00,(Control *)this);\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_assign\n            ((basic_string *)(this + 0x30));\n  *(undefined ***)this = &PTR_FUN_0071d488;\n  *(undefined ***)(this + 8) = &PTR_FUN_0071d518;\n  *(StaticTextCtrl **)(this + 0x78) = this + 0x88;\n  FUN_0060b9a0(this + 0x78,*(long *)param_4,*(long *)param_4 + *(long *)(param_4 + 8));\n  *(undefined8 *)(this + 0x98) = 0;\n  *(undefined8 *)(this + 0xa0) = 0;\n  *(undefined8 *)(this + 0xb0) = 0;\n  *(float *)(this + 0xa8) = param_5;\n  *(float *)(this + 0xac) = param_6;\n  if (param_7 == (ImoStyle *)0x0) {\n    param_7 = (ImoStyle *)Document::get_default_style(*(Document **)(this + 0x18));\n  }\n  *(ImoStyle **)(this + 0x50) = param_7;\n  measure(this);\n  if (param_2 != (Control *)0x0) {\n    p_Var2 = (_List_node_base *)operator_new(0x18);\n    *(StaticTextCtrl **)(p_Var2 + 0x10) = this;\n    std::__detail::_List_node_base::_M_hook(p_Var2);\n    *(long *)(param_2 + 0x70) = *(long *)(param_2 + 0x70) + 1;\n  }\n  return;\n}",
        "output": "```c\nvoid lomse::StaticTextCtrl::StaticTextCtrl(\n    StaticTextCtrl *this,\n    LibraryScope *libraryScope,\n    Control *control,\n    Document *document,\n    basic_string *text,\n    float width,\n    float height,\n    ImoStyle *style)\n{\n    StaticTextCtrl *self = this + 0x60;\n    IdAssigner *idAssigner = *(IdAssigner **)(document + 0x70);\n    \n    *(undefined **)this = &DAT_00753518;\n    *(undefined **)(this + 8) = &DAT_007535a8;\n    *(LibraryScope **)(this + 0x10) = libraryScope;\n    *(Document **)(this + 0x18) = document;\n    *(Control **)(this + 0x20) = control;\n    *(undefined4 *)(this + 0x28) = 0xffffffff;\n    *(StaticTextCtrl **)(this + 0x30) = this + 0x40;\n    *(undefined8 *)(this + 0x38) = 0;\n    this[0x40] = (StaticTextCtrl)0x0;\n    *(undefined8 *)(this + 0x50) = 0;\n    *(undefined2 *)(this + 0x58) = 0x101;\n    *(undefined4 *)(this + 0x5c) = 0xffffffff;\n    *(StaticTextCtrl **)self = self;\n    *(StaticTextCtrl **)(this + 0x68) = self;\n    *(undefined8 *)(this + 0x70) = 0;\n\n    IdAssigner::assign_id(idAssigner, (Control *)this);\n    std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_assign((basic_string *)(this + 0x30));\n    \n    *(undefined ***)this = &PTR_FUN_0071d488;\n    *(undefined ***)(this + 8) = &PTR_FUN_0071d518;\n    *(StaticTextCtrl **)(this + 0x78) = this + 0x88;\n    \n    FUN_0060b9a0(this + 0x78, *(long *)text, *(long *)(text + 8));\n    \n    *(undefined8 *)(this + 0x98) = 0;\n    *(undefined8 *)(this + 0xa0) = 0;\n    *(undefined8 *)(this + 0xb0) = 0;\n    *(float *)(this + 0xa8) = width;\n    *(float *)(this + 0xac) = height;\n\n    if (style == (ImoStyle *)0x0) {\n        style = (ImoStyle *)Document::get_default_style(*(Document **)(this + 0x18));\n    }\n    \n    *(ImoStyle **)(this + 0x50) = style;\n    measure(this);\n\n    if (control != (Control *)0x0) {\n        _List_node_base *newNode = (_List_node_base *)operator_new(0x18);\n        *(StaticTextCtrl **)(newNode + 0x10) = this;\n        std::__detail::_List_node_base::_M_hook(newNode);\n        *(long *)(control + 0x70) += 1;\n    }\n    \n    return;\n}\n```",
        "normed_func_sha256": "b30b4b23d208d2c99bdf6e365198061ac71e7015514c50d54d008f172a3f42af",
        "source_code": "StaticTextCtrl::StaticTextCtrl(LibraryScope& libScope, Control* pParent,\n                               Document* pDoc, const string& label,\n                               LUnits width, LUnits height, ImoStyle* pStyle)\n    : Control(libScope, pDoc, pParent)\n    , m_label(label)\n    , m_pMainBox(nullptr)\n    , m_width(width)\n    , m_height(height)\n    , m_xCenter(0.0f)\n    , m_yCenter(0.0f)\n{\n    m_style = (pStyle == nullptr ? create_default_style() : pStyle);\n\n    measure();\n\n    if (pParent)\n        pParent->take_ownership_of(this);\n}",
        "parsed_output": "void lomse::StaticTextCtrl::StaticTextCtrl(\n    StaticTextCtrl *this,\n    LibraryScope *libraryScope,\n    Control *control,\n    Document *document,\n    basic_string *text,\n    float width,\n    float height,\n    ImoStyle *style)\n{\n    StaticTextCtrl *self = this + 0x60;\n    IdAssigner *idAssigner = *(IdAssigner **)(document + 0x70);\n    \n    *(undefined **)this = &DAT_00753518;\n    *(undefined **)(this + 8) = &DAT_007535a8;\n    *(LibraryScope **)(this + 0x10) = libraryScope;\n    *(Document **)(this + 0x18) = document;\n    *(Control **)(this + 0x20) = control;\n    *(undefined4 *)(this + 0x28) = 0xffffffff;\n    *(StaticTextCtrl **)(this + 0x30) = this + 0x40;\n    *(undefined8 *)(this + 0x38) = 0;\n    this[0x40] = (StaticTextCtrl)0x0;\n    *(undefined8 *)(this + 0x50) = 0;\n    *(undefined2 *)(this + 0x58) = 0x101;\n    *(undefined4 *)(this + 0x5c) = 0xffffffff;\n    *(StaticTextCtrl **)self = self;\n    *(StaticTextCtrl **)(this + 0x68) = self;\n    *(undefined8 *)(this + 0x70) = 0;\n\n    IdAssigner::assign_id(idAssigner, (Control *)this);\n    std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_assign((basic_string *)(this + 0x30));\n    \n    *(undefined ***)this = &PTR_FUN_0071d488;\n    *(undefined ***)(this + 8) = &PTR_FUN_0071d518;\n    *(StaticTextCtrl **)(this + 0x78) = this + 0x88;\n    \n    FUN_0060b9a0(this + 0x78, *(long *)text, *(long *)(text + 8));\n    \n    *(undefined8 *)(this + 0x98) = 0;\n    *(undefined8 *)(this + 0xa0) = 0;\n    *(undefined8 *)(this + 0xb0) = 0;\n    *(float *)(this + 0xa8) = width;\n    *(float *)(this + 0xac) = height;\n\n    if (style == (ImoStyle *)0x0) {\n        style = (ImoStyle *)Document::get_default_style(*(Document **)(this + 0x18));\n    }\n    \n    *(ImoStyle **)(this + 0x50) = style;\n    measure(this);\n\n    if (control != (Control *)0x0) {\n        _List_node_base *newNode = (_List_node_base *)operator_new(0x18);\n        *(StaticTextCtrl **)(newNode + 0x10) = this;\n        std::__detail::_List_node_base::_M_hook(newNode);\n        *(long *)(control + 0x70) += 1;\n    }\n    \n    return;\n}",
        "baseline_code_stripped": "void __thiscall\nlomse::StaticTextCtrl::StaticTextCtrl\n          (StaticTextCtrl *this,LibraryScope *param_1,Control *param_2,Document *param_3,\n          basic_string *param_4,float param_5,float param_6,ImoStyle *param_7)\n{\n  StaticTextCtrl *pSVar1;\n  IdAssigner *this_00;\n  _List_node_base *p_Var2;\n  *(undefined **)this = &DAT_00753518;\n  *(undefined **)(this + 8) = &DAT_007535a8;\n  pSVar1 = this + 0x60;\n  *(LibraryScope **)(this + 0x10) = param_1;\n  *(Document **)(this + 0x18) = param_3;\n  *(Control **)(this + 0x20) = param_2;\n  *(undefined4 *)(this + 0x28) = 0xffffffff;\n  *(StaticTextCtrl **)(this + 0x30) = this + 0x40;\n  *(undefined8 *)(this + 0x38) = 0;\n  this[0x40] = (StaticTextCtrl)0x0;\n  this_00 = *(IdAssigner **)(param_3 + 0x70);\n  *(undefined8 *)(this + 0x50) = 0;\n  *(undefined2 *)(this + 0x58) = 0x101;\n  *(undefined4 *)(this + 0x5c) = 0xffffffff;\n  *(StaticTextCtrl **)pSVar1 = pSVar1;\n  *(StaticTextCtrl **)(this + 0x68) = pSVar1;\n  *(undefined8 *)(this + 0x70) = 0;\n  IdAssigner::assign_id(this_00,(Control *)this);\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_assign\n            ((basic_string *)(this + 0x30));\n  *(undefined ***)this = &PTR_FUN_0071d488;\n  *(undefined ***)(this + 8) = &PTR_FUN_0071d518;\n  *(StaticTextCtrl **)(this + 0x78) = this + 0x88;\n  FUN_0060b9a0(this + 0x78,*(long *)param_4,*(long *)param_4 + *(long *)(param_4 + 8));\n  *(undefined8 *)(this + 0x98) = 0;\n  *(undefined8 *)(this + 0xa0) = 0;\n  *(undefined8 *)(this + 0xb0) = 0;\n  *(float *)(this + 0xa8) = param_5;\n  *(float *)(this + 0xac) = param_6;\n  if (param_7 == (ImoStyle *)0x0) {\n    param_7 = (ImoStyle *)Document::get_default_style(*(Document **)(this + 0x18));\n  }\n  *(ImoStyle **)(this + 0x50) = param_7;\n  measure(this);\n  if (param_2 != (Control *)0x0) {\n    p_Var2 = (_List_node_base *)operator_new(0x18);\n    *(StaticTextCtrl **)(p_Var2 + 0x10) = this;\n    std::__detail::_List_node_base::_M_hook(p_Var2);\n    *(long *)(param_2 + 0x70) = *(long *)(param_2 + 0x70) + 1;\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.7231701016426086,
        "similarity_score_baseline_stripped": 0.6728371381759644
    },
    {
        "func_name": "lock_sec_rec_cons_read_sees",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nuint FUN_00c80530(uint param_1,int param_2,int param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(int *)(param_2 + 0x10) + 0x24) >> 0xb & 1;\n  if (uVar1 != 0) {\n    return uVar1;\n  }\n  param_1 = param_1 & -_DAT_01715a4c;\n  if ((param_1 & 0xfff) == 0) {\n    uVar1 = 1;\n    if (*(uint *)(param_3 + 8) <= *(uint *)(param_1 + 0x38)) {\n      if ((*(uint *)(param_3 + 8) == *(uint *)(param_1 + 0x38)) &&\n         (*(uint *)(param_1 + 0x3c) < *(uint *)(param_3 + 0xc))) {\n        uVar1 = 1;\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n    return uVar1;\n  }\n  __assert_fail(\"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n                \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\",0x22,\n                \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\");\n}",
        "output": "```c\nuint FUN_00c80530(uint param_1, int param_2, int param_3) {\n    uint alignmentCheck;\n    alignmentCheck = *(uint *)(*(int *)(param_2 + 0x10) + 0x24) >> 0xb & 1;\n\n    if (alignmentCheck != 0) {\n        return alignmentCheck;\n    }\n\n    param_1 = param_1 & -_DAT_01715a4c;\n\n    if ((param_1 & 0xfff) == 0) {\n        uint result = 1;\n\n        if (*(uint *)(param_3 + 8) <= *(uint *)(param_1 + 0x38)) {\n            if ((*(uint *)(param_3 + 8) == *(uint *)(param_1 + 0x38)) &&\n                (*(uint *)(param_1 + 0x3c) < *(uint *)(param_3 + 0xc))) {\n                result = 1;\n            } else {\n                result = 0;\n            }\n        }\n        return result;\n    }\n\n    __assert_fail(\"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n                  \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\", 0x22,\n                  \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\");\n}\n```",
        "normed_func_sha256": "a26d76f3057dd92f798a56ff71f5a80a588fd4e6d8f8570c1f04c4b84f408f6d",
        "source_code": "bool\nlock_sec_rec_cons_read_sees(\n/*========================*/\n\tconst rec_t*\t\trec,\t/*!< in: user record which\n\t\t\t\t\tshould be read or passed over\n\t\t\t\t\tby a read cursor */\n\tconst dict_index_t*\tindex,\t/*!< in: index */\n\tconst ReadView*\tview)\t/*!< in: consistent read view */\n{\n\tut_ad(page_rec_is_user_rec(rec));\n\tut_ad(!index->is_primary());\n\tut_ad(!rec_is_metadata(rec, *index));\n\n\t/* NOTE that we might call this function while holding the search\n\tsystem latch. */\n\n\tif (index->table->is_temporary()) {\n\n\t\t/* Temp-tables are not shared across connections and multiple\n\t\ttransactions from different connections cannot simultaneously\n\t\toperate on same temp-table and so read of temp-table is\n\t\talways consistent read. */\n\n\t\treturn(true);\n\t}\n\n\ttrx_id_t\tmax_trx_id = page_get_max_trx_id(page_align(rec));\n\n\tut_ad(max_trx_id > 0);\n\n\treturn(view->sees(max_trx_id));\n}",
        "parsed_output": "uint FUN_00c80530(uint param_1, int param_2, int param_3) {\n    uint alignmentCheck;\n    alignmentCheck = *(uint *)(*(int *)(param_2 + 0x10) + 0x24) >> 0xb & 1;\n\n    if (alignmentCheck != 0) {\n        return alignmentCheck;\n    }\n\n    param_1 = param_1 & -_DAT_01715a4c;\n\n    if ((param_1 & 0xfff) == 0) {\n        uint result = 1;\n\n        if (*(uint *)(param_3 + 8) <= *(uint *)(param_1 + 0x38)) {\n            if ((*(uint *)(param_3 + 8) == *(uint *)(param_1 + 0x38)) &&\n                (*(uint *)(param_1 + 0x3c) < *(uint *)(param_3 + 0xc))) {\n                result = 1;\n            } else {\n                result = 0;\n            }\n        }\n        return result;\n    }\n\n    __assert_fail(\"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n                  \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\", 0x22,\n                  \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\");\n}",
        "baseline_code_stripped": "uint FUN_00c80530(uint param_1,int param_2,int param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(int *)(param_2 + 0x10) + 0x24) >> 0xb & 1;\n  if (uVar1 != 0) {\n    return uVar1;\n  }\n  param_1 = param_1 & -_DAT_01715a4c;\n  if ((param_1 & 0xfff) == 0) {\n    uVar1 = 1;\n    if (*(uint *)(param_3 + 8) <= *(uint *)(param_1 + 0x38)) {\n      if ((*(uint *)(param_3 + 8) == *(uint *)(param_1 + 0x38)) &&\n         (*(uint *)(param_1 + 0x3c) < *(uint *)(param_3 + 0xc))) {\n        uVar1 = 1;\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n    return uVar1;\n  }\n  __assert_fail(\"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n                \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\",0x22,\n                \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\");\n}",
        "similarity_score_unixcoder": 0.5549696683883667,
        "similarity_score_baseline_stripped": 0.562998354434967
    },
    {
        "func_name": "dino_entities_call_set_id",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid dino_entities_call_set_id(int param_1,int param_2)\n{\n  undefined4 uVar1;\n  int iVar2;\n  if (param_1 == 0) {\n    g_return_if_fail_warning(\"libdino\",\"dino_entities_call_set_id\",\"self != NULL\");\n    return;\n  }\n  iVar2 = dino_entities_call_get_id();\n  uVar1 = DAT_00104078;\n  if (iVar2 == param_2) {\n    return;\n  }\n  **(int **)(param_1 + 0xc) = param_2;\n  g_object_notify_by_pspec(param_1,uVar1);\n  return;\n}",
        "output": "```c\nvoid dino_entities_call_set_id(int entity, int new_id)\n{\n    undefined4 property_spec;\n    int current_id;\n\n    if (entity == 0) {\n        g_return_if_fail_warning(\"libdino\", \"dino_entities_call_set_id\", \"self != NULL\");\n        return;\n    }\n\n    current_id = dino_entities_call_get_id();\n    property_spec = DAT_00104078;\n\n    if (current_id == new_id) {\n        return;\n    }\n\n    *(int **)(entity + 0xc) = new_id;\n    g_object_notify_by_pspec(entity, property_spec);\n}\n```",
        "normed_func_sha256": "e8c587dc368c66bdda52014c3bdeaea5cb523d64e123325b3f623b49dfe9ad4f",
        "source_code": "void\ndino_entities_call_set_id (DinoEntitiesCall* self,\n                           gint value)\n{\n\tgint old_value;\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\tg_return_if_fail (self != NULL);\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\told_value = dino_entities_call_get_id (self);\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\tif (old_value != value) {\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\t\tself->priv->_id = value;\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\t\tg_object_notify_by_pspec ((GObject *) self, dino_entities_call_properties[DINO_ENTITIES_CALL_ID_PROPERTY]);\n#line 1849 \"call.c\"\n\t}\n}",
        "parsed_output": "void dino_entities_call_set_id(int entity, int new_id)\n{\n    undefined4 property_spec;\n    int current_id;\n\n    if (entity == 0) {\n        g_return_if_fail_warning(\"libdino\", \"dino_entities_call_set_id\", \"self != NULL\");\n        return;\n    }\n\n    current_id = dino_entities_call_get_id();\n    property_spec = DAT_00104078;\n\n    if (current_id == new_id) {\n        return;\n    }\n\n    *(int **)(entity + 0xc) = new_id;\n    g_object_notify_by_pspec(entity, property_spec);\n}",
        "baseline_code_stripped": "void dino_entities_call_set_id(int param_1,int param_2)\n{\n  undefined4 uVar1;\n  int iVar2;\n  if (param_1 == 0) {\n    g_return_if_fail_warning(\"libdino\",\"dino_entities_call_set_id\",\"self != NULL\");\n    return;\n  }\n  iVar2 = dino_entities_call_get_id();\n  uVar1 = DAT_00104078;\n  if (iVar2 == param_2) {\n    return;\n  }\n  **(int **)(param_1 + 0xc) = param_2;\n  g_object_notify_by_pspec(param_1,uVar1);\n  return;\n}",
        "similarity_score_unixcoder": 0.7828042507171631,
        "similarity_score_baseline_stripped": 0.7299197912216187
    },
    {
        "func_name": "pattern1200",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_00e9f69c(long param_1,uint param_2)\n{\n  char cVar1;\n  byte bVar2;\n  cVar1 = FUN_01175500(DAT_01f6e6a0);\n  if (cVar1 != '\\0') {\n    bVar2 = *(byte *)(param_1 + 2);\n    if ((((bVar2 == param_2) && (cVar1 = FUN_01568900(DAT_01f6e6a8,(uint)bVar2), cVar1 != '\\0')) &&\n        (cVar1 = FUN_012fad90(DAT_01f6e6b0,bVar2), cVar1 != '\\0')) &&\n       (cVar1 = FUN_01175500(DAT_01f6e6b8,bVar2), cVar1 != '\\0')) {\n      bVar2 = FUN_01175a40(DAT_01f6e6c0,bVar2);\n      return bVar2 - 1;\n    }\n  }\n  return -1;\n}",
        "output": "```c\nint processFunction(long param_1, uint param_2) {\n    char status;\n    byte value;\n\n    status = FUN_01175500(DAT_01f6e6a0);\n    if (status != '\\0') {\n        value = *(byte *)(param_1 + 2);\n        if (value == param_2) {\n            status = FUN_01568900(DAT_01f6e6a8, (uint)value);\n            if (status != '\\0') {\n                status = FUN_012fad90(DAT_01f6e6b0, value);\n                if (status != '\\0') {\n                    status = FUN_01175500(DAT_01f6e6b8, value);\n                    if (status != '\\0') {\n                        value = FUN_01175a40(DAT_01f6e6c0, value);\n                        return value - 1;\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n```",
        "normed_func_sha256": "cb1a269f014b9c94858235ab51b55d30b45163cd1841f98f0ebfd8cb93647c70",
        "source_code": "static int\npattern1200 (rtx x1, machine_mode i1)\n{\n  rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\n  int res ATTRIBUTE_UNUSED;\n  if (!register_operand (operands[0], i1)\n      || GET_MODE (x1) != i1\n      || !float_vector_all_ones_operand (operands[1], i1)\n      || !const0_operand (operands[2], i1)\n      || !register_operand (operands[3], i1)\n      || !nonimmediate_operand (operands[4], i1))\n    return -1;\n  return 0;\n}",
        "parsed_output": "int processFunction(long param_1, uint param_2) {\n    char status;\n    byte value;\n\n    status = FUN_01175500(DAT_01f6e6a0);\n    if (status != '\\0') {\n        value = *(byte *)(param_1 + 2);\n        if (value == param_2) {\n            status = FUN_01568900(DAT_01f6e6a8, (uint)value);\n            if (status != '\\0') {\n                status = FUN_012fad90(DAT_01f6e6b0, value);\n                if (status != '\\0') {\n                    status = FUN_01175500(DAT_01f6e6b8, value);\n                    if (status != '\\0') {\n                        value = FUN_01175a40(DAT_01f6e6c0, value);\n                        return value - 1;\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}",
        "baseline_code_stripped": "int FUN_00e9f69c(long param_1,uint param_2)\n{\n  char cVar1;\n  byte bVar2;\n  cVar1 = FUN_01175500(DAT_01f6e6a0);\n  if (cVar1 != '\\0') {\n    bVar2 = *(byte *)(param_1 + 2);\n    if ((((bVar2 == param_2) && (cVar1 = FUN_01568900(DAT_01f6e6a8,(uint)bVar2), cVar1 != '\\0')) &&\n        (cVar1 = FUN_012fad90(DAT_01f6e6b0,bVar2), cVar1 != '\\0')) &&\n       (cVar1 = FUN_01175500(DAT_01f6e6b8,bVar2), cVar1 != '\\0')) {\n      bVar2 = FUN_01175a40(DAT_01f6e6c0,bVar2);\n      return bVar2 - 1;\n    }\n  }\n  return -1;\n}",
        "similarity_score_unixcoder": 0.4886677861213684,
        "similarity_score_baseline_stripped": 0.422084778547287
    },
    {
        "func_name": "kernel_interface_create",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid kernel_interface_create(void)\n{\n  code **__s;\n  code *pcVar1;\n  code *pcVar2;\n  code *pcVar3;\n  code *pcVar4;\n  int iVar5;\n  code **ppcVar6;\n  undefined4 uVar7;\n  int iVar8;\n  undefined4 local_30;\n  int local_2c;\n  local_2c = __stack_chk_guard;\n  __s = (code **)malloc(200);\n  pcVar1 = (code *)mutex_create(0);\n  pcVar2 = (code *)linked_list_create();\n  pcVar3 = (code *)mutex_create(0);\n  pcVar4 = (code *)linked_list_create();\n  memset(__s,0,200);\n  *__s = get_features;\n  __s[1] = get_spi;\n  __s[2] = get_cpi;\n  __s[3] = add_sa;\n  __s[4] = update_sa;\n  __s[5] = query_sa;\n  __s[6] = del_sa;\n  __s[7] = flush_sas;\n  __s[8] = add_policy;\n  __s[9] = query_policy;\n  __s[10] = del_policy;\n  __s[0xb] = flush_policies;\n  __s[0xc] = get_source_addr;\n  __s[0xd] = get_nexthop;\n  __s[0xe] = get_interface;\n  __s[0xf] = create_address_enumerator;\n  __s[0x10] = add_ip;\n  __s[0x11] = del_ip;\n  __s[0x12] = add_route;\n  __s[0x13] = del_route;\n  __s[0x14] = bypass_socket;\n  __s[0x15] = enable_udp_decap;\n  __s[0x16] = is_interface_usable;\n  __s[0x17] = all_interfaces_usable;\n  __s[0x18] = get_address_by_ts;\n  __s[0x19] = add_ipsec_interface;\n  __s[0x1a] = remove_ipsec_interface;\n  __s[0x1b] = add_net_interface;\n  __s[0x1c] = remove_net_interface;\n  __s[0x1d] = add_listener;\n  __s[0x1e] = remove_listener;\n  __s[0x1f] = acquire;\n  __s[0x20] = expire;\n  __s[0x2c] = pcVar1;\n  __s[0x2d] = pcVar2;\n  __s[0x2f] = pcVar4;\n  __s[0x21] = mapping;\n  __s[0x2e] = pcVar3;\n  __s[0x27] = destroy;\n  __s[0x22] = migrate;\n  __s[0x23] = roam;\n  __s[0x24] = tun;\n  __s[0x25] = register_algorithm;\n  __s[0x26] = lookup_algorithm;\n  iVar5 = (***(code ***)(lib + 0x50))\n                    (*(code ***)(lib + 0x50),\"%s.interfaces_use\",0,*(undefined4 *)(lib + 8));\n  iVar8 = lib;\n  if (iVar5 == 0) {\n    *(undefined *)(__s + 0x31) = 1;\n    ppcVar6 = *(code ***)(iVar8 + 0x50);\n    iVar5 = (**ppcVar6)(ppcVar6,\"%s.interfaces_ignore\",0,*(undefined4 *)(iVar8 + 8));\n    if (iVar5 == 0) goto LAB_000141bc;\n  }\n  ppcVar6 = (code **)enumerator_create_token(iVar5,&DAT_00014a60,&DAT_00014a5c);\n  while (iVar8 = (**ppcVar6)(ppcVar6,&local_30), iVar8 != 0) {\n    pcVar1 = __s[0x30];\n    if (pcVar1 == (code *)0x0) {\n      pcVar1 = (code *)linked_list_create();\n      __s[0x30] = pcVar1;\n    }\n    pcVar2 = *(code **)(pcVar1 + 0x24);\n    uVar7 = __strdup(local_30);\n    (*pcVar2)(pcVar1,uVar7);\n  }\n  (*ppcVar6[1])(ppcVar6);\nLAB_000141bc:\n  if (local_2c != __stack_chk_guard) {\n    __stack_chk_fail(__s);\n  }\n  return;\n}",
        "output": "```c\nvoid kernel_interface_create(void)\n{\n    code **function_list;\n    code *mutex1;\n    code *linked_list1;\n    code *mutex2;\n    code *linked_list2;\n    int result;\n    code **token_creator;\n    undefined4 duplicated_string;\n    int lib_handle;\n    undefined4 local_string;\n    int stack_guard;\n\n    stack_guard = __stack_chk_guard;\n    function_list = (code **)malloc(200);\n    \n    mutex1 = (code *)mutex_create(0);\n    linked_list1 = (code *)linked_list_create();\n    mutex2 = (code *)mutex_create(0);\n    linked_list2 = (code *)linked_list_create();\n    \n    memset(function_list, 0, 200);\n    \n    function_list[0] = get_features;\n    function_list[1] = get_spi;\n    function_list[2] = get_cpi;\n    function_list[3] = add_sa;\n    function_list[4] = update_sa;\n    function_list[5] = query_sa;\n    function_list[6] = del_sa;\n    function_list[7] = flush_sas;\n    function_list[8] = add_policy;\n    function_list[9] = query_policy;\n    function_list[10] = del_policy;\n    function_list[11] = flush_policies;\n    function_list[12] = get_source_addr;\n    function_list[13] = get_nexthop;\n    function_list[14] = get_interface;\n    function_list[15] = create_address_enumerator;\n    function_list[16] = add_ip;\n    function_list[17] = del_ip;\n    function_list[18] = add_route;\n    function_list[19] = del_route;\n    function_list[20] = bypass_socket;\n    function_list[21] = enable_udp_decap;\n    function_list[22] = is_interface_usable;\n    function_list[23] = all_interfaces_usable;\n    function_list[24] = get_address_by_ts;\n    function_list[25] = add_ipsec_interface;\n    function_list[26] = remove_ipsec_interface;\n    function_list[27] = add_net_interface;\n    function_list[28] = remove_net_interface;\n    function_list[29] = add_listener;\n    function_list[30] = remove_listener;\n    function_list[31] = acquire;\n    function_list[32] = expire;\n    function_list[44] = mutex1;\n    function_list[45] = linked_list1;\n    function_list[47] = linked_list2;\n    function_list[33] = mapping;\n    function_list[46] = mutex2;\n    function_list[39] = destroy;\n    function_list[34] = migrate;\n    function_list[35] = roam;\n    function_list[36] = tun;\n    function_list[37] = register_algorithm;\n    function_list[38] = lookup_algorithm;\n\n    result = (***(code ***)(lib + 0x50))(*(code ***)(lib + 0x50), \"%s.interfaces_use\", 0, *(undefined4 *)(lib + 8));\n    lib_handle = lib;\n\n    if (result == 0) {\n        *(undefined *)(function_list + 0x31) = 1;\n        token_creator = *(code ***)(lib_handle + 0x50);\n        result = (**token_creator)(token_creator, \"%s.interfaces_ignore\", 0, *(undefined4 *)(lib_handle + 8));\n        if (result == 0) goto cleanup;\n    }\n\n    token_creator = (code **)enumerator_create_token(result, &DAT_00014a60, &DAT_00014a5c);\n    \n    while ((lib_handle = (**token_creator)(token_creator, &local_string)) != 0) {\n        mutex1 = function_list[0x30];\n        if (mutex1 == (code *)0x0) {\n            mutex1 = (code *)linked_list_create();\n            function_list[0x30] = mutex1;\n        }\n        linked_list1 = *(code **)(mutex1 + 0x24);\n        duplicated_string = __strdup(local_string);\n        (*linked_list1)(mutex1, duplicated_string);\n    }\n    \n    (*token_creator[1])(token_creator);\n    \ncleanup:\n    if (stack_guard != __stack_chk_guard) {\n        __stack_chk_fail(function_list);\n    }\n    return;\n}\n```",
        "normed_func_sha256": "eaf17ed6fe181162b2bb7cdef83f79adfa393b826d5fbecc885f8653b47e9e34",
        "source_code": "kernel_interface_t *kernel_interface_create()\n{\n\tprivate_kernel_interface_t *this;\n\tchar *ifaces;\n\n\tINIT(this,\n\t\t.public = {\n\t\t\t.get_features = _get_features,\n\t\t\t.get_spi = _get_spi,\n\t\t\t.get_cpi = _get_cpi,\n\t\t\t.add_sa = _add_sa,\n\t\t\t.update_sa = _update_sa,\n\t\t\t.query_sa = _query_sa,\n\t\t\t.del_sa = _del_sa,\n\t\t\t.flush_sas = _flush_sas,\n\t\t\t.add_policy = _add_policy,\n\t\t\t.query_policy = _query_policy,\n\t\t\t.del_policy = _del_policy,\n\t\t\t.flush_policies = _flush_policies,\n\t\t\t.get_source_addr = _get_source_addr,\n\t\t\t.get_nexthop = _get_nexthop,\n\t\t\t.get_interface = _get_interface,\n\t\t\t.create_address_enumerator = _create_address_enumerator,\n\t\t\t.add_ip = _add_ip,\n\t\t\t.del_ip = _del_ip,\n\t\t\t.add_route = _add_route,\n\t\t\t.del_route = _del_route,\n\t\t\t.bypass_socket = _bypass_socket,\n\t\t\t.enable_udp_decap = _enable_udp_decap,\n\n\t\t\t.is_interface_usable = _is_interface_usable,\n\t\t\t.all_interfaces_usable = _all_interfaces_usable,\n\t\t\t.get_address_by_ts = _get_address_by_ts,\n\t\t\t.add_ipsec_interface = _add_ipsec_interface,\n\t\t\t.remove_ipsec_interface = _remove_ipsec_interface,\n\t\t\t.add_net_interface = _add_net_interface,\n\t\t\t.remove_net_interface = _remove_net_interface,\n\n\t\t\t.add_listener = _add_listener,\n\t\t\t.remove_listener = _remove_listener,\n\t\t\t.register_algorithm = _register_algorithm,\n\t\t\t.lookup_algorithm = _lookup_algorithm,\n\t\t\t.acquire = _acquire,\n\t\t\t.expire = _expire,\n\t\t\t.mapping = _mapping,\n\t\t\t.migrate = _migrate,\n\t\t\t.roam = _roam,\n\t\t\t.tun = _tun,\n\t\t\t.destroy = _destroy,\n\t\t},\n\t\t.mutex = mutex_create(MUTEX_TYPE_DEFAULT),\n\t\t.listeners = linked_list_create(),\n\t\t.mutex_algs = mutex_create(MUTEX_TYPE_DEFAULT),\n\t\t.algorithms = linked_list_create(),\n\t);\n\n\tifaces = lib->settings->get_str(lib->settings,\n\t\t\t\t\t\t\t\t\t\"%s.interfaces_use\", NULL, lib->ns);\n\tif (!ifaces)\n\t{\n\t\tthis->ifaces_exclude = TRUE;\n\t\tifaces = lib->settings->get_str(lib->settings,\n\t\t\t\t\t\t\t\t\t\"%s.interfaces_ignore\", NULL, lib->ns);\n\t}\n\tif (ifaces)\n\t{\n\t\tenumerator_t *enumerator;\n\t\tchar *iface;\n\n\t\tenumerator = enumerator_create_token(ifaces, \",\", \" \");\n\t\twhile (enumerator->enumerate(enumerator, &iface))\n\t\t{\n\t\t\tif (!this->ifaces_filter)\n\t\t\t{\n\t\t\t\tthis->ifaces_filter = linked_list_create();\n\t\t\t}\n\t\t\tthis->ifaces_filter->insert_last(this->ifaces_filter,\n\t\t\t\t\t\t\t\t\t\t\t strdup(iface));\n\t\t}\n\t\tenumerator->destroy(enumerator);\n\t}\n\n\treturn &this->public;\n}",
        "parsed_output": "void kernel_interface_create(void)\n{\n    code **function_list;\n    code *mutex1;\n    code *linked_list1;\n    code *mutex2;\n    code *linked_list2;\n    int result;\n    code **token_creator;\n    undefined4 duplicated_string;\n    int lib_handle;\n    undefined4 local_string;\n    int stack_guard;\n\n    stack_guard = __stack_chk_guard;\n    function_list = (code **)malloc(200);\n    \n    mutex1 = (code *)mutex_create(0);\n    linked_list1 = (code *)linked_list_create();\n    mutex2 = (code *)mutex_create(0);\n    linked_list2 = (code *)linked_list_create();\n    \n    memset(function_list, 0, 200);\n    \n    function_list[0] = get_features;\n    function_list[1] = get_spi;\n    function_list[2] = get_cpi;\n    function_list[3] = add_sa;\n    function_list[4] = update_sa;\n    function_list[5] = query_sa;\n    function_list[6] = del_sa;\n    function_list[7] = flush_sas;\n    function_list[8] = add_policy;\n    function_list[9] = query_policy;\n    function_list[10] = del_policy;\n    function_list[11] = flush_policies;\n    function_list[12] = get_source_addr;\n    function_list[13] = get_nexthop;\n    function_list[14] = get_interface;\n    function_list[15] = create_address_enumerator;\n    function_list[16] = add_ip;\n    function_list[17] = del_ip;\n    function_list[18] = add_route;\n    function_list[19] = del_route;\n    function_list[20] = bypass_socket;\n    function_list[21] = enable_udp_decap;\n    function_list[22] = is_interface_usable;\n    function_list[23] = all_interfaces_usable;\n    function_list[24] = get_address_by_ts;\n    function_list[25] = add_ipsec_interface;\n    function_list[26] = remove_ipsec_interface;\n    function_list[27] = add_net_interface;\n    function_list[28] = remove_net_interface;\n    function_list[29] = add_listener;\n    function_list[30] = remove_listener;\n    function_list[31] = acquire;\n    function_list[32] = expire;\n    function_list[44] = mutex1;\n    function_list[45] = linked_list1;\n    function_list[47] = linked_list2;\n    function_list[33] = mapping;\n    function_list[46] = mutex2;\n    function_list[39] = destroy;\n    function_list[34] = migrate;\n    function_list[35] = roam;\n    function_list[36] = tun;\n    function_list[37] = register_algorithm;\n    function_list[38] = lookup_algorithm;\n\n    result = (***(code ***)(lib + 0x50))(*(code ***)(lib + 0x50), \"%s.interfaces_use\", 0, *(undefined4 *)(lib + 8));\n    lib_handle = lib;\n\n    if (result == 0) {\n        *(undefined *)(function_list + 0x31) = 1;\n        token_creator = *(code ***)(lib_handle + 0x50);\n        result = (**token_creator)(token_creator, \"%s.interfaces_ignore\", 0, *(undefined4 *)(lib_handle + 8));\n        if (result == 0) goto cleanup;\n    }\n\n    token_creator = (code **)enumerator_create_token(result, &DAT_00014a60, &DAT_00014a5c);\n    \n    while ((lib_handle = (**token_creator)(token_creator, &local_string)) != 0) {\n        mutex1 = function_list[0x30];\n        if (mutex1 == (code *)0x0) {\n            mutex1 = (code *)linked_list_create();\n            function_list[0x30] = mutex1;\n        }\n        linked_list1 = *(code **)(mutex1 + 0x24);\n        duplicated_string = __strdup(local_string);\n        (*linked_list1)(mutex1, duplicated_string);\n    }\n    \n    (*token_creator[1])(token_creator);\n    \ncleanup:\n    if (stack_guard != __stack_chk_guard) {\n        __stack_chk_fail(function_list);\n    }\n    return;\n}",
        "baseline_code_stripped": "void kernel_interface_create(void)\n{\n  code **__s;\n  code *pcVar1;\n  code *pcVar2;\n  code *pcVar3;\n  code *pcVar4;\n  int iVar5;\n  code **ppcVar6;\n  undefined4 uVar7;\n  int iVar8;\n  undefined4 local_30;\n  int local_2c;\n  local_2c = __stack_chk_guard;\n  __s = (code **)malloc(200);\n  pcVar1 = (code *)mutex_create(0);\n  pcVar2 = (code *)linked_list_create();\n  pcVar3 = (code *)mutex_create(0);\n  pcVar4 = (code *)linked_list_create();\n  memset(__s,0,200);\n  *__s = get_features;\n  __s[1] = get_spi;\n  __s[2] = get_cpi;\n  __s[3] = add_sa;\n  __s[4] = update_sa;\n  __s[5] = query_sa;\n  __s[6] = del_sa;\n  __s[7] = flush_sas;\n  __s[8] = add_policy;\n  __s[9] = query_policy;\n  __s[10] = del_policy;\n  __s[0xb] = flush_policies;\n  __s[0xc] = get_source_addr;\n  __s[0xd] = get_nexthop;\n  __s[0xe] = get_interface;\n  __s[0xf] = create_address_enumerator;\n  __s[0x10] = add_ip;\n  __s[0x11] = del_ip;\n  __s[0x12] = add_route;\n  __s[0x13] = del_route;\n  __s[0x14] = bypass_socket;\n  __s[0x15] = enable_udp_decap;\n  __s[0x16] = is_interface_usable;\n  __s[0x17] = all_interfaces_usable;\n  __s[0x18] = get_address_by_ts;\n  __s[0x19] = add_ipsec_interface;\n  __s[0x1a] = remove_ipsec_interface;\n  __s[0x1b] = add_net_interface;\n  __s[0x1c] = remove_net_interface;\n  __s[0x1d] = add_listener;\n  __s[0x1e] = remove_listener;\n  __s[0x1f] = acquire;\n  __s[0x20] = expire;\n  __s[0x2c] = pcVar1;\n  __s[0x2d] = pcVar2;\n  __s[0x2f] = pcVar4;\n  __s[0x21] = mapping;\n  __s[0x2e] = pcVar3;\n  __s[0x27] = destroy;\n  __s[0x22] = migrate;\n  __s[0x23] = roam;\n  __s[0x24] = tun;\n  __s[0x25] = register_algorithm;\n  __s[0x26] = lookup_algorithm;\n  iVar5 = (***(code ***)(lib + 0x50))\n                    (*(code ***)(lib + 0x50),\"%s.interfaces_use\",0,*(undefined4 *)(lib + 8));\n  iVar8 = lib;\n  if (iVar5 == 0) {\n    *(undefined *)(__s + 0x31) = 1;\n    ppcVar6 = *(code ***)(iVar8 + 0x50);\n    iVar5 = (**ppcVar6)(ppcVar6,\"%s.interfaces_ignore\",0,*(undefined4 *)(iVar8 + 8));\n    if (iVar5 == 0) goto LAB_000141bc;\n  }\n  ppcVar6 = (code **)enumerator_create_token(iVar5,&DAT_00014a60,&DAT_00014a5c);\n  while (iVar8 = (**ppcVar6)(ppcVar6,&local_30), iVar8 != 0) {\n    pcVar1 = __s[0x30];\n    if (pcVar1 == (code *)0x0) {\n      pcVar1 = (code *)linked_list_create();\n      __s[0x30] = pcVar1;\n    }\n    pcVar2 = *(code **)(pcVar1 + 0x24);\n    uVar7 = __strdup(local_30);\n    (*pcVar2)(pcVar1,uVar7);\n  }\n  (*ppcVar6[1])(ppcVar6);\nLAB_000141bc:\n  if (local_2c != __stack_chk_guard) {\n    __stack_chk_fail(__s);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.7826865315437317,
        "similarity_score_baseline_stripped": 0.7532832026481628
    },
    {
        "func_name": "soap_PATCH__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_016adba6(undefined8 param_1,undefined8 param_2,long *param_3)\n{\n  code *pcVar1;\n  bool bVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  FUN_01aca350(param_1);\n  iVar3 = FUN_01add460(param_1,param_2,0,\"text/xml; charset=utf-8\");\n  if (iVar3 == 0) {\n    (**(code **)(*param_3 + 0x10))(param_3,param_1);\n    pcVar1 = *(code **)(*param_3 + 0x18);\n    lVar4 = (**(code **)*param_3)(param_3);\n    if (lVar4 == 0xe37) {\n      puVar6 = &DAT_01fe53c0;\n    }\n    else {\n      puVar6 = (undefined *)0x0;\n    }\n    iVar3 = (*pcVar1)(param_3,param_1,\"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\",puVar6);\n    if (iVar3 == 0) {\n      iVar3 = FUN_01adabd0(param_1);\n      if (iVar3 == 0) {\n        iVar3 = FUN_01ae4850(param_1);\n        if (iVar3 == 0) {\n          bVar2 = false;\n          goto LAB_016adc98;\n        }\n      }\n    }\n  }\n  bVar2 = true;\nLAB_016adc98:\n  if (bVar2) {\n    uVar5 = FUN_01ac5ad0(param_1);\n  }\n  else {\n    uVar5 = 0;\n  }\n  return uVar5;\n}",
        "output": "```c\nundefined8 ProcessUpdateAgentEvent(undefined8 param_1, undefined8 param_2, long *param_3) {\n    code *eventHandler;\n    bool isSuccess;\n    int result;\n    long eventCode;\n    undefined8 releaseNotes;\n    undefined *releaseNotesPtr;\n\n    // Initialize the process\n    FUN_01aca350(param_1);\n    \n    // Check if the parameters are valid\n    result = FUN_01add460(param_1, param_2, 0, \"text/xml; charset=utf-8\");\n    if (result == 0) {\n        // Call the event handler\n        (**(code **)(*param_3 + 0x10))(param_3, param_1);\n        eventHandler = *(code **)(*param_3 + 0x18);\n        eventCode = (**(code **)*param_3)(param_3);\n        \n        // Determine the release notes pointer based on the event code\n        releaseNotesPtr = (eventCode == 0xe37) ? &DAT_01fe53c0 : (undefined *)0x0;\n        \n        // Get the release notes\n        result = (*eventHandler)(param_3, param_1, \"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\", releaseNotesPtr);\n        if (result == 0) {\n            // Check for additional conditions\n            result = FUN_01adabd0(param_1);\n            if (result == 0) {\n                result = FUN_01ae4850(param_1);\n                if (result == 0) {\n                    isSuccess = false;\n                    goto ReturnResult;\n                }\n            }\n        }\n    }\n    isSuccess = true;\n\nReturnResult:\n    // Return the appropriate value based on success\n    return isSuccess ? FUN_01ac5ad0(param_1) : 0;\n}\n```",
        "normed_func_sha256": "39820e1ced6d0c6b58d860554c52e53553b6efdb70d792e512a65c71fc8766f9",
        "source_code": "int soap_PATCH__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes(struct soap *soap, const char *URL, _vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes const*p)\n{\n\tsoap_free_temp(soap);\n\tif (soap_PATCH(soap, URL, NULL, \"text/xml; charset=utf-8\") || (p->soap_serialize(soap), 0) || p->soap_put(soap, \"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\", p->soap_type() == SOAP_TYPE__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes ? \"\" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))\n\t\treturn soap_closesock(soap);\n\treturn SOAP_OK;\n}",
        "parsed_output": "undefined8 ProcessUpdateAgentEvent(undefined8 param_1, undefined8 param_2, long *param_3) {\n    code *eventHandler;\n    bool isSuccess;\n    int result;\n    long eventCode;\n    undefined8 releaseNotes;\n    undefined *releaseNotesPtr;\n\n    // Initialize the process\n    FUN_01aca350(param_1);\n    \n    // Check if the parameters are valid\n    result = FUN_01add460(param_1, param_2, 0, \"text/xml; charset=utf-8\");\n    if (result == 0) {\n        // Call the event handler\n        (**(code **)(*param_3 + 0x10))(param_3, param_1);\n        eventHandler = *(code **)(*param_3 + 0x18);\n        eventCode = (**(code **)*param_3)(param_3);\n        \n        // Determine the release notes pointer based on the event code\n        releaseNotesPtr = (eventCode == 0xe37) ? &DAT_01fe53c0 : (undefined *)0x0;\n        \n        // Get the release notes\n        result = (*eventHandler)(param_3, param_1, \"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\", releaseNotesPtr);\n        if (result == 0) {\n            // Check for additional conditions\n            result = FUN_01adabd0(param_1);\n            if (result == 0) {\n                result = FUN_01ae4850(param_1);\n                if (result == 0) {\n                    isSuccess = false;\n                    goto ReturnResult;\n                }\n            }\n        }\n    }\n    isSuccess = true;\n\nReturnResult:\n    // Return the appropriate value based on success\n    return isSuccess ? FUN_01ac5ad0(param_1) : 0;\n}",
        "baseline_code_stripped": "undefined8 FUN_016adba6(undefined8 param_1,undefined8 param_2,long *param_3)\n{\n  code *pcVar1;\n  bool bVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  FUN_01aca350(param_1);\n  iVar3 = FUN_01add460(param_1,param_2,0,\"text/xml; charset=utf-8\");\n  if (iVar3 == 0) {\n    (**(code **)(*param_3 + 0x10))(param_3,param_1);\n    pcVar1 = *(code **)(*param_3 + 0x18);\n    lVar4 = (**(code **)*param_3)(param_3);\n    if (lVar4 == 0xe37) {\n      puVar6 = &DAT_01fe53c0;\n    }\n    else {\n      puVar6 = (undefined *)0x0;\n    }\n    iVar3 = (*pcVar1)(param_3,param_1,\"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\",puVar6);\n    if (iVar3 == 0) {\n      iVar3 = FUN_01adabd0(param_1);\n      if (iVar3 == 0) {\n        iVar3 = FUN_01ae4850(param_1);\n        if (iVar3 == 0) {\n          bVar2 = false;\n          goto LAB_016adc98;\n        }\n      }\n    }\n  }\n  bVar2 = true;\nLAB_016adc98:\n  if (bVar2) {\n    uVar5 = FUN_01ac5ad0(param_1);\n  }\n  else {\n    uVar5 = 0;\n  }\n  return uVar5;\n}",
        "similarity_score_unixcoder": 0.595721423625946,
        "similarity_score_baseline_stripped": 0.4740559458732605
    },
    {
        "func_name": "MyMoneyFile::attachStorage",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall MyMoneyFile::attachStorage(MyMoneyFile *this,MyMoneyStorageMgr *param_1)\n{\n  bool bVar1;\n  int iVar2;\n  MyMoneyStorageMgr *pMVar3;\n  undefined8 *this_00;\n  MyMoneyStorageMgr *pMVar4;\n  MyMoneyStorageMgr **ppMVar5;\n  int *piVar6;\n  MyMoneySecurity aMStack_58 [8];\n  MyMoneyStorageMgr *local_50;\n  MyMoneyStorageMgr *local_40;\n  longlong local_38;\n  ppMVar5 = *(MyMoneyStorageMgr ***)(this + 0x10);\n  local_38 = ___stack_chk_guard;\n  if (*ppMVar5 != (MyMoneyStorageMgr *)0x0) {\n    this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n    std::runtime_error::runtime_error\n              ((runtime_error *)this_00,\n               \"Storage already attached /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:333\"\n              );\nLAB_001567dc:\n    *this_00 = &PTR_FUN_002a2ab0;\n    __cxa_throw(this_00,&MyMoneyException::typeinfo,FUN_0013f5a0);\n  }\n  if (param_1 == (MyMoneyStorageMgr *)0x0) {\n    this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n    std::runtime_error::runtime_error\n              ((runtime_error *)this_00,\n               \"Storage must not be 0 /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:336\"\n              );\n    goto LAB_001567dc;\n  }\n  *ppMVar5 = param_1;\n  MyMoneySecurity::MyMoneySecurity(aMStack_58);\n  pMVar4 = ppMVar5[3];\n  pMVar3 = ppMVar5[5];\n  ppMVar5[3] = local_50;\n  ppMVar5[5] = local_40;\n  local_50 = pMVar4;\n  local_40 = pMVar3;\n  MyMoneySecurity::_MyMoneySecurity(aMStack_58);\n  MyMoneyBalanceCache::clear((MyMoneyBalanceCache *)(*(longlong *)(this + 0x10) + 0x38));\n  piVar6 = *(int **)(*(longlong *)(this + 0x10) + 0x30);\n  *(undefined8 **)(*(longlong *)(this + 0x10) + 0x30) = &QMapDataBase::shared_null;\n  if (*piVar6 == 0) {\nLAB_00156728:\n    if (*(longlong *)(piVar6 + 4) != 0) {\n      FUN_00183cf8();\n      QMapDataBase::freeTree((QMapNodeBase *)piVar6,(int)*(undefined8 *)(piVar6 + 4));\n    }\n    QMapDataBase::freeData((QMapDataBase *)piVar6);\n  }\n  else if (*piVar6 != -1) {\n    SYNC(0);\n    iVar2 = *piVar6;\n    *piVar6 = iVar2 + -1;\n    SYNC(0);\n    if (iVar2 == 1) goto LAB_00156728;\n  }\n  if ((int)QMapDataBase::shared_null != 0) {\n    if ((int)QMapDataBase::shared_null == -1) goto LAB_001566dc;\n    SYNC(0);\n    iVar2 = (int)QMapDataBase::shared_null + -1;\n    SYNC(0);\n    bVar1 = (int)QMapDataBase::shared_null != 1;\n    QMapDataBase::shared_null._0_4_ = iVar2;\n    if (bVar1) goto LAB_001566dc;\n  }\n  if (__Init != 0) {\n    FUN_00183cf8();\n    QMapDataBase::freeTree((QMapNodeBase *)&QMapDataBase::shared_null,(int)__Init);\n  }\n  QMapDataBase::freeData((QMapDataBase *)&QMapDataBase::shared_null);\nLAB_001566dc:\n  beginChangeNotification(this);\n  dataChanged(this);\n  endChangeNotification(this);\n  if (local_38 != ___stack_chk_guard) {\n    __stack_chk_fail();\n  }\n  return;\n}",
        "output": "```c\nvoid MyMoneyFile::attachStorage(MyMoneyStorageMgr *storageManager) {\n    bool isSharedNull;\n    int referenceCount;\n    MyMoneyStorageMgr *previousStorage;\n    MyMoneyStorageMgr *currentStorage;\n    MyMoneyStorageMgr **storagePtr;\n    int *referenceCounter;\n    MyMoneySecurity securityStack[8];\n    MyMoneyStorageMgr *newStorage;\n    MyMoneyStorageMgr *oldStorage;\n    long long stackGuard;\n\n    storagePtr = *(MyMoneyStorageMgr ***)(this + 0x10);\n    stackGuard = ___stack_chk_guard;\n\n    if (*storagePtr != nullptr) {\n        auto exception = (undefined8 *)__cxa_allocate_exception(0x10);\n        std::runtime_error::runtime_error((runtime_error *)exception,\n            \"Storage already attached /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:333\");\n        *exception = &PTR_FUN_002a2ab0;\n        __cxa_throw(exception, &MyMoneyException::typeinfo, FUN_0013f5a0);\n    }\n\n    if (storageManager == nullptr) {\n        auto exception = (undefined8 *)__cxa_allocate_exception(0x10);\n        std::runtime_error::runtime_error((runtime_error *)exception,\n            \"Storage must not be 0 /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:336\");\n        *exception = &PTR_FUN_002a2ab0;\n        __cxa_throw(exception, &MyMoneyException::typeinfo, FUN_0013f5a0);\n    }\n\n    *storagePtr = storageManager;\n    MyMoneySecurity::MyMoneySecurity(securityStack);\n    oldStorage = storagePtr[3];\n    currentStorage = storagePtr[5];\n    storagePtr[3] = newStorage;\n    storagePtr[5] = oldStorage;\n    newStorage = currentStorage;\n    MyMoneySecurity::_MyMoneySecurity(securityStack);\n    MyMoneyBalanceCache::clear((MyMoneyBalanceCache *)(*(long long *)(this + 0x10) + 0x38));\n    referenceCounter = *(int **)(*(long long *)(this + 0x10) + 0x30);\n    *(undefined8 **)(*(long long *)(this + 0x10) + 0x30) = &QMapDataBase::shared_null;\n\n    if (*referenceCounter == 0) {\n        if (*(long long *)(referenceCounter + 4) != 0) {\n            FUN_00183cf8();\n            QMapDataBase::freeTree((QMapNodeBase *)referenceCounter, (int)*(undefined8 *)(referenceCounter + 4));\n        }\n        QMapDataBase::freeData((QMapDataBase *)referenceCounter);\n    } else if (*referenceCounter != -1) {\n        SYNC(0);\n        referenceCount = *referenceCounter;\n        *referenceCounter = referenceCount - 1;\n        SYNC(0);\n        if (referenceCount == 1) {\n            if (*(long long *)(referenceCounter + 4) != 0) {\n                FUN_00183cf8();\n                QMapDataBase::freeTree((QMapNodeBase *)referenceCounter, (int)*(undefined8 *)(referenceCounter + 4));\n            }\n            QMapDataBase::freeData((QMapDataBase *)referenceCounter);\n        }\n    }\n\n    if ((int)QMapDataBase::shared_null != 0) {\n        if ((int)QMapDataBase::shared_null == -1) {\n            goto cleanup;\n        }\n        SYNC(0);\n        referenceCount = (int)QMapDataBase::shared_null - 1;\n        SYNC(0);\n        isSharedNull = (int)QMapDataBase::shared_null != 1;\n        QMapDataBase::shared_null._0_4_ = referenceCount;\n        if (isSharedNull) {\n            goto cleanup;\n        }\n    }\n\n    if (__Init != 0) {\n        FUN_00183cf8();\n        QMapDataBase::freeTree((QMapNodeBase *)&QMapDataBase::shared_null, (int)__Init);\n    }\n    QMapDataBase::freeData((QMapDataBase *)&QMapDataBase::shared_null);\n\ncleanup:\n    beginChangeNotification(this);\n    dataChanged(this);\n    endChangeNotification(this);\n\n    if (stackGuard != ___stack_chk_guard) {\n        __stack_chk_fail();\n    }\n}\n```",
        "normed_func_sha256": "fa7ed3d52628e77b93a6b04997335646c7adfe772f062278c34366b3115d5033",
        "source_code": "void MyMoneyFile::attachStorage(IMyMoneyStorage* const storage)\n{\n  if (d->m_storage != 0)\n    throw MYMONEYEXCEPTION(\"Storage already attached\");\n  if (storage == 0)\n    throw MYMONEYEXCEPTION(\"Storage must not be 0\");\n  d->m_storage = storage;\n  d->m_baseCurrency = MyMoneySecurity();\n  d->m_balanceCache.clear();\n  d->m_cache.clear(storage);\n  d->m_priceCache.clear();\n  preloadCache();\n  emit beginChangeNotification();\n  emit dataChanged();\n  emit endChangeNotification();\n}",
        "parsed_output": "void MyMoneyFile::attachStorage(MyMoneyStorageMgr *storageManager) {\n    bool isSharedNull;\n    int referenceCount;\n    MyMoneyStorageMgr *previousStorage;\n    MyMoneyStorageMgr *currentStorage;\n    MyMoneyStorageMgr **storagePtr;\n    int *referenceCounter;\n    MyMoneySecurity securityStack[8];\n    MyMoneyStorageMgr *newStorage;\n    MyMoneyStorageMgr *oldStorage;\n    long long stackGuard;\n\n    storagePtr = *(MyMoneyStorageMgr ***)(this + 0x10);\n    stackGuard = ___stack_chk_guard;\n\n    if (*storagePtr != nullptr) {\n        auto exception = (undefined8 *)__cxa_allocate_exception(0x10);\n        std::runtime_error::runtime_error((runtime_error *)exception,\n            \"Storage already attached /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:333\");\n        *exception = &PTR_FUN_002a2ab0;\n        __cxa_throw(exception, &MyMoneyException::typeinfo, FUN_0013f5a0);\n    }\n\n    if (storageManager == nullptr) {\n        auto exception = (undefined8 *)__cxa_allocate_exception(0x10);\n        std::runtime_error::runtime_error((runtime_error *)exception,\n            \"Storage must not be 0 /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:336\");\n        *exception = &PTR_FUN_002a2ab0;\n        __cxa_throw(exception, &MyMoneyException::typeinfo, FUN_0013f5a0);\n    }\n\n    *storagePtr = storageManager;\n    MyMoneySecurity::MyMoneySecurity(securityStack);\n    oldStorage = storagePtr[3];\n    currentStorage = storagePtr[5];\n    storagePtr[3] = newStorage;\n    storagePtr[5] = oldStorage;\n    newStorage = currentStorage;\n    MyMoneySecurity::_MyMoneySecurity(securityStack);\n    MyMoneyBalanceCache::clear((MyMoneyBalanceCache *)(*(long long *)(this + 0x10) + 0x38));\n    referenceCounter = *(int **)(*(long long *)(this + 0x10) + 0x30);\n    *(undefined8 **)(*(long long *)(this + 0x10) + 0x30) = &QMapDataBase::shared_null;\n\n    if (*referenceCounter == 0) {\n        if (*(long long *)(referenceCounter + 4) != 0) {\n            FUN_00183cf8();\n            QMapDataBase::freeTree((QMapNodeBase *)referenceCounter, (int)*(undefined8 *)(referenceCounter + 4));\n        }\n        QMapDataBase::freeData((QMapDataBase *)referenceCounter);\n    } else if (*referenceCounter != -1) {\n        SYNC(0);\n        referenceCount = *referenceCounter;\n        *referenceCounter = referenceCount - 1;\n        SYNC(0);\n        if (referenceCount == 1) {\n            if (*(long long *)(referenceCounter + 4) != 0) {\n                FUN_00183cf8();\n                QMapDataBase::freeTree((QMapNodeBase *)referenceCounter, (int)*(undefined8 *)(referenceCounter + 4));\n            }\n            QMapDataBase::freeData((QMapDataBase *)referenceCounter);\n        }\n    }\n\n    if ((int)QMapDataBase::shared_null != 0) {\n        if ((int)QMapDataBase::shared_null == -1) {\n            goto cleanup;\n        }\n        SYNC(0);\n        referenceCount = (int)QMapDataBase::shared_null - 1;\n        SYNC(0);\n        isSharedNull = (int)QMapDataBase::shared_null != 1;\n        QMapDataBase::shared_null._0_4_ = referenceCount;\n        if (isSharedNull) {\n            goto cleanup;\n        }\n    }\n\n    if (__Init != 0) {\n        FUN_00183cf8();\n        QMapDataBase::freeTree((QMapNodeBase *)&QMapDataBase::shared_null, (int)__Init);\n    }\n    QMapDataBase::freeData((QMapDataBase *)&QMapDataBase::shared_null);\n\ncleanup:\n    beginChangeNotification(this);\n    dataChanged(this);\n    endChangeNotification(this);\n\n    if (stackGuard != ___stack_chk_guard) {\n        __stack_chk_fail();\n    }\n}",
        "baseline_code_stripped": "void __thiscall MyMoneyFile::attachStorage(MyMoneyFile *this,MyMoneyStorageMgr *param_1)\n{\n  bool bVar1;\n  int iVar2;\n  MyMoneyStorageMgr *pMVar3;\n  undefined8 *this_00;\n  MyMoneyStorageMgr *pMVar4;\n  MyMoneyStorageMgr **ppMVar5;\n  int *piVar6;\n  MyMoneySecurity aMStack_58 [8];\n  MyMoneyStorageMgr *local_50;\n  MyMoneyStorageMgr *local_40;\n  longlong local_38;\n  ppMVar5 = *(MyMoneyStorageMgr ***)(this + 0x10);\n  local_38 = ___stack_chk_guard;\n  if (*ppMVar5 != (MyMoneyStorageMgr *)0x0) {\n    this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n    std::runtime_error::runtime_error\n              ((runtime_error *)this_00,\n               \"Storage already attached /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:333\"\n              );\nLAB_001567dc:\n    *this_00 = &PTR_FUN_002a2ab0;\n    __cxa_throw(this_00,&MyMoneyException::typeinfo,FUN_0013f5a0);\n  }\n  if (param_1 == (MyMoneyStorageMgr *)0x0) {\n    this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n    std::runtime_error::runtime_error\n              ((runtime_error *)this_00,\n               \"Storage must not be 0 /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:336\"\n              );\n    goto LAB_001567dc;\n  }\n  *ppMVar5 = param_1;\n  MyMoneySecurity::MyMoneySecurity(aMStack_58);\n  pMVar4 = ppMVar5[3];\n  pMVar3 = ppMVar5[5];\n  ppMVar5[3] = local_50;\n  ppMVar5[5] = local_40;\n  local_50 = pMVar4;\n  local_40 = pMVar3;\n  MyMoneySecurity::_MyMoneySecurity(aMStack_58);\n  MyMoneyBalanceCache::clear((MyMoneyBalanceCache *)(*(longlong *)(this + 0x10) + 0x38));\n  piVar6 = *(int **)(*(longlong *)(this + 0x10) + 0x30);\n  *(undefined8 **)(*(longlong *)(this + 0x10) + 0x30) = &QMapDataBase::shared_null;\n  if (*piVar6 == 0) {\nLAB_00156728:\n    if (*(longlong *)(piVar6 + 4) != 0) {\n      FUN_00183cf8();\n      QMapDataBase::freeTree((QMapNodeBase *)piVar6,(int)*(undefined8 *)(piVar6 + 4));\n    }\n    QMapDataBase::freeData((QMapDataBase *)piVar6);\n  }\n  else if (*piVar6 != -1) {\n    SYNC(0);\n    iVar2 = *piVar6;\n    *piVar6 = iVar2 + -1;\n    SYNC(0);\n    if (iVar2 == 1) goto LAB_00156728;\n  }\n  if ((int)QMapDataBase::shared_null != 0) {\n    if ((int)QMapDataBase::shared_null == -1) goto LAB_001566dc;\n    SYNC(0);\n    iVar2 = (int)QMapDataBase::shared_null + -1;\n    SYNC(0);\n    bVar1 = (int)QMapDataBase::shared_null != 1;\n    QMapDataBase::shared_null._0_4_ = iVar2;\n    if (bVar1) goto LAB_001566dc;\n  }\n  if (__Init != 0) {\n    FUN_00183cf8();\n    QMapDataBase::freeTree((QMapNodeBase *)&QMapDataBase::shared_null,(int)__Init);\n  }\n  QMapDataBase::freeData((QMapDataBase *)&QMapDataBase::shared_null);\nLAB_001566dc:\n  beginChangeNotification(this);\n  dataChanged(this);\n  endChangeNotification(this);\n  if (local_38 != ___stack_chk_guard) {\n    __stack_chk_fail();\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.6056323051452637,
        "similarity_score_baseline_stripped": 0.5502229928970337
    },
    {
        "func_name": "mono_test_marshal_bool_ref_as_I1_U1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint mono_test_marshal_bool_ref_as_I1_U1(char *bTrue,char *bFalse)\n{\n  int iVar1;\n  if ((bTrue == (char *)0x0) || (bFalse == (char *)0x0)) {\n    iVar1 = 4;\n  }\n  else {\n    iVar1 = 5;\n    if ((*bTrue != '\\0') && (iVar1 = 6, *bFalse == '\\0')) {\n      *bFalse = '\\x01';\n      *bTrue = '\\0';\n      return 0;\n    }\n  }\n  return iVar1;\n}",
        "output": "```c\nint mono_test_marshal_bool_ref_as_I1_U1(char *bTrue, char *bFalse) {\n    int resultCode;\n\n    if (bTrue == NULL || bFalse == NULL) {\n        resultCode = 4;\n    } else {\n        resultCode = 5;\n\n        if (*bTrue != '\\0' && *bFalse == '\\0') {\n            *bFalse = '\\x01';\n            *bTrue = '\\0';\n            return 0;\n        }\n    }\n\n    return resultCode;\n}\n```",
        "normed_func_sha256": "883222a1f9789eb5ed2f3567257066381e091ed36407d9a1c3ccdee575d45922",
        "source_code": "STDCALL \nmono_test_marshal_bool_ref_as_I1_U1 (char* bTrue, char* bFalse)\n{\n\tif (!bTrue || !bFalse)\n                return 4;\n\tif (!(*bTrue))\n                return 5;\n        if (*bFalse)\n                return 6;\n\t*bFalse = 1;\n        *bTrue = 0;\n\treturn 0;\n}",
        "parsed_output": "int mono_test_marshal_bool_ref_as_I1_U1(char *bTrue, char *bFalse) {\n    int resultCode;\n\n    if (bTrue == NULL || bFalse == NULL) {\n        resultCode = 4;\n    } else {\n        resultCode = 5;\n\n        if (*bTrue != '\\0' && *bFalse == '\\0') {\n            *bFalse = '\\x01';\n            *bTrue = '\\0';\n            return 0;\n        }\n    }\n\n    return resultCode;\n}",
        "baseline_code_stripped": "int mono_test_marshal_bool_ref_as_I1_U1(char *bTrue,char *bFalse)\n{\n  int iVar1;\n  if ((bTrue == (char *)0x0) || (bFalse == (char *)0x0)) {\n    iVar1 = 4;\n  }\n  else {\n    iVar1 = 5;\n    if ((*bTrue != '\\0') && (iVar1 = 6, *bFalse == '\\0')) {\n      *bFalse = '\\x01';\n      *bTrue = '\\0';\n      return 0;\n    }\n  }\n  return iVar1;\n}",
        "similarity_score_unixcoder": 0.8678350448608398,
        "similarity_score_baseline_stripped": 0.8568769097328186
    },
    {
        "func_name": "RestoreBkpBlocks",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid RestoreBkpBlocks(int param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  int iVar2;\n  undefined4 extraout_ECX;\n  undefined4 *puVar3;\n  undefined4 *puVar4;\n  undefined4 *puVar5;\n  undefined8 uVar6;\n  undefined4 uVar7;\n  int local_48;\n  undefined4 local_3c [4];\n  undefined4 local_2c;\n  puVar3 = (undefined4 *)(*(ushort *)(param_1 + 0x1c) + 0x20 + param_1);\n  local_48 = 0;\n  do {\n    if ((8 >> ((byte)local_48 & 0x1f) & (uint)*(byte *)(param_1 + 0x1e)) != 0) {\n      puVar4 = puVar3;\n      puVar5 = local_3c;\n      for (iVar2 = 5; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n      }\n      iVar2 = XLogOpenRelation(1,*(undefined *)(param_1 + 0x1f),local_3c[2],local_3c[3]);\n      if (iVar2 != 0) {\n        uVar6 = XLogReadBuffer(1,iVar2,local_2c,extraout_ECX);\n        iVar2 = (int)((ulonglong)uVar6 >> 0x20);\n        iVar1 = (int)uVar6;\n        if (iVar1 < 0) {\n          if (SBORROW4(iVar1,-NLocBuffer) == iVar1 + NLocBuffer < 0) {\nLAB_0808f040:\n            if (iVar1 < 0) {\n              puVar4 = *(undefined4 **)(LocalBufferBlockPointers + -4 + iVar1 * -4);\n              iVar2 = LocalBufferBlockPointers;\n            }\n            else {\n              puVar4 = *(undefined4 **)(BufferBlockPointers + -4 + iVar1 * 4);\n            }\n            uVar7 = 0x2000;\n            memcpy(puVar4,puVar3 + 5,0x2000);\n            puVar4[1] = param_3;\n            *puVar4 = param_2;\n            puVar4[2] = ThisStartUpID;\n            LockBuffer(iVar1,0,uVar7,iVar2);\n            WriteBuffer(iVar1);\n          }\n        }\n        else if ((0 < iVar1) && (iVar1 <= NBuffers)) goto LAB_0808f040;\n      }\n      puVar3 = puVar3 + 0x805;\n    }\n    local_48 = local_48 + 1;\n    if (2 < local_48) {\n      return;\n    }\n  } while( true );\n}",
        "output": "```c\nvoid RestoreBkpBlocks(int param_1, undefined4 param_2, undefined4 param_3) {\n    int blockIndex;\n    int bufferIndex;\n    undefined4 extraOutput;\n    undefined4 *sourcePointer;\n    undefined4 *destinationPointer;\n    undefined4 *tempPointer;\n    undefined8 readBufferResult;\n    undefined4 bufferSize;\n    int localCounter;\n    undefined4 localData[4];\n    undefined4 localBuffer;\n\n    sourcePointer = (undefined4 *)(*(ushort *)(param_1 + 0x1c) + 0x20 + param_1);\n    localCounter = 0;\n\n    do {\n        if ((8 >> ((byte)localCounter & 0x1f) & (uint)*(byte *)(param_1 + 0x1e)) != 0) {\n            destinationPointer = localData;\n            tempPointer = sourcePointer;\n\n            for (bufferIndex = 5; bufferIndex != 0; bufferIndex--) {\n                *destinationPointer = *tempPointer;\n                tempPointer++;\n                destinationPointer++;\n            }\n\n            bufferIndex = XLogOpenRelation(1, *(undefined *)(param_1 + 0x1f), localData[2], localData[3]);\n            if (bufferIndex != 0) {\n                readBufferResult = XLogReadBuffer(1, bufferIndex, localBuffer, extraOutput);\n                bufferIndex = (int)((ulonglong)readBufferResult >> 0x20);\n                blockIndex = (int)readBufferResult;\n\n                if (blockIndex < 0) {\n                    if (SBORROW4(blockIndex, -NLocBuffer) == blockIndex + NLocBuffer < 0) {\n                        if (blockIndex < 0) {\n                            tempPointer = *(undefined4 **)(LocalBufferBlockPointers + -4 + blockIndex * -4);\n                            bufferIndex = LocalBufferBlockPointers;\n                        } else {\n                            tempPointer = *(undefined4 **)(BufferBlockPointers + -4 + blockIndex * 4);\n                        }\n                        bufferSize = 0x2000;\n                        memcpy(tempPointer, sourcePointer + 5, 0x2000);\n                        tempPointer[1] = param_3;\n                        *tempPointer = param_2;\n                        tempPointer[2] = ThisStartUpID;\n                        LockBuffer(blockIndex, 0, bufferSize, bufferIndex);\n                        WriteBuffer(blockIndex);\n                    }\n                } else if ((0 < blockIndex) && (blockIndex <= NBuffers)) {\n                    goto RestoreBuffer;\n                }\n            }\n            sourcePointer += 0x805;\n        }\n        localCounter++;\n        if (localCounter > 2) {\n            return;\n        }\n    } while (true);\n\nRestoreBuffer:\n    // Additional logic can be added here if needed\n}\n```",
        "normed_func_sha256": "a87ad1997447015e66b2f0e41db7eef191b7f77433afad4e4507aec39344d5a1",
        "source_code": "static void\nRestoreBkpBlocks(XLogRecord *record, XLogRecPtr lsn)\n{\n\tRelation\treln;\n\tBuffer\t\tbuffer;\n\tPage\t\tpage;\n\tBkpBlock\tbkpb;\n\tchar\t   *blk;\n\tint\t\t\ti;\n\n\tblk = (char *) XLogRecGetData(record) + record->xl_len;\n\tfor (i = 0; i < XLR_MAX_BKP_BLOCKS; i++)\n\t{\n\t\tif (!(record->xl_info & XLR_SET_BKP_BLOCK(i)))\n\t\t\tcontinue;\n\n\t\tmemcpy((char *) &bkpb, blk, sizeof(BkpBlock));\n\t\tblk += sizeof(BkpBlock);\n\n\t\treln = XLogOpenRelation(true, record->xl_rmid, bkpb.node);\n\n\t\tif (reln)\n\t\t{\n\t\t\tbuffer = XLogReadBuffer(true, reln, bkpb.block);\n\t\t\tif (BufferIsValid(buffer))\n\t\t\t{\n\t\t\t\tpage = (Page) BufferGetPage(buffer);\n\t\t\t\tmemcpy((char *) page, blk, BLCKSZ);\n\t\t\t\tPageSetLSN(page, lsn);\n\t\t\t\tPageSetSUI(page, ThisStartUpID);\n\t\t\t\tUnlockAndWriteBuffer(buffer);\n\t\t\t}\n\t\t}\n\n\t\tblk += BLCKSZ;\n\t}\n}",
        "parsed_output": "void RestoreBkpBlocks(int param_1, undefined4 param_2, undefined4 param_3) {\n    int blockIndex;\n    int bufferIndex;\n    undefined4 extraOutput;\n    undefined4 *sourcePointer;\n    undefined4 *destinationPointer;\n    undefined4 *tempPointer;\n    undefined8 readBufferResult;\n    undefined4 bufferSize;\n    int localCounter;\n    undefined4 localData[4];\n    undefined4 localBuffer;\n\n    sourcePointer = (undefined4 *)(*(ushort *)(param_1 + 0x1c) + 0x20 + param_1);\n    localCounter = 0;\n\n    do {\n        if ((8 >> ((byte)localCounter & 0x1f) & (uint)*(byte *)(param_1 + 0x1e)) != 0) {\n            destinationPointer = localData;\n            tempPointer = sourcePointer;\n\n            for (bufferIndex = 5; bufferIndex != 0; bufferIndex--) {\n                *destinationPointer = *tempPointer;\n                tempPointer++;\n                destinationPointer++;\n            }\n\n            bufferIndex = XLogOpenRelation(1, *(undefined *)(param_1 + 0x1f), localData[2], localData[3]);\n            if (bufferIndex != 0) {\n                readBufferResult = XLogReadBuffer(1, bufferIndex, localBuffer, extraOutput);\n                bufferIndex = (int)((ulonglong)readBufferResult >> 0x20);\n                blockIndex = (int)readBufferResult;\n\n                if (blockIndex < 0) {\n                    if (SBORROW4(blockIndex, -NLocBuffer) == blockIndex + NLocBuffer < 0) {\n                        if (blockIndex < 0) {\n                            tempPointer = *(undefined4 **)(LocalBufferBlockPointers + -4 + blockIndex * -4);\n                            bufferIndex = LocalBufferBlockPointers;\n                        } else {\n                            tempPointer = *(undefined4 **)(BufferBlockPointers + -4 + blockIndex * 4);\n                        }\n                        bufferSize = 0x2000;\n                        memcpy(tempPointer, sourcePointer + 5, 0x2000);\n                        tempPointer[1] = param_3;\n                        *tempPointer = param_2;\n                        tempPointer[2] = ThisStartUpID;\n                        LockBuffer(blockIndex, 0, bufferSize, bufferIndex);\n                        WriteBuffer(blockIndex);\n                    }\n                } else if ((0 < blockIndex) && (blockIndex <= NBuffers)) {\n                    goto RestoreBuffer;\n                }\n            }\n            sourcePointer += 0x805;\n        }\n        localCounter++;\n        if (localCounter > 2) {\n            return;\n        }\n    } while (true);\n\nRestoreBuffer:\n    // Additional logic can be added here if needed\n}",
        "baseline_code_stripped": "void RestoreBkpBlocks(int param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  int iVar2;\n  undefined4 extraout_ECX;\n  undefined4 *puVar3;\n  undefined4 *puVar4;\n  undefined4 *puVar5;\n  undefined8 uVar6;\n  undefined4 uVar7;\n  int local_48;\n  undefined4 local_3c [4];\n  undefined4 local_2c;\n  puVar3 = (undefined4 *)(*(ushort *)(param_1 + 0x1c) + 0x20 + param_1);\n  local_48 = 0;\n  do {\n    if ((8 >> ((byte)local_48 & 0x1f) & (uint)*(byte *)(param_1 + 0x1e)) != 0) {\n      puVar4 = puVar3;\n      puVar5 = local_3c;\n      for (iVar2 = 5; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n      }\n      iVar2 = XLogOpenRelation(1,*(undefined *)(param_1 + 0x1f),local_3c[2],local_3c[3]);\n      if (iVar2 != 0) {\n        uVar6 = XLogReadBuffer(1,iVar2,local_2c,extraout_ECX);\n        iVar2 = (int)((ulonglong)uVar6 >> 0x20);\n        iVar1 = (int)uVar6;\n        if (iVar1 < 0) {\n          if (SBORROW4(iVar1,-NLocBuffer) == iVar1 + NLocBuffer < 0) {\nLAB_0808f040:\n            if (iVar1 < 0) {\n              puVar4 = *(undefined4 **)(LocalBufferBlockPointers + -4 + iVar1 * -4);\n              iVar2 = LocalBufferBlockPointers;\n            }\n            else {\n              puVar4 = *(undefined4 **)(BufferBlockPointers + -4 + iVar1 * 4);\n            }\n            uVar7 = 0x2000;\n            memcpy(puVar4,puVar3 + 5,0x2000);\n            puVar4[1] = param_3;\n            *puVar4 = param_2;\n            puVar4[2] = ThisStartUpID;\n            LockBuffer(iVar1,0,uVar7,iVar2);\n            WriteBuffer(iVar1);\n          }\n        }\n        else if ((0 < iVar1) && (iVar1 <= NBuffers)) goto LAB_0808f040;\n      }\n      puVar3 = puVar3 + 0x805;\n    }\n    local_48 = local_48 + 1;\n    if (2 < local_48) {\n      return;\n    }\n  } while( true );\n}",
        "similarity_score_unixcoder": 0.6207327842712402,
        "similarity_score_baseline_stripped": 0.5974754691123962
    },
    {
        "func_name": "tenv::add",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4\nFUN_0032b670(undefined8 param_1,uint param_2,undefined4 param_3,long param_4,long param_5,\n            undefined8 param_6)\n{\n  long *plVar1;\n  long lVar2;\n  undefined4 uVar3;\n  long lVar4;\n  undefined8 uVar5;\n  long lVar6;\n  if (*(long *)(param_4 + 0x28) != 0) {\n    lVar2 = *(long *)(param_4 + 0x28);\n    lVar4 = param_4 + 0x20;\n    do {\n      while( true ) {\n        lVar6 = lVar2;\n        plVar1 = (long *)(lVar6 + 0x18);\n        if (param_2 <= *(uint *)(lVar6 + 0x20)) break;\n        lVar2 = *plVar1;\n        lVar6 = lVar4;\n        if (*plVar1 == 0) goto LAB_0032b6c0;\n      }\n      lVar2 = *(long *)(lVar6 + 0x10);\n      lVar4 = lVar6;\n    } while (*(long *)(lVar6 + 0x10) != 0);\nLAB_0032b6c0:\n    if (((param_4 + 0x20 != lVar6) && (*(uint *)(lVar6 + 0x20) <= param_2)) &&\n       (*(long *)(lVar6 + 0x28) != lVar6 + 0x28)) {\n      lVar2 = *(long *)(*(long *)(lVar6 + 0x28) + 0x10);\n      uVar3 = FUN_0039b900(lVar2,param_6);\n      if ((char)uVar3 == '\\0') {\n        return uVar3;\n      }\n      lVar4 = lVar2;\n      if (param_5 != 0) {\n        lVar4 = FUN_001b5be0(0x50);\n        FUN_0032b3d0(lVar4,lVar2,param_5);\n        uVar5 = *(undefined8 *)(lVar2 + 0x48);\n        *(undefined8 *)(lVar4 + 0x40) = *(undefined8 *)(lVar2 + 0x40);\n        uVar5 = FUN_0032b440(param_5,uVar5);\n        *(undefined8 *)(lVar4 + 0x48) = uVar5;\n      }\n      FUN_00243270(param_1,param_3,lVar4);\n      return uVar3;\n    }\n  }\n  return 0;\n}",
        "output": "```c\nundefined4 FUN_0032b670(undefined8 param_1, uint param_2, undefined4 param_3, long param_4, long param_5, undefined8 param_6) {\n    long *nextNode;\n    long currentNode;\n    undefined4 result;\n    long parentNode;\n    undefined8 processedValue;\n    long childNode;\n\n    if (*(long *)(param_4 + 0x28) != 0) {\n        currentNode = *(long *)(param_4 + 0x28);\n        parentNode = param_4 + 0x20;\n\n        do {\n            while (true) {\n                childNode = currentNode;\n                nextNode = (long *)(childNode + 0x18);\n                if (param_2 <= *(uint *)(childNode + 0x20)) break;\n                currentNode = *nextNode;\n                childNode = parentNode;\n                if (*nextNode == 0) goto exit_loop;\n            }\n            currentNode = *(long *)(childNode + 0x10);\n            parentNode = childNode;\n        } while (*(long *)(childNode + 0x10) != 0);\n    }\n\nexit_loop:\n    if ((param_4 + 0x20 != childNode) && (*(uint *)(childNode + 0x20) <= param_2) && (*(long *)(childNode + 0x28) != childNode + 0x28)) {\n        currentNode = *(long *)(*(long *)(childNode + 0x28) + 0x10);\n        result = FUN_0039b900(currentNode, param_6);\n        \n        if ((char)result == '\\0') {\n            return result;\n        }\n\n        parentNode = currentNode;\n        if (param_5 != 0) {\n            parentNode = FUN_001b5be0(0x50);\n            FUN_0032b3d0(parentNode, currentNode, param_5);\n            processedValue = *(undefined8 *)(currentNode + 0x48);\n            *(undefined8 *)(parentNode + 0x40) = *(undefined8 *)(currentNode + 0x40);\n            processedValue = FUN_0032b440(param_5, processedValue);\n            *(undefined8 *)(parentNode + 0x48) = processedValue;\n        }\n        FUN_00243270(param_1, param_3, parentNode);\n        return result;\n    }\n    \n    return 0;\n}\n```",
        "normed_func_sha256": "f3316ab41fcff0990e9d596ed2de03eb54144e5bce5a58a53246af7334050345",
        "source_code": "bool tenv::add(symbol src, symbol dest,\n               tenv& source, varEntry *qualifier, coder &c) {\n  names_t::iterator p = source.names.find(src);\n  if (p != source.names.end())\n    return add(dest, *p, qualifier, c);\n  else\n    return false;\n}",
        "parsed_output": "undefined4 FUN_0032b670(undefined8 param_1, uint param_2, undefined4 param_3, long param_4, long param_5, undefined8 param_6) {\n    long *nextNode;\n    long currentNode;\n    undefined4 result;\n    long parentNode;\n    undefined8 processedValue;\n    long childNode;\n\n    if (*(long *)(param_4 + 0x28) != 0) {\n        currentNode = *(long *)(param_4 + 0x28);\n        parentNode = param_4 + 0x20;\n\n        do {\n            while (true) {\n                childNode = currentNode;\n                nextNode = (long *)(childNode + 0x18);\n                if (param_2 <= *(uint *)(childNode + 0x20)) break;\n                currentNode = *nextNode;\n                childNode = parentNode;\n                if (*nextNode == 0) goto exit_loop;\n            }\n            currentNode = *(long *)(childNode + 0x10);\n            parentNode = childNode;\n        } while (*(long *)(childNode + 0x10) != 0);\n    }\n\nexit_loop:\n    if ((param_4 + 0x20 != childNode) && (*(uint *)(childNode + 0x20) <= param_2) && (*(long *)(childNode + 0x28) != childNode + 0x28)) {\n        currentNode = *(long *)(*(long *)(childNode + 0x28) + 0x10);\n        result = FUN_0039b900(currentNode, param_6);\n        \n        if ((char)result == '\\0') {\n            return result;\n        }\n\n        parentNode = currentNode;\n        if (param_5 != 0) {\n            parentNode = FUN_001b5be0(0x50);\n            FUN_0032b3d0(parentNode, currentNode, param_5);\n            processedValue = *(undefined8 *)(currentNode + 0x48);\n            *(undefined8 *)(parentNode + 0x40) = *(undefined8 *)(currentNode + 0x40);\n            processedValue = FUN_0032b440(param_5, processedValue);\n            *(undefined8 *)(parentNode + 0x48) = processedValue;\n        }\n        FUN_00243270(param_1, param_3, parentNode);\n        return result;\n    }\n    \n    return 0;\n}",
        "baseline_code_stripped": "undefined4\nFUN_0032b670(undefined8 param_1,uint param_2,undefined4 param_3,long param_4,long param_5,\n            undefined8 param_6)\n{\n  long *plVar1;\n  long lVar2;\n  undefined4 uVar3;\n  long lVar4;\n  undefined8 uVar5;\n  long lVar6;\n  if (*(long *)(param_4 + 0x28) != 0) {\n    lVar2 = *(long *)(param_4 + 0x28);\n    lVar4 = param_4 + 0x20;\n    do {\n      while( true ) {\n        lVar6 = lVar2;\n        plVar1 = (long *)(lVar6 + 0x18);\n        if (param_2 <= *(uint *)(lVar6 + 0x20)) break;\n        lVar2 = *plVar1;\n        lVar6 = lVar4;\n        if (*plVar1 == 0) goto LAB_0032b6c0;\n      }\n      lVar2 = *(long *)(lVar6 + 0x10);\n      lVar4 = lVar6;\n    } while (*(long *)(lVar6 + 0x10) != 0);\nLAB_0032b6c0:\n    if (((param_4 + 0x20 != lVar6) && (*(uint *)(lVar6 + 0x20) <= param_2)) &&\n       (*(long *)(lVar6 + 0x28) != lVar6 + 0x28)) {\n      lVar2 = *(long *)(*(long *)(lVar6 + 0x28) + 0x10);\n      uVar3 = FUN_0039b900(lVar2,param_6);\n      if ((char)uVar3 == '\\0') {\n        return uVar3;\n      }\n      lVar4 = lVar2;\n      if (param_5 != 0) {\n        lVar4 = FUN_001b5be0(0x50);\n        FUN_0032b3d0(lVar4,lVar2,param_5);\n        uVar5 = *(undefined8 *)(lVar2 + 0x48);\n        *(undefined8 *)(lVar4 + 0x40) = *(undefined8 *)(lVar2 + 0x40);\n        uVar5 = FUN_0032b440(param_5,uVar5);\n        *(undefined8 *)(lVar4 + 0x48) = uVar5;\n      }\n      FUN_00243270(param_1,param_3,lVar4);\n      return uVar3;\n    }\n  }\n  return 0;\n}",
        "similarity_score_unixcoder": 0.4511071443557739,
        "similarity_score_baseline_stripped": 0.43949276208877563
    },
    {
        "func_name": "PitchPreset::write",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall PitchPreset::write(PitchPreset *this,PresetType param_1,basic_ptree *param_2)\n{\n  code *pcVar1;\n  long *local_28 [2];\n  long local_18 [2];\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  pcVar1 = *(code **)(*(long *)this + 0x20);\n  local_28[0] = local_18;\n  if (param_1 == 1) {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"output\",0x29a93e);\n    (*pcVar1)(this,param_2,local_28,this + 0x10);\n  }\n  else {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"input\",0x29a945);\n    (*pcVar1)(this,param_2,local_28,this + 8);\n  }\n  if (local_28[0] != local_18) {\n    operator_delete(local_28[0],local_18[0] + 1);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nvoid PitchPreset::write(PitchPreset *this, PresetType presetType, basic_ptree *paramTree) {\n    code *functionPointer;\n    long *allocatedMemory[2];\n    long localMemory[2];\n    long stackGuard = ___stack_chk_guard;\n\n    functionPointer = *(code **)(*(long *)this + 0x20);\n    allocatedMemory[0] = localMemory;\n\n    if (presetType == 1) {\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::\n        _M_construct_char_const__((char *)allocatedMemory, \"output\", 0x29a93e);\n        (*functionPointer)(this, paramTree, allocatedMemory, this + 0x10);\n    } else {\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::\n        _M_construct_char_const__((char *)allocatedMemory, \"input\", 0x29a945);\n        (*functionPointer)(this, paramTree, allocatedMemory, this + 8);\n    }\n\n    if (allocatedMemory[0] != localMemory) {\n        operator_delete(allocatedMemory[0], localMemory[0] + 1);\n    }\n\n    if (stackGuard == ___stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}\n```",
        "normed_func_sha256": "a93c4aeae8a726e70df61e9a3cf7185a80af0769cafb0c375a5bf6680280a660",
        "source_code": "void PitchPreset::write(PresetType preset_type, boost::property_tree::ptree& root) {\n  if (preset_type == PresetType::output) {\n    save(root, \"output\", output_settings);\n  } else {\n    save(root, \"input\", input_settings);\n  }\n}",
        "parsed_output": "void PitchPreset::write(PitchPreset *this, PresetType presetType, basic_ptree *paramTree) {\n    code *functionPointer;\n    long *allocatedMemory[2];\n    long localMemory[2];\n    long stackGuard = ___stack_chk_guard;\n\n    functionPointer = *(code **)(*(long *)this + 0x20);\n    allocatedMemory[0] = localMemory;\n\n    if (presetType == 1) {\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::\n        _M_construct_char_const__((char *)allocatedMemory, \"output\", 0x29a93e);\n        (*functionPointer)(this, paramTree, allocatedMemory, this + 0x10);\n    } else {\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::\n        _M_construct_char_const__((char *)allocatedMemory, \"input\", 0x29a945);\n        (*functionPointer)(this, paramTree, allocatedMemory, this + 8);\n    }\n\n    if (allocatedMemory[0] != localMemory) {\n        operator_delete(allocatedMemory[0], localMemory[0] + 1);\n    }\n\n    if (stackGuard == ___stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "void __thiscall PitchPreset::write(PitchPreset *this,PresetType param_1,basic_ptree *param_2)\n{\n  code *pcVar1;\n  long *local_28 [2];\n  long local_18 [2];\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  pcVar1 = *(code **)(*(long *)this + 0x20);\n  local_28[0] = local_18;\n  if (param_1 == 1) {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"output\",0x29a93e);\n    (*pcVar1)(this,param_2,local_28,this + 0x10);\n  }\n  else {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"input\",0x29a945);\n    (*pcVar1)(this,param_2,local_28,this + 8);\n  }\n  if (local_28[0] != local_18) {\n    operator_delete(local_28[0],local_18[0] + 1);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.6506672501564026,
        "similarity_score_baseline_stripped": 0.595273494720459
    },
    {
        "func_name": "meth_wxRichTextBuffer_ClearStyleStack",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined * FUN_001e1f20(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  long local_40 [2];\n  undefined8 local_30;\n  long *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  local_40[0] = param_1;\n  if ((param_1 == 0) ||\n     (iVar1 = (**(code **)(sipAPI__richtext + 0x3a8))(param_1,param_2,0), iVar1 != 0)) {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) goto LAB_001e2014;\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    wxRichTextBuffer::ClearStyleStack();\n  }\n  else {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) {\nLAB_001e2014:\n      (**(code **)(sipAPI__richtext + 0x2a0))(local_30,\"RichTextBuffer\",\"ClearStyleStack\",0);\n      puVar4 = (undefined *)0x0;\n      goto LAB_001e203c;\n    }\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    (**(code **)(*local_28 + 0x458))();\n  }\n  PyEval_RestoreThread(uVar2);\n  lVar3 = PyErr_Occurred();\n  puVar4 = (undefined *)0x0;\n  if (lVar3 == 0) {\n    puVar4 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\nLAB_001e203c:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return puVar4;\n}",
        "output": "```c\nundefined * ClearRichTextBuffer(long param_1, undefined8 param_2) {\n    int result;\n    undefined8 threadState;\n    long errorOccurred;\n    undefined *returnValue = (undefined *)0x0;\n    long stackCheckValue;\n    long localParams[2];\n    undefined8 localBuffer;\n    long *localRichTextBuffer;\n    \n    stackCheckValue = *(long *)(in_FS_OFFSET + 0x28);\n    localBuffer = 0;\n    localParams[0] = param_1;\n\n    if (param_1 == 0 || (result = (*(code **)(sipAPI__richtext + 0x3a8))(param_1, param_2, 0), result != 0)) {\n        result = (*(code **)(sipAPI__richtext + 0x280))(&localBuffer, param_2, &DAT_002f29ba, localParams,\n                                                         PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550, &localRichTextBuffer);\n        if (result == 0) {\n            goto HandleError;\n        }\n        PyErr_Clear();\n        threadState = PyEval_SaveThread();\n        wxRichTextBuffer::ClearStyleStack();\n    } else {\n        result = (*(code **)(sipAPI__richtext + 0x280))(&localBuffer, param_2, &DAT_002f29ba, localParams,\n                                                         PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550, &localRichTextBuffer);\n        if (result == 0) {\nHandleError:\n            (*(code **)(sipAPI__richtext + 0x2a0))(localBuffer, \"RichTextBuffer\", \"ClearStyleStack\", 0);\n            return returnValue;\n        }\n        PyErr_Clear();\n        threadState = PyEval_SaveThread();\n        (*(code **)(*localRichTextBuffer + 0x458))();\n    }\n\n    PyEval_RestoreThread(threadState);\n    errorOccurred = PyErr_Occurred();\n    \n    if (errorOccurred == 0) {\n        returnValue = &_Py_NoneStruct;\n        __Py_NoneStruct = __Py_NoneStruct + 1;\n    }\n\n    if (stackCheckValue != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n    \n    return returnValue;\n}\n```",
        "normed_func_sha256": "a840ac8c9b53f94fde4a54c9b47e2c197818531eb2b738acb1f4b3db4ca79508",
        "source_code": "static PyObject *meth_wxRichTextBuffer_ClearStyleStack(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));\n\n    {\n         ::wxRichTextBuffer *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_wxRichTextBuffer, &sipCpp))\n        {\n            PyErr_Clear();\n\n            Py_BEGIN_ALLOW_THREADS\n            (sipSelfWasArg ? sipCpp-> ::wxRichTextBuffer::ClearStyleStack() : sipCpp->ClearStyleStack());\n            Py_END_ALLOW_THREADS\n\n            if (PyErr_Occurred())\n                return 0;\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    sipNoMethod(sipParseErr, sipName_RichTextBuffer, sipName_ClearStyleStack, SIP_NULLPTR);\n\n    return SIP_NULLPTR;\n}",
        "parsed_output": "undefined * ClearRichTextBuffer(long param_1, undefined8 param_2) {\n    int result;\n    undefined8 threadState;\n    long errorOccurred;\n    undefined *returnValue = (undefined *)0x0;\n    long stackCheckValue;\n    long localParams[2];\n    undefined8 localBuffer;\n    long *localRichTextBuffer;\n    \n    stackCheckValue = *(long *)(in_FS_OFFSET + 0x28);\n    localBuffer = 0;\n    localParams[0] = param_1;\n\n    if (param_1 == 0 || (result = (*(code **)(sipAPI__richtext + 0x3a8))(param_1, param_2, 0), result != 0)) {\n        result = (*(code **)(sipAPI__richtext + 0x280))(&localBuffer, param_2, &DAT_002f29ba, localParams,\n                                                         PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550, &localRichTextBuffer);\n        if (result == 0) {\n            goto HandleError;\n        }\n        PyErr_Clear();\n        threadState = PyEval_SaveThread();\n        wxRichTextBuffer::ClearStyleStack();\n    } else {\n        result = (*(code **)(sipAPI__richtext + 0x280))(&localBuffer, param_2, &DAT_002f29ba, localParams,\n                                                         PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550, &localRichTextBuffer);\n        if (result == 0) {\nHandleError:\n            (*(code **)(sipAPI__richtext + 0x2a0))(localBuffer, \"RichTextBuffer\", \"ClearStyleStack\", 0);\n            return returnValue;\n        }\n        PyErr_Clear();\n        threadState = PyEval_SaveThread();\n        (*(code **)(*localRichTextBuffer + 0x458))();\n    }\n\n    PyEval_RestoreThread(threadState);\n    errorOccurred = PyErr_Occurred();\n    \n    if (errorOccurred == 0) {\n        returnValue = &_Py_NoneStruct;\n        __Py_NoneStruct = __Py_NoneStruct + 1;\n    }\n\n    if (stackCheckValue != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n    \n    return returnValue;\n}",
        "baseline_code_stripped": "undefined * FUN_001e1f20(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  long local_40 [2];\n  undefined8 local_30;\n  long *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  local_40[0] = param_1;\n  if ((param_1 == 0) ||\n     (iVar1 = (**(code **)(sipAPI__richtext + 0x3a8))(param_1,param_2,0), iVar1 != 0)) {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) goto LAB_001e2014;\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    wxRichTextBuffer::ClearStyleStack();\n  }\n  else {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) {\nLAB_001e2014:\n      (**(code **)(sipAPI__richtext + 0x2a0))(local_30,\"RichTextBuffer\",\"ClearStyleStack\",0);\n      puVar4 = (undefined *)0x0;\n      goto LAB_001e203c;\n    }\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    (**(code **)(*local_28 + 0x458))();\n  }\n  PyEval_RestoreThread(uVar2);\n  lVar3 = PyErr_Occurred();\n  puVar4 = (undefined *)0x0;\n  if (lVar3 == 0) {\n    puVar4 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\nLAB_001e203c:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return puVar4;\n}",
        "similarity_score_unixcoder": 0.6860706210136414,
        "similarity_score_baseline_stripped": 0.6001149415969849
    },
    {
        "func_name": "message_new_empty",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_00172170(long param_1,undefined8 *param_2)\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  undefined8 uVar3;\n  if (param_2 != (undefined8 *)0x0) {\n    puVar2 = (undefined4 *)calloc(1,0x430);\n    if (puVar2 == (undefined4 *)0x0) {\n      uVar3 = 0xfffffff4;\n    }\n    else {\n      uVar1 = *(undefined4 *)(param_1 + 0x18);\n      *(byte *)(puVar2 + 0x109) = *(byte *)(puVar2 + 0x109) & 0xfe;\n      *puVar2 = 1;\n      puVar2[4] = uVar1;\n      *param_2 = puVar2;\n      uVar3 = 0;\n    }\n    return uVar3;\n  }\n  FUN_00148060(0,&DAT_001bfb62,\"../src/libsystemd/sd-netlink/netlink-message.c\",0x1b,\n               \"message_new_empty\");\n  return 0xffffffea;\n}",
        "output": "```c\n#include <stdlib.h>\n\nundefined8 create_empty_message(long param_1, undefined8 *param_2) {\n    undefined4 message_type;\n    undefined4 *message_buffer;\n    undefined8 return_value;\n\n    if (param_2 != NULL) {\n        message_buffer = (undefined4 *)calloc(1, 0x430);\n        if (message_buffer == NULL) {\n            return_value = 0xfffffff4; // Memory allocation failed\n        } else {\n            message_type = *(undefined4 *)(param_1 + 0x18);\n            *(byte *)(message_buffer + 0x109) &= 0xfe; // Clear a specific bit\n            *message_buffer = 1; // Set initial message state\n            message_buffer[4] = message_type; // Set message type\n            *param_2 = message_buffer; // Return the message buffer\n            return_value = 0; // Success\n        }\n        return return_value;\n    }\n\n    log_error(0, &DAT_001bfb62, \"../src/libsystemd/sd-netlink/netlink-message.c\", 0x1b, \"message_new_empty\");\n    return 0xffffffea; // Error code for null parameter\n}\n```",
        "normed_func_sha256": "0be0f08bab1e2ad99d5ddfb69ba8a99572936aceb896597fa4c99c45b642a592",
        "source_code": "int message_new_empty(sd_netlink *rtnl, sd_netlink_message **ret) {\n        sd_netlink_message *m;\n        assert_return(ret, -EINVAL);\n        m = new0(sd_netlink_message, 1);\n        if (!m)\n                return -ENOMEM;\n        m->n_ref = 1;\n        m->protocol = rtnl->protocol;\n        m->sealed = false;\n        *ret = m;\n        return 0;\n}",
        "parsed_output": "#include <stdlib.h>\n\nundefined8 create_empty_message(long param_1, undefined8 *param_2) {\n    undefined4 message_type;\n    undefined4 *message_buffer;\n    undefined8 return_value;\n\n    if (param_2 != NULL) {\n        message_buffer = (undefined4 *)calloc(1, 0x430);\n        if (message_buffer == NULL) {\n            return_value = 0xfffffff4; // Memory allocation failed\n        } else {\n            message_type = *(undefined4 *)(param_1 + 0x18);\n            *(byte *)(message_buffer + 0x109) &= 0xfe; // Clear a specific bit\n            *message_buffer = 1; // Set initial message state\n            message_buffer[4] = message_type; // Set message type\n            *param_2 = message_buffer; // Return the message buffer\n            return_value = 0; // Success\n        }\n        return return_value;\n    }\n\n    log_error(0, &DAT_001bfb62, \"../src/libsystemd/sd-netlink/netlink-message.c\", 0x1b, \"message_new_empty\");\n    return 0xffffffea; // Error code for null parameter\n}",
        "baseline_code_stripped": "undefined8 FUN_00172170(long param_1,undefined8 *param_2)\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  undefined8 uVar3;\n  if (param_2 != (undefined8 *)0x0) {\n    puVar2 = (undefined4 *)calloc(1,0x430);\n    if (puVar2 == (undefined4 *)0x0) {\n      uVar3 = 0xfffffff4;\n    }\n    else {\n      uVar1 = *(undefined4 *)(param_1 + 0x18);\n      *(byte *)(puVar2 + 0x109) = *(byte *)(puVar2 + 0x109) & 0xfe;\n      *puVar2 = 1;\n      puVar2[4] = uVar1;\n      *param_2 = puVar2;\n      uVar3 = 0;\n    }\n    return uVar3;\n  }\n  FUN_00148060(0,&DAT_001bfb62,\"../src/libsystemd/sd-netlink/netlink-message.c\",0x1b,\n               \"message_new_empty\");\n  return 0xffffffea;\n}",
        "similarity_score_unixcoder": 0.6326839327812195,
        "similarity_score_baseline_stripped": 0.5321404933929443
    },
    {
        "func_name": "send_CharSet",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00186aab(undefined8 param_1,long param_2)\n{\n  byte bVar1;\n  undefined *local_10;\n  local_10 = (undefined *)0x0;\n  bVar1 = *(byte *)(param_2 + 2) >> 4;\n  if (bVar1 == 3) {\n    local_10 = &DAT_001cffac;\n  }\n  else if (bVar1 < 4) {\n    if (bVar1 == 2) {\n      local_10 = &DAT_001cffa8;\n    }\n    else if (bVar1 < 3) {\n      if (bVar1 == 0) {\n        local_10 = &DAT_001cffa0;\n      }\n      else if (bVar1 == 1) {\n        local_10 = &DAT_001cffa4;\n      }\n    }\n  }\n  if (local_10 != (undefined *)0x0) {\n    FUN_00186fdd(param_1,local_10);\n  }\n  return;\n}",
        "output": "```c\nvoid processData(undefined8 param_1, long param_2) {\n    byte value;\n    undefined *dataPointer = NULL;\n\n    value = *(byte *)(param_2 + 2) >> 4;\n\n    switch (value) {\n        case 3:\n            dataPointer = &DAT_001cffac;\n            break;\n        case 2:\n            dataPointer = &DAT_001cffa8;\n            break;\n        case 1:\n            dataPointer = &DAT_001cffa4;\n            break;\n        case 0:\n            dataPointer = &DAT_001cffa0;\n            break;\n        default:\n            break;\n    }\n\n    if (dataPointer != NULL) {\n        FUN_00186fdd(param_1, dataPointer);\n    }\n}\n```",
        "normed_func_sha256": "f2b2d298b3cf7e51637cf5484e6481f38c14bce7a51afba8d2e58f36203a60e0",
        "source_code": "static void\nsend_CharSet(XtermWidget xw, LineData *ld)\n{\n#if OPT_DEC_CHRSET\n    const char *msg = 0;\n\n    switch (GetLineDblCS(ld)) {\n    case CSET_SWL:\n\tmsg = \"\\033#5\";\n\tbreak;\n    case CSET_DHL_TOP:\n\tmsg = \"\\033#3\";\n\tbreak;\n    case CSET_DHL_BOT:\n\tmsg = \"\\033#4\";\n\tbreak;\n    case CSET_DWL:\n\tmsg = \"\\033#6\";\n\tbreak;\n    }\n    if (msg != 0)\n\tstringToPrinter(xw, msg);\n#else\n    (void) xw;\n    (void) ld;\n#endif /* OPT_DEC_CHRSET */\n}",
        "parsed_output": "void processData(undefined8 param_1, long param_2) {\n    byte value;\n    undefined *dataPointer = NULL;\n\n    value = *(byte *)(param_2 + 2) >> 4;\n\n    switch (value) {\n        case 3:\n            dataPointer = &DAT_001cffac;\n            break;\n        case 2:\n            dataPointer = &DAT_001cffa8;\n            break;\n        case 1:\n            dataPointer = &DAT_001cffa4;\n            break;\n        case 0:\n            dataPointer = &DAT_001cffa0;\n            break;\n        default:\n            break;\n    }\n\n    if (dataPointer != NULL) {\n        FUN_00186fdd(param_1, dataPointer);\n    }\n}",
        "baseline_code_stripped": "void FUN_00186aab(undefined8 param_1,long param_2)\n{\n  byte bVar1;\n  undefined *local_10;\n  local_10 = (undefined *)0x0;\n  bVar1 = *(byte *)(param_2 + 2) >> 4;\n  if (bVar1 == 3) {\n    local_10 = &DAT_001cffac;\n  }\n  else if (bVar1 < 4) {\n    if (bVar1 == 2) {\n      local_10 = &DAT_001cffa8;\n    }\n    else if (bVar1 < 3) {\n      if (bVar1 == 0) {\n        local_10 = &DAT_001cffa0;\n      }\n      else if (bVar1 == 1) {\n        local_10 = &DAT_001cffa4;\n      }\n    }\n  }\n  if (local_10 != (undefined *)0x0) {\n    FUN_00186fdd(param_1,local_10);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.5087401270866394,
        "similarity_score_baseline_stripped": 0.494633287191391
    },
    {
        "func_name": "meth_QQuickItem_grabToImage",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0018aef0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  undefined8 local_38 [2];\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 *local_18;\n  QSize *pQStack_10;\n  long local_8;\n  local_18 = &local_20;\n  local_28 = 0;\n  local_20 = 0xffffffffffffffff;\n  local_8 = ___stack_chk_guard;\n  local_38[0] = param_1;\n  iVar1 = (**(code **)(DAT_00273618 + 0x370))\n                    (&local_28,param_2,param_3,&PTR_s_targetSize_002626c0,0,&DAT_001f6098,local_38,\n                     PTR_DAT_00272258,&pQStack_10,PTR_s_QSize_00272728,&local_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_00273618 + 0x2a0))\n              (local_28,\"QQuickItem\",\"grabToImage\",s_grabToImage_self__targetSize__QS_00261ed8);\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = PyEval_SaveThread();\n    puVar3 = (undefined8 *)operator_new(0x10);\n    QQuickItem::grabToImage(pQStack_10);\n    PyEval_RestoreThread(uVar2);\n    uVar2 = (**(code **)(DAT_00273618 + 0x90))(*puVar3,PTR_DAT_00272290,0);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(uVar2);\n}",
        "output": "```c\nvoid grabToImageWithParams(undefined8 param1, undefined8 param2, undefined8 param3) {\n    int result;\n    undefined8 returnValue;\n    undefined8 *allocatedMemory;\n    undefined8 localParams[2];\n    undefined8 targetSize;\n    undefined8 imageHandle;\n    undefined8 *imagePointer;\n    QSize *sizeStack;\n    long stackGuard;\n    \n    imagePointer = &imageHandle;\n    targetSize = 0;\n    imageHandle = 0xffffffffffffffff;\n    stackGuard = ___stack_chk_guard;\n    localParams[0] = param1;\n\n    result = (**(code **)(DAT_00273618 + 0x370))(\n        &targetSize,\n        param2,\n        param3,\n        &PTR_s_targetSize_002626c0,\n        0,\n        &DAT_001f6098,\n        localParams,\n        PTR_DAT_00272258,\n        &sizeStack,\n        PTR_s_QSize_00272728,\n        &imagePointer\n    );\n\n    if (result == 0) {\n        (**(code **)(DAT_00273618 + 0x2a0))(targetSize, \"QQuickItem\", \"grabToImage\", s_grabToImage_self__targetSize__QS_00261ed8);\n        returnValue = 0;\n    } else {\n        returnValue = PyEval_SaveThread();\n        allocatedMemory = (undefined8 *)operator_new(0x10);\n        QQuickItem::grabToImage(sizeStack);\n        PyEval_RestoreThread(returnValue);\n        returnValue = (**(code **)(DAT_00273618 + 0x90))(*allocatedMemory, PTR_DAT_00272290, 0);\n    }\n\n    if (stackGuard == ___stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail(returnValue);\n}\n```",
        "normed_func_sha256": "415a100168782cf8af63c903dee54b2c1005845202e4086a5dc13ab1ea1d8c36",
        "source_code": "static PyObject *meth_QQuickItem_grabToImage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        const  ::QSize& a0def = QSize();\n        const  ::QSize* a0 = &a0def;\n         ::QQuickItem *sipCpp;\n\n        static const char *sipKwdList[] = {\n            sipName_targetSize,\n        };\n\n        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, \"B|J9\", &sipSelf, sipType_QQuickItem, &sipCpp, sipType_QSize, &a0))\n        {\n             ::QQuickItemGrabResult*sipRes = 0;\n\n#line 282 \"/builddir/build/BUILD/PyQt5_gpl-5.11.3/aarch64-redhat-linux-gnu/sip/QtQuick/qquickitem.sip\"\n        QSharedPointer<QQuickItemGrabResult> *grab;\n        \n        Py_BEGIN_ALLOW_THREADS\n        // This will leak but there seems to be no way to detach the object.\n        grab = new QSharedPointer<QQuickItemGrabResult>(sipCpp->grabToImage(*a0));\n        Py_END_ALLOW_THREADS\n        \n        sipRes = grab->data();\n#line 4464 \"/builddir/build/BUILD/PyQt5_gpl-5.11.3/aarch64-redhat-linux-gnu/QtQuick/sipQtQuickQQuickItem.cpp\"\n\n            return sipConvertFromNewType(sipRes,sipType_QQuickItemGrabResult,NULL);\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QQuickItem, sipName_grabToImage, doc_QQuickItem_grabToImage);\n\n    return NULL;\n}",
        "parsed_output": "void grabToImageWithParams(undefined8 param1, undefined8 param2, undefined8 param3) {\n    int result;\n    undefined8 returnValue;\n    undefined8 *allocatedMemory;\n    undefined8 localParams[2];\n    undefined8 targetSize;\n    undefined8 imageHandle;\n    undefined8 *imagePointer;\n    QSize *sizeStack;\n    long stackGuard;\n    \n    imagePointer = &imageHandle;\n    targetSize = 0;\n    imageHandle = 0xffffffffffffffff;\n    stackGuard = ___stack_chk_guard;\n    localParams[0] = param1;\n\n    result = (**(code **)(DAT_00273618 + 0x370))(\n        &targetSize,\n        param2,\n        param3,\n        &PTR_s_targetSize_002626c0,\n        0,\n        &DAT_001f6098,\n        localParams,\n        PTR_DAT_00272258,\n        &sizeStack,\n        PTR_s_QSize_00272728,\n        &imagePointer\n    );\n\n    if (result == 0) {\n        (**(code **)(DAT_00273618 + 0x2a0))(targetSize, \"QQuickItem\", \"grabToImage\", s_grabToImage_self__targetSize__QS_00261ed8);\n        returnValue = 0;\n    } else {\n        returnValue = PyEval_SaveThread();\n        allocatedMemory = (undefined8 *)operator_new(0x10);\n        QQuickItem::grabToImage(sizeStack);\n        PyEval_RestoreThread(returnValue);\n        returnValue = (**(code **)(DAT_00273618 + 0x90))(*allocatedMemory, PTR_DAT_00272290, 0);\n    }\n\n    if (stackGuard == ___stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail(returnValue);\n}",
        "baseline_code_stripped": "void FUN_0018aef0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  undefined8 local_38 [2];\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 *local_18;\n  QSize *pQStack_10;\n  long local_8;\n  local_18 = &local_20;\n  local_28 = 0;\n  local_20 = 0xffffffffffffffff;\n  local_8 = ___stack_chk_guard;\n  local_38[0] = param_1;\n  iVar1 = (**(code **)(DAT_00273618 + 0x370))\n                    (&local_28,param_2,param_3,&PTR_s_targetSize_002626c0,0,&DAT_001f6098,local_38,\n                     PTR_DAT_00272258,&pQStack_10,PTR_s_QSize_00272728,&local_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_00273618 + 0x2a0))\n              (local_28,\"QQuickItem\",\"grabToImage\",s_grabToImage_self__targetSize__QS_00261ed8);\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = PyEval_SaveThread();\n    puVar3 = (undefined8 *)operator_new(0x10);\n    QQuickItem::grabToImage(pQStack_10);\n    PyEval_RestoreThread(uVar2);\n    uVar2 = (**(code **)(DAT_00273618 + 0x90))(*puVar3,PTR_DAT_00272290,0);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(uVar2);\n}",
        "similarity_score_unixcoder": 0.6786922216415405,
        "similarity_score_baseline_stripped": 0.632226288318634
    },
    {
        "func_name": "game_hub_data_compat_tool_real_run_data_free",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid game_hub_data_compat_tool_real_run_data_free(int param_1)\n{\n  if (*(int *)(param_1 + 0x14) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x14));\n    *(undefined4 *)(param_1 + 0x14) = 0;\n  }\n  if (*(int *)(param_1 + 0x10) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x10));\n    *(undefined4 *)(param_1 + 0x10) = 0;\n  }\n  g_slice_free1(0x18,param_1);\n  return;\n}",
        "output": "```c\nvoid free_game_hub_data(int data_pointer)\n{\n    int *first_object = (int *)(data_pointer + 0x14);\n    int *second_object = (int *)(data_pointer + 0x10);\n\n    if (*first_object != 0) {\n        g_object_unref(*(undefined4 *)first_object);\n        *first_object = 0;\n    }\n\n    if (*second_object != 0) {\n        g_object_unref(*(undefined4 *)second_object);\n        *second_object = 0;\n    }\n\n    g_slice_free1(0x18, data_pointer);\n}\n```",
        "normed_func_sha256": "438821cb6448faf6abb4221552c9c43641d71545bf24150f264e7e3ad33332b0",
        "source_code": "static void\ngame_hub_data_compat_tool_real_run_data_free (gpointer _data)\n{\n\tGameHubDataCompatToolRunData* _data_;\n\t_data_ = _data;\n#line 25 \"../src/data/CompatTool.vala\"\n\t_g_object_unref0 (_data_->game);\n#line 25 \"../src/data/CompatTool.vala\"\n\t_g_object_unref0 (_data_->self);\n#line 25 \"../src/data/CompatTool.vala\"\n\tg_slice_free (GameHubDataCompatToolRunData, _data_);\n#line 1016 \"CompatTool.c\"\n}",
        "parsed_output": "void free_game_hub_data(int data_pointer)\n{\n    int *first_object = (int *)(data_pointer + 0x14);\n    int *second_object = (int *)(data_pointer + 0x10);\n\n    if (*first_object != 0) {\n        g_object_unref(*(undefined4 *)first_object);\n        *first_object = 0;\n    }\n\n    if (*second_object != 0) {\n        g_object_unref(*(undefined4 *)second_object);\n        *second_object = 0;\n    }\n\n    g_slice_free1(0x18, data_pointer);\n}",
        "baseline_code_stripped": "void game_hub_data_compat_tool_real_run_data_free(int param_1)\n{\n  if (*(int *)(param_1 + 0x14) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x14));\n    *(undefined4 *)(param_1 + 0x14) = 0;\n  }\n  if (*(int *)(param_1 + 0x10) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x10));\n    *(undefined4 *)(param_1 + 0x10) = 0;\n  }\n  g_slice_free1(0x18,param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.6664842367172241,
        "similarity_score_baseline_stripped": 0.7293176651000977
    },
    {
        "func_name": "sipQtCharts_QScatterSeries::connectNotify",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall\nsipQtCharts_QScatterSeries::connectNotify(sipQtCharts_QScatterSeries *this,QMetaMethod *param_1)\n{\n  _object *p_Var1;\n  int in_GS_OFFSET;\n  PyGILState_STATE local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  p_Var1 = (_object *)\n           (**(code **)(DAT_000d2940 + 0x164))\n                     (&local_14,this + 0x16,*(undefined4 *)(this + 0xc),0,\"connectNotify\");\n  if (p_Var1 == (_object *)0x0) {\n    FUN_00035fa0(this,param_1);\n  }\n  else {\n    sipVH_QtChart_0(local_14,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)\n                             PTR_s_PyQt5_000cc22c,*(_sipSimpleWrapper **)(this + 0xc),p_Var1,param_1\n                   );\n  }\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  __stack_chk_fail_local();\n}",
        "output": "```c\nvoid sipQtCharts_QScatterSeries::connectNotify(sipQtCharts_QScatterSeries *this, QMetaMethod *param_1) {\n    _object *resultObject;\n    int stackCheckValue;\n    PyGILState_STATE gilState;\n    \n    stackCheckValue = *(int *)(in_GS_OFFSET + 0x14);\n    \n    resultObject = (_object *)(**(code **)(DAT_000d2940 + 0x164))(&gilState, this + 0x16, *(undefined4 *)(this + 0xc), 0, \"connectNotify\");\n    \n    if (resultObject == (_object *)0x0) {\n        FUN_00035fa0(this, param_1);\n    } else {\n        sipVH_QtChart_0(gilState, \n                         (_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)PTR_s_PyQt5_000cc22c, \n                         *(_sipSimpleWrapper **)(this + 0xc), \n                         resultObject, \n                         param_1);\n    }\n    \n    if (stackCheckValue == *(int *)(in_GS_OFFSET + 0x14)) {\n        return;\n    }\n    \n    __stack_chk_fail_local();\n}\n```",
        "normed_func_sha256": "cf635fe8270631b3f5917c72303734da6dc28985b7e711e2912fbcd3abc33de3",
        "source_code": "void sipQtCharts_QScatterSeries::connectNotify(const  ::QMetaMethod& a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_connectNotify);\n\n    if (!sipMeth)\n    {\n         ::QtCharts::QScatterSeries::connectNotify(a0);\n        return;\n    }\n\n    extern void sipVH_QtChart_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);\n\n    sipVH_QtChart_0(sipGILState, sipImportedVirtErrorHandlers_QtChart_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);\n}",
        "parsed_output": "void sipQtCharts_QScatterSeries::connectNotify(sipQtCharts_QScatterSeries *this, QMetaMethod *param_1) {\n    _object *resultObject;\n    int stackCheckValue;\n    PyGILState_STATE gilState;\n    \n    stackCheckValue = *(int *)(in_GS_OFFSET + 0x14);\n    \n    resultObject = (_object *)(**(code **)(DAT_000d2940 + 0x164))(&gilState, this + 0x16, *(undefined4 *)(this + 0xc), 0, \"connectNotify\");\n    \n    if (resultObject == (_object *)0x0) {\n        FUN_00035fa0(this, param_1);\n    } else {\n        sipVH_QtChart_0(gilState, \n                         (_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)PTR_s_PyQt5_000cc22c, \n                         *(_sipSimpleWrapper **)(this + 0xc), \n                         resultObject, \n                         param_1);\n    }\n    \n    if (stackCheckValue == *(int *)(in_GS_OFFSET + 0x14)) {\n        return;\n    }\n    \n    __stack_chk_fail_local();\n}",
        "baseline_code_stripped": "void __thiscall\nsipQtCharts_QScatterSeries::connectNotify(sipQtCharts_QScatterSeries *this,QMetaMethod *param_1)\n{\n  _object *p_Var1;\n  int in_GS_OFFSET;\n  PyGILState_STATE local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  p_Var1 = (_object *)\n           (**(code **)(DAT_000d2940 + 0x164))\n                     (&local_14,this + 0x16,*(undefined4 *)(this + 0xc),0,\"connectNotify\");\n  if (p_Var1 == (_object *)0x0) {\n    FUN_00035fa0(this,param_1);\n  }\n  else {\n    sipVH_QtChart_0(local_14,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)\n                             PTR_s_PyQt5_000cc22c,*(_sipSimpleWrapper **)(this + 0xc),p_Var1,param_1\n                   );\n  }\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  __stack_chk_fail_local();\n}",
        "similarity_score_unixcoder": 0.7294150590896606,
        "similarity_score_baseline_stripped": 0.7519751191139221
    },
    {
        "func_name": "RemoveObstacle::apply",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_005a0ee0(undefined8 param_1,long *param_2,long *param_3,undefined8 param_4)\n{\n  undefined4 uVar1;\n  long *plVar2;\n  JsonNode *pJVar3;\n  CObstacleInstance *this;\n  undefined local_d1;\n  undefined auStack_d0 [8];\n  _Rb_tree_node_base a_Stack_c8 [8];\n  undefined8 local_c0;\n  _Rb_tree_node_base *local_b8;\n  undefined **local_a0;\n  undefined8 uStack_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  JsonNode *local_80;\n  JsonNode *local_78;\n  JsonNode *local_70;\n  long local_68;\n  local_88 = 0xffffffff;\n  local_68 = ___stack_chk_guard;\n  local_a0 = &PTR_FUN_007f7050;\n  uStack_98 = 0;\n  local_90 = 0;\n  local_80 = (JsonNode *)0x0;\n  local_78 = (JsonNode *)0x0;\n  local_70 = (JsonNode *)0x0;\n  if (*(code **)(*param_3 + 0x148) == spells::BaseMechanics::battle) {\n    plVar2 = (long *)param_3[10];\n  }\n  else {\n    plVar2 = (long *)(**(code **)(*param_3 + 0x148))(param_3);\n  }\n  plVar2 = (long *)(**(code **)(*(long *)((long)plVar2 + *(long *)(*plVar2 + -0x98)) + 0x18))\n                             ((long)plVar2 + *(long *)(*plVar2 + -0x98));\n  if (*(code **)(*plVar2 + 0x18) == BattleInfo::getBattleID) {\n    local_88 = *(undefined4 *)(plVar2 + 1);\n  }\n  else {\n    local_88 = (**(code **)(*plVar2 + 0x18))();\n  }\n  FUN_0059c0f4(param_1,param_3,param_4,0);\n  pJVar3 = local_78;\n  while (local_78 = pJVar3, local_b8 != a_Stack_c8) {\n    local_d1 = 3;\n    this = *(CObstacleInstance **)(local_b8 + 0x20);\n    if (pJVar3 == local_70) {\n      FUN_002d3b60(&local_80,pJVar3,this + 0xc,&local_d1);\n      pJVar3 = local_78 + -0x78;\n    }\n    else {\n      uVar1 = *(undefined4 *)(this + 0xc);\n      JsonNode::JsonNode(pJVar3,0);\n      pJVar3[0x70] = (JsonNode)0x3;\n      *(undefined4 *)(pJVar3 + 0x74) = uVar1;\n      pJVar3 = local_78;\n      local_78 = local_78 + 0x78;\n    }\n    CObstacleInstance::toInfo(this,(ObstacleChanges *)pJVar3,3);\n    local_b8 = (_Rb_tree_node_base *)std::_Rb_tree_increment(local_b8);\n    pJVar3 = local_78;\n  }\n  FUN_002b8b20(auStack_d0,local_c0);\n  if (local_80 != local_78) {\n    (**(code **)(*param_2 + 0x58))(param_2,&local_a0);\n  }\n  FUN_002bf270(&local_a0);\n  if (local_68 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_68 - ___stack_chk_guard);\n}",
        "output": "```c\nvoid ProcessBattleMechanics(undefined8 param_1, long *param_2, long *param_3, undefined8 param_4) {\n    undefined4 battleID;\n    long *obstacleInstancePtr;\n    JsonNode *currentJsonNode;\n    CObstacleInstance *obstacleInstance;\n    undefined localFlag;\n    undefined stackBuffer[8];\n    _Rb_tree_node_base stackNode[8];\n    undefined8 localData;\n    _Rb_tree_node_base *currentNode;\n    undefined **jsonNodeArray;\n    undefined8 unusedStack;\n    undefined8 localJsonNodePtr;\n    undefined4 localObstacleID;\n    JsonNode *jsonNodeListStart;\n    JsonNode *jsonNodeListEnd;\n    JsonNode *jsonNodeCurrent;\n    long stackGuard;\n\n    localObstacleID = 0xffffffff;\n    stackGuard = ___stack_chk_guard;\n    jsonNodeArray = &PTR_FUN_007f7050;\n    unusedStack = 0;\n    localJsonNodePtr = 0;\n    jsonNodeListStart = (JsonNode *)0x0;\n    jsonNodeListEnd = (JsonNode *)0x0;\n    jsonNodeCurrent = (JsonNode *)0x0;\n\n    if (*(code **)(*param_3 + 0x148) == spells::BaseMechanics::battle) {\n        obstacleInstancePtr = (long *)param_3[10];\n    } else {\n        obstacleInstancePtr = (long *)(**(code **)(*param_3 + 0x148))(param_3);\n    }\n\n    obstacleInstancePtr = (long *)(**(code **)(*(long *)((long)obstacleInstancePtr + *(long *)(*obstacleInstancePtr - 0x98)) + 0x18))\n                               ((long)obstacleInstancePtr + *(long *)(*obstacleInstancePtr - 0x98));\n\n    if (*(code **)(*obstacleInstancePtr + 0x18) == BattleInfo::getBattleID) {\n        localObstacleID = *(undefined4 *)(obstacleInstancePtr + 1);\n    } else {\n        localObstacleID = (**(code **)(*obstacleInstancePtr + 0x18))();\n    }\n\n    FUN_0059c0f4(param_1, param_3, param_4, 0);\n    currentJsonNode = jsonNodeListEnd;\n\n    while (jsonNodeListEnd = currentJsonNode, currentNode != stackNode) {\n        localFlag = 3;\n        obstacleInstance = *(CObstacleInstance **)(currentNode + 0x20);\n\n        if (currentJsonNode == jsonNodeCurrent) {\n            FUN_002d3b60(&jsonNodeListStart, currentJsonNode, obstacleInstance + 0xc, &localFlag);\n            currentJsonNode = jsonNodeListEnd - 0x78;\n        } else {\n            battleID = *(undefined4 *)(obstacleInstance + 0xc);\n            JsonNode::JsonNode(currentJsonNode, 0);\n            currentJsonNode[0x70] = (JsonNode)0x3;\n            *(undefined4 *)(currentJsonNode + 0x74) = battleID;\n            currentJsonNode = jsonNodeListEnd;\n            jsonNodeListEnd = jsonNodeListEnd + 0x78;\n        }\n\n        CObstacleInstance::toInfo(obstacleInstance, (ObstacleChanges *)currentJsonNode, 3);\n        currentNode = (_Rb_tree_node_base *)std::_Rb_tree_increment(currentNode);\n        currentJsonNode = jsonNodeListEnd;\n    }\n\n    FUN_002b8b20(stackBuffer, localData);\n\n    if (jsonNodeListStart != jsonNodeListEnd) {\n        (**(code **)(*param_2 + 0x58))(param_2, &jsonNodeArray);\n    }\n\n    FUN_002bf270(&jsonNodeArray);\n\n    if (stackGuard - ___stack_chk_guard == 0) {\n        return;\n    }\n\n    __stack_chk_fail(&__stack_chk_guard, 0, stackGuard - ___stack_chk_guard);\n}\n```",
        "normed_func_sha256": "477d534fa11340a99a8fca21f0af40048992ce748121a484385fdc070fa07878",
        "source_code": "void RemoveObstacle::apply(ServerCallback * server, const Mechanics * m, const EffectTarget & target) const\n{\n\tBattleObstaclesChanged pack;\n\tpack.battleID = m->battle()->getBattle()->getBattleID();\n\n\tfor(const auto & obstacle : getTargets(m, target, false))\n\t{\n\t\tauto * serializable = const_cast<CObstacleInstance*>(obstacle); //Workaround\n\t\tpack.changes.emplace_back(obstacle->uniqueID, BattleChanges::EOperation::REMOVE);\n\t\tserializable->toInfo(pack.changes.back(), BattleChanges::EOperation::REMOVE);\n\t}\n\n\tif(!pack.changes.empty())\n\t\tserver->apply(&pack);\n}",
        "parsed_output": "void ProcessBattleMechanics(undefined8 param_1, long *param_2, long *param_3, undefined8 param_4) {\n    undefined4 battleID;\n    long *obstacleInstancePtr;\n    JsonNode *currentJsonNode;\n    CObstacleInstance *obstacleInstance;\n    undefined localFlag;\n    undefined stackBuffer[8];\n    _Rb_tree_node_base stackNode[8];\n    undefined8 localData;\n    _Rb_tree_node_base *currentNode;\n    undefined **jsonNodeArray;\n    undefined8 unusedStack;\n    undefined8 localJsonNodePtr;\n    undefined4 localObstacleID;\n    JsonNode *jsonNodeListStart;\n    JsonNode *jsonNodeListEnd;\n    JsonNode *jsonNodeCurrent;\n    long stackGuard;\n\n    localObstacleID = 0xffffffff;\n    stackGuard = ___stack_chk_guard;\n    jsonNodeArray = &PTR_FUN_007f7050;\n    unusedStack = 0;\n    localJsonNodePtr = 0;\n    jsonNodeListStart = (JsonNode *)0x0;\n    jsonNodeListEnd = (JsonNode *)0x0;\n    jsonNodeCurrent = (JsonNode *)0x0;\n\n    if (*(code **)(*param_3 + 0x148) == spells::BaseMechanics::battle) {\n        obstacleInstancePtr = (long *)param_3[10];\n    } else {\n        obstacleInstancePtr = (long *)(**(code **)(*param_3 + 0x148))(param_3);\n    }\n\n    obstacleInstancePtr = (long *)(**(code **)(*(long *)((long)obstacleInstancePtr + *(long *)(*obstacleInstancePtr - 0x98)) + 0x18))\n                               ((long)obstacleInstancePtr + *(long *)(*obstacleInstancePtr - 0x98));\n\n    if (*(code **)(*obstacleInstancePtr + 0x18) == BattleInfo::getBattleID) {\n        localObstacleID = *(undefined4 *)(obstacleInstancePtr + 1);\n    } else {\n        localObstacleID = (**(code **)(*obstacleInstancePtr + 0x18))();\n    }\n\n    FUN_0059c0f4(param_1, param_3, param_4, 0);\n    currentJsonNode = jsonNodeListEnd;\n\n    while (jsonNodeListEnd = currentJsonNode, currentNode != stackNode) {\n        localFlag = 3;\n        obstacleInstance = *(CObstacleInstance **)(currentNode + 0x20);\n\n        if (currentJsonNode == jsonNodeCurrent) {\n            FUN_002d3b60(&jsonNodeListStart, currentJsonNode, obstacleInstance + 0xc, &localFlag);\n            currentJsonNode = jsonNodeListEnd - 0x78;\n        } else {\n            battleID = *(undefined4 *)(obstacleInstance + 0xc);\n            JsonNode::JsonNode(currentJsonNode, 0);\n            currentJsonNode[0x70] = (JsonNode)0x3;\n            *(undefined4 *)(currentJsonNode + 0x74) = battleID;\n            currentJsonNode = jsonNodeListEnd;\n            jsonNodeListEnd = jsonNodeListEnd + 0x78;\n        }\n\n        CObstacleInstance::toInfo(obstacleInstance, (ObstacleChanges *)currentJsonNode, 3);\n        currentNode = (_Rb_tree_node_base *)std::_Rb_tree_increment(currentNode);\n        currentJsonNode = jsonNodeListEnd;\n    }\n\n    FUN_002b8b20(stackBuffer, localData);\n\n    if (jsonNodeListStart != jsonNodeListEnd) {\n        (**(code **)(*param_2 + 0x58))(param_2, &jsonNodeArray);\n    }\n\n    FUN_002bf270(&jsonNodeArray);\n\n    if (stackGuard - ___stack_chk_guard == 0) {\n        return;\n    }\n\n    __stack_chk_fail(&__stack_chk_guard, 0, stackGuard - ___stack_chk_guard);\n}",
        "baseline_code_stripped": "void FUN_005a0ee0(undefined8 param_1,long *param_2,long *param_3,undefined8 param_4)\n{\n  undefined4 uVar1;\n  long *plVar2;\n  JsonNode *pJVar3;\n  CObstacleInstance *this;\n  undefined local_d1;\n  undefined auStack_d0 [8];\n  _Rb_tree_node_base a_Stack_c8 [8];\n  undefined8 local_c0;\n  _Rb_tree_node_base *local_b8;\n  undefined **local_a0;\n  undefined8 uStack_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  JsonNode *local_80;\n  JsonNode *local_78;\n  JsonNode *local_70;\n  long local_68;\n  local_88 = 0xffffffff;\n  local_68 = ___stack_chk_guard;\n  local_a0 = &PTR_FUN_007f7050;\n  uStack_98 = 0;\n  local_90 = 0;\n  local_80 = (JsonNode *)0x0;\n  local_78 = (JsonNode *)0x0;\n  local_70 = (JsonNode *)0x0;\n  if (*(code **)(*param_3 + 0x148) == spells::BaseMechanics::battle) {\n    plVar2 = (long *)param_3[10];\n  }\n  else {\n    plVar2 = (long *)(**(code **)(*param_3 + 0x148))(param_3);\n  }\n  plVar2 = (long *)(**(code **)(*(long *)((long)plVar2 + *(long *)(*plVar2 + -0x98)) + 0x18))\n                             ((long)plVar2 + *(long *)(*plVar2 + -0x98));\n  if (*(code **)(*plVar2 + 0x18) == BattleInfo::getBattleID) {\n    local_88 = *(undefined4 *)(plVar2 + 1);\n  }\n  else {\n    local_88 = (**(code **)(*plVar2 + 0x18))();\n  }\n  FUN_0059c0f4(param_1,param_3,param_4,0);\n  pJVar3 = local_78;\n  while (local_78 = pJVar3, local_b8 != a_Stack_c8) {\n    local_d1 = 3;\n    this = *(CObstacleInstance **)(local_b8 + 0x20);\n    if (pJVar3 == local_70) {\n      FUN_002d3b60(&local_80,pJVar3,this + 0xc,&local_d1);\n      pJVar3 = local_78 + -0x78;\n    }\n    else {\n      uVar1 = *(undefined4 *)(this + 0xc);\n      JsonNode::JsonNode(pJVar3,0);\n      pJVar3[0x70] = (JsonNode)0x3;\n      *(undefined4 *)(pJVar3 + 0x74) = uVar1;\n      pJVar3 = local_78;\n      local_78 = local_78 + 0x78;\n    }\n    CObstacleInstance::toInfo(this,(ObstacleChanges *)pJVar3,3);\n    local_b8 = (_Rb_tree_node_base *)std::_Rb_tree_increment(local_b8);\n    pJVar3 = local_78;\n  }\n  FUN_002b8b20(auStack_d0,local_c0);\n  if (local_80 != local_78) {\n    (**(code **)(*param_2 + 0x58))(param_2,&local_a0);\n  }\n  FUN_002bf270(&local_a0);\n  if (local_68 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_68 - ___stack_chk_guard);\n}",
        "similarity_score_unixcoder": 0.5284202098846436,
        "similarity_score_baseline_stripped": 0.37734994292259216
    },
    {
        "func_name": "sipQTransposeProxyModel::headerData",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_000aeb40(int param_1,Orientation param_2,int param_3,undefined4 param_4,undefined4 param_5)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  int unaff_EDI;\n  int in_GS_OFFSET;\n  undefined4 uStack_20;\n  undefined auStack_1c [8];\n  undefined local_14 [4];\n  undefined4 local_10;\n  FUN_00089011();\n  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  iVar1 = (**(code **)(*(int *)((int)&fde_0024eb90 + unaff_EDI + 2) + 0x260))\n                    (local_14,param_2 + 0x25,param_2 + 8,0,unaff_EDI + 0x161867);\n  if (iVar1 == 0) {\n    QTransposeProxyModel::headerData(param_1,param_2,param_3);\n    puVar2 = &uStack_20;\n  }\n  else {\n    uStack_20 = param_5;\n    FUN_001d4e90(iVar1,param_3,param_4);\n    puVar2 = (undefined4 *)auStack_1c;\n  }\n  if (*(int *)((int)puVar2 + 0xc) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return param_1;\n  }\n  *(undefined **)((int)puVar2 + -4) = &UNK_000aebea;\n  FUN_001da030();\n}",
        "output": "```c\nint processFunction(int param_1, Orientation param_2, int param_3, undefined4 param_4, undefined4 param_5) {\n    int result;\n    undefined4 *resultPointer;\n    int unaff_EDI;\n    int in_GS_OFFSET;\n    undefined4 returnValue;\n    undefined localBuffer[8];\n    undefined localData[4];\n    undefined4 localValue;\n\n    initializeFunction();\n    localValue = *(undefined4 *)(in_GS_OFFSET + 0x14);\n    \n    result = (*(code **)(*(int *)((int)&fde_0024eb90 + unaff_EDI + 2) + 0x260))(\n        localData, \n        param_2 + 0x25, \n        param_2 + 8, \n        0, \n        unaff_EDI + 0x161867\n    );\n\n    if (result == 0) {\n        QTransposeProxyModel::headerData(param_1, param_2, param_3);\n        resultPointer = &returnValue;\n    } else {\n        returnValue = param_5;\n        FUN_001d4e90(result, param_3, param_4);\n        resultPointer = (undefined4 *)localBuffer;\n    }\n\n    if (*(int *)((int)resultPointer + 0xc) == *(int *)(in_GS_OFFSET + 0x14)) {\n        return param_1;\n    }\n\n    *(undefined **)((int)resultPointer - 4) = &UNK_000aebea;\n    FUN_001da030();\n}\n```",
        "normed_func_sha256": "558b272a016bf8d4cdce8dcd4e1fee402fbe8b8de5f2dbc1b95f26e7a679853c",
        "source_code": "::QVariant sipQTransposeProxyModel::headerData(int a0, ::Qt::Orientation a1,int a2) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n#if SIP_ABI_MAJOR_VERSION >= 12 && SIP_ABI_MINOR_VERSION >= 8\n    sipMeth = sipIsPyMethod_12_8(&sipGILState, const_cast<char *>(&sipPyMethods[25]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_headerData);\n\n#else\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[25]), sipPySelf, SIP_NULLPTR, sipName_headerData);\n#endif\n\n    if (!sipMeth)\n        return  ::QTransposeProxyModel::headerData(a0,a1,a2);\n\n    extern  ::QVariant sipVH_QtCore_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int, ::Qt::Orientation,int);\n\n    return sipVH_QtCore_25(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0, a1, a2);\n}",
        "parsed_output": "int processFunction(int param_1, Orientation param_2, int param_3, undefined4 param_4, undefined4 param_5) {\n    int result;\n    undefined4 *resultPointer;\n    int unaff_EDI;\n    int in_GS_OFFSET;\n    undefined4 returnValue;\n    undefined localBuffer[8];\n    undefined localData[4];\n    undefined4 localValue;\n\n    initializeFunction();\n    localValue = *(undefined4 *)(in_GS_OFFSET + 0x14);\n    \n    result = (*(code **)(*(int *)((int)&fde_0024eb90 + unaff_EDI + 2) + 0x260))(\n        localData, \n        param_2 + 0x25, \n        param_2 + 8, \n        0, \n        unaff_EDI + 0x161867\n    );\n\n    if (result == 0) {\n        QTransposeProxyModel::headerData(param_1, param_2, param_3);\n        resultPointer = &returnValue;\n    } else {\n        returnValue = param_5;\n        FUN_001d4e90(result, param_3, param_4);\n        resultPointer = (undefined4 *)localBuffer;\n    }\n\n    if (*(int *)((int)resultPointer + 0xc) == *(int *)(in_GS_OFFSET + 0x14)) {\n        return param_1;\n    }\n\n    *(undefined **)((int)resultPointer - 4) = &UNK_000aebea;\n    FUN_001da030();\n}",
        "baseline_code_stripped": "int FUN_000aeb40(int param_1,Orientation param_2,int param_3,undefined4 param_4,undefined4 param_5)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  int unaff_EDI;\n  int in_GS_OFFSET;\n  undefined4 uStack_20;\n  undefined auStack_1c [8];\n  undefined local_14 [4];\n  undefined4 local_10;\n  FUN_00089011();\n  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  iVar1 = (**(code **)(*(int *)((int)&fde_0024eb90 + unaff_EDI + 2) + 0x260))\n                    (local_14,param_2 + 0x25,param_2 + 8,0,unaff_EDI + 0x161867);\n  if (iVar1 == 0) {\n    QTransposeProxyModel::headerData(param_1,param_2,param_3);\n    puVar2 = &uStack_20;\n  }\n  else {\n    uStack_20 = param_5;\n    FUN_001d4e90(iVar1,param_3,param_4);\n    puVar2 = (undefined4 *)auStack_1c;\n  }\n  if (*(int *)((int)puVar2 + 0xc) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return param_1;\n  }\n  *(undefined **)((int)puVar2 + -4) = &UNK_000aebea;\n  FUN_001da030();\n}",
        "similarity_score_unixcoder": 0.6325695514678955,
        "similarity_score_baseline_stripped": 0.6006065607070923
    },
    {
        "func_name": "ServicePage::onCurrentServerChanged",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall ServicePage::onCurrentServerChanged(ServicePage *this)\n{\n  QString *pQVar1;\n  code *pcVar2;\n  char cVar3;\n  int iVar4;\n  long *plVar5;\n  long in_FS_OFFSET;\n  QString local_68 [8];\n  QString local_60 [8];\n  Jid local_58 [8];\n  undefined8 local_50;\n  undefined8 *local_48;\n  long local_40;\n  local_50 = *(undefined8 *)(this + 0x70);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  *(undefined8 **)(this + 0x70) = &QListData::shared_null;\n  local_48 = &QListData::shared_null;\n  QList<Jid>::_QList((QList_Jid_ *)&local_50);\n  QList<Jid>::_QList((QList_Jid_ *)&local_48);\n  QComboBox::clear();\n  local_48 = &QArrayData::shared_null;\n  QLabel::setText(*(QString **)(this + 0x30));\n  QString::_QString((QString *)&local_48);\n  iVar4 = QComboBox::count();\n  if (0 < iVar4) {\n    iVar4 = QComboBox::count();\n    if (0 < iVar4) {\n      plVar5 = (long *)PluginHelper::pluginInstance_IServiceDiscovery_();\n      if (plVar5 != (long *)0x0) {\n        pcVar2 = *(code **)(*plVar5 + 0xd0);\n        local_48 = &QArrayData::shared_null;\n        serverJid();\n        Jid::Jid((Jid *)&local_50,local_60);\n        streamJid();\n        Jid::Jid(local_58,local_68);\n        cVar3 = (*pcVar2)(plVar5,local_58,&local_50,&local_48);\n        Jid::_Jid(local_58);\n        QString::_QString(local_68);\n        Jid::_Jid((Jid *)&local_50);\n        QString::_QString(local_60);\n        QString::_QString((QString *)&local_48);\n        if (cVar3 != '\\0') {\n          this[0x68] = (ServicePage)0x1;\n          pQVar1 = *(QString **)(this + 0x30);\n          QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae20);\n          QLabel::setText(pQVar1);\n          goto LAB_001d5fc8;\n        }\n      }\n      pQVar1 = *(QString **)(this + 0x30);\n      QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae48);\n      QLabel::setText(pQVar1);\n      goto LAB_001d5fc8;\n    }\n  }\n  pQVar1 = *(QString **)(this + 0x30);\n  QMetaObject::tr((char *)&local_48,staticMetaObject,0x20adf8);\n  QLabel::setText(pQVar1);\nLAB_001d5fc8:\n  QString::_QString((QString *)&local_48);\n  QWizardPage::completeChanged();\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nvoid ServicePage::onCurrentServerChanged(ServicePage *this)\n{\n    QString *currentText;\n    code *pluginFunction;\n    char resultFlag;\n    int comboBoxCount;\n    long *pluginInstance;\n    long stackCheckValue;\n    QString localString1[8];\n    QString localString2[8];\n    Jid localJid1[8];\n    undefined8 localData1;\n    undefined8 *localData2;\n    long localStackValue;\n\n    localData1 = *(undefined8 *)(this + 0x70);\n    localStackValue = *(long *)(in_FS_OFFSET + 0x28);\n    *(undefined8 **)(this + 0x70) = &QListData::shared_null;\n    localData2 = &QListData::shared_null;\n\n    QList<Jid>::_QList((QList_Jid_ *)&localData1);\n    QList<Jid>::_QList((QList_Jid_ *)&localData2);\n    QComboBox::clear();\n\n    localData2 = &QArrayData::shared_null;\n    QLabel::setText(*(QString **)(this + 0x30));\n    QString::_QString((QString *)&localData2);\n\n    comboBoxCount = QComboBox::count();\n    if (comboBoxCount > 0) {\n        comboBoxCount = QComboBox::count();\n        if (comboBoxCount > 0) {\n            pluginInstance = (long *)PluginHelper::pluginInstance_IServiceDiscovery_();\n            if (pluginInstance != nullptr) {\n                pluginFunction = *(code **)(*pluginInstance + 0xd0);\n                localData2 = &QArrayData::shared_null;\n\n                serverJid();\n                Jid::Jid((Jid *)&localData1, localString2);\n                streamJid();\n                Jid::Jid(localJid1, localString1);\n\n                resultFlag = (*pluginFunction)(pluginInstance, localJid1, &localData1, &localData2);\n                Jid::_Jid(localJid1);\n                QString::_QString(localString1);\n                Jid::_Jid((Jid *)&localData1);\n                QString::_QString(localString2);\n                QString::_QString((QString *)&localData2);\n\n                if (resultFlag != '\\0') {\n                    this[0x68] = (ServicePage)0x1;\n                    currentText = *(QString **)(this + 0x30);\n                    QMetaObject::tr((char *)&localData2, staticMetaObject, 0x20ae20);\n                    QLabel::setText(currentText);\n                    goto endFunction;\n                }\n            }\n            currentText = *(QString **)(this + 0x30);\n            QMetaObject::tr((char *)&localData2, staticMetaObject, 0x20ae48);\n            QLabel::setText(currentText);\n            goto endFunction;\n        }\n    }\n    currentText = *(QString **)(this + 0x30);\n    QMetaObject::tr((char *)&localData2, staticMetaObject, 0x20adf8);\n    QLabel::setText(currentText);\n\nendFunction:\n    QString::_QString((QString *)&localData2);\n    QWizardPage::completeChanged();\n\n    if (localStackValue == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n    }\n    __stack_chk_fail();\n}\n```",
        "normed_func_sha256": "7a286658067c6031477184439dab50eec06e0f427fdf391692752e761748097e",
        "source_code": "void ServicePage::onCurrentServerChanged()\r\n{\r\n\tFWaitInfo.clear();\r\n\tcmbService->clear();\r\n\tlblInfo->setText(QString::null);\r\n\r\n\tif (cmbAccount->count()>0 && cmbServer->count()>0)\r\n\t{\r\n\t\tIServiceDiscovery *discovery = PluginHelper::pluginInstance<IServiceDiscovery>();\r\n\t\tif (discovery && discovery->requestDiscoItems(streamJid(),serverJid()))\r\n\t\t{\r\n\t\t\tFWaitItems = true;\r\n\t\t\tlblInfo->setText(tr(\"Loading list of available services...\"));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlblInfo->setText(tr(\"Failed to load list of services\"));\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlblInfo->setText(tr(\"Account or server is not selected\"));\r\n\t}\r\n\r\n\temit completeChanged();\r\n}",
        "parsed_output": "void ServicePage::onCurrentServerChanged(ServicePage *this)\n{\n    QString *currentText;\n    code *pluginFunction;\n    char resultFlag;\n    int comboBoxCount;\n    long *pluginInstance;\n    long stackCheckValue;\n    QString localString1[8];\n    QString localString2[8];\n    Jid localJid1[8];\n    undefined8 localData1;\n    undefined8 *localData2;\n    long localStackValue;\n\n    localData1 = *(undefined8 *)(this + 0x70);\n    localStackValue = *(long *)(in_FS_OFFSET + 0x28);\n    *(undefined8 **)(this + 0x70) = &QListData::shared_null;\n    localData2 = &QListData::shared_null;\n\n    QList<Jid>::_QList((QList_Jid_ *)&localData1);\n    QList<Jid>::_QList((QList_Jid_ *)&localData2);\n    QComboBox::clear();\n\n    localData2 = &QArrayData::shared_null;\n    QLabel::setText(*(QString **)(this + 0x30));\n    QString::_QString((QString *)&localData2);\n\n    comboBoxCount = QComboBox::count();\n    if (comboBoxCount > 0) {\n        comboBoxCount = QComboBox::count();\n        if (comboBoxCount > 0) {\n            pluginInstance = (long *)PluginHelper::pluginInstance_IServiceDiscovery_();\n            if (pluginInstance != nullptr) {\n                pluginFunction = *(code **)(*pluginInstance + 0xd0);\n                localData2 = &QArrayData::shared_null;\n\n                serverJid();\n                Jid::Jid((Jid *)&localData1, localString2);\n                streamJid();\n                Jid::Jid(localJid1, localString1);\n\n                resultFlag = (*pluginFunction)(pluginInstance, localJid1, &localData1, &localData2);\n                Jid::_Jid(localJid1);\n                QString::_QString(localString1);\n                Jid::_Jid((Jid *)&localData1);\n                QString::_QString(localString2);\n                QString::_QString((QString *)&localData2);\n\n                if (resultFlag != '\\0') {\n                    this[0x68] = (ServicePage)0x1;\n                    currentText = *(QString **)(this + 0x30);\n                    QMetaObject::tr((char *)&localData2, staticMetaObject, 0x20ae20);\n                    QLabel::setText(currentText);\n                    goto endFunction;\n                }\n            }\n            currentText = *(QString **)(this + 0x30);\n            QMetaObject::tr((char *)&localData2, staticMetaObject, 0x20ae48);\n            QLabel::setText(currentText);\n            goto endFunction;\n        }\n    }\n    currentText = *(QString **)(this + 0x30);\n    QMetaObject::tr((char *)&localData2, staticMetaObject, 0x20adf8);\n    QLabel::setText(currentText);\n\nendFunction:\n    QString::_QString((QString *)&localData2);\n    QWizardPage::completeChanged();\n\n    if (localStackValue == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n    }\n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "void __thiscall ServicePage::onCurrentServerChanged(ServicePage *this)\n{\n  QString *pQVar1;\n  code *pcVar2;\n  char cVar3;\n  int iVar4;\n  long *plVar5;\n  long in_FS_OFFSET;\n  QString local_68 [8];\n  QString local_60 [8];\n  Jid local_58 [8];\n  undefined8 local_50;\n  undefined8 *local_48;\n  long local_40;\n  local_50 = *(undefined8 *)(this + 0x70);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  *(undefined8 **)(this + 0x70) = &QListData::shared_null;\n  local_48 = &QListData::shared_null;\n  QList<Jid>::_QList((QList_Jid_ *)&local_50);\n  QList<Jid>::_QList((QList_Jid_ *)&local_48);\n  QComboBox::clear();\n  local_48 = &QArrayData::shared_null;\n  QLabel::setText(*(QString **)(this + 0x30));\n  QString::_QString((QString *)&local_48);\n  iVar4 = QComboBox::count();\n  if (0 < iVar4) {\n    iVar4 = QComboBox::count();\n    if (0 < iVar4) {\n      plVar5 = (long *)PluginHelper::pluginInstance_IServiceDiscovery_();\n      if (plVar5 != (long *)0x0) {\n        pcVar2 = *(code **)(*plVar5 + 0xd0);\n        local_48 = &QArrayData::shared_null;\n        serverJid();\n        Jid::Jid((Jid *)&local_50,local_60);\n        streamJid();\n        Jid::Jid(local_58,local_68);\n        cVar3 = (*pcVar2)(plVar5,local_58,&local_50,&local_48);\n        Jid::_Jid(local_58);\n        QString::_QString(local_68);\n        Jid::_Jid((Jid *)&local_50);\n        QString::_QString(local_60);\n        QString::_QString((QString *)&local_48);\n        if (cVar3 != '\\0') {\n          this[0x68] = (ServicePage)0x1;\n          pQVar1 = *(QString **)(this + 0x30);\n          QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae20);\n          QLabel::setText(pQVar1);\n          goto LAB_001d5fc8;\n        }\n      }\n      pQVar1 = *(QString **)(this + 0x30);\n      QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae48);\n      QLabel::setText(pQVar1);\n      goto LAB_001d5fc8;\n    }\n  }\n  pQVar1 = *(QString **)(this + 0x30);\n  QMetaObject::tr((char *)&local_48,staticMetaObject,0x20adf8);\n  QLabel::setText(pQVar1);\nLAB_001d5fc8:\n  QString::_QString((QString *)&local_48);\n  QWizardPage::completeChanged();\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.6318463683128357,
        "similarity_score_baseline_stripped": 0.6262897849082947
    },
    {
        "func_name": "botlink_resolve_success",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_10011df0(int param_1)\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined4 uVar5;\n  char *__src;\n  iVar1 = param_1 * 0x188;\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc + 0x184);\n  uVar5 = *(undefined4 *)(iVar3 + 0x18);\n  *(undefined4 *)(iVar1 + _DAT_10077ffc + 4) = *(undefined4 *)(iVar3 + 0x14);\n  __src = *(char **)(iVar3 + 0x10);\n  FUN_10027460(param_1,&PTR_s_FORK_BOT_10075e48,0x9c);\n  iVar3 = iVar1 + _DAT_10077ffc;\n  *(undefined4 *)(iVar3 + 0x17c) = _DAT_100780c4;\n  strcpy((char *)(*(int *)(iVar3 + 0x184) + 0x79),__src);\n  iVar3 = _DAT_10077ffc;\n  iVar2 = iVar1 + _DAT_10077ffc;\n  puVar4 = *(undefined4 **)(iVar2 + 0x184);\n  puVar4[2] = 0x76652062;\n  puVar4[3] = 0x6f742900;\n  puVar4[1] = 0x6d697469;\n  *puVar4 = 0x28707269;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x90) = uVar5;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x94) = *(undefined4 *)(iVar2 + 8);\n  uVar5 = FUN_10039320(0x20);\n  *(undefined4 *)(iVar1 + iVar3) = uVar5;\n  FUN_100319f0(__src,\"botnet.c\",0x42b);\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc);\n  if (-1 < iVar3) {\n    uVar5 = FUN_10038c20(*(undefined4 *)(iVar1 + _DAT_10077ffc + 4));\n    iVar1 = FUN_1003a5d0(iVar3,uVar5,*(undefined4 *)(iVar1 + _DAT_10077ffc + 8));\n    if (-1 < iVar1) {\n      return;\n    }\n  }\n  FUN_10024db0(param_1);\n  return;\n}",
        "output": "```c\nvoid processFunction(int param_1)\n{\n    int baseIndex = param_1 * 0x188;\n    int dataOffset = *(int *)(baseIndex + _DAT_10077ffc + 0x184);\n    uint32_t retrievedValue = *(uint32_t *)(dataOffset + 0x18);\n    \n    *(uint32_t *)(baseIndex + _DAT_10077ffc + 4) = *(uint32_t *)(dataOffset + 0x14);\n    char *sourceString = *(char **)(dataOffset + 0x10);\n    \n    FUN_10027460(param_1, &PTR_s_FORK_BOT_10075e48, 0x9c);\n    \n    int finalIndex = baseIndex + _DAT_10077ffc;\n    *(uint32_t *)(finalIndex + 0x17c) = _DAT_100780c4;\n    \n    strcpy((char *)(*(int *)(finalIndex + 0x184) + 0x79), sourceString);\n    \n    int dataPointer = _DAT_10077ffc;\n    int currentIndex = baseIndex + _DAT_10077ffc;\n    uint32_t *dataArray = *(uint32_t **)(currentIndex + 0x184);\n    \n    dataArray[0] = 0x28707269; // \"pir(\"\n    dataArray[1] = 0x6d697469; // \"itim\"\n    dataArray[2] = 0x76652062; // \" be\"\n    dataArray[3] = 0x6f742900; // \"ot)\"\n    \n    *(uint32_t *)(*(int *)(currentIndex + 0x184) + 0x90) = retrievedValue;\n    *(uint32_t *)(*(int *)(currentIndex + 0x184) + 0x94) = *(uint32_t *)(currentIndex + 8);\n    \n    retrievedValue = FUN_10039320(0x20);\n    *(uint32_t *)(baseIndex + dataPointer) = retrievedValue;\n    \n    FUN_100319f0(sourceString, \"botnet.c\", 0x42b);\n    \n    int checkValue = *(int *)(baseIndex + _DAT_10077ffc);\n    if (checkValue >= 0) {\n        retrievedValue = FUN_10038c20(*(uint32_t *)(baseIndex + _DAT_10077ffc + 4));\n        int result = FUN_1003a5d0(checkValue, retrievedValue, *(uint32_t *)(baseIndex + _DAT_10077ffc + 8));\n        \n        if (result >= 0) {\n            return;\n        }\n    }\n    \n    FUN_10024db0(param_1);\n    return;\n}\n```",
        "normed_func_sha256": "515d28efdd2e4c7a363a30b26e9ac714b550cba85844ae7e085d90156e2bc1ad",
        "source_code": "static void botlink_resolve_success(int i)\n{\n  int idx = dcc[i].u.dns->ibuf;\n  char *linker = dcc[i].u.dns->cptr;\n\n  dcc[i].addr = dcc[i].u.dns->ip;\n  changeover_dcc(i, &DCC_FORK_BOT, sizeof(struct bot_info));\n  dcc[i].timeval = now;\n  strcpy(dcc[i].u.bot->linker, linker);\n  strcpy(dcc[i].u.bot->version, \"(primitive bot)\");\n  dcc[i].u.bot->numver = idx;\n  dcc[i].u.bot->port = dcc[i].port;     /* Remember where i started */\n  dcc[i].sock = getsock(SOCK_STRONGCONN);\n  nfree(linker);\n  if (dcc[i].sock < 0 ||\n      open_telnet_raw(dcc[i].sock, iptostr(htonl(dcc[i].addr)),\n                      dcc[i].port) < 0)\n    failed_link(i);\n}",
        "parsed_output": "void processFunction(int param_1)\n{\n    int baseIndex = param_1 * 0x188;\n    int dataOffset = *(int *)(baseIndex + _DAT_10077ffc + 0x184);\n    uint32_t retrievedValue = *(uint32_t *)(dataOffset + 0x18);\n    \n    *(uint32_t *)(baseIndex + _DAT_10077ffc + 4) = *(uint32_t *)(dataOffset + 0x14);\n    char *sourceString = *(char **)(dataOffset + 0x10);\n    \n    FUN_10027460(param_1, &PTR_s_FORK_BOT_10075e48, 0x9c);\n    \n    int finalIndex = baseIndex + _DAT_10077ffc;\n    *(uint32_t *)(finalIndex + 0x17c) = _DAT_100780c4;\n    \n    strcpy((char *)(*(int *)(finalIndex + 0x184) + 0x79), sourceString);\n    \n    int dataPointer = _DAT_10077ffc;\n    int currentIndex = baseIndex + _DAT_10077ffc;\n    uint32_t *dataArray = *(uint32_t **)(currentIndex + 0x184);\n    \n    dataArray[0] = 0x28707269; // \"pir(\"\n    dataArray[1] = 0x6d697469; // \"itim\"\n    dataArray[2] = 0x76652062; // \" be\"\n    dataArray[3] = 0x6f742900; // \"ot)\"\n    \n    *(uint32_t *)(*(int *)(currentIndex + 0x184) + 0x90) = retrievedValue;\n    *(uint32_t *)(*(int *)(currentIndex + 0x184) + 0x94) = *(uint32_t *)(currentIndex + 8);\n    \n    retrievedValue = FUN_10039320(0x20);\n    *(uint32_t *)(baseIndex + dataPointer) = retrievedValue;\n    \n    FUN_100319f0(sourceString, \"botnet.c\", 0x42b);\n    \n    int checkValue = *(int *)(baseIndex + _DAT_10077ffc);\n    if (checkValue >= 0) {\n        retrievedValue = FUN_10038c20(*(uint32_t *)(baseIndex + _DAT_10077ffc + 4));\n        int result = FUN_1003a5d0(checkValue, retrievedValue, *(uint32_t *)(baseIndex + _DAT_10077ffc + 8));\n        \n        if (result >= 0) {\n            return;\n        }\n    }\n    \n    FUN_10024db0(param_1);\n    return;\n}",
        "baseline_code_stripped": "void FUN_10011df0(int param_1)\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined4 uVar5;\n  char *__src;\n  iVar1 = param_1 * 0x188;\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc + 0x184);\n  uVar5 = *(undefined4 *)(iVar3 + 0x18);\n  *(undefined4 *)(iVar1 + _DAT_10077ffc + 4) = *(undefined4 *)(iVar3 + 0x14);\n  __src = *(char **)(iVar3 + 0x10);\n  FUN_10027460(param_1,&PTR_s_FORK_BOT_10075e48,0x9c);\n  iVar3 = iVar1 + _DAT_10077ffc;\n  *(undefined4 *)(iVar3 + 0x17c) = _DAT_100780c4;\n  strcpy((char *)(*(int *)(iVar3 + 0x184) + 0x79),__src);\n  iVar3 = _DAT_10077ffc;\n  iVar2 = iVar1 + _DAT_10077ffc;\n  puVar4 = *(undefined4 **)(iVar2 + 0x184);\n  puVar4[2] = 0x76652062;\n  puVar4[3] = 0x6f742900;\n  puVar4[1] = 0x6d697469;\n  *puVar4 = 0x28707269;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x90) = uVar5;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x94) = *(undefined4 *)(iVar2 + 8);\n  uVar5 = FUN_10039320(0x20);\n  *(undefined4 *)(iVar1 + iVar3) = uVar5;\n  FUN_100319f0(__src,\"botnet.c\",0x42b);\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc);\n  if (-1 < iVar3) {\n    uVar5 = FUN_10038c20(*(undefined4 *)(iVar1 + _DAT_10077ffc + 4));\n    iVar1 = FUN_1003a5d0(iVar3,uVar5,*(undefined4 *)(iVar1 + _DAT_10077ffc + 8));\n    if (-1 < iVar1) {\n      return;\n    }\n  }\n  FUN_10024db0(param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.43362775444984436,
        "similarity_score_baseline_stripped": 0.4765426218509674
    },
    {
        "func_name": "truncate64",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint truncate64(char *__file,__off64_t __length)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  uVar1 = (**(code **)(in_GS_OFFSET + 0x10))();\n  if (0xfffff000 < uVar1) {\n    *(uint *)((undefined *)0x8 + in_GS_OFFSET) = -uVar1;\n    uVar1 = 0xffffffff;\n  }\n  return uVar1;\n}",
        "output": "```c\n#include <stdint.h>\n\nint truncate64(char *file, __off64_t length) {\n    uint32_t result;\n    int gs_offset;\n\n    result = (**(code **)(gs_offset + 0x10))();\n\n    if (result > 0xfffff000) {\n        *(uint32_t *)((undefined *)0x8 + gs_offset) = -result;\n        result = 0xffffffff;\n    }\n\n    return result;\n}\n```",
        "normed_func_sha256": "ef59824173e1837ee91fe70d42957dccc71cf4f253c65ae334e63dda8115f708",
        "source_code": "int\ntruncate64 (const char *path, off64_t length)\n{\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n  if (! __have_no_truncate64)\n#endif\n    {\n      unsigned int low = length & 0xffffffff;\n      unsigned int high = length >> 32;\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n      int saved_errno = errno;\n#endif\n      int result = INLINE_SYSCALL (truncate64, 3, CHECK_STRING (path),\n\t\t\t\t   __LONG_LONG_PAIR (high, low));\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n      if (result != -1 || errno != ENOSYS)\n#endif\n\treturn result;\n\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n      __set_errno (saved_errno);\n      __have_no_truncate64 = 1;\n#endif\n    }\n\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n  if ((off_t) length != length)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  return __truncate (path, (off_t) length);\n#endif\n}",
        "parsed_output": "#include <stdint.h>\n\nint truncate64(char *file, __off64_t length) {\n    uint32_t result;\n    int gs_offset;\n\n    result = (**(code **)(gs_offset + 0x10))();\n\n    if (result > 0xfffff000) {\n        *(uint32_t *)((undefined *)0x8 + gs_offset) = -result;\n        result = 0xffffffff;\n    }\n\n    return result;\n}",
        "baseline_code_stripped": "int truncate64(char *__file,__off64_t __length)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  uVar1 = (**(code **)(in_GS_OFFSET + 0x10))();\n  if (0xfffff000 < uVar1) {\n    *(uint *)((undefined *)0x8 + in_GS_OFFSET) = -uVar1;\n    uVar1 = 0xffffffff;\n  }\n  return uVar1;\n}",
        "similarity_score_unixcoder": 0.7510965466499329,
        "similarity_score_baseline_stripped": 0.6443058848381042
    },
    {
        "func_name": "ByteString_CreateFromInt32",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nbinfilter * __thiscall\nbinfilter::ByteString_CreateFromInt32(binfilter *this,long param_1,short param_2)\n{\n  ushort uVar1;\n  int in_GS_OFFSET;\n  char local_31 [33];\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar1 = rtl_str_valueOfInt32(local_31,param_1,(int)param_2);\n  ByteString::ByteString((ByteString *)this,local_31,uVar1);\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return this;\n  }\n  FUN_0019b1f0();\n}",
        "output": "```c\nbinfilter * __thiscall\nbinfilter::ByteString_CreateFromInt32(binfilter *this, long integerValue, short base)\n{\n    ushort stringLength;\n    int stackGuard;\n    char stringBuffer[33];\n    int localGuard;\n\n    localGuard = *(int *)(stackGuard + 0x14);\n    stringLength = rtl_str_valueOfInt32(stringBuffer, integerValue, (int)base);\n    ByteString::ByteString((ByteString *)this, stringBuffer, stringLength);\n\n    if (localGuard == *(int *)(stackGuard + 0x14)) {\n        return this;\n    }\n    \n    FUN_0019b1f0();\n}\n```",
        "normed_func_sha256": "7d289aa6ea103094a0f31a150ef7fafefe5fa908bfa7516227bace0055418cd4",
        "source_code": "ByteString ByteString_CreateFromInt32(sal_Int32 n, sal_Int16 nRadix)\n    {\n        sal_Char aBuf[RTL_STR_MAX_VALUEOFINT32];\n        BOOST_STATIC_ASSERT(RTL_STR_MAX_VALUEOFINT32 <= STRING_MAXLEN);\n        return ByteString(\n            aBuf,\n            static_cast< xub_StrLen >(rtl_str_valueOfInt32( aBuf, n, nRadix )) );\n    }",
        "parsed_output": "binfilter * __thiscall\nbinfilter::ByteString_CreateFromInt32(binfilter *this, long integerValue, short base)\n{\n    ushort stringLength;\n    int stackGuard;\n    char stringBuffer[33];\n    int localGuard;\n\n    localGuard = *(int *)(stackGuard + 0x14);\n    stringLength = rtl_str_valueOfInt32(stringBuffer, integerValue, (int)base);\n    ByteString::ByteString((ByteString *)this, stringBuffer, stringLength);\n\n    if (localGuard == *(int *)(stackGuard + 0x14)) {\n        return this;\n    }\n    \n    FUN_0019b1f0();\n}",
        "baseline_code_stripped": "binfilter * __thiscall\nbinfilter::ByteString_CreateFromInt32(binfilter *this,long param_1,short param_2)\n{\n  ushort uVar1;\n  int in_GS_OFFSET;\n  char local_31 [33];\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar1 = rtl_str_valueOfInt32(local_31,param_1,(int)param_2);\n  ByteString::ByteString((ByteString *)this,local_31,uVar1);\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return this;\n  }\n  FUN_0019b1f0();\n}",
        "similarity_score_unixcoder": 0.6552784442901611,
        "similarity_score_baseline_stripped": 0.5975655913352966
    },
    {
        "func_name": "save_as_application_proceed",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_001b07d8(longlong param_1)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 in_r8;\n  longlong in_r13;\n  longlong local_88;\n  longlong local_40;\n  longlong local_38;\n  local_38 = *(longlong *)(in_r13 + -0x7010);\n  local_40 = 0;\n  iVar1 = FUN_00148400(*(undefined8 *)(param_1 + 0x30),*(undefined8 *)(param_1 + 0x10),\n                       *(undefined8 *)(param_1 + 0x38),*(undefined4 *)(param_1 + 0x68),&local_40,\n                       in_r8,0,0);\n  if (iVar1 == 0) {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d48,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(local_40 + 8));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n  }\n  else {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d78,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n    uVar4 = FUN_00152220(0,local_88 + -0x47d10,5);\n    FUN_00143f80(uVar3,uVar4,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30)\n                );\n    FUN_001452c0(uVar3,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30));\n    uVar4 = FUN_00149ec0(*(undefined8 *)(param_1 + 0x30));\n    FUN_0014d740(2,0,local_88 + -0xa76b0,uVar4);\n    FUN_00144ac0(0);\n  }\n  FUN_001459a0(uVar3,1);\n  uVar4 = FUN_001479c0();\n  FUN_001508a0(uVar4,*(undefined8 *)(param_1 + 0x28),uVar3);\n  FUN_001b06a8(param_1);\n  if (local_40 != 0) {\n    FUN_00151b40();\n  }\n  FUN_00144ac0(uVar2);\n  if (local_38 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  FUN_0014f3a0();\n}",
        "output": "```c\nvoid processFunction(longlong param_1)\n{\n    int result;\n    undefined8 intermediateValue1;\n    undefined8 intermediateValue2;\n    undefined8 intermediateValue3;\n    undefined8 inputValue;\n    longlong referenceValue;\n    longlong localVariable88;\n    longlong localVariable40;\n    longlong localVariable38;\n\n    localVariable38 = *(longlong *)(referenceValue + -0x7010);\n    localVariable40 = 0;\n\n    result = FUN_00148400(\n        *(undefined8 *)(param_1 + 0x30),\n        *(undefined8 *)(param_1 + 0x10),\n        *(undefined8 *)(param_1 + 0x38),\n        *(undefined4 *)(param_1 + 0x68),\n        &localVariable40,\n        inputValue,\n        0,\n        0\n    );\n\n    if (result == 0) {\n        intermediateValue1 = FUN_00152220(0, localVariable88 - 0x47d48, 5);\n        intermediateValue1 = FUN_001536e0(intermediateValue1, *(undefined8 *)(param_1 + 0x28), *(undefined8 *)(localVariable40 + 8));\n        intermediateValue2 = FUN_0014b9a0();\n\n        if (*(longlong *)(param_1 + 0x58) != 0) {\n            FUN_0014d380();\n        }\n    } else {\n        intermediateValue1 = FUN_00152220(0, localVariable88 - 0x47d78, 5);\n        intermediateValue1 = FUN_001536e0(intermediateValue1, *(undefined8 *)(param_1 + 0x28));\n        intermediateValue2 = FUN_0014b9a0();\n\n        if (*(longlong *)(param_1 + 0x58) != 0) {\n            FUN_0014d380();\n        }\n\n        intermediateValue3 = FUN_00152220(0, localVariable88 - 0x47d10, 5);\n        FUN_00143f80(intermediateValue2, intermediateValue3, localVariable88 - 0x47d08, localVariable88 - 0x4bd08, *(undefined8 *)(param_1 + 0x30));\n        FUN_001452c0(intermediateValue2, localVariable88 - 0x47d08, localVariable88 - 0x4bd08, *(undefined8 *)(param_1 + 0x30));\n        intermediateValue3 = FUN_00149ec0(*(undefined8 *)(param_1 + 0x30));\n        FUN_0014d740(2, 0, localVariable88 - 0xa76b0, intermediateValue3);\n        FUN_00144ac0(0);\n    }\n\n    FUN_001459a0(intermediateValue2, 1);\n    intermediateValue3 = FUN_001479c0();\n    FUN_001508a0(intermediateValue3, *(undefined8 *)(param_1 + 0x28), intermediateValue2);\n    FUN_001b06a8(param_1);\n\n    if (localVariable40 != 0) {\n        FUN_00151b40();\n    }\n\n    FUN_00144ac0(intermediateValue1);\n\n    if (localVariable38 == *(longlong *)(referenceValue + -0x7010)) {\n        return;\n    }\n\n    FUN_0014f3a0();\n}\n```",
        "normed_func_sha256": "f14a16a1ca5b344a98cdf047dc65aaa0e72eec918d30dd77d74214e31d86ccfc",
        "source_code": "static void\nsave_as_application_proceed (EphyApplicationDialogData *data)\n{\n  g_autofree char *message = NULL;\n  GNotification *notification;\n  gboolean success;\n  g_autoptr (GError) error = NULL;\n\n  /* Create Web Application, including a new profile and .desktop file. */\n  success = ephy_web_application_create (data->app_id,\n                                         data->url,\n                                         data->token,\n                                         data->webapp_options,\n                                         &error);\n\n  if (success)\n    message = g_strdup_printf (_(\"The application \u201c%s\u201d is ready to be used\"),\n                               data->chosen_name);\n  else\n    message = g_strdup_printf (_(\"The application \u201c%s\u201d could not be created: %s\"),\n                               data->chosen_name, error->message);\n\n  notification = g_notification_new (message);\n\n  if (data->framed_pixbuf)\n    g_notification_set_icon (notification, G_ICON (data->framed_pixbuf));\n\n  if (success) {\n    /* Translators: Desktop notification when a new web app is created. */\n    g_notification_add_button_with_target (notification, _(\"Launch\"), \"app.launch-app\", \"s\", data->app_id);\n    g_notification_set_default_action_and_target (notification, \"app.launch-app\", \"s\", data->app_id);\n\n    ephy_focus_desktop_app (data->app_id);\n  }\n\n  g_notification_set_priority (notification, G_NOTIFICATION_PRIORITY_LOW);\n\n  g_application_send_notification (G_APPLICATION (g_application_get_default ()), data->chosen_name, notification);\n\n  ephy_application_dialog_data_free (data);\n}",
        "parsed_output": "void processFunction(longlong param_1)\n{\n    int result;\n    undefined8 intermediateValue1;\n    undefined8 intermediateValue2;\n    undefined8 intermediateValue3;\n    undefined8 inputValue;\n    longlong referenceValue;\n    longlong localVariable88;\n    longlong localVariable40;\n    longlong localVariable38;\n\n    localVariable38 = *(longlong *)(referenceValue + -0x7010);\n    localVariable40 = 0;\n\n    result = FUN_00148400(\n        *(undefined8 *)(param_1 + 0x30),\n        *(undefined8 *)(param_1 + 0x10),\n        *(undefined8 *)(param_1 + 0x38),\n        *(undefined4 *)(param_1 + 0x68),\n        &localVariable40,\n        inputValue,\n        0,\n        0\n    );\n\n    if (result == 0) {\n        intermediateValue1 = FUN_00152220(0, localVariable88 - 0x47d48, 5);\n        intermediateValue1 = FUN_001536e0(intermediateValue1, *(undefined8 *)(param_1 + 0x28), *(undefined8 *)(localVariable40 + 8));\n        intermediateValue2 = FUN_0014b9a0();\n\n        if (*(longlong *)(param_1 + 0x58) != 0) {\n            FUN_0014d380();\n        }\n    } else {\n        intermediateValue1 = FUN_00152220(0, localVariable88 - 0x47d78, 5);\n        intermediateValue1 = FUN_001536e0(intermediateValue1, *(undefined8 *)(param_1 + 0x28));\n        intermediateValue2 = FUN_0014b9a0();\n\n        if (*(longlong *)(param_1 + 0x58) != 0) {\n            FUN_0014d380();\n        }\n\n        intermediateValue3 = FUN_00152220(0, localVariable88 - 0x47d10, 5);\n        FUN_00143f80(intermediateValue2, intermediateValue3, localVariable88 - 0x47d08, localVariable88 - 0x4bd08, *(undefined8 *)(param_1 + 0x30));\n        FUN_001452c0(intermediateValue2, localVariable88 - 0x47d08, localVariable88 - 0x4bd08, *(undefined8 *)(param_1 + 0x30));\n        intermediateValue3 = FUN_00149ec0(*(undefined8 *)(param_1 + 0x30));\n        FUN_0014d740(2, 0, localVariable88 - 0xa76b0, intermediateValue3);\n        FUN_00144ac0(0);\n    }\n\n    FUN_001459a0(intermediateValue2, 1);\n    intermediateValue3 = FUN_001479c0();\n    FUN_001508a0(intermediateValue3, *(undefined8 *)(param_1 + 0x28), intermediateValue2);\n    FUN_001b06a8(param_1);\n\n    if (localVariable40 != 0) {\n        FUN_00151b40();\n    }\n\n    FUN_00144ac0(intermediateValue1);\n\n    if (localVariable38 == *(longlong *)(referenceValue + -0x7010)) {\n        return;\n    }\n\n    FUN_0014f3a0();\n}",
        "baseline_code_stripped": "void FUN_001b07d8(longlong param_1)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 in_r8;\n  longlong in_r13;\n  longlong local_88;\n  longlong local_40;\n  longlong local_38;\n  local_38 = *(longlong *)(in_r13 + -0x7010);\n  local_40 = 0;\n  iVar1 = FUN_00148400(*(undefined8 *)(param_1 + 0x30),*(undefined8 *)(param_1 + 0x10),\n                       *(undefined8 *)(param_1 + 0x38),*(undefined4 *)(param_1 + 0x68),&local_40,\n                       in_r8,0,0);\n  if (iVar1 == 0) {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d48,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(local_40 + 8));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n  }\n  else {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d78,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n    uVar4 = FUN_00152220(0,local_88 + -0x47d10,5);\n    FUN_00143f80(uVar3,uVar4,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30)\n                );\n    FUN_001452c0(uVar3,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30));\n    uVar4 = FUN_00149ec0(*(undefined8 *)(param_1 + 0x30));\n    FUN_0014d740(2,0,local_88 + -0xa76b0,uVar4);\n    FUN_00144ac0(0);\n  }\n  FUN_001459a0(uVar3,1);\n  uVar4 = FUN_001479c0();\n  FUN_001508a0(uVar4,*(undefined8 *)(param_1 + 0x28),uVar3);\n  FUN_001b06a8(param_1);\n  if (local_40 != 0) {\n    FUN_00151b40();\n  }\n  FUN_00144ac0(uVar2);\n  if (local_38 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  FUN_0014f3a0();\n}",
        "similarity_score_unixcoder": 0.38363757729530334,
        "similarity_score_baseline_stripped": 0.40226635336875916
    },
    {
        "func_name": "_wrap_meep_grid_volume_icenter",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00058de0(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined local_48 [4];\n  undefined4 local_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  undefined4 uStack_38;\n  undefined4 local_34;\n  undefined4 uStack_30;\n  undefined4 local_2c;\n  undefined4 uStack_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 local_1c;\n  undefined4 uStack_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  iVar1 = FUN_0002aef4(param_1,local_48,DAT_000e6ce8,0);\n  if (iVar1 < 0) {\n    scm_wrong_type_arg(\"meep-grid-volume-icenter\",1,param_1);\n  }\n  meep::grid_volume::icenter();\n  local_44 = local_2c;\n  uStack_40 = uStack_28;\n  uStack_3c = uStack_24;\n  uStack_38 = uStack_20;\n  local_34 = local_1c;\n  uStack_30 = uStack_18;\n  puVar2 = (undefined4 *)operator_new(0x18);\n  local_44 = local_2c;\n  *puVar2 = local_2c;\n  puVar2[1] = uStack_40;\n  puVar2[2] = uStack_3c;\n  puVar2[3] = uStack_38;\n  puVar2[4] = local_34;\n  puVar2[5] = uStack_30;\n  FUN_0002b164(puVar2,DAT_000e6d00,1);\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nvoid process_grid_volume(undefined4 param_1) {\n    int result;\n    undefined4 *dataPointer;\n    undefined local_buffer[4];\n    undefined4 local_value_1;\n    undefined4 stack_value_1;\n    undefined4 stack_value_2;\n    undefined4 stack_value_3;\n    undefined4 local_value_2;\n    undefined4 stack_value_4;\n    undefined4 local_value_3;\n    undefined4 stack_value_5;\n    undefined4 stack_value_6;\n    undefined4 stack_value_7;\n    undefined4 local_value_4;\n    undefined4 stack_value_8;\n    int stack_guard_value;\n    \n    stack_guard_value = __stack_chk_guard;\n    result = FUN_0002aef4(param_1, local_buffer, DAT_000e6ce8, 0);\n    \n    if (result < 0) {\n        scm_wrong_type_arg(\"meep-grid-volume-icenter\", 1, param_1);\n    }\n    \n    meep::grid_volume::icenter();\n    \n    local_value_1 = local_value_3;\n    stack_value_1 = stack_value_5;\n    stack_value_2 = stack_value_6;\n    stack_value_3 = stack_value_7;\n    local_value_2 = local_value_4;\n    stack_value_4 = stack_value_8;\n    \n    dataPointer = (undefined4 *)operator_new(0x18);\n    \n    local_value_1 = local_value_3;\n    *dataPointer = local_value_3;\n    dataPointer[1] = stack_value_1;\n    dataPointer[2] = stack_value_2;\n    dataPointer[3] = stack_value_3;\n    dataPointer[4] = local_value_2;\n    dataPointer[5] = stack_value_4;\n    \n    FUN_0002b164(dataPointer, DAT_000e6d00, 1);\n    \n    if (stack_guard_value == __stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}\n```",
        "normed_func_sha256": "5f2c1e968960a76781eb3f969cc9f4071c3bb34c2b8642b6058203432a8b905b",
        "source_code": "static SCM\n_wrap_meep_grid_volume_icenter (SCM s_0)\n{\n#define FUNC_NAME \"meep-grid-volume-icenter\"\n  meep::grid_volume *arg1 = (meep::grid_volume *) 0 ;\n  SCM gswig_result;\n  SWIGUNUSED int gswig_list_p = 0;\n  meep::ivec result;\n  \n  {\n    arg1 = (meep::grid_volume *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_meep__grid_volume, 1, 0);\n  }\n  result = ((meep::grid_volume const *)arg1)->icenter();\n  {\n    meep::ivec * resultptr;\n    resultptr = new meep::ivec((const meep::ivec &) result);\n    gswig_result =  SWIG_NewPointerObj (resultptr, SWIGTYPE_p_meep__ivec, 1);\n  }\n  \n  \n  return gswig_result;\n#undef FUNC_NAME\n}",
        "parsed_output": "void process_grid_volume(undefined4 param_1) {\n    int result;\n    undefined4 *dataPointer;\n    undefined local_buffer[4];\n    undefined4 local_value_1;\n    undefined4 stack_value_1;\n    undefined4 stack_value_2;\n    undefined4 stack_value_3;\n    undefined4 local_value_2;\n    undefined4 stack_value_4;\n    undefined4 local_value_3;\n    undefined4 stack_value_5;\n    undefined4 stack_value_6;\n    undefined4 stack_value_7;\n    undefined4 local_value_4;\n    undefined4 stack_value_8;\n    int stack_guard_value;\n    \n    stack_guard_value = __stack_chk_guard;\n    result = FUN_0002aef4(param_1, local_buffer, DAT_000e6ce8, 0);\n    \n    if (result < 0) {\n        scm_wrong_type_arg(\"meep-grid-volume-icenter\", 1, param_1);\n    }\n    \n    meep::grid_volume::icenter();\n    \n    local_value_1 = local_value_3;\n    stack_value_1 = stack_value_5;\n    stack_value_2 = stack_value_6;\n    stack_value_3 = stack_value_7;\n    local_value_2 = local_value_4;\n    stack_value_4 = stack_value_8;\n    \n    dataPointer = (undefined4 *)operator_new(0x18);\n    \n    local_value_1 = local_value_3;\n    *dataPointer = local_value_3;\n    dataPointer[1] = stack_value_1;\n    dataPointer[2] = stack_value_2;\n    dataPointer[3] = stack_value_3;\n    dataPointer[4] = local_value_2;\n    dataPointer[5] = stack_value_4;\n    \n    FUN_0002b164(dataPointer, DAT_000e6d00, 1);\n    \n    if (stack_guard_value == __stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "void FUN_00058de0(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined local_48 [4];\n  undefined4 local_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  undefined4 uStack_38;\n  undefined4 local_34;\n  undefined4 uStack_30;\n  undefined4 local_2c;\n  undefined4 uStack_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 local_1c;\n  undefined4 uStack_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  iVar1 = FUN_0002aef4(param_1,local_48,DAT_000e6ce8,0);\n  if (iVar1 < 0) {\n    scm_wrong_type_arg(\"meep-grid-volume-icenter\",1,param_1);\n  }\n  meep::grid_volume::icenter();\n  local_44 = local_2c;\n  uStack_40 = uStack_28;\n  uStack_3c = uStack_24;\n  uStack_38 = uStack_20;\n  local_34 = local_1c;\n  uStack_30 = uStack_18;\n  puVar2 = (undefined4 *)operator_new(0x18);\n  local_44 = local_2c;\n  *puVar2 = local_2c;\n  puVar2[1] = uStack_40;\n  puVar2[2] = uStack_3c;\n  puVar2[3] = uStack_38;\n  puVar2[4] = local_34;\n  puVar2[5] = uStack_30;\n  FUN_0002b164(puVar2,DAT_000e6d00,1);\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.6873957514762878,
        "similarity_score_baseline_stripped": 0.6443890929222107
    },
    {
        "func_name": "remoteDomainGetGuestInfo",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4\nFUN_003f3652(long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,\n            undefined4 param_5)\n{\n  undefined8 uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  undefined4 local_54;\n  undefined4 local_48 [2];\n  undefined8 local_40;\n  undefined local_38 [32];\n  undefined4 local_18;\n  undefined4 local_14;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_54 = 0xffffffff;\n  uVar1 = *(undefined8 *)(*(long *)(param_1 + 0x18) + 0x88);\n  FUN_003ca6fa(uVar1);\n  FUN_003f3f4c(local_38,param_1);\n  local_18 = param_2;\n  local_14 = param_5;\n  memset(local_48,0,0x10);\n  iVar2 = FUN_003efead(*(undefined8 *)(param_1 + 0x18),uVar1,0,0x1a2,\n                       xdr_remote_domain_get_guest_info_args,local_38,\n                       xdr_remote_domain_get_guest_info_ret,local_48,param_4,param_3,param_5);\n  if (iVar2 != -1) {\n    iVar2 = virTypedParamsDeserialize(local_40,local_48[0],0x800,param_3,param_4);\n    if (-1 < iVar2) {\n      local_54 = 0;\n    }\n    xdr_free(xdr_remote_domain_get_guest_info_ret,(char *)local_48);\n  }\n  FUN_003ca71a(uVar1);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return local_54;\n}",
        "output": "```c\nundefined4 FUN_003f3652(long param_1, undefined4 param_2, undefined8 param_3, undefined8 param_4, undefined4 param_5) {\n    undefined8 guestInfoHandle;\n    int result;\n    long stackGuard;\n    undefined4 returnValue = 0xffffffff;\n    undefined4 responseParams[2];\n    undefined8 deserializedParams;\n    undefined localBuffer[32];\n    undefined4 arg2 = param_2;\n    undefined4 arg5 = param_5;\n\n    stackGuard = *(long *)(in_FS_OFFSET + 0x28);\n    guestInfoHandle = *(undefined8 *)(*(long *)(param_1 + 0x18) + 0x88);\n    \n    FUN_003ca6fa(guestInfoHandle);\n    FUN_003f3f4c(localBuffer, param_1);\n    \n    memset(responseParams, 0, sizeof(responseParams));\n    \n    result = FUN_003efead(\n        *(undefined8 *)(param_1 + 0x18),\n        guestInfoHandle,\n        0,\n        0x1a2,\n        xdr_remote_domain_get_guest_info_args,\n        localBuffer,\n        xdr_remote_domain_get_guest_info_ret,\n        responseParams,\n        param_4,\n        param_3,\n        param_5\n    );\n\n    if (result != -1) {\n        result = virTypedParamsDeserialize(deserializedParams, responseParams[0], 0x800, param_3, param_4);\n        if (result >= 0) {\n            returnValue = 0;\n        }\n        xdr_free(xdr_remote_domain_get_guest_info_ret, (char *)responseParams);\n    }\n    \n    FUN_003ca71a(guestInfoHandle);\n    \n    if (stackGuard != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n    \n    return returnValue;\n}\n```",
        "normed_func_sha256": "11ac12fba50d67b18e05e56afecdba6c7683af36674a47348feb748fc8fbad20",
        "source_code": "static int\nremoteDomainGetGuestInfo(virDomainPtr dom,\n                         unsigned int types,\n                         virTypedParameterPtr *params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    int rv = -1;\n    struct private_data *priv = dom->conn->privateData;\n    remote_domain_get_guest_info_args args;\n    remote_domain_get_guest_info_ret ret;\n\n    remoteDriverLock(priv);\n\n    make_nonnull_domain(&args.dom, dom);\n\n    args.types = types;\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n\n    if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_GET_GUEST_INFO,\n             (xdrproc_t)xdr_remote_domain_get_guest_info_args, (char *)&args,\n             (xdrproc_t)xdr_remote_domain_get_guest_info_ret, (char *)&ret) == -1)\n        goto done;\n\n    if (virTypedParamsDeserialize((struct _virTypedParameterRemote *) ret.params.params_val,\n                                  ret.params.params_len,\n                                  REMOTE_DOMAIN_GUEST_INFO_PARAMS_MAX,\n                                  params,\n                                  nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_remote_domain_get_guest_info_ret,\n             (char *) &ret);\n\n done:\n    remoteDriverUnlock(priv);\n    return rv;\n}",
        "parsed_output": "undefined4 FUN_003f3652(long param_1, undefined4 param_2, undefined8 param_3, undefined8 param_4, undefined4 param_5) {\n    undefined8 guestInfoHandle;\n    int result;\n    long stackGuard;\n    undefined4 returnValue = 0xffffffff;\n    undefined4 responseParams[2];\n    undefined8 deserializedParams;\n    undefined localBuffer[32];\n    undefined4 arg2 = param_2;\n    undefined4 arg5 = param_5;\n\n    stackGuard = *(long *)(in_FS_OFFSET + 0x28);\n    guestInfoHandle = *(undefined8 *)(*(long *)(param_1 + 0x18) + 0x88);\n    \n    FUN_003ca6fa(guestInfoHandle);\n    FUN_003f3f4c(localBuffer, param_1);\n    \n    memset(responseParams, 0, sizeof(responseParams));\n    \n    result = FUN_003efead(\n        *(undefined8 *)(param_1 + 0x18),\n        guestInfoHandle,\n        0,\n        0x1a2,\n        xdr_remote_domain_get_guest_info_args,\n        localBuffer,\n        xdr_remote_domain_get_guest_info_ret,\n        responseParams,\n        param_4,\n        param_3,\n        param_5\n    );\n\n    if (result != -1) {\n        result = virTypedParamsDeserialize(deserializedParams, responseParams[0], 0x800, param_3, param_4);\n        if (result >= 0) {\n            returnValue = 0;\n        }\n        xdr_free(xdr_remote_domain_get_guest_info_ret, (char *)responseParams);\n    }\n    \n    FUN_003ca71a(guestInfoHandle);\n    \n    if (stackGuard != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n    \n    return returnValue;\n}",
        "baseline_code_stripped": "undefined4\nFUN_003f3652(long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,\n            undefined4 param_5)\n{\n  undefined8 uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  undefined4 local_54;\n  undefined4 local_48 [2];\n  undefined8 local_40;\n  undefined local_38 [32];\n  undefined4 local_18;\n  undefined4 local_14;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_54 = 0xffffffff;\n  uVar1 = *(undefined8 *)(*(long *)(param_1 + 0x18) + 0x88);\n  FUN_003ca6fa(uVar1);\n  FUN_003f3f4c(local_38,param_1);\n  local_18 = param_2;\n  local_14 = param_5;\n  memset(local_48,0,0x10);\n  iVar2 = FUN_003efead(*(undefined8 *)(param_1 + 0x18),uVar1,0,0x1a2,\n                       xdr_remote_domain_get_guest_info_args,local_38,\n                       xdr_remote_domain_get_guest_info_ret,local_48,param_4,param_3,param_5);\n  if (iVar2 != -1) {\n    iVar2 = virTypedParamsDeserialize(local_40,local_48[0],0x800,param_3,param_4);\n    if (-1 < iVar2) {\n      local_54 = 0;\n    }\n    xdr_free(xdr_remote_domain_get_guest_info_ret,(char *)local_48);\n  }\n  FUN_003ca71a(uVar1);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return local_54;\n}",
        "similarity_score_unixcoder": 0.7063804864883423,
        "similarity_score_baseline_stripped": 0.6256576776504517
    },
    {
        "func_name": "dino_entities_message_get_real_jid",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 dino_entities_message_get_real_jid(int param_1)\n{\n  if (param_1 != 0) {\n    return *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x14);\n  }\n  g_return_if_fail_warning(\"libdino\",\"dino_entities_message_get_real_jid\",\"self != NULL\");\n  return 0;\n}",
        "output": "```c\nuint32_t dino_entities_message_get_real_jid(int entity)\n{\n    if (entity != 0) {\n        return *(uint32_t *)(*(int *)(entity + 0xc) + 0x14);\n    }\n    g_return_if_fail_warning(\"libdino\", \"dino_entities_message_get_real_jid\", \"entity != NULL\");\n    return 0;\n}\n```",
        "normed_func_sha256": "c6b9c1e0af59c12795773ec2273afdbaacf73d0a8b10047eab11045269403fc3",
        "source_code": "XmppJid*\ndino_entities_message_get_real_jid (DinoEntitiesMessage* self)\n{\n\tXmppJid* result;\n\tXmppJid* _tmp0_;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\tg_return_val_if_fail (self != NULL, NULL);\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\t_tmp0_ = self->priv->_real_jid;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\tresult = _tmp0_;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\treturn result;\n#line 2816 \"message.c\"\n}",
        "parsed_output": "uint32_t dino_entities_message_get_real_jid(int entity)\n{\n    if (entity != 0) {\n        return *(uint32_t *)(*(int *)(entity + 0xc) + 0x14);\n    }\n    g_return_if_fail_warning(\"libdino\", \"dino_entities_message_get_real_jid\", \"entity != NULL\");\n    return 0;\n}",
        "baseline_code_stripped": "undefined4 dino_entities_message_get_real_jid(int param_1)\n{\n  if (param_1 != 0) {\n    return *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x14);\n  }\n  g_return_if_fail_warning(\"libdino\",\"dino_entities_message_get_real_jid\",\"self != NULL\");\n  return 0;\n}",
        "similarity_score_unixcoder": 0.6569542288780212,
        "similarity_score_baseline_stripped": 0.7007763981819153
    },
    {
        "func_name": "sipQgsLayoutView::showEvent",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_004dc6c4(int *param_1)\n{\n  undefined4 uVar1;\n  uVar1 = PyEval_SaveThread();\n  if (param_1 != (int *)0x0) {\n    (**(code **)(*param_1 + 4))(param_1);\n  }\n  PyEval_RestoreThread(uVar1);\n  return;\n}",
        "output": "```c\nvoid RestoreThreadAndExecute(int *param_1)\n{\n    undefined4 savedThreadState;\n    savedThreadState = PyEval_SaveThread();\n    \n    if (param_1 != NULL) {\n        void (*executeFunction)(int *) = (void (*)(int *))(*param_1 + 4);\n        executeFunction(param_1);\n    }\n    \n    PyEval_RestoreThread(savedThreadState);\n}\n```",
        "normed_func_sha256": "1a6bc7810dbed627cc7cf033d7c2b28cc099ff9edde8c0816daeccba084dfb7b",
        "source_code": "void sipQgsLayoutView::showEvent( ::QShowEvent*a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[13],sipPySelf,NULL,sipName_showEvent);\n\n    if (!sipMeth)\n    {\n         ::QgsLayoutView::showEvent(a0);\n        return;\n    }\n\n    extern void sipVH__gui_30(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QShowEvent*);\n\n    sipVH__gui_30(sipGILState, sipImportedVirtErrorHandlers__gui_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);\n}",
        "parsed_output": "void RestoreThreadAndExecute(int *param_1)\n{\n    undefined4 savedThreadState;\n    savedThreadState = PyEval_SaveThread();\n    \n    if (param_1 != NULL) {\n        void (*executeFunction)(int *) = (void (*)(int *))(*param_1 + 4);\n        executeFunction(param_1);\n    }\n    \n    PyEval_RestoreThread(savedThreadState);\n}",
        "baseline_code_stripped": "void FUN_004dc6c4(int *param_1)\n{\n  undefined4 uVar1;\n  uVar1 = PyEval_SaveThread();\n  if (param_1 != (int *)0x0) {\n    (**(code **)(*param_1 + 4))(param_1);\n  }\n  PyEval_RestoreThread(uVar1);\n  return;\n}",
        "similarity_score_unixcoder": 0.4784028232097626,
        "similarity_score_baseline_stripped": 0.4899625778198242
    },
    {
        "func_name": "_wrap_ephy_password_manager_add_password",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined1 * FUN_004ca070(long param_1,undefined8 param_2,undefined8 param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined1 *puVar6;\n  long local_18;\n  iVar3 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"O:EphyPasswordManager.add_password\",&PTR_s_info_00620a90,\n                     &local_18);\n  puVar6 = (undefined1 *)0x0;\n  if (iVar3 != 0) {\n    if (((*(long *)(local_18 + 8) == *(long *)(_PyGObject_API + 0x80)) ||\n        (iVar3 = PyType_IsSubtype(), iVar3 != 0)) &&\n       (lVar1 = *(long *)(local_18 + 0x18), lVar4 = ephy_password_info_get_type(), lVar1 == lVar4))\n    {\n      uVar2 = *(undefined8 *)(local_18 + 0x10);\n      uVar5 = ephy_password_manager_get_type();\n      uVar5 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 0x10),uVar5);\n      ephy_password_manager_add_password(uVar5,uVar2);\n      _Py_NoneStruct._0_4_ = _Py_NoneStruct._0_4_ + 1;\n      puVar6 = _Py_NoneStruct;\n    }\n    else {\n      PyErr_SetString(PyExc_TypeError,\"info should be a EphyPasswordInfo\");\n      puVar6 = (undefined1 *)0x0;\n    }\n  }\n  return puVar6;\n}",
        "output": "```c\nundefined1 * EphyPasswordManager_add_password(long param_1, undefined8 param_2, undefined8 param_3) {\n    long passwordInfoPtr;\n    undefined8 passwordData;\n    int parseResult;\n    long passwordInfoType;\n    undefined8 passwordManagerType;\n    undefined1 *result = (undefined1 *)0x0;\n    long local_18;\n\n    parseResult = PyArg_ParseTupleAndKeywords(param_2, param_3, \"O:EphyPasswordManager.add_password\", &PTR_s_info_00620a90, &local_18);\n    \n    if (parseResult != 0) {\n        if (((*(long *)(local_18 + 8) == *(long *)(_PyGObject_API + 0x80)) || \n            (parseResult = PyType_IsSubtype(), parseResult != 0)) && \n            (passwordInfoPtr = *(long *)(local_18 + 0x18), \n            passwordInfoType = ephy_password_info_get_type(), \n            passwordInfoPtr == passwordInfoType)) {\n            \n            passwordData = *(undefined8 *)(local_18 + 0x10);\n            passwordManagerType = ephy_password_manager_get_type();\n            passwordManagerType = g_type_check_instance_cast(*(undefined8 *)(param_1 + 0x10), passwordManagerType);\n            ephy_password_manager_add_password(passwordManagerType, passwordData);\n            _Py_NoneStruct._0_4_ += 1;\n            result = _Py_NoneStruct;\n        } else {\n            PyErr_SetString(PyExc_TypeError, \"info should be a EphyPasswordInfo\");\n            result = (undefined1 *)0x0;\n        }\n    }\n    \n    return result;\n}\n```",
        "normed_func_sha256": "21440c1d75f502c6675c600c42168ee588884369e11133af9cf9f1a84c0e0961",
        "source_code": "static PyObject *\n_wrap_ephy_password_manager_add_password(PyGObject *self, PyObject *args, PyObject *kwargs)\n{\n    static char *kwlist[] = { \"info\", NULL };\n    PyObject *py_info;\n    EphyPasswordInfo *info = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs, \"O:EphyPasswordManager.add_password\", kwlist, &py_info))\n        return NULL;\n    if (pyg_boxed_check(py_info, EPHY_TYPE_PASSWORD_INFO))\n        info = pyg_boxed_get(py_info, EphyPasswordInfo);\n    else {\n        PyErr_SetString(PyExc_TypeError, \"info should be a EphyPasswordInfo\");\n        return NULL;\n    }\n    ephy_password_manager_add_password(EPHY_PASSWORD_MANAGER(self->obj), info);\n    Py_INCREF(Py_None);\n    return Py_None;\n}",
        "parsed_output": "undefined1 * EphyPasswordManager_add_password(long param_1, undefined8 param_2, undefined8 param_3) {\n    long passwordInfoPtr;\n    undefined8 passwordData;\n    int parseResult;\n    long passwordInfoType;\n    undefined8 passwordManagerType;\n    undefined1 *result = (undefined1 *)0x0;\n    long local_18;\n\n    parseResult = PyArg_ParseTupleAndKeywords(param_2, param_3, \"O:EphyPasswordManager.add_password\", &PTR_s_info_00620a90, &local_18);\n    \n    if (parseResult != 0) {\n        if (((*(long *)(local_18 + 8) == *(long *)(_PyGObject_API + 0x80)) || \n            (parseResult = PyType_IsSubtype(), parseResult != 0)) && \n            (passwordInfoPtr = *(long *)(local_18 + 0x18), \n            passwordInfoType = ephy_password_info_get_type(), \n            passwordInfoPtr == passwordInfoType)) {\n            \n            passwordData = *(undefined8 *)(local_18 + 0x10);\n            passwordManagerType = ephy_password_manager_get_type();\n            passwordManagerType = g_type_check_instance_cast(*(undefined8 *)(param_1 + 0x10), passwordManagerType);\n            ephy_password_manager_add_password(passwordManagerType, passwordData);\n            _Py_NoneStruct._0_4_ += 1;\n            result = _Py_NoneStruct;\n        } else {\n            PyErr_SetString(PyExc_TypeError, \"info should be a EphyPasswordInfo\");\n            result = (undefined1 *)0x0;\n        }\n    }\n    \n    return result;\n}",
        "baseline_code_stripped": "undefined1 * FUN_004ca070(long param_1,undefined8 param_2,undefined8 param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined1 *puVar6;\n  long local_18;\n  iVar3 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"O:EphyPasswordManager.add_password\",&PTR_s_info_00620a90,\n                     &local_18);\n  puVar6 = (undefined1 *)0x0;\n  if (iVar3 != 0) {\n    if (((*(long *)(local_18 + 8) == *(long *)(_PyGObject_API + 0x80)) ||\n        (iVar3 = PyType_IsSubtype(), iVar3 != 0)) &&\n       (lVar1 = *(long *)(local_18 + 0x18), lVar4 = ephy_password_info_get_type(), lVar1 == lVar4))\n    {\n      uVar2 = *(undefined8 *)(local_18 + 0x10);\n      uVar5 = ephy_password_manager_get_type();\n      uVar5 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 0x10),uVar5);\n      ephy_password_manager_add_password(uVar5,uVar2);\n      _Py_NoneStruct._0_4_ = _Py_NoneStruct._0_4_ + 1;\n      puVar6 = _Py_NoneStruct;\n    }\n    else {\n      PyErr_SetString(PyExc_TypeError,\"info should be a EphyPasswordInfo\");\n      puVar6 = (undefined1 *)0x0;\n    }\n  }\n  return puVar6;\n}",
        "similarity_score_unixcoder": 0.82192063331604,
        "similarity_score_baseline_stripped": 0.7029593586921692
    },
    {
        "func_name": "getGuard",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar * getGuard(int param_1)\n{\n  undefined8 uVar1;\n  undefined4 in_ESI;\n  undefined4 in_register_0000003c;\n  char *pcVar2;\n  cString acStack_28 [24];\n  pcVar2 = (char *)CONCAT44(in_register_0000003c,param_1);\n  switch(in_ESI) {\n  case 0:\n    cString::sprintf(pcVar2,&DAT_0012d554);\n    break;\n  case 1:\n    cString::sprintf(pcVar2,&DAT_0012d559);\n    break;\n  case 2:\n    cString::sprintf(pcVar2,&DAT_0012d55e);\n    break;\n  case 3:\n    cString::sprintf(pcVar2,&DAT_0012d562);\n    break;\n  case 4:\n    uVar1 = I18nTranslate(\"Auto\",\"femon\");\n    cString::sprintf((char *)acStack_28,\"%s\",uVar1);\n    cString::_cString(acStack_28);\n  default:\n    cString::sprintf(pcVar2,&DAT_00128586);\n  }\n  return pcVar2;\n}",
        "output": "```c\nchar * getGuard(int param_1)\n{\n    undefined8 translationResult;\n    undefined4 in_ESI;\n    undefined4 in_register_0000003c;\n    char *outputString;\n    cString formattedString[24];\n\n    outputString = (char *)CONCAT44(in_register_0000003c, param_1);\n    \n    switch(in_ESI) {\n        case 0:\n            cString::sprintf(outputString, &DAT_0012d554);\n            break;\n        case 1:\n            cString::sprintf(outputString, &DAT_0012d559);\n            break;\n        case 2:\n            cString::sprintf(outputString, &DAT_0012d55e);\n            break;\n        case 3:\n            cString::sprintf(outputString, &DAT_0012d562);\n            break;\n        case 4:\n            translationResult = I18nTranslate(\"Auto\", \"femon\");\n            cString::sprintf((char *)formattedString, \"%s\", translationResult);\n            cString::_cString(formattedString);\n            break;\n        default:\n            cString::sprintf(outputString, &DAT_00128586);\n            break;\n    }\n    \n    return outputString;\n}\n```",
        "normed_func_sha256": "fa9da67e45a6fef8f712a6823fd4cf79fee510cdf38aecc82547cbe7e235f190",
        "source_code": "cString getGuard(int value)\n{\n  switch (value) {\n    case GUARD_INTERVAL_1_32: return cString::sprintf(\"1/32\");\n    case GUARD_INTERVAL_1_16: return cString::sprintf(\"1/16\");\n    case GUARD_INTERVAL_1_8:  return cString::sprintf(\"1/8\");\n    case GUARD_INTERVAL_1_4:  return cString::sprintf(\"1/4\");\n    case GUARD_INTERVAL_AUTO: cString::sprintf(\"%s\", tr(\"Auto\"));\n    }\n  return cString::sprintf(\"---\");\n}",
        "parsed_output": "char * getGuard(int param_1)\n{\n    undefined8 translationResult;\n    undefined4 in_ESI;\n    undefined4 in_register_0000003c;\n    char *outputString;\n    cString formattedString[24];\n\n    outputString = (char *)CONCAT44(in_register_0000003c, param_1);\n    \n    switch(in_ESI) {\n        case 0:\n            cString::sprintf(outputString, &DAT_0012d554);\n            break;\n        case 1:\n            cString::sprintf(outputString, &DAT_0012d559);\n            break;\n        case 2:\n            cString::sprintf(outputString, &DAT_0012d55e);\n            break;\n        case 3:\n            cString::sprintf(outputString, &DAT_0012d562);\n            break;\n        case 4:\n            translationResult = I18nTranslate(\"Auto\", \"femon\");\n            cString::sprintf((char *)formattedString, \"%s\", translationResult);\n            cString::_cString(formattedString);\n            break;\n        default:\n            cString::sprintf(outputString, &DAT_00128586);\n            break;\n    }\n    \n    return outputString;\n}",
        "baseline_code_stripped": "char * getGuard(int param_1)\n{\n  undefined8 uVar1;\n  undefined4 in_ESI;\n  undefined4 in_register_0000003c;\n  char *pcVar2;\n  cString acStack_28 [24];\n  pcVar2 = (char *)CONCAT44(in_register_0000003c,param_1);\n  switch(in_ESI) {\n  case 0:\n    cString::sprintf(pcVar2,&DAT_0012d554);\n    break;\n  case 1:\n    cString::sprintf(pcVar2,&DAT_0012d559);\n    break;\n  case 2:\n    cString::sprintf(pcVar2,&DAT_0012d55e);\n    break;\n  case 3:\n    cString::sprintf(pcVar2,&DAT_0012d562);\n    break;\n  case 4:\n    uVar1 = I18nTranslate(\"Auto\",\"femon\");\n    cString::sprintf((char *)acStack_28,\"%s\",uVar1);\n    cString::_cString(acStack_28);\n  default:\n    cString::sprintf(pcVar2,&DAT_00128586);\n  }\n  return pcVar2;\n}",
        "similarity_score_unixcoder": 0.6018937826156616,
        "similarity_score_baseline_stripped": 0.5830280184745789
    },
    {
        "func_name": "_wrap_ColorShift_SetJsonValue",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_00058cd0(int param_1,undefined4 *param_2,undefined4 param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 extraout_ECX;\n  int in_GS_OFFSET;\n  undefined8 uVar5;\n  Value *local_54;\n  Value local_50 [24];\n  Value local_38 [24];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x58cdb;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar2 = Json::Value::Value(local_50,0);\n  if (param_1 != 1) {\n    rb_raise(_rb_eArgError,\"wrong # of arguments(%d for 1)\",param_1,uVar2);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(1,param_3,param_2,param_2);\n    if (iVar3 == -1) {\n      iVar3 = -5;\n    }\n    uVar4 = FUN_0003948e();\n    rb_raise(uVar4,&DAT_0013fdc3,uVar2,iVar3);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(2,*param_2,extraout_ECX,extraout_ECX);\n    uVar5 = FUN_0003948e();\n    rb_raise((int)uVar5,&DAT_0013fdc3,uVar2,(int)((ulonglong)uVar5 >> 0x20));\n  }\n  if (local_54 != (Value *)0x0) {\n    Json::Value::Value(local_38,local_54);\n    Json::Value::operator_(local_50,SUB41(local_38,0));\n    Json::Value::_Value(local_38);\n    pcVar1 = *(code **)(iRam00000000 + 0x24);\n    Json::Value::Value(local_38,local_50);\n    (*pcVar1)(0,local_38);\n    Json::Value::_Value(local_38);\n    Json::Value::_Value(local_50);\n    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n      return 4;\n    }\n    FUN_0013fce0();\n  }\n  uVar2 = FUN_000392b0(2,*param_2,0,0);\n  rb_raise(_rb_eArgError,&DAT_0013fdc3,uVar2);\n}",
        "output": "```c\nundefined4 process_function(int arg_count, undefined4 *arg_values, undefined4 arg_param) {\n    code *callback_function;\n    undefined4 result_value;\n    int status;\n    undefined4 error_value;\n    undefined4 extra_value;\n    int stack_guard;\n    undefined8 callback_result;\n    Value *local_value;\n    Value value_array_1[24];\n    Value value_array_2[24];\n    int local_guard_value;\n    undefined4 stack_value;\n\n    stack_value = 0x58cdb;\n    local_guard_value = *(int *)(in_GS_OFFSET + 0x14);\n    result_value = Json::Value::Value(value_array_1, 0);\n\n    if (arg_count != 1) {\n        rb_raise(_rb_eArgError, \"wrong # of arguments(%d for 1)\", arg_count, result_value);\n    }\n\n    status = FUN_0003e770(0, 0);\n    if (status < 0) {\n        result_value = FUN_000392b0(1, arg_param, arg_values, arg_values);\n        if (status == -1) {\n            status = -5;\n        }\n        error_value = FUN_0003948e();\n        rb_raise(error_value, &DAT_0013fdc3, result_value, status);\n    }\n\n    status = FUN_0003e770(0, 0);\n    if (status < 0) {\n        result_value = FUN_000392b0(2, *arg_values, extra_value, extra_value);\n        callback_result = FUN_0003948e();\n        rb_raise((int)callback_result, &DAT_0013fdc3, result_value, (int)((ulonglong)callback_result >> 0x20));\n    }\n\n    if (local_value != (Value *)0x0) {\n        Json::Value::Value(value_array_2, local_value);\n        Json::Value::operator_(value_array_1, SUB41(value_array_2, 0));\n        Json::Value::_Value(value_array_2);\n        callback_function = *(code **)(iRam00000000 + 0x24);\n        Json::Value::Value(value_array_2, value_array_1);\n        (*callback_function)(0, value_array_2);\n        Json::Value::_Value(value_array_2);\n        Json::Value::_Value(value_array_1);\n\n        if (local_guard_value == *(int *)(in_GS_OFFSET + 0x14)) {\n            return 4;\n        }\n        FUN_0013fce0();\n    }\n\n    result_value = FUN_000392b0(2, *arg_values, 0, 0);\n    rb_raise(_rb_eArgError, &DAT_0013fdc3, result_value);\n}\n```",
        "normed_func_sha256": "cee1148d3ea61c3c3baf1ef9ea29a39f11cac582360540b57e55f906871652fd",
        "source_code": "SWIGINTERN VALUE\n_wrap_ColorShift_SetJsonValue(int argc, VALUE *argv, VALUE self) {\n  openshot::ColorShift *arg1 = (openshot::ColorShift *) 0 ;\n  Json::Value arg2 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  void *argp2 ;\n  int res2 = 0 ;\n  \n  if ((argc < 1) || (argc > 1)) {\n    rb_raise(rb_eArgError, \"wrong # of arguments(%d for 1)\",argc); SWIG_fail;\n  }\n  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_openshot__ColorShift, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( \"\", \"openshot::ColorShift *\",\"SetJsonValue\", 1, self )); \n  }\n  arg1 = reinterpret_cast< openshot::ColorShift * >(argp1);\n  {\n    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_Json__Value,  0 );\n    if (!SWIG_IsOK(res2)) {\n      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( \"\", \"Json::Value const\",\"SetJsonValue\", 2, argv[0] )); \n    }  \n    if (!argp2) {\n      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError(\"invalid null reference \", \"Json::Value const\",\"SetJsonValue\", 2, argv[0]));\n    } else {\n      arg2 = *(reinterpret_cast< Json::Value * >(argp2));\n    }\n  }\n  (arg1)->SetJsonValue(arg2);\n  return Qnil;\nfail:\n  return Qnil;\n}",
        "parsed_output": "undefined4 process_function(int arg_count, undefined4 *arg_values, undefined4 arg_param) {\n    code *callback_function;\n    undefined4 result_value;\n    int status;\n    undefined4 error_value;\n    undefined4 extra_value;\n    int stack_guard;\n    undefined8 callback_result;\n    Value *local_value;\n    Value value_array_1[24];\n    Value value_array_2[24];\n    int local_guard_value;\n    undefined4 stack_value;\n\n    stack_value = 0x58cdb;\n    local_guard_value = *(int *)(in_GS_OFFSET + 0x14);\n    result_value = Json::Value::Value(value_array_1, 0);\n\n    if (arg_count != 1) {\n        rb_raise(_rb_eArgError, \"wrong # of arguments(%d for 1)\", arg_count, result_value);\n    }\n\n    status = FUN_0003e770(0, 0);\n    if (status < 0) {\n        result_value = FUN_000392b0(1, arg_param, arg_values, arg_values);\n        if (status == -1) {\n            status = -5;\n        }\n        error_value = FUN_0003948e();\n        rb_raise(error_value, &DAT_0013fdc3, result_value, status);\n    }\n\n    status = FUN_0003e770(0, 0);\n    if (status < 0) {\n        result_value = FUN_000392b0(2, *arg_values, extra_value, extra_value);\n        callback_result = FUN_0003948e();\n        rb_raise((int)callback_result, &DAT_0013fdc3, result_value, (int)((ulonglong)callback_result >> 0x20));\n    }\n\n    if (local_value != (Value *)0x0) {\n        Json::Value::Value(value_array_2, local_value);\n        Json::Value::operator_(value_array_1, SUB41(value_array_2, 0));\n        Json::Value::_Value(value_array_2);\n        callback_function = *(code **)(iRam00000000 + 0x24);\n        Json::Value::Value(value_array_2, value_array_1);\n        (*callback_function)(0, value_array_2);\n        Json::Value::_Value(value_array_2);\n        Json::Value::_Value(value_array_1);\n\n        if (local_guard_value == *(int *)(in_GS_OFFSET + 0x14)) {\n            return 4;\n        }\n        FUN_0013fce0();\n    }\n\n    result_value = FUN_000392b0(2, *arg_values, 0, 0);\n    rb_raise(_rb_eArgError, &DAT_0013fdc3, result_value);\n}",
        "baseline_code_stripped": "undefined4 FUN_00058cd0(int param_1,undefined4 *param_2,undefined4 param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 extraout_ECX;\n  int in_GS_OFFSET;\n  undefined8 uVar5;\n  Value *local_54;\n  Value local_50 [24];\n  Value local_38 [24];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x58cdb;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar2 = Json::Value::Value(local_50,0);\n  if (param_1 != 1) {\n    rb_raise(_rb_eArgError,\"wrong # of arguments(%d for 1)\",param_1,uVar2);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(1,param_3,param_2,param_2);\n    if (iVar3 == -1) {\n      iVar3 = -5;\n    }\n    uVar4 = FUN_0003948e();\n    rb_raise(uVar4,&DAT_0013fdc3,uVar2,iVar3);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(2,*param_2,extraout_ECX,extraout_ECX);\n    uVar5 = FUN_0003948e();\n    rb_raise((int)uVar5,&DAT_0013fdc3,uVar2,(int)((ulonglong)uVar5 >> 0x20));\n  }\n  if (local_54 != (Value *)0x0) {\n    Json::Value::Value(local_38,local_54);\n    Json::Value::operator_(local_50,SUB41(local_38,0));\n    Json::Value::_Value(local_38);\n    pcVar1 = *(code **)(iRam00000000 + 0x24);\n    Json::Value::Value(local_38,local_50);\n    (*pcVar1)(0,local_38);\n    Json::Value::_Value(local_38);\n    Json::Value::_Value(local_50);\n    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n      return 4;\n    }\n    FUN_0013fce0();\n  }\n  uVar2 = FUN_000392b0(2,*param_2,0,0);\n  rb_raise(_rb_eArgError,&DAT_0013fdc3,uVar2);\n}",
        "similarity_score_unixcoder": 0.579233705997467,
        "similarity_score_baseline_stripped": 0.5859086513519287
    },
    {
        "func_name": "lu_shadow_uses_elevated_privileges",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nbool FUN_00013089(int param_1)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  char *pcVar3;\n  int iVar4;\n  int iVar5;\n  uVar1 = g_strconcat(*(undefined4 *)(param_1 + 0xc),\"/directory\",0);\n  uVar2 = lu_cfg_read_single(*(undefined4 *)(param_1 + 0x10),uVar1,&DAT_00018a38);\n  g_free(uVar1);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/shadow\",0);\n  iVar4 = access(pcVar3,6);\n  g_free(pcVar3);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/gshadow\",0);\n  iVar5 = access(pcVar3,6);\n  g_free(pcVar3);\n  return iVar5 != 0 || iVar4 != 0;\n}",
        "output": "```c\nbool checkShadowAndGShadow(int config)\n{\n    char *directoryPath;\n    char *shadowPath;\n    char *gshadowPath;\n    int shadowAccess;\n    int gshadowAccess;\n\n    directoryPath = g_strconcat(*(undefined4 *)(config + 0xc), \"/directory\", 0);\n    undefined4 configValue = lu_cfg_read_single(*(undefined4 *)(config + 0x10), directoryPath, &DAT_00018a38);\n    g_free(directoryPath);\n\n    shadowPath = g_strconcat(\"%s/%s\", configValue, \"/shadow\", 0);\n    shadowAccess = access(shadowPath, 6);\n    g_free(shadowPath);\n\n    gshadowPath = g_strconcat(\"%s/%s\", configValue, \"/gshadow\", 0);\n    gshadowAccess = access(gshadowPath, 6);\n    g_free(gshadowPath);\n\n    return gshadowAccess != 0 || shadowAccess != 0;\n}\n```",
        "normed_func_sha256": "52320d3b6a1ca684d2aefa145f40839fcc9dfb973bc0a2677aec0765513bb45d",
        "source_code": "static gboolean\nlu_shadow_uses_elevated_privileges(struct lu_module *module)\n{\n\tconst char *directory;\n\tchar *path, *key;\n\tgboolean ret = FALSE;\n\t/* Get the directory the files are in. */\n\tkey = g_strconcat(module->name, \"/directory\", NULL);\n\tdirectory = lu_cfg_read_single(module->lu_context, key, SYSCONFDIR);\n\tg_free(key);\n\t/* If we can't access the shadow file as a normal user, then the\n\t * answer is \"yes\". */\n\tpath = g_strconcat(\"%s/%s\", directory, \"/shadow\", NULL);\n\tif (access(path, R_OK | W_OK) != 0) {\n\t\tret = TRUE;\n\t}\n\tg_free(path);\n\t/* If we can't access the gshadow file as a normal user, then the\n\t * answer is \"yes\". */\n\tpath = g_strconcat(\"%s/%s\", directory, \"/gshadow\", NULL);\n\tif (access(path, R_OK | W_OK) != 0) {\n\t\tret = TRUE;\n\t}\n\tg_free(path);\n\treturn ret;\n}",
        "parsed_output": "bool checkShadowAndGShadow(int config)\n{\n    char *directoryPath;\n    char *shadowPath;\n    char *gshadowPath;\n    int shadowAccess;\n    int gshadowAccess;\n\n    directoryPath = g_strconcat(*(undefined4 *)(config + 0xc), \"/directory\", 0);\n    undefined4 configValue = lu_cfg_read_single(*(undefined4 *)(config + 0x10), directoryPath, &DAT_00018a38);\n    g_free(directoryPath);\n\n    shadowPath = g_strconcat(\"%s/%s\", configValue, \"/shadow\", 0);\n    shadowAccess = access(shadowPath, 6);\n    g_free(shadowPath);\n\n    gshadowPath = g_strconcat(\"%s/%s\", configValue, \"/gshadow\", 0);\n    gshadowAccess = access(gshadowPath, 6);\n    g_free(gshadowPath);\n\n    return gshadowAccess != 0 || shadowAccess != 0;\n}",
        "baseline_code_stripped": "bool FUN_00013089(int param_1)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  char *pcVar3;\n  int iVar4;\n  int iVar5;\n  uVar1 = g_strconcat(*(undefined4 *)(param_1 + 0xc),\"/directory\",0);\n  uVar2 = lu_cfg_read_single(*(undefined4 *)(param_1 + 0x10),uVar1,&DAT_00018a38);\n  g_free(uVar1);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/shadow\",0);\n  iVar4 = access(pcVar3,6);\n  g_free(pcVar3);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/gshadow\",0);\n  iVar5 = access(pcVar3,6);\n  g_free(pcVar3);\n  return iVar5 != 0 || iVar4 != 0;\n}",
        "similarity_score_unixcoder": 0.6638950705528259,
        "similarity_score_baseline_stripped": 0.5106364488601685
    },
    {
        "func_name": "sequeler_widgets_connection_dialog_class_init",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sequeler_widgets_connection_dialog_class_init(undefined8 param_1)\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  DAT_00160530 = g_type_class_peek_parent();\n  g_type_class_adjust_private_offset(param_1,&DAT_00160528);\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x20) = _vala_sequeler_widgets_connection_dialog_get_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x18) = _vala_sequeler_widgets_connection_dialog_set_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x10) = sequeler_widgets_connection_dialog_constructor;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x30) = sequeler_widgets_connection_dialog_finalize;\n  uVar2 = g_type_check_class_cast(param_1,0x50);\n  uVar3 = sequeler_window_get_type();\n  DAT_00160540 = g_param_spec_object(\"window\",\"window\",\"window\",uVar3,0xeb);\n  g_object_class_install_property(uVar2,1);\n  return;\n}",
        "output": "```c\nvoid sequeler_widgets_connection_dialog_class_init(undefined8 class_type)\n{\n    long class_instance;\n    undefined8 parent_class;\n    undefined8 window_type;\n\n    // Get the parent class type\n    DAT_00160530 = g_type_class_peek_parent();\n\n    // Adjust the private offset for the class\n    g_type_class_adjust_private_offset(class_type, &DAT_00160528);\n\n    // Cast the class type to the specific class and set up property getters and setters\n    class_instance = g_type_check_class_cast(class_type, 0x50);\n    *(code **)(class_instance + 0x20) = _vala_sequeler_widgets_connection_dialog_get_property;\n    *(code **)(class_instance + 0x18) = _vala_sequeler_widgets_connection_dialog_set_property;\n    *(code **)(class_instance + 0x10) = sequeler_widgets_connection_dialog_constructor;\n    *(code **)(class_instance + 0x30) = sequeler_widgets_connection_dialog_finalize;\n\n    // Get the type for the window property\n    parent_class = g_type_check_class_cast(class_type, 0x50);\n    window_type = sequeler_window_get_type();\n    \n    // Install the window property for the class\n    DAT_00160540 = g_param_spec_object(\"window\", \"window\", \"window\", window_type, 0xeb);\n    g_object_class_install_property(parent_class, 1);\n}\n```",
        "normed_func_sha256": "ddc6034aff01cf7ce7461601663446e999c5617d85f93f43f9ca537883a8840b",
        "source_code": "static void\nsequeler_widgets_connection_dialog_class_init (SequelerWidgetsConnectionDialogClass * klass,\n                                               gpointer klass_data)\n{\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tsequeler_widgets_connection_dialog_parent_class = g_type_class_peek_parent (klass);\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tg_type_class_adjust_private_offset (klass, &SequelerWidgetsConnectionDialog_private_offset);\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->get_property = _vala_sequeler_widgets_connection_dialog_get_property;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->set_property = _vala_sequeler_widgets_connection_dialog_set_property;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->constructor = sequeler_widgets_connection_dialog_constructor;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->finalize = sequeler_widgets_connection_dialog_finalize;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tg_object_class_install_property (G_OBJECT_CLASS (klass), SEQUELER_WIDGETS_CONNECTION_DIALOG_WINDOW_PROPERTY, sequeler_widgets_connection_dialog_properties[SEQUELER_WIDGETS_CONNECTION_DIALOG_WINDOW_PROPERTY] = g_param_spec_object (\"window\", \"window\", \"window\", SEQUELER_TYPE_WINDOW, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));\n#line 5302 \"ConnectionDialog.c\"\n}",
        "parsed_output": "void sequeler_widgets_connection_dialog_class_init(undefined8 class_type)\n{\n    long class_instance;\n    undefined8 parent_class;\n    undefined8 window_type;\n\n    // Get the parent class type\n    DAT_00160530 = g_type_class_peek_parent();\n\n    // Adjust the private offset for the class\n    g_type_class_adjust_private_offset(class_type, &DAT_00160528);\n\n    // Cast the class type to the specific class and set up property getters and setters\n    class_instance = g_type_check_class_cast(class_type, 0x50);\n    *(code **)(class_instance + 0x20) = _vala_sequeler_widgets_connection_dialog_get_property;\n    *(code **)(class_instance + 0x18) = _vala_sequeler_widgets_connection_dialog_set_property;\n    *(code **)(class_instance + 0x10) = sequeler_widgets_connection_dialog_constructor;\n    *(code **)(class_instance + 0x30) = sequeler_widgets_connection_dialog_finalize;\n\n    // Get the type for the window property\n    parent_class = g_type_check_class_cast(class_type, 0x50);\n    window_type = sequeler_window_get_type();\n    \n    // Install the window property for the class\n    DAT_00160540 = g_param_spec_object(\"window\", \"window\", \"window\", window_type, 0xeb);\n    g_object_class_install_property(parent_class, 1);\n}",
        "baseline_code_stripped": "void sequeler_widgets_connection_dialog_class_init(undefined8 param_1)\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  DAT_00160530 = g_type_class_peek_parent();\n  g_type_class_adjust_private_offset(param_1,&DAT_00160528);\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x20) = _vala_sequeler_widgets_connection_dialog_get_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x18) = _vala_sequeler_widgets_connection_dialog_set_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x10) = sequeler_widgets_connection_dialog_constructor;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x30) = sequeler_widgets_connection_dialog_finalize;\n  uVar2 = g_type_check_class_cast(param_1,0x50);\n  uVar3 = sequeler_window_get_type();\n  DAT_00160540 = g_param_spec_object(\"window\",\"window\",\"window\",uVar3,0xeb);\n  g_object_class_install_property(uVar2,1);\n  return;\n}",
        "similarity_score_unixcoder": 0.8325364589691162,
        "similarity_score_baseline_stripped": 0.8177669644355774
    },
    {
        "func_name": "imap_cmd_parser_copy",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00119230(int param_1,longlong param_2,longlong param_3,undefined8 param_4,\n                 undefined8 param_5)\n{\n  size_t sVar1;\n  uint uVar2;\n  longlong lVar3;\n  longlong lVar4;\n  longlong in_r13;\n  undefined8 uVar5;\n  char *__s;\n  longlong lStack_305c8;\n  undefined auStack_3053c [12];\n  undefined8 uStack_30530;\n  undefined8 uStack_30528;\n  void *pvStack_30518;\n  undefined8 uStack_30510;\n  undefined8 uStack_30508;\n  undefined8 uStack_304e8;\n  undefined8 uStack_304e0;\n  undefined8 uStack_304d8;\n  undefined8 *puStack_304d0;\n  undefined8 uStack_304c8;\n  undefined8 uStack_304c0;\n  undefined8 uStack_304b8;\n  undefined4 uStack_304b0;\n  undefined8 uStack_304a8;\n  undefined8 uStack_304a0;\n  undefined auStack_30498 [197640];\n  uVar5 = 0x70d;\n  lVar4 = *(longlong *)(in_r13 + -0x7010);\n  uStack_30530 = 0;\n  uStack_30528 = 0;\n  pvStack_30518 = (void *)0x0;\n  uStack_30510 = 0;\n  uStack_30508 = 0;\n  if ((*(int *)(param_3 + 0xd8) != 5) || (uVar5 = 0x708, param_1 < 4)) goto LAB_001192dc;\n  lVar3 = FUN_00118778(param_3,*(undefined8 *)(param_2 + 0x10),&pvStack_30518,param_4,param_5,0);\n  if ((lVar3 == 0) && (__s = *(char **)(param_2 + 0x18), *__s != '\\0')) {\n    sVar1 = strlen(__s);\n    if (0x3ff < sVar1) goto LAB_00119480;\n    lVar3 = FUN_00113948(param_3 + 0x208ad,__s,auStack_30498);\n    if (lVar3 == 0) goto LAB_00119480;\n    uStack_304b0 = *(undefined4 *)(lStack_305c8 + -0x2d30c);\n    puStack_304d0 = &uStack_304a0;\n    uStack_304e8 = 0;\n    uStack_304e0 = 0;\n    uStack_304d8 = 0;\n    uStack_304c0 = 0;\n    uStack_304b8 = 0;\n    uStack_304a8 = 0;\n    uStack_304a0 = 0;\n    uStack_304c8 = 1;\n    uVar2 = (**(code **)(lStack_305c8 + -0x6a70))\n                      (param_3 + 0x207ad,param_3 + 0x108,&pvStack_30518,&uStack_304e8,auStack_3053c)\n    ;\n    if (uVar2 < 6) {\n      (*(code *)((longlong)*(int *)(lStack_305c8 + -0x4ea98) +\n                (longlong)(int *)(lStack_305c8 + -0x4ea98)))((ulonglong)uVar2 << 2);\n      return;\n    }\n    uVar5 = 0x77f;\n    FUN_00128d48(&puStack_304d0);\n    FUN_00128c98(&uStack_304e8);\n  }\n  else {\nLAB_00119480:\n    uVar5 = 0x708;\n  }\n  if (pvStack_30518 != (void *)0x0) {\n    operator_delete(pvStack_30518);\n  }\nLAB_001192dc:\n  if (lVar4 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  __stack_chk_fail(uVar5);\n}",
        "output": "```c\nvoid processFunction(int param1, long long param2, long long param3, undefined8 param4, undefined8 param5) {\n    size_t stringLength;\n    uint returnValue;\n    long long localVar1;\n    long long localVar2;\n    long long in_r13;\n    undefined8 errorCode;\n    char *inputString;\n    long long stackVariable;\n    undefined buffer[12];\n    undefined8 tempVar1;\n    undefined8 tempVar2;\n    void *dynamicMemory;\n    undefined8 tempVar3;\n    undefined8 tempVar4;\n    undefined8 tempVar5;\n    undefined8 tempVar6;\n    undefined8 tempVar7;\n    undefined8 tempVar8;\n    undefined8 *pointerToStack;\n    undefined8 tempVar9;\n    undefined8 tempVar10;\n    undefined8 tempVar11;\n    undefined4 tempVar12;\n    undefined8 tempVar13;\n    undefined8 tempVar14;\n    undefined bufferArray[197640];\n\n    errorCode = 0x70d;\n    localVar2 = *(long long *)(in_r13 - 0x7010);\n    tempVar1 = 0;\n    tempVar2 = 0;\n    dynamicMemory = (void *)0x0;\n    tempVar3 = 0;\n    tempVar4 = 0;\n\n    if ((*(int *)(param3 + 0xd8) != 5) || (errorCode = 0x708, param1 < 4)) {\n        goto cleanup;\n    }\n\n    localVar1 = FUN_00118778(param3, *(undefined8 *)(param2 + 0x10), &dynamicMemory, param4, param5, 0);\n    if ((localVar1 == 0) && (inputString = *(char **)(param2 + 0x18), *inputString != '\\0')) {\n        stringLength = strlen(inputString);\n        if (stringLength > 0x3ff) {\n            goto errorHandling;\n        }\n\n        localVar1 = FUN_00113948(param3 + 0x208ad, inputString, bufferArray);\n        if (localVar1 == 0) {\n            goto errorHandling;\n        }\n\n        tempVar12 = *(undefined4 *)(stackVariable - 0x2d30c);\n        pointerToStack = &tempVar13;\n        tempVar5 = 0;\n        tempVar6 = 0;\n        tempVar7 = 0;\n        tempVar10 = 0;\n        tempVar11 = 0;\n        tempVar9 = 0;\n        tempVar8 = 0;\n        tempVar10 = 1;\n\n        returnValue = (**(code **)(stackVariable - 0x6a70))(param3 + 0x207ad, param3 + 0x108, &dynamicMemory, &tempVar5, buffer);\n        if (returnValue < 6) {\n            (*(code *)((long long)*(int *)(stackVariable - 0x4ea98) + (long long)(int *)(stackVariable - 0x4ea98)))((ulonglong)returnValue << 2);\n            return;\n        }\n\n        errorCode = 0x77f;\n        FUN_00128d48(&pointerToStack);\n        FUN_00128c98(&tempVar5);\n    } else {\nerrorHandling:\n        errorCode = 0x708;\n    }\n\ncleanup:\n    if (dynamicMemory != (void *)0x0) {\n        operator_delete(dynamicMemory);\n    }\n\n    if (localVar2 == *(long long *)(in_r13 - 0x7010)) {\n        return;\n    }\n    __stack_chk_fail(errorCode);\n}\n```",
        "normed_func_sha256": "b8ca09fcc5483d042f325f768af4c47af19446f5bcb0ce7f74e4cca0f0f16856",
        "source_code": "int imap_cmd_parser_copy(int argc, char **argv, IMAP_CONTEXT *pcontext) try\n{\n\tunsigned int uid;\n\tint errnum;\n\tBOOL b_first;\n\tBOOL b_copied;\n\tint i, j;\n\tunsigned long uidvalidity;\n\tsize_t string_length = 0, string_length1 = 0;\n\tchar buff[64*1024];\n\tchar temp_name[1024];\n\timap_seq_list list_uid;\n\tchar uid_string[64*1024];\n\tchar uid_string1[64*1024];\n    \n\tif (pcontext->proto_stat != iproto_stat::select)\n\t\treturn 1805;\n\tif (argc < 4 || parse_imap_seqx(*pcontext, argv[2], list_uid) != 0 ||\n\t    strlen(argv[3]) == 0 || strlen(argv[3]) >= 1024 ||\n\t    !imap_cmd_parser_imapfolder_to_sysfolder(pcontext->lang, argv[3], temp_name))\n\t\treturn 1800;\n\tXARRAY xarray;\n\tauto ssr = system_services_fetch_simple_uid(pcontext->maildir,\n\t           pcontext->selected_folder, list_uid, &xarray, &errnum);\n\tauto result = m2icode(ssr, errnum);\n\tif (result != 0)\n\t\treturn result;\n\tif (system_services_summary_folder(pcontext->maildir,\n\t    temp_name, nullptr, nullptr, nullptr, &uidvalidity, nullptr,\n\t    nullptr, &errnum) != MIDB_RESULT_OK)\n\t\tuidvalidity = 0;\n\tb_copied = TRUE;\n\tb_first = FALSE;\n\tstring_length = 0;\n\tstring_length1 = 0;\n\tint num = xarray.get_capacity();\n\tfor (i=0; i<num; i++) {\n\t\tauto pitem = xarray.get_item(i);\n\t\tpitem = pcontext->contents.get_itemx(pitem->uid);\n\t\tif (pitem == nullptr)\n\t\t\tcontinue;\n\t\tif (system_services_copy_mail(pcontext->maildir,\n\t\t    pcontext->selected_folder, pitem->mid, temp_name,\n\t\t    pitem->mid, &errnum) != MIDB_RESULT_OK) {\n\t\t\tb_copied = FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tif (uidvalidity == 0)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\tif (system_services_get_uid(pcontext->maildir,\n\t\t\t    temp_name, pitem->mid, &uid) != MIDB_RESULT_OK) {\n\t\t\t\tusleep(500000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b_first) {\n\t\t\t\tuid_string[string_length++] = ',';\n\t\t\t\tuid_string1[string_length1++] = ',';\n\t\t\t} else {\n\t\t\t\tb_first =  TRUE;\n\t\t\t}\n\t\t\tstring_length += gx_snprintf(uid_string + string_length,\n\t\t\t\t\t std::size(uid_string) - string_length, \"%d\", pitem->uid);\n\t\t\tstring_length1 += gx_snprintf(uid_string1 + string_length1,\n\t\t\t\t\t  std::size(uid_string1) - string_length1, \"%d\", uid);\n\t\t\tbreak;\n\t\t}\n\t\tif (j == 10)\n\t\t\tuidvalidity = 0;\n\t}\n\tif (!b_copied) {\n\t\tstd::vector<MITEM *> exp_list;\n\t\tfor (;i>0; i--) {\n\t\t\tauto pitem = xarray.get_item(i - 1);\n\t\t\tif (pitem->uid == 0)\n\t\t\t\tcontinue;\n\t\t\texp_list.push_back(pitem);\n\t\t}\n\t\tsystem_services_remove_mail(pcontext->maildir,\n\t\t\ttemp_name, exp_list, &errnum);\n\t}\n\tpcontext->stream.clear();\n\tif (b_copied) {\n\t\timap_parser_echo_modify(pcontext, &pcontext->stream);\n\t\t/* IMAP_CODE_2170022: OK <COPYUID> COPY completed */\n\t\tauto imap_reply_str = resource_get_imap_code(1722, 1, &string_length);\n\t\tauto imap_reply_str1 = resource_get_imap_code(1722, 2, &string_length1);\n\t\tif (uidvalidity != 0)\n\t\t\tstring_length = gx_snprintf(buff, std::size(buff),\n\t\t\t\t\"%s %s [COPYUID %llu %s %s] %s\", argv[0],\n\t\t\t\timap_reply_str, LLU{uidvalidity},\n\t\t\t\tuid_string, uid_string1, imap_reply_str1);\n\t\telse\n\t\t\tstring_length = gx_snprintf(buff, std::size(buff),\n\t\t\t\t\"%s %s %s\", argv[0], imap_reply_str, imap_reply_str1);\n\t} else {\n\t\t/* IMAP_CODE_2190016: NO COPY failed */\n\t\tauto imap_reply_str = resource_get_imap_code(1916, 1, &string_length);\n\t\tstring_length = gx_snprintf(buff, std::size(buff),\n\t\t\t\"%s %s\", argv[0], imap_reply_str);\n\t}\n\tif (pcontext->stream.write(buff, string_length) != STREAM_WRITE_OK)\n\t\treturn 1922;\n\tpcontext->write_offset = 0;\n\tpcontext->sched_stat = isched_stat::wrlst;\n\treturn DISPATCH_BREAK;\n} catch (const std::bad_alloc &) {\n\tmlog(LV_ERR, \"E-1245: ENOMEM\");\n\treturn 1918;\n}",
        "parsed_output": "void processFunction(int param1, long long param2, long long param3, undefined8 param4, undefined8 param5) {\n    size_t stringLength;\n    uint returnValue;\n    long long localVar1;\n    long long localVar2;\n    long long in_r13;\n    undefined8 errorCode;\n    char *inputString;\n    long long stackVariable;\n    undefined buffer[12];\n    undefined8 tempVar1;\n    undefined8 tempVar2;\n    void *dynamicMemory;\n    undefined8 tempVar3;\n    undefined8 tempVar4;\n    undefined8 tempVar5;\n    undefined8 tempVar6;\n    undefined8 tempVar7;\n    undefined8 tempVar8;\n    undefined8 *pointerToStack;\n    undefined8 tempVar9;\n    undefined8 tempVar10;\n    undefined8 tempVar11;\n    undefined4 tempVar12;\n    undefined8 tempVar13;\n    undefined8 tempVar14;\n    undefined bufferArray[197640];\n\n    errorCode = 0x70d;\n    localVar2 = *(long long *)(in_r13 - 0x7010);\n    tempVar1 = 0;\n    tempVar2 = 0;\n    dynamicMemory = (void *)0x0;\n    tempVar3 = 0;\n    tempVar4 = 0;\n\n    if ((*(int *)(param3 + 0xd8) != 5) || (errorCode = 0x708, param1 < 4)) {\n        goto cleanup;\n    }\n\n    localVar1 = FUN_00118778(param3, *(undefined8 *)(param2 + 0x10), &dynamicMemory, param4, param5, 0);\n    if ((localVar1 == 0) && (inputString = *(char **)(param2 + 0x18), *inputString != '\\0')) {\n        stringLength = strlen(inputString);\n        if (stringLength > 0x3ff) {\n            goto errorHandling;\n        }\n\n        localVar1 = FUN_00113948(param3 + 0x208ad, inputString, bufferArray);\n        if (localVar1 == 0) {\n            goto errorHandling;\n        }\n\n        tempVar12 = *(undefined4 *)(stackVariable - 0x2d30c);\n        pointerToStack = &tempVar13;\n        tempVar5 = 0;\n        tempVar6 = 0;\n        tempVar7 = 0;\n        tempVar10 = 0;\n        tempVar11 = 0;\n        tempVar9 = 0;\n        tempVar8 = 0;\n        tempVar10 = 1;\n\n        returnValue = (**(code **)(stackVariable - 0x6a70))(param3 + 0x207ad, param3 + 0x108, &dynamicMemory, &tempVar5, buffer);\n        if (returnValue < 6) {\n            (*(code *)((long long)*(int *)(stackVariable - 0x4ea98) + (long long)(int *)(stackVariable - 0x4ea98)))((ulonglong)returnValue << 2);\n            return;\n        }\n\n        errorCode = 0x77f;\n        FUN_00128d48(&pointerToStack);\n        FUN_00128c98(&tempVar5);\n    } else {\nerrorHandling:\n        errorCode = 0x708;\n    }\n\ncleanup:\n    if (dynamicMemory != (void *)0x0) {\n        operator_delete(dynamicMemory);\n    }\n\n    if (localVar2 == *(long long *)(in_r13 - 0x7010)) {\n        return;\n    }\n    __stack_chk_fail(errorCode);\n}",
        "baseline_code_stripped": "void FUN_00119230(int param_1,longlong param_2,longlong param_3,undefined8 param_4,\n                 undefined8 param_5)\n{\n  size_t sVar1;\n  uint uVar2;\n  longlong lVar3;\n  longlong lVar4;\n  longlong in_r13;\n  undefined8 uVar5;\n  char *__s;\n  longlong lStack_305c8;\n  undefined auStack_3053c [12];\n  undefined8 uStack_30530;\n  undefined8 uStack_30528;\n  void *pvStack_30518;\n  undefined8 uStack_30510;\n  undefined8 uStack_30508;\n  undefined8 uStack_304e8;\n  undefined8 uStack_304e0;\n  undefined8 uStack_304d8;\n  undefined8 *puStack_304d0;\n  undefined8 uStack_304c8;\n  undefined8 uStack_304c0;\n  undefined8 uStack_304b8;\n  undefined4 uStack_304b0;\n  undefined8 uStack_304a8;\n  undefined8 uStack_304a0;\n  undefined auStack_30498 [197640];\n  uVar5 = 0x70d;\n  lVar4 = *(longlong *)(in_r13 + -0x7010);\n  uStack_30530 = 0;\n  uStack_30528 = 0;\n  pvStack_30518 = (void *)0x0;\n  uStack_30510 = 0;\n  uStack_30508 = 0;\n  if ((*(int *)(param_3 + 0xd8) != 5) || (uVar5 = 0x708, param_1 < 4)) goto LAB_001192dc;\n  lVar3 = FUN_00118778(param_3,*(undefined8 *)(param_2 + 0x10),&pvStack_30518,param_4,param_5,0);\n  if ((lVar3 == 0) && (__s = *(char **)(param_2 + 0x18), *__s != '\\0')) {\n    sVar1 = strlen(__s);\n    if (0x3ff < sVar1) goto LAB_00119480;\n    lVar3 = FUN_00113948(param_3 + 0x208ad,__s,auStack_30498);\n    if (lVar3 == 0) goto LAB_00119480;\n    uStack_304b0 = *(undefined4 *)(lStack_305c8 + -0x2d30c);\n    puStack_304d0 = &uStack_304a0;\n    uStack_304e8 = 0;\n    uStack_304e0 = 0;\n    uStack_304d8 = 0;\n    uStack_304c0 = 0;\n    uStack_304b8 = 0;\n    uStack_304a8 = 0;\n    uStack_304a0 = 0;\n    uStack_304c8 = 1;\n    uVar2 = (**(code **)(lStack_305c8 + -0x6a70))\n                      (param_3 + 0x207ad,param_3 + 0x108,&pvStack_30518,&uStack_304e8,auStack_3053c)\n    ;\n    if (uVar2 < 6) {\n      (*(code *)((longlong)*(int *)(lStack_305c8 + -0x4ea98) +\n                (longlong)(int *)(lStack_305c8 + -0x4ea98)))((ulonglong)uVar2 << 2);\n      return;\n    }\n    uVar5 = 0x77f;\n    FUN_00128d48(&puStack_304d0);\n    FUN_00128c98(&uStack_304e8);\n  }\n  else {\nLAB_00119480:\n    uVar5 = 0x708;\n  }\n  if (pvStack_30518 != (void *)0x0) {\n    operator_delete(pvStack_30518);\n  }\nLAB_001192dc:\n  if (lVar4 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  __stack_chk_fail(uVar5);\n}",
        "similarity_score_unixcoder": 0.4660976529121399,
        "similarity_score_baseline_stripped": 0.5057766437530518
    },
    {
        "func_name": "BotTree::serialize",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 __fastcall FUN_10002610(int param_1)\n{\n  undefined4 unaff_retaddr;\n  FUN_1004a620(param_1 + 0x21d8,64000,0);\n  if ((_DAT_10840e5c & 1) == 0) {\n    _DAT_10840e5c = _DAT_10840e5c | 1;\n    DAT_10840e58 = FUN_1004a640(1);\n  }\n  FUN_1004a7b0(DAT_10840e58);\n  (**(code **)(**(int **)(param_1 + 0x21d4) + 0x10))(DAT_10840e58);\n  FUN_1004a730(DAT_10840e58,param_1 + 0x1b0c,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 4,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 5,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 6,1,0);\n  DAT_10840e54 = FUN_1004a7c0(DAT_10840e58);\n  FUN_1004a7b0(DAT_10840e58);\n  FUN_1004a6b0(DAT_10840e58,unaff_retaddr,DAT_10840e54,0);\n  return 1;\n}",
        "output": "```c\nuint32_t process_function(int param_1) {\n    uint32_t return_address;\n    \n    // Initialize some resource with a specific size\n    initialize_resource(param_1 + 0x21d8, 64000, 0);\n    \n    // Check and set a flag if not already set\n    if ((_DAT_10840e5c & 1) == 0) {\n        _DAT_10840e5c |= 1;\n        DAT_10840e58 = allocate_resource(1);\n    }\n    \n    // Perform operations on the allocated resource\n    release_resource(DAT_10840e58);\n    (*(code **)(*(int **)(param_1 + 0x21d4) + 0x10))(DAT_10840e58);\n    \n    // Process data at various offsets\n    process_data(DAT_10840e58, param_1 + 0x1b0c, 1, 0);\n    process_data(DAT_10840e58, param_1 + 4, 1, 0);\n    process_data(DAT_10840e58, param_1 + 5, 1, 0);\n    process_data(DAT_10840e58, param_1 + 6, 1, 0);\n    \n    // Finalize the resource and clean up\n    DAT_10840e54 = finalize_resource(DAT_10840e58);\n    release_resource(DAT_10840e58);\n    cleanup_resource(DAT_10840e58, return_address, DAT_10840e54, 0);\n    \n    return 1;\n}\n```",
        "normed_func_sha256": "76fe8713c2d7998c190a0e815fd24283ab97f4c85ccb45333e160b7124920fb9",
        "source_code": "bool BotTree::serialize(void *data_)\n{\n   memstream_set_buffer(buffer, MEM_STREAM_BUFFER_SIZE);\n   static memstream_t *stream = memstream_open(1);\n   assert(stream != NULL);\n   memstream_rewind(stream);\n   assert(tree != NULL);\n   tree->serialize(stream);                                                                            // write to the stream\n   memstream_write(stream, &calculatedBestCellToPickUpBonus, sizeof(calculatedBestCellToPickUpBonus)); // write to the stream\n   memstream_write(stream, &_direction1FrameAgo, sizeof(_direction1FrameAgo));                         // write to the stream\n   memstream_write(stream, &_direction2FramesAgo, sizeof(_direction2FramesAgo));                       // write to the stream\n   memstream_write(stream, &_shiveringCounter, sizeof(_shiveringCounter));                             // write to the stream\n   serializeSize = memstream_pos(stream);\n   memstream_rewind(stream);\n   memstream_read(stream, data_, serializeSize);     // read from the stream\n   return(true);\n}",
        "parsed_output": "uint32_t process_function(int param_1) {\n    uint32_t return_address;\n    \n    // Initialize some resource with a specific size\n    initialize_resource(param_1 + 0x21d8, 64000, 0);\n    \n    // Check and set a flag if not already set\n    if ((_DAT_10840e5c & 1) == 0) {\n        _DAT_10840e5c |= 1;\n        DAT_10840e58 = allocate_resource(1);\n    }\n    \n    // Perform operations on the allocated resource\n    release_resource(DAT_10840e58);\n    (*(code **)(*(int **)(param_1 + 0x21d4) + 0x10))(DAT_10840e58);\n    \n    // Process data at various offsets\n    process_data(DAT_10840e58, param_1 + 0x1b0c, 1, 0);\n    process_data(DAT_10840e58, param_1 + 4, 1, 0);\n    process_data(DAT_10840e58, param_1 + 5, 1, 0);\n    process_data(DAT_10840e58, param_1 + 6, 1, 0);\n    \n    // Finalize the resource and clean up\n    DAT_10840e54 = finalize_resource(DAT_10840e58);\n    release_resource(DAT_10840e58);\n    cleanup_resource(DAT_10840e58, return_address, DAT_10840e54, 0);\n    \n    return 1;\n}",
        "baseline_code_stripped": "undefined4 __fastcall FUN_10002610(int param_1)\n{\n  undefined4 unaff_retaddr;\n  FUN_1004a620(param_1 + 0x21d8,64000,0);\n  if ((_DAT_10840e5c & 1) == 0) {\n    _DAT_10840e5c = _DAT_10840e5c | 1;\n    DAT_10840e58 = FUN_1004a640(1);\n  }\n  FUN_1004a7b0(DAT_10840e58);\n  (**(code **)(**(int **)(param_1 + 0x21d4) + 0x10))(DAT_10840e58);\n  FUN_1004a730(DAT_10840e58,param_1 + 0x1b0c,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 4,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 5,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 6,1,0);\n  DAT_10840e54 = FUN_1004a7c0(DAT_10840e58);\n  FUN_1004a7b0(DAT_10840e58);\n  FUN_1004a6b0(DAT_10840e58,unaff_retaddr,DAT_10840e54,0);\n  return 1;\n}",
        "similarity_score_unixcoder": 0.46545690298080444,
        "similarity_score_baseline_stripped": 0.45023924112319946
    },
    {
        "func_name": "fp_Line::findNextTabStop",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nbool __thiscall\nfp_Line::findNextTabStop\n          (fp_Line *this,int param_1,int *param_2,eTabType *param_3,eTabLeader *param_4)\n{\n  fl_BlockLayout *this_00;\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int in_GS_OFFSET;\n  undefined4 local_2c;\n  undefined4 local_28;\n  int local_24;\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x25e569;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  this_00 = *(fl_BlockLayout **)(this + 0x94);\n  local_24 = 0;\n  local_28 = 0;\n  local_2c = 0;\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar3 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar3 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  iVar1 = getMaxWidth(this);\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar2 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar2 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  fl_BlockLayout::findNextTabStop\n            (this_00,iVar2 + param_1,iVar3 + iVar1,&local_24,(eTabType *)&local_28,\n             (eTabLeader *)&local_2c);\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar3 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar3 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  iVar3 = local_24 - iVar3;\n  local_24 = iVar3;\n  iVar1 = getMaxWidth(this);\n  if (iVar3 <= iVar1) {\n    *param_2 = iVar3;\n    *(undefined4 *)param_3 = local_28;\n    *(undefined4 *)param_4 = local_2c;\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return iVar3 <= iVar1;\n  }\n  FUN_00549f50();\n}",
        "output": "```c\nbool fp_Line::findNextTabStop(fp_Line *this, int offset, int *result, eTabType *tabType, eTabLeader *tabLeader) {\n    fl_BlockLayout *blockLayout;\n    int currentX;\n    int maxWidth;\n    int nextTabStop;\n    int localCheck;\n    int calculatedTabStop = 0;\n    int tabTypeValue = 0;\n    int tabLeaderValue = 0;\n\n    localCheck = *(int *)(in_GS_OFFSET + 0x14);\n    blockLayout = *(fl_BlockLayout **)(this + 0x94);\n\n    if (*(code **)(*(int *)this + 0x20) == getX) {\n        currentX = *(int *)(this + 0xbc);\n    } else {\n        currentX = (**(code **)(*(int *)this + 0x20))(this);\n    }\n\n    maxWidth = getMaxWidth(this);\n\n    if (*(code **)(*(int *)this + 0x20) == getX) {\n        currentX = *(int *)(this + 0xbc);\n    } else {\n        currentX = (**(code **)(*(int *)this + 0x20))(this);\n    }\n\n    fl_BlockLayout::findNextTabStop(blockLayout, currentX + offset, currentX + maxWidth, &calculatedTabStop, (eTabType *)&tabTypeValue, (eTabLeader *)&tabLeaderValue);\n\n    currentX = (calculatedTabStop - currentX);\n    calculatedTabStop = currentX;\n\n    maxWidth = getMaxWidth(this);\n\n    if (calculatedTabStop <= maxWidth) {\n        *result = calculatedTabStop;\n        *tabType = tabTypeValue;\n        *tabLeader = tabLeaderValue;\n    }\n\n    if (localCheck == *(int *)(in_GS_OFFSET + 0x14)) {\n        return calculatedTabStop <= maxWidth;\n    }\n\n    FUN_00549f50();\n}\n```",
        "normed_func_sha256": "fecba40e7ff4a373a5ef76f55418342d9ff5122d0f973287b53889c52c6f7357",
        "source_code": "bool\tfp_Line::findNextTabStop(UT_sint32 iStartX, UT_sint32& iPosition, eTabType & iType, eTabLeader & iLeader )\n{\n\tUT_sint32\tiTabStopPosition = 0;\n\teTabType\tiTabStopType = FL_TAB_NONE;\n\teTabLeader\tiTabStopLeader = FL_LEADER_NONE;\n\n\tUT_DebugOnly<bool> bRes = m_pBlock->findNextTabStop(iStartX + getX(), \n\t\t\t\t\t\t\t    getX() + getMaxWidth(), \n\t\t\t\t\t\t\t    iTabStopPosition, iTabStopType, \n\t\t\t\t\t\t\t    iTabStopLeader);\n\tUT_ASSERT(bRes);\n\n\tiTabStopPosition -= getX();\n\n\t//has to be <=\n\tif (iTabStopPosition <= getMaxWidth())\n\t{\n\t\tiPosition = iTabStopPosition;\n\t\tiType = iTabStopType;\n\t\tiLeader = iTabStopLeader;\n\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tUT_DEBUGMSG((\"fp_Line::findNextTabStop: iStartX %d, getMaxWidth %d\\n\"\n\t\t\t\t\t \"\t\t\tiPosition %d, iTabStopPosition %d, iType %d, iLeader %d\\n\",\n\t\t\t     iStartX, getMaxWidth(),iPosition, iTabStopPosition,static_cast<UT_sint32>(iType), static_cast<UT_sint32>(iLeader)));\n\t\treturn false;\n\t}\n}",
        "parsed_output": "bool fp_Line::findNextTabStop(fp_Line *this, int offset, int *result, eTabType *tabType, eTabLeader *tabLeader) {\n    fl_BlockLayout *blockLayout;\n    int currentX;\n    int maxWidth;\n    int nextTabStop;\n    int localCheck;\n    int calculatedTabStop = 0;\n    int tabTypeValue = 0;\n    int tabLeaderValue = 0;\n\n    localCheck = *(int *)(in_GS_OFFSET + 0x14);\n    blockLayout = *(fl_BlockLayout **)(this + 0x94);\n\n    if (*(code **)(*(int *)this + 0x20) == getX) {\n        currentX = *(int *)(this + 0xbc);\n    } else {\n        currentX = (**(code **)(*(int *)this + 0x20))(this);\n    }\n\n    maxWidth = getMaxWidth(this);\n\n    if (*(code **)(*(int *)this + 0x20) == getX) {\n        currentX = *(int *)(this + 0xbc);\n    } else {\n        currentX = (**(code **)(*(int *)this + 0x20))(this);\n    }\n\n    fl_BlockLayout::findNextTabStop(blockLayout, currentX + offset, currentX + maxWidth, &calculatedTabStop, (eTabType *)&tabTypeValue, (eTabLeader *)&tabLeaderValue);\n\n    currentX = (calculatedTabStop - currentX);\n    calculatedTabStop = currentX;\n\n    maxWidth = getMaxWidth(this);\n\n    if (calculatedTabStop <= maxWidth) {\n        *result = calculatedTabStop;\n        *tabType = tabTypeValue;\n        *tabLeader = tabLeaderValue;\n    }\n\n    if (localCheck == *(int *)(in_GS_OFFSET + 0x14)) {\n        return calculatedTabStop <= maxWidth;\n    }\n\n    FUN_00549f50();\n}",
        "baseline_code_stripped": "bool __thiscall\nfp_Line::findNextTabStop\n          (fp_Line *this,int param_1,int *param_2,eTabType *param_3,eTabLeader *param_4)\n{\n  fl_BlockLayout *this_00;\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int in_GS_OFFSET;\n  undefined4 local_2c;\n  undefined4 local_28;\n  int local_24;\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x25e569;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  this_00 = *(fl_BlockLayout **)(this + 0x94);\n  local_24 = 0;\n  local_28 = 0;\n  local_2c = 0;\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar3 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar3 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  iVar1 = getMaxWidth(this);\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar2 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar2 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  fl_BlockLayout::findNextTabStop\n            (this_00,iVar2 + param_1,iVar3 + iVar1,&local_24,(eTabType *)&local_28,\n             (eTabLeader *)&local_2c);\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar3 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar3 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  iVar3 = local_24 - iVar3;\n  local_24 = iVar3;\n  iVar1 = getMaxWidth(this);\n  if (iVar3 <= iVar1) {\n    *param_2 = iVar3;\n    *(undefined4 *)param_3 = local_28;\n    *(undefined4 *)param_4 = local_2c;\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return iVar3 <= iVar1;\n  }\n  FUN_00549f50();\n}",
        "similarity_score_unixcoder": 0.8084120750427246,
        "similarity_score_baseline_stripped": 0.7001904845237732
    },
    {
        "func_name": "TypeName",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar * FUN_080917f0(undefined4 param_1)\n{\n  undefined4 uVar1;\n  char *pcVar2;\n  undefined local_20 [19];\n  undefined local_d;\n  switch(param_1) {\n  default:\n    FUN_080992e0(local_20,3,\"../../src/google/protobuf/compiler/java/java_extension.cc\",0x48);\n    uVar1 = FUN_080998e0(local_20,\"Can\\'t get here.\");\n    FUN_08099bc0(&local_d,uVar1);\n    FUN_08099a40(local_20);\n    pcVar2 = (char *)0x0;\n    break;\n  case 1:\n    pcVar2 = \"DOUBLE\";\n    break;\n  case 2:\n    pcVar2 = \"FLOAT\";\n    break;\n  case 3:\n    pcVar2 = \"INT64\";\n    break;\n  case 4:\n    pcVar2 = \"UINT64\";\n    break;\n  case 5:\n    pcVar2 = \"INT32\";\n    break;\n  case 6:\n    pcVar2 = \"FIXED64\";\n    break;\n  case 7:\n    pcVar2 = \"FIXED32\";\n    break;\n  case 8:\n    pcVar2 = \"BOOL\";\n    break;\n  case 9:\n    pcVar2 = \"STRING\";\n    break;\n  case 10:\n    pcVar2 = \"GROUP\";\n    break;\n  case 0xb:\n    pcVar2 = \"MESSAGE\";\n    break;\n  case 0xc:\n    pcVar2 = \"BYTES\";\n    break;\n  case 0xd:\n    pcVar2 = \"UINT32\";\n    break;\n  case 0xe:\n    pcVar2 = \"ENUM\";\n    break;\n  case 0xf:\n    pcVar2 = \"SFIXED32\";\n    break;\n  case 0x10:\n    pcVar2 = \"SFIXED64\";\n    break;\n  case 0x11:\n    pcVar2 = \"SINT32\";\n    break;\n  case 0x12:\n    pcVar2 = \"SINT64\";\n  }\n  return pcVar2;\n}",
        "output": "```c\nchar * getTypeName(undefined4 typeId) {\n    undefined4 errorCode;\n    char *typeName;\n    undefined localBuffer[19];\n    undefined localError;\n\n    switch(typeId) {\n        default:\n            FUN_080992e0(localBuffer, 3, \"../../src/google/protobuf/compiler/java/java_extension.cc\", 0x48);\n            errorCode = FUN_080998e0(localBuffer, \"Can't get here.\");\n            FUN_08099bc0(&localError, errorCode);\n            FUN_08099a40(localBuffer);\n            typeName = NULL;\n            break;\n        case 1:\n            typeName = \"DOUBLE\";\n            break;\n        case 2:\n            typeName = \"FLOAT\";\n            break;\n        case 3:\n            typeName = \"INT64\";\n            break;\n        case 4:\n            typeName = \"UINT64\";\n            break;\n        case 5:\n            typeName = \"INT32\";\n            break;\n        case 6:\n            typeName = \"FIXED64\";\n            break;\n        case 7:\n            typeName = \"FIXED32\";\n            break;\n        case 8:\n            typeName = \"BOOL\";\n            break;\n        case 9:\n            typeName = \"STRING\";\n            break;\n        case 10:\n            typeName = \"GROUP\";\n            break;\n        case 11:\n            typeName = \"MESSAGE\";\n            break;\n        case 12:\n            typeName = \"BYTES\";\n            break;\n        case 13:\n            typeName = \"UINT32\";\n            break;\n        case 14:\n            typeName = \"ENUM\";\n            break;\n        case 15:\n            typeName = \"SFIXED32\";\n            break;\n        case 16:\n            typeName = \"SFIXED64\";\n            break;\n        case 17:\n            typeName = \"SINT32\";\n            break;\n        case 18:\n            typeName = \"SINT64\";\n            break;\n    }\n    return typeName;\n}\n```",
        "normed_func_sha256": "d5684d4d62f54b30d28882da40876d002cb7ef0f485aedf958a63d17b5fbb2a5",
        "source_code": "const char* TypeName(FieldDescriptor::Type field_type) {\n  switch (field_type) {\n    case FieldDescriptor::TYPE_INT32   : return \"INT32\";\n    case FieldDescriptor::TYPE_UINT32  : return \"UINT32\";\n    case FieldDescriptor::TYPE_SINT32  : return \"SINT32\";\n    case FieldDescriptor::TYPE_FIXED32 : return \"FIXED32\";\n    case FieldDescriptor::TYPE_SFIXED32: return \"SFIXED32\";\n    case FieldDescriptor::TYPE_INT64   : return \"INT64\";\n    case FieldDescriptor::TYPE_UINT64  : return \"UINT64\";\n    case FieldDescriptor::TYPE_SINT64  : return \"SINT64\";\n    case FieldDescriptor::TYPE_FIXED64 : return \"FIXED64\";\n    case FieldDescriptor::TYPE_SFIXED64: return \"SFIXED64\";\n    case FieldDescriptor::TYPE_FLOAT   : return \"FLOAT\";\n    case FieldDescriptor::TYPE_DOUBLE  : return \"DOUBLE\";\n    case FieldDescriptor::TYPE_BOOL    : return \"BOOL\";\n    case FieldDescriptor::TYPE_STRING  : return \"STRING\";\n    case FieldDescriptor::TYPE_BYTES   : return \"BYTES\";\n    case FieldDescriptor::TYPE_ENUM    : return \"ENUM\";\n    case FieldDescriptor::TYPE_GROUP   : return \"GROUP\";\n    case FieldDescriptor::TYPE_MESSAGE : return \"MESSAGE\";\n  }\n  GOOGLE_LOG(FATAL) << \"Can't get here.\";\n  return NULL;\n}",
        "parsed_output": "char * getTypeName(undefined4 typeId) {\n    undefined4 errorCode;\n    char *typeName;\n    undefined localBuffer[19];\n    undefined localError;\n\n    switch(typeId) {\n        default:\n            FUN_080992e0(localBuffer, 3, \"../../src/google/protobuf/compiler/java/java_extension.cc\", 0x48);\n            errorCode = FUN_080998e0(localBuffer, \"Can't get here.\");\n            FUN_08099bc0(&localError, errorCode);\n            FUN_08099a40(localBuffer);\n            typeName = NULL;\n            break;\n        case 1:\n            typeName = \"DOUBLE\";\n            break;\n        case 2:\n            typeName = \"FLOAT\";\n            break;\n        case 3:\n            typeName = \"INT64\";\n            break;\n        case 4:\n            typeName = \"UINT64\";\n            break;\n        case 5:\n            typeName = \"INT32\";\n            break;\n        case 6:\n            typeName = \"FIXED64\";\n            break;\n        case 7:\n            typeName = \"FIXED32\";\n            break;\n        case 8:\n            typeName = \"BOOL\";\n            break;\n        case 9:\n            typeName = \"STRING\";\n            break;\n        case 10:\n            typeName = \"GROUP\";\n            break;\n        case 11:\n            typeName = \"MESSAGE\";\n            break;\n        case 12:\n            typeName = \"BYTES\";\n            break;\n        case 13:\n            typeName = \"UINT32\";\n            break;\n        case 14:\n            typeName = \"ENUM\";\n            break;\n        case 15:\n            typeName = \"SFIXED32\";\n            break;\n        case 16:\n            typeName = \"SFIXED64\";\n            break;\n        case 17:\n            typeName = \"SINT32\";\n            break;\n        case 18:\n            typeName = \"SINT64\";\n            break;\n    }\n    return typeName;\n}",
        "baseline_code_stripped": "char * FUN_080917f0(undefined4 param_1)\n{\n  undefined4 uVar1;\n  char *pcVar2;\n  undefined local_20 [19];\n  undefined local_d;\n  switch(param_1) {\n  default:\n    FUN_080992e0(local_20,3,\"../../src/google/protobuf/compiler/java/java_extension.cc\",0x48);\n    uVar1 = FUN_080998e0(local_20,\"Can\\'t get here.\");\n    FUN_08099bc0(&local_d,uVar1);\n    FUN_08099a40(local_20);\n    pcVar2 = (char *)0x0;\n    break;\n  case 1:\n    pcVar2 = \"DOUBLE\";\n    break;\n  case 2:\n    pcVar2 = \"FLOAT\";\n    break;\n  case 3:\n    pcVar2 = \"INT64\";\n    break;\n  case 4:\n    pcVar2 = \"UINT64\";\n    break;\n  case 5:\n    pcVar2 = \"INT32\";\n    break;\n  case 6:\n    pcVar2 = \"FIXED64\";\n    break;\n  case 7:\n    pcVar2 = \"FIXED32\";\n    break;\n  case 8:\n    pcVar2 = \"BOOL\";\n    break;\n  case 9:\n    pcVar2 = \"STRING\";\n    break;\n  case 10:\n    pcVar2 = \"GROUP\";\n    break;\n  case 0xb:\n    pcVar2 = \"MESSAGE\";\n    break;\n  case 0xc:\n    pcVar2 = \"BYTES\";\n    break;\n  case 0xd:\n    pcVar2 = \"UINT32\";\n    break;\n  case 0xe:\n    pcVar2 = \"ENUM\";\n    break;\n  case 0xf:\n    pcVar2 = \"SFIXED32\";\n    break;\n  case 0x10:\n    pcVar2 = \"SFIXED64\";\n    break;\n  case 0x11:\n    pcVar2 = \"SINT32\";\n    break;\n  case 0x12:\n    pcVar2 = \"SINT64\";\n  }\n  return pcVar2;\n}",
        "similarity_score_unixcoder": 0.7829382419586182,
        "similarity_score_baseline_stripped": 0.593778669834137
    },
    {
        "func_name": "log_Z3_algebraic_eval",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_012f3f90(undefined8 param_1,undefined8 param_2,int param_3,undefined8 *param_4)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  FUN_012ea5d0();\n  FUN_012ea740(param_1);\n  FUN_012ea740(param_2);\n  FUN_012ea6f0(param_3);\n  puVar1 = param_4 + (ulong)(param_3 - 1) + 1;\n  if (param_3 != 0) {\n    do {\n      uVar2 = *param_4;\n      param_4 = param_4 + 1;\n      FUN_012ea740(uVar2);\n    } while (param_4 != puVar1);\n  }\n  FUN_012ea830(param_3);\n  FUN_012ea6a0(0x207);\n  return;\n}",
        "output": "```c\nvoid processParameters(undefined8 param1, undefined8 param2, int paramCount, undefined8 *paramArray)\n{\n    undefined8 *endPointer;\n    undefined8 currentParam;\n\n    initializeFunction();\n    handleParameter(param1);\n    handleParameter(param2);\n    validateParameterCount(paramCount);\n\n    endPointer = paramArray + paramCount; // Point to the end of the parameters\n    if (paramCount > 0) {\n        for (undefined8 *currentPointer = paramArray; currentPointer != endPointer; currentPointer++) {\n            currentParam = *currentPointer;\n            handleParameter(currentParam);\n        }\n    }\n\n    finalizeProcessing(paramCount);\n    logStatus(0x207);\n    return;\n}\n```",
        "normed_func_sha256": "2b3e7f22436b94f80bd68b8460b22a2dc95cb730cfbf85d7aa1c78caa227c9db",
        "source_code": "void log_Z3_algebraic_eval(Z3_context a0, Z3_ast a1, unsigned a2, Z3_ast const * a3) {\n  R();\n  P(a0);\n  P(a1);\n  U(a2);\n  for (unsigned i = 0; i < a2; i++) { P(a3[i]); }\n  Ap(a2);\n  C(519);\n}",
        "parsed_output": "void processParameters(undefined8 param1, undefined8 param2, int paramCount, undefined8 *paramArray)\n{\n    undefined8 *endPointer;\n    undefined8 currentParam;\n\n    initializeFunction();\n    handleParameter(param1);\n    handleParameter(param2);\n    validateParameterCount(paramCount);\n\n    endPointer = paramArray + paramCount; // Point to the end of the parameters\n    if (paramCount > 0) {\n        for (undefined8 *currentPointer = paramArray; currentPointer != endPointer; currentPointer++) {\n            currentParam = *currentPointer;\n            handleParameter(currentParam);\n        }\n    }\n\n    finalizeProcessing(paramCount);\n    logStatus(0x207);\n    return;\n}",
        "baseline_code_stripped": "void FUN_012f3f90(undefined8 param_1,undefined8 param_2,int param_3,undefined8 *param_4)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  FUN_012ea5d0();\n  FUN_012ea740(param_1);\n  FUN_012ea740(param_2);\n  FUN_012ea6f0(param_3);\n  puVar1 = param_4 + (ulong)(param_3 - 1) + 1;\n  if (param_3 != 0) {\n    do {\n      uVar2 = *param_4;\n      param_4 = param_4 + 1;\n      FUN_012ea740(uVar2);\n    } while (param_4 != puVar1);\n  }\n  FUN_012ea830(param_3);\n  FUN_012ea6a0(0x207);\n  return;\n}",
        "similarity_score_unixcoder": 0.4578036069869995,
        "similarity_score_baseline_stripped": 0.49670955538749695
    },
    {
        "func_name": "CAAEquinoxesAndSolstices::LengthOfSummer",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\ndouble FUN_18002d650(long param_1,char param_2,bool param_3)\n{\n  double dVar1;\n  double dVar2;\n  if (param_2 == '\\0') {\n    dVar1 = CAAEquinoxesAndSolstices::NorthwardEquinox(param_1 + 1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::SouthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  else {\n    dVar1 = CAAEquinoxesAndSolstices::SouthwardEquinox(param_1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::NorthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  return dVar1;\n}",
        "output": "```c\ndouble CalculateEquinoxAndSolsticeDifference(long year, char hemisphere, bool isLeapYear)\n{\n    double equinox;\n    double solstice;\n\n    if (hemisphere == '\\0') {\n        equinox = CAAEquinoxesAndSolstices::NorthwardEquinox(year + 1, isLeapYear);\n        solstice = CAAEquinoxesAndSolstices::SouthernSolstice(year, isLeapYear);\n    } else {\n        equinox = CAAEquinoxesAndSolstices::SouthwardEquinox(year, isLeapYear);\n        solstice = CAAEquinoxesAndSolstices::NorthernSolstice(year, isLeapYear);\n    }\n\n    return equinox - solstice;\n}\n```",
        "normed_func_sha256": "de710b8ff868c8b978ae374914daad4f0d5ac6873216a44ff1afcd9f6b0ed833",
        "source_code": "double CAAEquinoxesAndSolstices::LengthOfSummer(long Year, bool bNorthernHemisphere, bool bHighPrecision) noexcept\r\n{\r\n  if (bNorthernHemisphere)\r\n    return SouthwardEquinox(Year, bHighPrecision) - NorthernSolstice(Year, bHighPrecision);\r\n  else\r\n  {\r\n    //The Summer season wraps around into the following year for the southern hemisphere\r\n    return NorthwardEquinox(Year + 1, bHighPrecision) - SouthernSolstice(Year, bHighPrecision);\r\n  }\r\n}",
        "parsed_output": "double CalculateEquinoxAndSolsticeDifference(long year, char hemisphere, bool isLeapYear)\n{\n    double equinox;\n    double solstice;\n\n    if (hemisphere == '\\0') {\n        equinox = CAAEquinoxesAndSolstices::NorthwardEquinox(year + 1, isLeapYear);\n        solstice = CAAEquinoxesAndSolstices::SouthernSolstice(year, isLeapYear);\n    } else {\n        equinox = CAAEquinoxesAndSolstices::SouthwardEquinox(year, isLeapYear);\n        solstice = CAAEquinoxesAndSolstices::NorthernSolstice(year, isLeapYear);\n    }\n\n    return equinox - solstice;\n}",
        "baseline_code_stripped": "double FUN_18002d650(long param_1,char param_2,bool param_3)\n{\n  double dVar1;\n  double dVar2;\n  if (param_2 == '\\0') {\n    dVar1 = CAAEquinoxesAndSolstices::NorthwardEquinox(param_1 + 1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::SouthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  else {\n    dVar1 = CAAEquinoxesAndSolstices::SouthwardEquinox(param_1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::NorthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  return dVar1;\n}",
        "similarity_score_unixcoder": 0.7971938848495483,
        "similarity_score_baseline_stripped": 0.5614171624183655
    },
    {
        "func_name": "Scm_S32VectorSet",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint Scm_S32VectorSet(int param_1,int param_2,undefined4 param_3,undefined4 param_4)\n{\n  undefined4 uVar1;\n  if ((param_2 < 0) || (*(int *)(param_1 + 4) >> 1 <= param_2)) {\n    Scm_Error(\"index out of range: %d\",param_2);\n  }\n  if ((*(byte *)(param_1 + 4) & 1) != 0) {\n    Scm_Error(\"uniform vector is immutable: %S\",param_1);\n  }\n  uVar1 = Scm_GetInteger32Clamp(param_3,param_4,0);\n  *(undefined4 *)(*(int *)(param_1 + 0xc) + param_2 * 4) = uVar1;\n  return param_1;\n}",
        "output": "```c\nint Scm_S32VectorSet(int vectorPtr, int index, undefined4 value, undefined4 clampValue)\n{\n    undefined4 clampedValue;\n\n    // Check if the index is out of range\n    if ((index < 0) || (*(int *)(vectorPtr + 4) >> 1 <= index)) {\n        Scm_Error(\"index out of range: %d\", index);\n    }\n\n    // Check if the vector is immutable\n    if ((*(byte *)(vectorPtr + 4) & 1) != 0) {\n        Scm_Error(\"uniform vector is immutable: %S\", vectorPtr);\n    }\n\n    // Clamp the value and set it in the vector\n    clampedValue = Scm_GetInteger32Clamp(value, clampValue, 0);\n    *(undefined4 *)(*(int *)(vectorPtr + 0xc) + index * 4) = clampedValue;\n\n    return vectorPtr;\n}\n```",
        "normed_func_sha256": "747814e3360de27d88c17c45d311f75c97043d5c39faf4a77b6b7c2eea7dd68a",
        "source_code": "ScmObj Scm_S32VectorSet(ScmS32Vector *vec, int index, ScmObj val, int clamp)\n{\n    ScmInt32 elt;\n    if (index < 0 || index >= SCM_S32VECTOR_SIZE(vec))\n        Scm_Error(\"index out of range: %d\", index);\n    SCM_UVECTOR_CHECK_MUTABLE(vec);\n    elt = (ScmInt32)Scm_GetInteger32Clamp(val, clamp, NULL);\n    SCM_S32VECTOR_ELEMENTS(vec)[index] = elt;\n    return SCM_OBJ(vec);\n}",
        "parsed_output": "int Scm_S32VectorSet(int vectorPtr, int index, undefined4 value, undefined4 clampValue)\n{\n    undefined4 clampedValue;\n\n    // Check if the index is out of range\n    if ((index < 0) || (*(int *)(vectorPtr + 4) >> 1 <= index)) {\n        Scm_Error(\"index out of range: %d\", index);\n    }\n\n    // Check if the vector is immutable\n    if ((*(byte *)(vectorPtr + 4) & 1) != 0) {\n        Scm_Error(\"uniform vector is immutable: %S\", vectorPtr);\n    }\n\n    // Clamp the value and set it in the vector\n    clampedValue = Scm_GetInteger32Clamp(value, clampValue, 0);\n    *(undefined4 *)(*(int *)(vectorPtr + 0xc) + index * 4) = clampedValue;\n\n    return vectorPtr;\n}",
        "baseline_code_stripped": "int Scm_S32VectorSet(int param_1,int param_2,undefined4 param_3,undefined4 param_4)\n{\n  undefined4 uVar1;\n  if ((param_2 < 0) || (*(int *)(param_1 + 4) >> 1 <= param_2)) {\n    Scm_Error(\"index out of range: %d\",param_2);\n  }\n  if ((*(byte *)(param_1 + 4) & 1) != 0) {\n    Scm_Error(\"uniform vector is immutable: %S\",param_1);\n  }\n  uVar1 = Scm_GetInteger32Clamp(param_3,param_4,0);\n  *(undefined4 *)(*(int *)(param_1 + 0xc) + param_2 * 4) = uVar1;\n  return param_1;\n}",
        "similarity_score_unixcoder": 0.7870751023292542,
        "similarity_score_baseline_stripped": 0.7355295419692993
    },
    {
        "func_name": "rtw89_ops_add_interface",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint rtw89_ops_add_interface(long param_1,long param_2)\n{\n  long lVar1;\n  char cVar2;\n  int iVar3;\n  long lVar4;\n  long lVar5;\n  long *plVar6;\n  lVar1 = param_2 + 0x408;\n  lVar5 = *(long *)(param_1 + 0x50);\n  mutex_lock(lVar5 + 0x298);\n  *(long *)(param_2 + 0x418) = lVar5;\n  plVar6 = *(long **)(lVar5 + 0x2c0);\n  cVar2 = __list_add_valid(lVar1,plVar6,lVar5 + 0x2b8);\n  if (cVar2 != '\\0') {\n    *(long *)(lVar5 + 0x2c0) = lVar1;\n    *(long *)(param_2 + 0x408) = lVar5 + 0x2b8;\n    *(long **)(param_2 + 0x410) = plVar6;\n    *plVar6 = lVar1;\n  }\n  *(undefined8 *)(param_2 + 0x440) = 0xfffffffe0;\n  *(long *)(param_2 + 0x448) = param_2 + 0x448;\n  *(long *)(param_2 + 0x450) = param_2 + 0x448;\n  *(code **)(param_2 + 0x458) = rtw89_core_update_beacon_work;\n  rtw89_leave_ps_mode(lVar5);\n  rtw89_traffic_stats_init(lVar5,param_2 + 0x500);\n  rtw89_vif_type_mapping(param_2,0);\n  cVar2 = rtw89_core_acquire_bit_map(lVar5 + 0x5c0,5);\n  *(char *)(param_2 + 0x421) = cVar2;\n  if (cVar2 == '\\x05') {\n    iVar3 = -0x1c;\n  }\n  else {\n    *(undefined2 *)(param_2 + 0x42e) = 0;\n    *(undefined2 *)(param_2 + 0x434) = 0;\n    *(undefined4 *)(param_2 + 0x422) = *(undefined4 *)(param_2 + 0x3dc);\n    *(undefined2 *)(param_2 + 0x426) = *(undefined2 *)(param_2 + 0x3e0);\n    iVar3 = rtw89_mac_add_vif(lVar5,lVar1);\n    if (iVar3 == 0) {\n      lVar4 = *(long *)(param_2 + 1000);\n      if (lVar4 != 0) {\n        *(long *)(lVar4 + 0x18) = lVar4 + 0x18;\n        *(long *)(lVar4 + 0x20) = lVar4 + 0x18;\n      }\n      rtw89_btc_ntfy_role_info(lVar5,lVar1,0,0);\n      rtw89_recalc_lps(lVar5);\n    }\n    else {\n      rtw89_core_release_bit_map(lVar5 + 0x5c0,*(undefined *)(param_2 + 0x421));\n    }\n  }\n  mutex_unlock(lVar5 + 0x298);\n  return iVar3;\n}",
        "output": "```c\nint rtw89_ops_add_interface(long param_1, long param_2) {\n    long interface_address;\n    char bitmap_status;\n    int result;\n    long device_context;\n    long vif_pointer;\n    long *list_pointer;\n\n    interface_address = param_2 + 0x408;\n    device_context = *(long *)(param_1 + 0x50);\n    \n    mutex_lock(device_context + 0x298);\n    \n    *(long *)(param_2 + 0x418) = device_context;\n    list_pointer = *(long **)(device_context + 0x2c0);\n    \n    bitmap_status = __list_add_valid(interface_address, list_pointer, device_context + 0x2b8);\n    \n    if (bitmap_status != '\\0') {\n        *(long *)(device_context + 0x2c0) = interface_address;\n        *(long *)(param_2 + 0x408) = device_context + 0x2b8;\n        *(long **)(param_2 + 0x410) = list_pointer;\n        *list_pointer = interface_address;\n    }\n    \n    *(undefined8 *)(param_2 + 0x440) = 0xfffffffe0;\n    *(long *)(param_2 + 0x448) = param_2 + 0x448;\n    *(long *)(param_2 + 0x450) = param_2 + 0x448;\n    *(code **)(param_2 + 0x458) = rtw89_core_update_beacon_work;\n    \n    rtw89_leave_ps_mode(device_context);\n    rtw89_traffic_stats_init(device_context, param_2 + 0x500);\n    rtw89_vif_type_mapping(param_2, 0);\n    \n    bitmap_status = rtw89_core_acquire_bit_map(device_context + 0x5c0, 5);\n    *(char *)(param_2 + 0x421) = bitmap_status;\n    \n    if (bitmap_status == '\\x05') {\n        result = -0x1c;\n    } else {\n        *(undefined2 *)(param_2 + 0x42e) = 0;\n        *(undefined2 *)(param_2 + 0x434) = 0;\n        *(undefined4 *)(param_2 + 0x422) = *(undefined4 *)(param_2 + 0x3dc);\n        *(undefined2 *)(param_2 + 0x426) = *(undefined2 *)(param_2 + 0x3e0);\n        \n        result = rtw89_mac_add_vif(device_context, interface_address);\n        \n        if (result == 0) {\n            vif_pointer = *(long *)(param_2 + 1000);\n            if (vif_pointer != 0) {\n                *(long *)(vif_pointer + 0x18) = vif_pointer + 0x18;\n                *(long *)(vif_pointer + 0x20) = vif_pointer + 0x18;\n            }\n            rtw89_btc_ntfy_role_info(device_context, interface_address, 0, 0);\n            rtw89_recalc_lps(device_context);\n        } else {\n            rtw89_core_release_bit_map(device_context + 0x5c0, *(undefined *)(param_2 + 0x421));\n        }\n    }\n    \n    mutex_unlock(device_context + 0x298);\n    return result;\n}\n```",
        "normed_func_sha256": "e412389363a5bbe12a8c36cbbf208b0c9c41f543489e2645bf58beb28294b68b",
        "source_code": "static int rtw89_ops_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tint ret = 0;\n\n\trtw89_debug(rtwdev, RTW89_DBG_STATE, \"add vif %pM type %d, p2p %d\\n\",\n\t\t    vif->addr, vif->type, vif->p2p);\n\n\tmutex_lock(&rtwdev->mutex);\n\trtwvif->rtwdev = rtwdev;\n\tlist_add_tail(&rtwvif->list, &rtwdev->rtwvifs_list);\n\tINIT_WORK(&rtwvif->update_beacon_work, rtw89_core_update_beacon_work);\n\trtw89_leave_ps_mode(rtwdev);\n\n\trtw89_traffic_stats_init(rtwdev, &rtwvif->stats);\n\trtw89_vif_type_mapping(vif, false);\n\trtwvif->port = rtw89_core_acquire_bit_map(rtwdev->hw_port,\n\t\t\t\t\t\t  RTW89_PORT_NUM);\n\tif (rtwvif->port == RTW89_PORT_NUM) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\trtwvif->bcn_hit_cond = 0;\n\trtwvif->mac_idx = RTW89_MAC_0;\n\trtwvif->phy_idx = RTW89_PHY_0;\n\trtwvif->hit_rule = 0;\n\tether_addr_copy(rtwvif->mac_addr, vif->addr);\n\n\tret = rtw89_mac_add_vif(rtwdev, rtwvif);\n\tif (ret) {\n\t\trtw89_core_release_bit_map(rtwdev->hw_port, rtwvif->port);\n\t\tgoto out;\n\t}\n\n\trtw89_core_txq_init(rtwdev, vif->txq);\n\n\trtw89_btc_ntfy_role_info(rtwdev, rtwvif, NULL, BTC_ROLE_START);\n\n\trtw89_recalc_lps(rtwdev);\nout:\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}",
        "parsed_output": "int rtw89_ops_add_interface(long param_1, long param_2) {\n    long interface_address;\n    char bitmap_status;\n    int result;\n    long device_context;\n    long vif_pointer;\n    long *list_pointer;\n\n    interface_address = param_2 + 0x408;\n    device_context = *(long *)(param_1 + 0x50);\n    \n    mutex_lock(device_context + 0x298);\n    \n    *(long *)(param_2 + 0x418) = device_context;\n    list_pointer = *(long **)(device_context + 0x2c0);\n    \n    bitmap_status = __list_add_valid(interface_address, list_pointer, device_context + 0x2b8);\n    \n    if (bitmap_status != '\\0') {\n        *(long *)(device_context + 0x2c0) = interface_address;\n        *(long *)(param_2 + 0x408) = device_context + 0x2b8;\n        *(long **)(param_2 + 0x410) = list_pointer;\n        *list_pointer = interface_address;\n    }\n    \n    *(undefined8 *)(param_2 + 0x440) = 0xfffffffe0;\n    *(long *)(param_2 + 0x448) = param_2 + 0x448;\n    *(long *)(param_2 + 0x450) = param_2 + 0x448;\n    *(code **)(param_2 + 0x458) = rtw89_core_update_beacon_work;\n    \n    rtw89_leave_ps_mode(device_context);\n    rtw89_traffic_stats_init(device_context, param_2 + 0x500);\n    rtw89_vif_type_mapping(param_2, 0);\n    \n    bitmap_status = rtw89_core_acquire_bit_map(device_context + 0x5c0, 5);\n    *(char *)(param_2 + 0x421) = bitmap_status;\n    \n    if (bitmap_status == '\\x05') {\n        result = -0x1c;\n    } else {\n        *(undefined2 *)(param_2 + 0x42e) = 0;\n        *(undefined2 *)(param_2 + 0x434) = 0;\n        *(undefined4 *)(param_2 + 0x422) = *(undefined4 *)(param_2 + 0x3dc);\n        *(undefined2 *)(param_2 + 0x426) = *(undefined2 *)(param_2 + 0x3e0);\n        \n        result = rtw89_mac_add_vif(device_context, interface_address);\n        \n        if (result == 0) {\n            vif_pointer = *(long *)(param_2 + 1000);\n            if (vif_pointer != 0) {\n                *(long *)(vif_pointer + 0x18) = vif_pointer + 0x18;\n                *(long *)(vif_pointer + 0x20) = vif_pointer + 0x18;\n            }\n            rtw89_btc_ntfy_role_info(device_context, interface_address, 0, 0);\n            rtw89_recalc_lps(device_context);\n        } else {\n            rtw89_core_release_bit_map(device_context + 0x5c0, *(undefined *)(param_2 + 0x421));\n        }\n    }\n    \n    mutex_unlock(device_context + 0x298);\n    return result;\n}",
        "baseline_code_stripped": "int rtw89_ops_add_interface(long param_1,long param_2)\n{\n  long lVar1;\n  char cVar2;\n  int iVar3;\n  long lVar4;\n  long lVar5;\n  long *plVar6;\n  lVar1 = param_2 + 0x408;\n  lVar5 = *(long *)(param_1 + 0x50);\n  mutex_lock(lVar5 + 0x298);\n  *(long *)(param_2 + 0x418) = lVar5;\n  plVar6 = *(long **)(lVar5 + 0x2c0);\n  cVar2 = __list_add_valid(lVar1,plVar6,lVar5 + 0x2b8);\n  if (cVar2 != '\\0') {\n    *(long *)(lVar5 + 0x2c0) = lVar1;\n    *(long *)(param_2 + 0x408) = lVar5 + 0x2b8;\n    *(long **)(param_2 + 0x410) = plVar6;\n    *plVar6 = lVar1;\n  }\n  *(undefined8 *)(param_2 + 0x440) = 0xfffffffe0;\n  *(long *)(param_2 + 0x448) = param_2 + 0x448;\n  *(long *)(param_2 + 0x450) = param_2 + 0x448;\n  *(code **)(param_2 + 0x458) = rtw89_core_update_beacon_work;\n  rtw89_leave_ps_mode(lVar5);\n  rtw89_traffic_stats_init(lVar5,param_2 + 0x500);\n  rtw89_vif_type_mapping(param_2,0);\n  cVar2 = rtw89_core_acquire_bit_map(lVar5 + 0x5c0,5);\n  *(char *)(param_2 + 0x421) = cVar2;\n  if (cVar2 == '\\x05') {\n    iVar3 = -0x1c;\n  }\n  else {\n    *(undefined2 *)(param_2 + 0x42e) = 0;\n    *(undefined2 *)(param_2 + 0x434) = 0;\n    *(undefined4 *)(param_2 + 0x422) = *(undefined4 *)(param_2 + 0x3dc);\n    *(undefined2 *)(param_2 + 0x426) = *(undefined2 *)(param_2 + 0x3e0);\n    iVar3 = rtw89_mac_add_vif(lVar5,lVar1);\n    if (iVar3 == 0) {\n      lVar4 = *(long *)(param_2 + 1000);\n      if (lVar4 != 0) {\n        *(long *)(lVar4 + 0x18) = lVar4 + 0x18;\n        *(long *)(lVar4 + 0x20) = lVar4 + 0x18;\n      }\n      rtw89_btc_ntfy_role_info(lVar5,lVar1,0,0);\n      rtw89_recalc_lps(lVar5);\n    }\n    else {\n      rtw89_core_release_bit_map(lVar5 + 0x5c0,*(undefined *)(param_2 + 0x421));\n    }\n  }\n  mutex_unlock(lVar5 + 0x298);\n  return iVar3;\n}",
        "similarity_score_unixcoder": 0.7267266511917114,
        "similarity_score_baseline_stripped": 0.6887229681015015
    },
    {
        "func_name": "imap_appenduid",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 __regparm3\nFUN_08060340(void *param_1_00,undefined4 param_2_00,undefined4 param_3_00,int param_1,\n            undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,\n            undefined4 param_6)\n{\n  int iVar1;\n  char **ppcVar2;\n  byte bVar3;\n  char *local_20d8;\n  undefined4 local_20d4;\n  int local_20cc;\n  int local_20c8;\n  undefined4 local_20c4;\n  undefined4 local_20c0;\n  undefined4 local_20bc;\n  undefined4 local_20b8;\n  undefined4 local_20b4;\n  ulong local_2090;\n  char *local_2080;\n  undefined4 local_207c;\n  undefined4 local_2078;\n  ulong local_205c;\n  undefined4 local_2054;\n  undefined4 local_2050;\n  bVar3 = 0;\n  iVar1 = FUN_08088df0(DAT_08098edc,\"[APPENDUID \");\n  if (iVar1 != 0) {\n    local_205c = strtoul((char *)(iVar1 + 0xb),&local_20d8,10);\n    local_2090 = strtoul(local_20d8,&local_2080,10);\n    if ((((local_205c != 0) && (local_2090 != 0)) && ((char *)(iVar1 + 0xb) < local_20d8)) &&\n       (((*local_20d8 == ' ' && (local_20d8 < local_2080)) && (*local_2080 == ']')))) {\n      memcpy(&local_2080,param_1_00,0x2064);\n      local_2050 = 0;\n      local_2054 = FUN_080880d0(param_6);\n      local_207c = param_2_00;\n      local_2078 = param_2_00;\n      FUN_080697d0(&local_2080);\n      ppcVar2 = &local_20d8;\n      for (iVar1 = 0x16; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *ppcVar2 = (char *)0x0;\n        ppcVar2 = ppcVar2 + (uint)bVar3 * -2 + 1;\n      }\n      local_20d8 = (char *)CONCAT31((uint3)((uint)param_5 >> 8) & 1,0x80);\n      local_20d4 = 3;\n      local_20cc = param_1 + 0xfff;\n      if (-1 < param_1) {\n        local_20cc = param_1;\n      }\n      local_20cc = local_20cc >> 0xc;\n      local_20c8 = param_1 % 0x1000;\n      local_20c4 = param_3;\n      local_20c0 = param_2;\n      local_20b8 = param_4;\n      local_20bc = param_4;\n      local_20b4 = param_3_00;\n      FUN_08069260(&local_2080,&local_20d8);\n      return 1;\n    }\n  }\n  return 0;\n}",
        "output": "```c\nundefined4 __regparm3\nFUN_08060340(void *inputParam, undefined4 param2, undefined4 param3, int param1,\n            undefined4 param4, undefined4 param5, undefined4 param6, undefined4 param7,\n            undefined4 param8)\n{\n    int result;\n    char **stringPointer;\n    byte flag;\n    char *localBuffer;\n    undefined4 localValue1;\n    int localValue2;\n    int localValue3;\n    undefined4 localValue4;\n    undefined4 localValue5;\n    undefined4 localValue6;\n    undefined4 localValue7;\n    undefined4 localValue8;\n    ulong localValue9;\n    char *localPointer;\n    undefined4 localValue10;\n    undefined4 localValue11;\n    ulong localValue12;\n    undefined4 localValue13;\n    undefined4 localValue14;\n\n    flag = 0;\n    result = FUN_08088df0(DAT_08098edc, \"[APPENDUID \");\n    \n    if (result != 0) {\n        localValue12 = strtoul((char *)(result + 0xb), &localBuffer, 10);\n        localValue9 = strtoul(localBuffer, &localPointer, 10);\n        \n        if (localValue12 != 0 && localValue9 != 0 && (char *)(result + 0xb) < localBuffer &&\n            *localBuffer == ' ' && localBuffer < localPointer && *localPointer == ']') {\n            \n            memcpy(&localPointer, inputParam, 0x2064);\n            localValue14 = 0;\n            localValue13 = FUN_080880d0(param8);\n            localValue10 = param2;\n            localValue11 = param2;\n            FUN_080697d0(&localPointer);\n            \n            stringPointer = &localBuffer;\n            for (result = 0x16; result != 0; result--) {\n                *stringPointer = (char *)0x0;\n                stringPointer += (uint)flag * -2 + 1;\n            }\n            \n            localBuffer = (char *)CONCAT31((uint3)((uint)param7 >> 8) & 1, 0x80);\n            localValue1 = 3;\n            localValue2 = param1 + 0xfff;\n            \n            if (param1 >= 0) {\n                localValue2 = param1;\n            }\n            \n            localValue2 >>= 0xc;\n            localValue3 = param1 % 0x1000;\n            localValue4 = param3;\n            localValue5 = param2;\n            localValue8 = param6;\n            localValue6 = param6;\n            localValue7 = param5;\n            \n            FUN_08069260(&localPointer, &localBuffer);\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n```",
        "normed_func_sha256": "5e356651556c06d457242e6b3cfe55e6221a6c8cf7f642fb73c9e7899908ca3c",
        "source_code": "static enum okay\nimap_appenduid(struct mailbox *mp, FILE *fp, time_t t, long off1,\n\t\tlong xsize, long size, long lines, int flag, const char *name)\n{\n\tconst char\t*cp;\n\tunsigned long\tuidvalidity, uid;\n\tstruct mailbox\txmb;\n\tstruct message\txm;\n\tif ((cp = asccasestr(responded_text, \"[APPENDUID \")) == NULL ||\n\t\t\timap_appenduid_parse(&cp[11], &uidvalidity,\n\t\t\t\t&uid) == STOP)\n\t\treturn STOP;\n\txmb = *mp;\n\txmb.mb_cache_directory = NULL;\n\txmb.mb_imap_mailbox = savestr(name);\n\txmb.mb_uidvalidity = uidvalidity;\n\txmb.mb_otf = xmb.mb_itf = fp;\n\tinitcache(&xmb);\n\tmemset(&xm, 0, sizeof xm);\n\txm.m_flag = (flag & MREAD) | MNEW;\n\txm.m_time = t;\n\txm.m_block = mailx_blockof(off1);\n\txm.m_offset = mailx_offsetof(off1);\n\txm.m_size = size;\n\txm.m_xsize = xsize;\n\txm.m_lines = xm.m_xlines = lines;\n\txm.m_uid = uid;\n\txm.m_have = HAVE_HEADER|HAVE_BODY;\n\tputcache(&xmb, &xm);\n\treturn OKAY;\n}",
        "parsed_output": "undefined4 __regparm3\nFUN_08060340(void *inputParam, undefined4 param2, undefined4 param3, int param1,\n            undefined4 param4, undefined4 param5, undefined4 param6, undefined4 param7,\n            undefined4 param8)\n{\n    int result;\n    char **stringPointer;\n    byte flag;\n    char *localBuffer;\n    undefined4 localValue1;\n    int localValue2;\n    int localValue3;\n    undefined4 localValue4;\n    undefined4 localValue5;\n    undefined4 localValue6;\n    undefined4 localValue7;\n    undefined4 localValue8;\n    ulong localValue9;\n    char *localPointer;\n    undefined4 localValue10;\n    undefined4 localValue11;\n    ulong localValue12;\n    undefined4 localValue13;\n    undefined4 localValue14;\n\n    flag = 0;\n    result = FUN_08088df0(DAT_08098edc, \"[APPENDUID \");\n    \n    if (result != 0) {\n        localValue12 = strtoul((char *)(result + 0xb), &localBuffer, 10);\n        localValue9 = strtoul(localBuffer, &localPointer, 10);\n        \n        if (localValue12 != 0 && localValue9 != 0 && (char *)(result + 0xb) < localBuffer &&\n            *localBuffer == ' ' && localBuffer < localPointer && *localPointer == ']') {\n            \n            memcpy(&localPointer, inputParam, 0x2064);\n            localValue14 = 0;\n            localValue13 = FUN_080880d0(param8);\n            localValue10 = param2;\n            localValue11 = param2;\n            FUN_080697d0(&localPointer);\n            \n            stringPointer = &localBuffer;\n            for (result = 0x16; result != 0; result--) {\n                *stringPointer = (char *)0x0;\n                stringPointer += (uint)flag * -2 + 1;\n            }\n            \n            localBuffer = (char *)CONCAT31((uint3)((uint)param7 >> 8) & 1, 0x80);\n            localValue1 = 3;\n            localValue2 = param1 + 0xfff;\n            \n            if (param1 >= 0) {\n                localValue2 = param1;\n            }\n            \n            localValue2 >>= 0xc;\n            localValue3 = param1 % 0x1000;\n            localValue4 = param3;\n            localValue5 = param2;\n            localValue8 = param6;\n            localValue6 = param6;\n            localValue7 = param5;\n            \n            FUN_08069260(&localPointer, &localBuffer);\n            return 1;\n        }\n    }\n    \n    return 0;\n}",
        "baseline_code_stripped": "undefined4 __regparm3\nFUN_08060340(void *param_1_00,undefined4 param_2_00,undefined4 param_3_00,int param_1,\n            undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,\n            undefined4 param_6)\n{\n  int iVar1;\n  char **ppcVar2;\n  byte bVar3;\n  char *local_20d8;\n  undefined4 local_20d4;\n  int local_20cc;\n  int local_20c8;\n  undefined4 local_20c4;\n  undefined4 local_20c0;\n  undefined4 local_20bc;\n  undefined4 local_20b8;\n  undefined4 local_20b4;\n  ulong local_2090;\n  char *local_2080;\n  undefined4 local_207c;\n  undefined4 local_2078;\n  ulong local_205c;\n  undefined4 local_2054;\n  undefined4 local_2050;\n  bVar3 = 0;\n  iVar1 = FUN_08088df0(DAT_08098edc,\"[APPENDUID \");\n  if (iVar1 != 0) {\n    local_205c = strtoul((char *)(iVar1 + 0xb),&local_20d8,10);\n    local_2090 = strtoul(local_20d8,&local_2080,10);\n    if ((((local_205c != 0) && (local_2090 != 0)) && ((char *)(iVar1 + 0xb) < local_20d8)) &&\n       (((*local_20d8 == ' ' && (local_20d8 < local_2080)) && (*local_2080 == ']')))) {\n      memcpy(&local_2080,param_1_00,0x2064);\n      local_2050 = 0;\n      local_2054 = FUN_080880d0(param_6);\n      local_207c = param_2_00;\n      local_2078 = param_2_00;\n      FUN_080697d0(&local_2080);\n      ppcVar2 = &local_20d8;\n      for (iVar1 = 0x16; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *ppcVar2 = (char *)0x0;\n        ppcVar2 = ppcVar2 + (uint)bVar3 * -2 + 1;\n      }\n      local_20d8 = (char *)CONCAT31((uint3)((uint)param_5 >> 8) & 1,0x80);\n      local_20d4 = 3;\n      local_20cc = param_1 + 0xfff;\n      if (-1 < param_1) {\n        local_20cc = param_1;\n      }\n      local_20cc = local_20cc >> 0xc;\n      local_20c8 = param_1 % 0x1000;\n      local_20c4 = param_3;\n      local_20c0 = param_2;\n      local_20b8 = param_4;\n      local_20bc = param_4;\n      local_20b4 = param_3_00;\n      FUN_08069260(&local_2080,&local_20d8);\n      return 1;\n    }\n  }\n  return 0;\n}",
        "similarity_score_unixcoder": 0.5005503296852112,
        "similarity_score_baseline_stripped": 0.4950212240219116
    },
    {
        "func_name": "nmethod::nmethod",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0037a4e8(undefined8 *param_1,undefined8 param_2,undefined param_3,undefined4 param_4,\n                 undefined4 param_5,long param_6,long param_7,undefined8 param_8,undefined4 param_9,\n                 undefined4 param_10,undefined4 param_11,undefined4 param_12_00,undefined8 param_12)\n{\n  short sVar1;\n  undefined8 uVar2;\n  undefined auStack_8 [8];\n  FUN_0023abf8(param_1,\"native nmethod\",1,param_7,param_4,0xd8,*(undefined2 *)(param_6 + 8),param_8,\n               param_12,0);\n  param_1[7] = 0;\n  *param_1 = &PTR_LAB_004fa598;\n  uVar2 = FUN_002400ec();\n  param_1[8] = uVar2;\n  param_1[9] = param_2;\n  *(undefined4 *)(param_1 + 10) = param_9;\n  *(undefined4 *)((long)param_1 + 0x54) = param_11;\n  FUN_00375c50(param_1,param_7,param_6);\n  *(undefined *)((long)param_1 + 0xcc) = 0;\n  *(undefined4 *)((long)param_1 + 0x94) = 0xffffffff;\n  *(undefined *)((long)param_1 + 0xcd) = param_3;\n  param_1[0xc] = 0;\n  param_1[0x11] = 0;\n  *(undefined4 *)((long)param_1 + 0xc4) = 0;\n  *(undefined4 *)(param_1 + 0x19) = param_5;\n  *(undefined2 *)((long)param_1 + 0xb2) = *(undefined2 *)(*(long *)(param_1[9] + 8) + 0x30);\n  if (*(int *)(param_6 + 0x10) == -1) {\n    *(undefined4 *)((long)param_1 + 0xa4) = 0;\n  }\n  else {\n    *(int *)((long)param_1 + 0xa4) = *(int *)((long)param_1 + 0x24) + *(int *)(param_6 + 0x10);\n  }\n  *(undefined2 *)(param_1 + 0x16) = 0;\n  param_1[0x15] = 0;\n  if (*(long *)(param_7 + 0x130) == 0) {\n    sVar1 = 0;\n  }\n  else {\n    sVar1 = FUN_003857f0(*(long *)(param_7 + 0x130) + 8);\n  }\n  *(ushort *)((long)param_1 + 0xb4) = sVar1 + 7U & 0xfff8;\n  FUN_0037ad4c(param_7);\n  *(undefined4 *)(param_1 + 0x13) = 0;\n  *(undefined4 *)((long)param_1 + 0xb6) = 0;\n  *(undefined8 *)((long)param_1 + 0xbc) = 0;\n  param_1[0xb] = (long)param_1 + (long)*(int *)(param_1 + 3);\n  FUN_0023e344(param_7,param_1);\n  FUN_0023e9f0(param_7,param_1);\n  FUN_0037ad64(param_7,param_1);\n  FUN_00378f30(param_1);\n  if (DAT_0051549e != '\\0') {\n    FUN_002492c8(auStack_8);\n    if (DAT_0054cc40 != 0) {\n      FUN_0046a004(DAT_0054cc40,\"print_native_nmethod\");\n      FUN_0046a5ec(DAT_0054cc40,param_1[9]);\n      FUN_0046a2f0(DAT_0054cc40);\n      FUN_0046a188(DAT_0054cc40,\" address=\\'0x%016lx\\'\",param_1);\n    }\n    if (DAT_0051549e == '\\0') {\n      FUN_00377f6c(param_1);\n    }\n    else {\n      FUN_0039e450(PTR_DAT_00507218,\n                   \"-------------------------- Assembly (native nmethod) ---------------------------\"\n                  );\n      FUN_0037a488(param_1);\n      FUN_0039e450(PTR_DAT_00507218,\n                   \"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \"\n                  );\n    }\n    if (DAT_0054cc40 != 0) {\n      FUN_0046a214(DAT_0054cc40,\"print_native_nmethod\");\n    }\n    FUN_002492ec(auStack_8);\n  }\n  return;\n}",
        "output": "```c\nvoid processNativeNMethod(undefined8 *nmethod, undefined8 param2, undefined param3, undefined4 param4,\n                          undefined4 param5, long param6, long param7, undefined8 param8, \n                          undefined4 param9, undefined4 param10, undefined4 param11, \n                          undefined4 param12_00, undefined8 param12)\n{\n    short sVar1;\n    undefined8 uVar2;\n    undefined auStack_8[8];\n\n    initializeNMethod(nmethod, \"native nmethod\", 1, param7, param4, 0xd8, *(undefined2 *)(param6 + 8), param8,\n                      param12, 0);\n    \n    nmethod[7] = 0;\n    *nmethod = &PTR_LAB_004fa598;\n    uVar2 = getSomeValue();\n    nmethod[8] = uVar2;\n    nmethod[9] = param2;\n    *(undefined4 *)(nmethod + 10) = param9;\n    *(undefined4 *)((long)nmethod + 0x54) = param11;\n\n    updateNMethod(nmethod, param7, param6);\n    \n    *(undefined *)((long)nmethod + 0xcc) = 0;\n    *(undefined4 *)((long)nmethod + 0x94) = 0xffffffff;\n    *(undefined *)((long)nmethod + 0xcd) = param3;\n    nmethod[0xc] = 0;\n    nmethod[0x11] = 0;\n    *(undefined4 *)((long)nmethod + 0xc4) = 0;\n    *(undefined4 *)(nmethod + 0x19) = param5;\n\n    *(undefined2 *)((long)nmethod + 0xb2) = *(undefined2 *)(*(long *)(nmethod[9] + 8) + 0x30);\n    \n    if (*(int *)(param6 + 0x10) == -1) {\n        *(undefined4 *)((long)nmethod + 0xa4) = 0;\n    } else {\n        *(int *)((long)nmethod + 0xa4) = *(int *)((long)nmethod + 0x24) + *(int *)(param6 + 0x10);\n    }\n\n    *(undefined2 *)(nmethod + 0x16) = 0;\n    nmethod[0x15] = 0;\n\n    if (*(long *)(param7 + 0x130) == 0) {\n        sVar1 = 0;\n    } else {\n        sVar1 = getSomeShortValue(*(long *)(param7 + 0x130) + 8);\n    }\n\n    *(ushort *)((long)nmethod + 0xb4) = (sVar1 + 7U) & 0xfff8;\n\n    finalizeNMethod(param7);\n    \n    *(undefined4 *)(nmethod + 0x13) = 0;\n    *(undefined4 *)((long)nmethod + 0xb6) = 0;\n    *(undefined8 *)((long)nmethod + 0xbc) = 0;\n    nmethod[0xb] = (long)nmethod + (long)*(int *)(nmethod + 3);\n\n    callAdditionalFunctions(param7, nmethod);\n    \n    if (DAT_0051549e != '\\0') {\n        handleDebugging(auStack_8, nmethod);\n    }\n    \n    return;\n}\n```",
        "normed_func_sha256": "33f94793a5dc5183748e51c1dda09a5fb6c2f4d17ce64b9274e01d73a39b4d93",
        "source_code": "nmethod::nmethod(\n  methodOop method,\n  int nmethod_size,\n  int compile_id,\n  CodeOffsets* offsets,\n  CodeBuffer* code_buffer,\n  int frame_size,\n  ByteSize basic_lock_owner_sp_offset,\n  ByteSize basic_lock_sp_offset,\n  OopMapSet* oop_maps )\n  : CodeBlob(\"native nmethod\", code_buffer, sizeof(nmethod),\n             nmethod_size, offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps),\n  _native_receiver_sp_offset(basic_lock_owner_sp_offset),\n  _native_basic_lock_sp_offset(basic_lock_sp_offset)\n{\n  {\n    debug_only(No_Safepoint_Verifier nsv;)\n    assert_locked_or_safepoint(CodeCache_lock);\n\n    init_defaults();\n    _method                  = method;\n    _entry_bci               = InvocationEntryBci;\n    // We have no exception handler or deopt handler make the\n    // values something that will never match a pc like the nmethod vtable entry\n    _exception_offset        = 0;\n    _deoptimize_offset       = 0;\n    _deoptimize_mh_offset    = 0;\n    _orig_pc_offset          = 0;\n\n    _consts_offset           = data_offset();\n    _stub_offset             = data_offset();\n    _oops_offset             = data_offset();\n    _scopes_data_offset      = _oops_offset          + round_to(code_buffer->total_oop_size(), oopSize);\n    _scopes_pcs_offset       = _scopes_data_offset;\n    _dependencies_offset     = _scopes_pcs_offset;\n    _handler_table_offset    = _dependencies_offset;\n    _nul_chk_table_offset    = _handler_table_offset;\n    _nmethod_end_offset      = _nul_chk_table_offset;\n    _compile_id              = compile_id;\n    _comp_level              = CompLevel_none;\n    _entry_point             = code_begin()          + offsets->value(CodeOffsets::Entry);\n    _verified_entry_point    = code_begin()          + offsets->value(CodeOffsets::Verified_Entry);\n    _osr_entry_point         = NULL;\n    _exception_cache         = NULL;\n    _pc_desc_cache.reset_to(NULL);\n\n    code_buffer->copy_oops_to(this);\n    if (ScavengeRootsInCode && detect_scavenge_root_oops()) {\n      CodeCache::add_scavenge_root_nmethod(this);\n    }\n    debug_only(verify_scavenge_root_oops());\n    CodeCache::commit(this);\n  }\n\n  if (PrintNativeNMethods || PrintDebugInfo || PrintRelocations || PrintDependencies) {\n    ttyLocker ttyl;  // keep the following output all in one block\n    // This output goes directly to the tty, not the compiler log.\n    // To enable tools to match it up with the compilation activity,\n    // be sure to tag this tty output with the compile ID.\n    if (xtty != NULL) {\n      xtty->begin_head(\"print_native_nmethod\");\n      xtty->method(_method);\n      xtty->stamp();\n      xtty->end_head(\" address='\" INTPTR_FORMAT \"'\", (intptr_t) this);\n    }\n    // print the header part first\n    print();\n    // then print the requested information\n    if (PrintNativeNMethods) {\n      print_code();\n      oop_maps->print();\n    }\n    if (PrintRelocations) {\n      print_relocations();\n    }\n    if (xtty != NULL) {\n      xtty->tail(\"print_native_nmethod\");\n    }\n  }\n  Events::log(\"Create nmethod \" INTPTR_FORMAT, this);\n}",
        "parsed_output": "void processNativeNMethod(undefined8 *nmethod, undefined8 param2, undefined param3, undefined4 param4,\n                          undefined4 param5, long param6, long param7, undefined8 param8, \n                          undefined4 param9, undefined4 param10, undefined4 param11, \n                          undefined4 param12_00, undefined8 param12)\n{\n    short sVar1;\n    undefined8 uVar2;\n    undefined auStack_8[8];\n\n    initializeNMethod(nmethod, \"native nmethod\", 1, param7, param4, 0xd8, *(undefined2 *)(param6 + 8), param8,\n                      param12, 0);\n    \n    nmethod[7] = 0;\n    *nmethod = &PTR_LAB_004fa598;\n    uVar2 = getSomeValue();\n    nmethod[8] = uVar2;\n    nmethod[9] = param2;\n    *(undefined4 *)(nmethod + 10) = param9;\n    *(undefined4 *)((long)nmethod + 0x54) = param11;\n\n    updateNMethod(nmethod, param7, param6);\n    \n    *(undefined *)((long)nmethod + 0xcc) = 0;\n    *(undefined4 *)((long)nmethod + 0x94) = 0xffffffff;\n    *(undefined *)((long)nmethod + 0xcd) = param3;\n    nmethod[0xc] = 0;\n    nmethod[0x11] = 0;\n    *(undefined4 *)((long)nmethod + 0xc4) = 0;\n    *(undefined4 *)(nmethod + 0x19) = param5;\n\n    *(undefined2 *)((long)nmethod + 0xb2) = *(undefined2 *)(*(long *)(nmethod[9] + 8) + 0x30);\n    \n    if (*(int *)(param6 + 0x10) == -1) {\n        *(undefined4 *)((long)nmethod + 0xa4) = 0;\n    } else {\n        *(int *)((long)nmethod + 0xa4) = *(int *)((long)nmethod + 0x24) + *(int *)(param6 + 0x10);\n    }\n\n    *(undefined2 *)(nmethod + 0x16) = 0;\n    nmethod[0x15] = 0;\n\n    if (*(long *)(param7 + 0x130) == 0) {\n        sVar1 = 0;\n    } else {\n        sVar1 = getSomeShortValue(*(long *)(param7 + 0x130) + 8);\n    }\n\n    *(ushort *)((long)nmethod + 0xb4) = (sVar1 + 7U) & 0xfff8;\n\n    finalizeNMethod(param7);\n    \n    *(undefined4 *)(nmethod + 0x13) = 0;\n    *(undefined4 *)((long)nmethod + 0xb6) = 0;\n    *(undefined8 *)((long)nmethod + 0xbc) = 0;\n    nmethod[0xb] = (long)nmethod + (long)*(int *)(nmethod + 3);\n\n    callAdditionalFunctions(param7, nmethod);\n    \n    if (DAT_0051549e != '\\0') {\n        handleDebugging(auStack_8, nmethod);\n    }\n    \n    return;\n}",
        "baseline_code_stripped": "void FUN_0037a4e8(undefined8 *param_1,undefined8 param_2,undefined param_3,undefined4 param_4,\n                 undefined4 param_5,long param_6,long param_7,undefined8 param_8,undefined4 param_9,\n                 undefined4 param_10,undefined4 param_11,undefined4 param_12_00,undefined8 param_12)\n{\n  short sVar1;\n  undefined8 uVar2;\n  undefined auStack_8 [8];\n  FUN_0023abf8(param_1,\"native nmethod\",1,param_7,param_4,0xd8,*(undefined2 *)(param_6 + 8),param_8,\n               param_12,0);\n  param_1[7] = 0;\n  *param_1 = &PTR_LAB_004fa598;\n  uVar2 = FUN_002400ec();\n  param_1[8] = uVar2;\n  param_1[9] = param_2;\n  *(undefined4 *)(param_1 + 10) = param_9;\n  *(undefined4 *)((long)param_1 + 0x54) = param_11;\n  FUN_00375c50(param_1,param_7,param_6);\n  *(undefined *)((long)param_1 + 0xcc) = 0;\n  *(undefined4 *)((long)param_1 + 0x94) = 0xffffffff;\n  *(undefined *)((long)param_1 + 0xcd) = param_3;\n  param_1[0xc] = 0;\n  param_1[0x11] = 0;\n  *(undefined4 *)((long)param_1 + 0xc4) = 0;\n  *(undefined4 *)(param_1 + 0x19) = param_5;\n  *(undefined2 *)((long)param_1 + 0xb2) = *(undefined2 *)(*(long *)(param_1[9] + 8) + 0x30);\n  if (*(int *)(param_6 + 0x10) == -1) {\n    *(undefined4 *)((long)param_1 + 0xa4) = 0;\n  }\n  else {\n    *(int *)((long)param_1 + 0xa4) = *(int *)((long)param_1 + 0x24) + *(int *)(param_6 + 0x10);\n  }\n  *(undefined2 *)(param_1 + 0x16) = 0;\n  param_1[0x15] = 0;\n  if (*(long *)(param_7 + 0x130) == 0) {\n    sVar1 = 0;\n  }\n  else {\n    sVar1 = FUN_003857f0(*(long *)(param_7 + 0x130) + 8);\n  }\n  *(ushort *)((long)param_1 + 0xb4) = sVar1 + 7U & 0xfff8;\n  FUN_0037ad4c(param_7);\n  *(undefined4 *)(param_1 + 0x13) = 0;\n  *(undefined4 *)((long)param_1 + 0xb6) = 0;\n  *(undefined8 *)((long)param_1 + 0xbc) = 0;\n  param_1[0xb] = (long)param_1 + (long)*(int *)(param_1 + 3);\n  FUN_0023e344(param_7,param_1);\n  FUN_0023e9f0(param_7,param_1);\n  FUN_0037ad64(param_7,param_1);\n  FUN_00378f30(param_1);\n  if (DAT_0051549e != '\\0') {\n    FUN_002492c8(auStack_8);\n    if (DAT_0054cc40 != 0) {\n      FUN_0046a004(DAT_0054cc40,\"print_native_nmethod\");\n      FUN_0046a5ec(DAT_0054cc40,param_1[9]);\n      FUN_0046a2f0(DAT_0054cc40);\n      FUN_0046a188(DAT_0054cc40,\" address=\\'0x%016lx\\'\",param_1);\n    }\n    if (DAT_0051549e == '\\0') {\n      FUN_00377f6c(param_1);\n    }\n    else {\n      FUN_0039e450(PTR_DAT_00507218,\n                   \"-------------------------- Assembly (native nmethod) ---------------------------\"\n                  );\n      FUN_0037a488(param_1);\n      FUN_0039e450(PTR_DAT_00507218,\n                   \"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \"\n                  );\n    }\n    if (DAT_0054cc40 != 0) {\n      FUN_0046a214(DAT_0054cc40,\"print_native_nmethod\");\n    }\n    FUN_002492ec(auStack_8);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.49956536293029785,
        "similarity_score_baseline_stripped": 0.4730994999408722
    },
    {
        "func_name": "geary_app_local_load_operation_real_execute_async_co",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 geary_app_local_load_operation_real_execute_async_co(int *param_1)\n{\n  undefined8 uVar1;\n  long lVar2;\n  if (*param_1 == 0) {\n    *(undefined8 *)(param_1 + 10) = 0;\n    uVar1 = geary_app_conversation_operation_get_type();\n    lVar2 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 8),uVar1);\n    uVar1 = *(undefined8 *)(lVar2 + 0x28);\n    *param_1 = 1;\n    *(undefined8 *)(param_1 + 10) = uVar1;\n    geary_app_conversation_monitor_local_load_async\n              (uVar1,geary_app_local_load_operation_execute_async_ready,param_1);\n    return 0;\n  }\n  if (*param_1 == 1) {\n    geary_app_conversation_monitor_local_load_finish\n              (*(undefined8 *)(param_1 + 10),*(undefined8 *)(param_1 + 4));\n    if (*param_1 == 0) {\n      g_simple_async_result_complete_in_idle(*(undefined8 *)(param_1 + 6));\n    }\n    else {\n      g_simple_async_result_complete();\n    }\n    g_object_unref(*(undefined8 *)(param_1 + 6));\n    return 0;\n  }\n  g_assertion_message_expr\n            (0,\n             \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n             ,0xc,\"geary_app_local_load_operation_real_execute_async_co\",0);\n}",
        "output": "```c\nundefined8 geary_app_local_load_operation_real_execute_async_co(int *state)\n{\n    undefined8 operationType;\n    long instance;\n\n    if (*state == 0) {\n        *(undefined8 *)(state + 10) = 0;\n        operationType = geary_app_conversation_operation_get_type();\n        instance = g_type_check_instance_cast(*(undefined8 *)(state + 8), operationType);\n        operationType = *(undefined8 *)(instance + 0x28);\n        *state = 1;\n        *(undefined8 *)(state + 10) = operationType;\n        geary_app_conversation_monitor_local_load_async(\n            operationType,\n            geary_app_local_load_operation_execute_async_ready,\n            state\n        );\n        return 0;\n    }\n\n    if (*state == 1) {\n        geary_app_conversation_monitor_local_load_finish(\n            *(undefined8 *)(state + 10),\n            *(undefined8 *)(state + 4)\n        );\n\n        if (*state == 0) {\n            g_simple_async_result_complete_in_idle(*(undefined8 *)(state + 6));\n        } else {\n            g_simple_async_result_complete();\n        }\n\n        g_object_unref(*(undefined8 *)(state + 6));\n        return 0;\n    }\n\n    g_assertion_message_expr(\n        0,\n        \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\",\n        0xc,\n        \"geary_app_local_load_operation_real_execute_async_co\",\n        0\n    );\n}\n```",
        "normed_func_sha256": "588dfdb7ad76474622e3a5a6ace14cf7983b04d33782202ab9dc62edfbb0cf31",
        "source_code": "static gboolean geary_app_local_load_operation_real_execute_async_co (GearyAppLocalLoadOperationExecuteAsyncData* _data_) {\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\tswitch (_data_->_state_) {\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t\tcase 0:\n#line 210 \"app-local-load-operation.c\"\n\t\tgoto _state_0;\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t\tcase 1:\n#line 214 \"app-local-load-operation.c\"\n\t\tgoto _state_1;\n\t\tdefault:\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t\tg_assert_not_reached ();\n#line 219 \"app-local-load-operation.c\"\n\t}\n\t_state_0:\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t_data_->_tmp0_ = NULL;\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t_data_->_tmp0_ = G_TYPE_CHECK_INSTANCE_CAST (_data_->self, GEARY_APP_TYPE_CONVERSATION_OPERATION, GearyAppConversationOperation)->monitor;\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t_data_->_state_ = 1;\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\tgeary_app_conversation_monitor_local_load_async (_data_->_tmp0_, geary_app_local_load_operation_execute_async_ready, _data_);\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\treturn FALSE;\n#line 232 \"app-local-load-operation.c\"\n\t_state_1:\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\tgeary_app_conversation_monitor_local_load_finish (_data_->_tmp0_, _data_->_res_);\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\tif (_data_->_state_ == 0) {\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t\tg_simple_async_result_complete_in_idle (_data_->_async_result);\n#line 240 \"app-local-load-operation.c\"\n\t} else {\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t\tg_simple_async_result_complete (_data_->_async_result);\n#line 244 \"app-local-load-operation.c\"\n\t}\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\tg_object_unref (_data_->_async_result);\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\treturn FALSE;\n#line 250 \"app-local-load-operation.c\"\n}",
        "parsed_output": "undefined8 geary_app_local_load_operation_real_execute_async_co(int *state)\n{\n    undefined8 operationType;\n    long instance;\n\n    if (*state == 0) {\n        *(undefined8 *)(state + 10) = 0;\n        operationType = geary_app_conversation_operation_get_type();\n        instance = g_type_check_instance_cast(*(undefined8 *)(state + 8), operationType);\n        operationType = *(undefined8 *)(instance + 0x28);\n        *state = 1;\n        *(undefined8 *)(state + 10) = operationType;\n        geary_app_conversation_monitor_local_load_async(\n            operationType,\n            geary_app_local_load_operation_execute_async_ready,\n            state\n        );\n        return 0;\n    }\n\n    if (*state == 1) {\n        geary_app_conversation_monitor_local_load_finish(\n            *(undefined8 *)(state + 10),\n            *(undefined8 *)(state + 4)\n        );\n\n        if (*state == 0) {\n            g_simple_async_result_complete_in_idle(*(undefined8 *)(state + 6));\n        } else {\n            g_simple_async_result_complete();\n        }\n\n        g_object_unref(*(undefined8 *)(state + 6));\n        return 0;\n    }\n\n    g_assertion_message_expr(\n        0,\n        \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\",\n        0xc,\n        \"geary_app_local_load_operation_real_execute_async_co\",\n        0\n    );\n}",
        "baseline_code_stripped": "undefined8 geary_app_local_load_operation_real_execute_async_co(int *param_1)\n{\n  undefined8 uVar1;\n  long lVar2;\n  if (*param_1 == 0) {\n    *(undefined8 *)(param_1 + 10) = 0;\n    uVar1 = geary_app_conversation_operation_get_type();\n    lVar2 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 8),uVar1);\n    uVar1 = *(undefined8 *)(lVar2 + 0x28);\n    *param_1 = 1;\n    *(undefined8 *)(param_1 + 10) = uVar1;\n    geary_app_conversation_monitor_local_load_async\n              (uVar1,geary_app_local_load_operation_execute_async_ready,param_1);\n    return 0;\n  }\n  if (*param_1 == 1) {\n    geary_app_conversation_monitor_local_load_finish\n              (*(undefined8 *)(param_1 + 10),*(undefined8 *)(param_1 + 4));\n    if (*param_1 == 0) {\n      g_simple_async_result_complete_in_idle(*(undefined8 *)(param_1 + 6));\n    }\n    else {\n      g_simple_async_result_complete();\n    }\n    g_object_unref(*(undefined8 *)(param_1 + 6));\n    return 0;\n  }\n  g_assertion_message_expr\n            (0,\n             \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n             ,0xc,\"geary_app_local_load_operation_real_execute_async_co\",0);\n}",
        "similarity_score_unixcoder": 0.7206697463989258,
        "similarity_score_baseline_stripped": 0.7635511159896851
    },
    {
        "func_name": "_wrap_SpinButton_SetValue",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined * FUN_00078f64(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int *local_138;\n  undefined4 local_134;\n  undefined4 local_130;\n  undefined4 local_12c;\n  undefined *local_128;\n  undefined *local_124;\n  undefined4 local_120;\n  undefined auStack_11c [268];\n  local_130 = 0;\n  local_138 = (int *)0x0;\n  local_134 = 0;\n  local_120 = _DAT_00104c40;\n  local_128 = PTR_DAT_00104c38;\n  local_124 = PTR_DAT_00104c3c;\n  iVar1 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"OO:SpinButton_SetValue\",&local_128,&local_134,&local_130);\n  if (iVar1 != 0) {\n    FUN_00041f74(local_134,&local_138,_DAT_00113c10,1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",1);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    uVar2 = local_130;\n    iVar1 = PyNumber_Check(local_130);\n    if (iVar1 == 0) {\n      FUN_00041db4(\"number\",uVar2);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = PyInt_AsLong(uVar2);\n    }\n    local_12c = uVar2;\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",2);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    uVar3 = (**(code **)(_DAT_001124f8 + 0x10))();\n    (**(code **)(*local_138 + 700))(local_138,uVar2);\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    (**(code **)(_DAT_001124f8 + 0x14))(uVar3);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      __Py_NoneStruct = __Py_NoneStruct + 1;\n      return &_Py_NoneStruct;\n    }\n  }\n  return (undefined *)0x0;\n}",
        "output": "```c\nundefined * SpinButton_SetValue(undefined4 param_1, undefined4 param_2, undefined4 param_3) {\n    int result;\n    undefined4 value;\n    undefined4 convertedValue;\n    int *localPointer = NULL;\n    undefined4 localValue1 = 0;\n    undefined4 localValue2 = 0;\n    undefined4 localValue3 = 0;\n    undefined *apiPointer1 = PTR_DAT_00104c38;\n    undefined *apiPointer2 = PTR_DAT_00104c3c;\n    undefined4 apiValue = _DAT_00104c40;\n    undefined auStack[268];\n\n    result = PyArg_ParseTupleAndKeywords(param_2, param_3, \"OO:SpinButton_SetValue\", &apiPointer1, &localValue1, &localValue2);\n    \n    if (result != 0) {\n        FUN_00041f74(localValue1, &localPointer, _DAT_00113c10, 1);\n        result = PyErr_Occurred();\n        \n        if (result != 0) {\n            PyOS_snprintf(auStack, 0x100, \"argument number %d:\", 1);\n            result = FUN_0003da74(auStack, 1);\n            if (result != 0) {\n                return (undefined *)0x0;\n            }\n        }\n\n        value = localValue2;\n        result = PyNumber_Check(localValue2);\n        \n        if (result == 0) {\n            FUN_00041db4(\"number\", value);\n            value = 0;\n        } else {\n            value = PyInt_AsLong(value);\n        }\n        \n        localValue3 = value;\n        result = PyErr_Occurred();\n        \n        if (result != 0) {\n            PyOS_snprintf(auStack, 0x100, \"argument number %d:\", 2);\n            result = FUN_0003da74(auStack, 1);\n            if (result != 0) {\n                return (undefined *)0x0;\n            }\n        }\n\n        if (_DAT_001124f8 == 0) {\n            _DAT_001124f8 = PyCObject_Import(\"wx._core_\", \"_wxPyCoreAPI\");\n        }\n        \n        convertedValue = (**(code **)(_DAT_001124f8 + 0x10))();\n        (**(code **)(*localPointer + 700))(localPointer, value);\n        \n        if (_DAT_001124f8 == 0) {\n            _DAT_001124f8 = PyCObject_Import(\"wx._core_\", \"_wxPyCoreAPI\");\n        }\n        \n        (**(code **)(_DAT_001124f8 + 0x14))(convertedValue);\n        result = PyErr_Occurred();\n        \n        if (result == 0) {\n            __Py_NoneStruct = __Py_NoneStruct + 1;\n            return &_Py_NoneStruct;\n        }\n    }\n    \n    return (undefined *)0x0;\n}\n```",
        "normed_func_sha256": "4372c039ca3a0465f8cbb97b3b7a556824a043afd1618b9316bbe9bc9896b79b",
        "source_code": "static PyObject *_wrap_SpinButton_SetValue(PyObject *, PyObject *args, PyObject *kwargs) {\n    PyObject *resultobj = NULL;\n    wxSpinButton *arg1 = (wxSpinButton *) 0 ;\n    int arg2 ;\n    PyObject * obj0 = 0 ;\n    PyObject * obj1 = 0 ;\n    char *kwnames[] = {\n        (char *) \"self\",(char *) \"val\", NULL \n    };\n    \n    if(!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"OO:SpinButton_SetValue\",kwnames,&obj0,&obj1)) goto fail;\n    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_wxSpinButton, SWIG_POINTER_EXCEPTION | 0);\n    if (SWIG_arg_fail(1)) SWIG_fail;\n    {\n        arg2 = static_cast<int >(SWIG_As_int(obj1)); \n        if (SWIG_arg_fail(2)) SWIG_fail;\n    }\n    {\n        PyThreadState* __tstate = wxPyBeginAllowThreads();\n        (arg1)->SetValue(arg2);\n        \n        wxPyEndAllowThreads(__tstate);\n        if (PyErr_Occurred()) SWIG_fail;\n    }\n    Py_INCREF(Py_None); resultobj = Py_None;\n    return resultobj;\n    fail:\n    return NULL;\n}",
        "parsed_output": "undefined * SpinButton_SetValue(undefined4 param_1, undefined4 param_2, undefined4 param_3) {\n    int result;\n    undefined4 value;\n    undefined4 convertedValue;\n    int *localPointer = NULL;\n    undefined4 localValue1 = 0;\n    undefined4 localValue2 = 0;\n    undefined4 localValue3 = 0;\n    undefined *apiPointer1 = PTR_DAT_00104c38;\n    undefined *apiPointer2 = PTR_DAT_00104c3c;\n    undefined4 apiValue = _DAT_00104c40;\n    undefined auStack[268];\n\n    result = PyArg_ParseTupleAndKeywords(param_2, param_3, \"OO:SpinButton_SetValue\", &apiPointer1, &localValue1, &localValue2);\n    \n    if (result != 0) {\n        FUN_00041f74(localValue1, &localPointer, _DAT_00113c10, 1);\n        result = PyErr_Occurred();\n        \n        if (result != 0) {\n            PyOS_snprintf(auStack, 0x100, \"argument number %d:\", 1);\n            result = FUN_0003da74(auStack, 1);\n            if (result != 0) {\n                return (undefined *)0x0;\n            }\n        }\n\n        value = localValue2;\n        result = PyNumber_Check(localValue2);\n        \n        if (result == 0) {\n            FUN_00041db4(\"number\", value);\n            value = 0;\n        } else {\n            value = PyInt_AsLong(value);\n        }\n        \n        localValue3 = value;\n        result = PyErr_Occurred();\n        \n        if (result != 0) {\n            PyOS_snprintf(auStack, 0x100, \"argument number %d:\", 2);\n            result = FUN_0003da74(auStack, 1);\n            if (result != 0) {\n                return (undefined *)0x0;\n            }\n        }\n\n        if (_DAT_001124f8 == 0) {\n            _DAT_001124f8 = PyCObject_Import(\"wx._core_\", \"_wxPyCoreAPI\");\n        }\n        \n        convertedValue = (**(code **)(_DAT_001124f8 + 0x10))();\n        (**(code **)(*localPointer + 700))(localPointer, value);\n        \n        if (_DAT_001124f8 == 0) {\n            _DAT_001124f8 = PyCObject_Import(\"wx._core_\", \"_wxPyCoreAPI\");\n        }\n        \n        (**(code **)(_DAT_001124f8 + 0x14))(convertedValue);\n        result = PyErr_Occurred();\n        \n        if (result == 0) {\n            __Py_NoneStruct = __Py_NoneStruct + 1;\n            return &_Py_NoneStruct;\n        }\n    }\n    \n    return (undefined *)0x0;\n}",
        "baseline_code_stripped": "undefined * FUN_00078f64(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int *local_138;\n  undefined4 local_134;\n  undefined4 local_130;\n  undefined4 local_12c;\n  undefined *local_128;\n  undefined *local_124;\n  undefined4 local_120;\n  undefined auStack_11c [268];\n  local_130 = 0;\n  local_138 = (int *)0x0;\n  local_134 = 0;\n  local_120 = _DAT_00104c40;\n  local_128 = PTR_DAT_00104c38;\n  local_124 = PTR_DAT_00104c3c;\n  iVar1 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"OO:SpinButton_SetValue\",&local_128,&local_134,&local_130);\n  if (iVar1 != 0) {\n    FUN_00041f74(local_134,&local_138,_DAT_00113c10,1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",1);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    uVar2 = local_130;\n    iVar1 = PyNumber_Check(local_130);\n    if (iVar1 == 0) {\n      FUN_00041db4(\"number\",uVar2);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = PyInt_AsLong(uVar2);\n    }\n    local_12c = uVar2;\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",2);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    uVar3 = (**(code **)(_DAT_001124f8 + 0x10))();\n    (**(code **)(*local_138 + 700))(local_138,uVar2);\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    (**(code **)(_DAT_001124f8 + 0x14))(uVar3);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      __Py_NoneStruct = __Py_NoneStruct + 1;\n      return &_Py_NoneStruct;\n    }\n  }\n  return (undefined *)0x0;\n}",
        "similarity_score_unixcoder": 0.6799274682998657,
        "similarity_score_baseline_stripped": 0.6331114172935486
    },
    {
        "func_name": "gen_aarch64_fcmla0v8hf",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_10dda440(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 uVar1;\n  longlong lVar2;\n  longlong lVar3;\n  uVar1 = FUN_102c5b28(2,param_3,param_4);\n  lVar2 = FUN_106a7fd8(0x14);\n  *(undefined4 *)(lVar2 + 0x10) = 0x175;\n  *(undefined8 *)(lVar2 + 8) = uVar1;\n  *(undefined *)(lVar2 + 2) = 0x67;\n  lVar3 = FUN_106a7fd8(0x36);\n  *(undefined *)(lVar3 + 2) = 0x67;\n  *(undefined8 *)(lVar3 + 8) = param_2;\n  *(longlong *)(lVar3 + 0x10) = lVar2;\n  lVar2 = FUN_106a7fd8(0x19);\n  *(undefined *)(lVar2 + 2) = 0;\n  *(undefined8 *)(lVar2 + 8) = param_1;\n  *(longlong *)(lVar2 + 0x10) = lVar3;\n  return;\n}",
        "output": "```c\nvoid processFunction(undefined8 param1, undefined8 param2, undefined8 param3, undefined8 param4) {\n    undefined8 result;\n    longlong firstBlock;\n    longlong secondBlock;\n\n    result = FUN_102c5b28(2, param3, param4);\n    firstBlock = FUN_106a7fd8(0x14);\n    *(undefined4 *)(firstBlock + 0x10) = 0x175;\n    *(undefined8 *)(firstBlock + 8) = result;\n    *(undefined *)(firstBlock + 2) = 0x67;\n\n    secondBlock = FUN_106a7fd8(0x36);\n    *(undefined *)(secondBlock + 2) = 0x67;\n    *(undefined8 *)(secondBlock + 8) = param2;\n    *(longlong *)(secondBlock + 0x10) = firstBlock;\n\n    firstBlock = FUN_106a7fd8(0x19);\n    *(undefined *)(firstBlock + 2) = 0;\n    *(undefined8 *)(firstBlock + 8) = param1;\n    *(longlong *)(firstBlock + 0x10) = secondBlock;\n\n    return;\n}\n```",
        "normed_func_sha256": "9993a206e0c3c63f19e507a837715d8e0b7a32cb6924ca53e7f90e67cb5e1013",
        "source_code": "rtx\ngen_aarch64_fcmla0v8hf (rtx operand0 ATTRIBUTE_UNUSED,\n\trtx operand1 ATTRIBUTE_UNUSED,\n\trtx operand2 ATTRIBUTE_UNUSED,\n\trtx operand3 ATTRIBUTE_UNUSED)\n{\n  return gen_rtx_SET (operand0,\n\tgen_rtx_PLUS (V8HFmode,\n\toperand1,\n\tgen_rtx_UNSPEC (V8HFmode,\n\tgen_rtvec (2,\n\t\toperand2,\n\t\toperand3),\n\t373)));\n}",
        "parsed_output": "void processFunction(undefined8 param1, undefined8 param2, undefined8 param3, undefined8 param4) {\n    undefined8 result;\n    longlong firstBlock;\n    longlong secondBlock;\n\n    result = FUN_102c5b28(2, param3, param4);\n    firstBlock = FUN_106a7fd8(0x14);\n    *(undefined4 *)(firstBlock + 0x10) = 0x175;\n    *(undefined8 *)(firstBlock + 8) = result;\n    *(undefined *)(firstBlock + 2) = 0x67;\n\n    secondBlock = FUN_106a7fd8(0x36);\n    *(undefined *)(secondBlock + 2) = 0x67;\n    *(undefined8 *)(secondBlock + 8) = param2;\n    *(longlong *)(secondBlock + 0x10) = firstBlock;\n\n    firstBlock = FUN_106a7fd8(0x19);\n    *(undefined *)(firstBlock + 2) = 0;\n    *(undefined8 *)(firstBlock + 8) = param1;\n    *(longlong *)(firstBlock + 0x10) = secondBlock;\n\n    return;\n}",
        "baseline_code_stripped": "void FUN_10dda440(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 uVar1;\n  longlong lVar2;\n  longlong lVar3;\n  uVar1 = FUN_102c5b28(2,param_3,param_4);\n  lVar2 = FUN_106a7fd8(0x14);\n  *(undefined4 *)(lVar2 + 0x10) = 0x175;\n  *(undefined8 *)(lVar2 + 8) = uVar1;\n  *(undefined *)(lVar2 + 2) = 0x67;\n  lVar3 = FUN_106a7fd8(0x36);\n  *(undefined *)(lVar3 + 2) = 0x67;\n  *(undefined8 *)(lVar3 + 8) = param_2;\n  *(longlong *)(lVar3 + 0x10) = lVar2;\n  lVar2 = FUN_106a7fd8(0x19);\n  *(undefined *)(lVar2 + 2) = 0;\n  *(undefined8 *)(lVar2 + 8) = param_1;\n  *(longlong *)(lVar2 + 0x10) = lVar3;\n  return;\n}",
        "similarity_score_unixcoder": 0.5011886954307556,
        "similarity_score_baseline_stripped": 0.4848305284976959
    },
    {
        "func_name": "netdfs_dissect_struct_dfs_Info7",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_0137dda0(undefined4 param_1,uint param_2,int param_3,int param_4,undefined4 param_5,\n                undefined4 param_6)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  if ((*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0) && ((param_2 & 3) != 0)) {\n    param_2 = (param_2 & 0xfffffffc) + 4;\n  }\n  uVar1 = 0;\n  uVar3 = 0;\n  if (param_4 != 0) {\n    uVar3 = proto_tree_add_item(param_4,param_6,param_1,param_2,0xffffffff,1);\n    uVar1 = proto_item_add_subtree(uVar3,DAT_0274f2c4);\n  }\n  iVar2 = dissect_ndr_uuid_t(param_1,param_2,param_3,uVar1,param_5,DAT_0274f3c8,0);\n  proto_item_set_len(uVar3,iVar2 - param_2);\n  return iVar2;\n}",
        "output": "```c\nint process_data(undefined4 param_1, uint param_2, int param_3, int param_4, undefined4 param_5, undefined4 param_6) {\n    undefined4 subtree_item;\n    int length;\n    undefined4 proto_item;\n\n    // Adjust param_2 if certain conditions are met\n    if ((*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0) && ((param_2 & 3) != 0)) {\n        param_2 = (param_2 & 0xfffffffc) + 4;\n    }\n\n    subtree_item = 0;\n    proto_item = 0;\n\n    // If param_4 is not zero, add a proto tree item\n    if (param_4 != 0) {\n        proto_item = proto_tree_add_item(param_4, param_6, param_1, param_2, 0xffffffff, 1);\n        subtree_item = proto_item_add_subtree(proto_item, DAT_0274f2c4);\n    }\n\n    // Dissect the UUID and get the length\n    length = dissect_ndr_uuid_t(param_1, param_2, param_3, subtree_item, param_5, DAT_0274f3c8, 0);\n    \n    // Set the length of the proto item\n    proto_item_set_len(proto_item, length - param_2);\n    \n    return length;\n}\n```",
        "normed_func_sha256": "a48f04ed5282635da9004526d138dcf00b3d91031e468b552e50939e57c80577",
        "source_code": "int\nnetdfs_dissect_struct_dfs_Info7(tvbuff_t *tvb _U_, int offset _U_, packet_info *pinfo _U_, proto_tree *parent_tree _U_, guint8 *drep _U_, int hf_index _U_, guint32 param _U_)\n{\n\tproto_item *item = NULL;\n\tproto_tree *tree = NULL;\n\tint old_offset;\n\n\tALIGN_TO_4_BYTES;\n\n\told_offset = offset;\n\n\tif (parent_tree) {\n\t\titem = proto_tree_add_item(parent_tree, hf_index, tvb, offset, -1, TRUE);\n\t\ttree = proto_item_add_subtree(item, ett_netdfs_dfs_Info7);\n\t}\n\t\n\toffset = netdfs_dissect_element_dfs_Info7_generation_guid(tvb, offset, pinfo, tree, drep);\n\n\n\tproto_item_set_len(item, offset-old_offset);\n\n\treturn offset;\n}",
        "parsed_output": "int process_data(undefined4 param_1, uint param_2, int param_3, int param_4, undefined4 param_5, undefined4 param_6) {\n    undefined4 subtree_item;\n    int length;\n    undefined4 proto_item;\n\n    // Adjust param_2 if certain conditions are met\n    if ((*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0) && ((param_2 & 3) != 0)) {\n        param_2 = (param_2 & 0xfffffffc) + 4;\n    }\n\n    subtree_item = 0;\n    proto_item = 0;\n\n    // If param_4 is not zero, add a proto tree item\n    if (param_4 != 0) {\n        proto_item = proto_tree_add_item(param_4, param_6, param_1, param_2, 0xffffffff, 1);\n        subtree_item = proto_item_add_subtree(proto_item, DAT_0274f2c4);\n    }\n\n    // Dissect the UUID and get the length\n    length = dissect_ndr_uuid_t(param_1, param_2, param_3, subtree_item, param_5, DAT_0274f3c8, 0);\n    \n    // Set the length of the proto item\n    proto_item_set_len(proto_item, length - param_2);\n    \n    return length;\n}",
        "baseline_code_stripped": "int FUN_0137dda0(undefined4 param_1,uint param_2,int param_3,int param_4,undefined4 param_5,\n                undefined4 param_6)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  if ((*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0) && ((param_2 & 3) != 0)) {\n    param_2 = (param_2 & 0xfffffffc) + 4;\n  }\n  uVar1 = 0;\n  uVar3 = 0;\n  if (param_4 != 0) {\n    uVar3 = proto_tree_add_item(param_4,param_6,param_1,param_2,0xffffffff,1);\n    uVar1 = proto_item_add_subtree(uVar3,DAT_0274f2c4);\n  }\n  iVar2 = dissect_ndr_uuid_t(param_1,param_2,param_3,uVar1,param_5,DAT_0274f3c8,0);\n  proto_item_set_len(uVar3,iVar2 - param_2);\n  return iVar2;\n}",
        "similarity_score_unixcoder": 0.7608578205108643,
        "similarity_score_baseline_stripped": 0.709363579750061
    },
    {
        "func_name": "YUVProgramContext::updateUProjection",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall YUVProgramContext::updateUProjection(YUVProgramContext *this)\n{\n  *(undefined4 *)(this + 0x78) = 0x40000000;\n  *(undefined4 *)(this + 0x7c) = 0;\n  *(undefined4 *)(this + 0x80) = 0;\n  *(undefined4 *)(this + 0x84) = 0;\n  *(undefined4 *)(this + 0x88) = 0;\n  *(undefined4 *)(this + 0x8c) = 0x40000000;\n  __aeabi_memclr8(this + 0x90,0x18);\n  *(undefined4 *)(this + 0xa8) = 0xbf800000;\n  *(undefined4 *)(this + 0xac) = 0xbf800000;\n  *(undefined4 *)(this + 0xb0) = 0;\n  *(undefined4 *)(this + 0xb4) = 0x3f800000;\n  if ((*(int *)(this + 0x104) != 0) && (*(int *)(this + 0x100) != 0)) {\n    *(float *)(this + 0x78) = 2.0 / (float)(longlong)*(int *)(this + 0x100);\n    *(float *)(this + 0x8c) = 2.0 / (float)(longlong)*(int *)(this + 0x104);\n  }\n  return;\n}",
        "output": "```c\nvoid YUVProgramContext::updateUProjection() {\n    // Initialize projection matrix values\n    *(uint32_t *)(this + 0x78) = 0x40000000; // 2.0 in fixed-point representation\n    *(uint32_t *)(this + 0x7c) = 0;          // Zero\n    *(uint32_t *)(this + 0x80) = 0;          // Zero\n    *(uint32_t *)(this + 0x84) = 0;          // Zero\n    *(uint32_t *)(this + 0x88) = 0;          // Zero\n    *(uint32_t *)(this + 0x8c) = 0x40000000; // 2.0 in fixed-point representation\n    __aeabi_memclr8(this + 0x90, 0x18);      // Clear memory for additional data\n\n    // Set default values for other parameters\n    *(uint32_t *)(this + 0xa8) = 0xbf800000; // -1.0 in fixed-point representation\n    *(uint32_t *)(this + 0xac) = 0xbf800000; // -1.0 in fixed-point representation\n    *(uint32_t *)(this + 0xb0) = 0;          // Zero\n    *(uint32_t *)(this + 0xb4) = 0x3f800000; // 1.0 in fixed-point representation\n\n    // Update projection values based on conditions\n    if (*(int *)(this + 0x104) != 0 && *(int *)(this + 0x100) != 0) {\n        *(float *)(this + 0x78) = 2.0f / (float)(long long)*(int *)(this + 0x100);\n        *(float *)(this + 0x8c) = 2.0f / (float)(long long)*(int *)(this + 0x104);\n    }\n}\n```",
        "normed_func_sha256": "54cc64237870bf521c109ddb31036fe18f5055766efe64a8abe1744dd89c4844",
        "source_code": "void YUVProgramContext::updateUProjection() {\n    mUProjection[0][0] = 2.0f;\n    mUProjection[0][1] = 0.0f;\n    mUProjection[0][2] = 0.0f;\n    mUProjection[0][3] = 0.0f;\n    mUProjection[1][0] = 0.0f;\n    mUProjection[1][1] = 2.0f;\n    mUProjection[1][2] = 0.0f;\n    mUProjection[1][3] = 0.0f;\n    mUProjection[2][0] = 0.0f;\n    mUProjection[2][1] = 0.0f;\n    mUProjection[2][2] = 0.0f;\n    mUProjection[2][3] = 0.0f;\n    mUProjection[3][0] = -1.0f;\n    mUProjection[3][1] = -1.0f;\n    mUProjection[3][2] = 0.0f;\n    mUProjection[3][3] = 1.0f;\n\n    if (mWindowHeight != 0 && mWindowWidth != 0) {\n        mUProjection[0][0] = 2.0f / mWindowWidth;\n        mUProjection[1][1] = 2.0f / mWindowHeight;\n    }\n}",
        "parsed_output": "void YUVProgramContext::updateUProjection() {\n    // Initialize projection matrix values\n    *(uint32_t *)(this + 0x78) = 0x40000000; // 2.0 in fixed-point representation\n    *(uint32_t *)(this + 0x7c) = 0;          // Zero\n    *(uint32_t *)(this + 0x80) = 0;          // Zero\n    *(uint32_t *)(this + 0x84) = 0;          // Zero\n    *(uint32_t *)(this + 0x88) = 0;          // Zero\n    *(uint32_t *)(this + 0x8c) = 0x40000000; // 2.0 in fixed-point representation\n    __aeabi_memclr8(this + 0x90, 0x18);      // Clear memory for additional data\n\n    // Set default values for other parameters\n    *(uint32_t *)(this + 0xa8) = 0xbf800000; // -1.0 in fixed-point representation\n    *(uint32_t *)(this + 0xac) = 0xbf800000; // -1.0 in fixed-point representation\n    *(uint32_t *)(this + 0xb0) = 0;          // Zero\n    *(uint32_t *)(this + 0xb4) = 0x3f800000; // 1.0 in fixed-point representation\n\n    // Update projection values based on conditions\n    if (*(int *)(this + 0x104) != 0 && *(int *)(this + 0x100) != 0) {\n        *(float *)(this + 0x78) = 2.0f / (float)(long long)*(int *)(this + 0x100);\n        *(float *)(this + 0x8c) = 2.0f / (float)(long long)*(int *)(this + 0x104);\n    }\n}",
        "baseline_code_stripped": "void __thiscall YUVProgramContext::updateUProjection(YUVProgramContext *this)\n{\n  *(undefined4 *)(this + 0x78) = 0x40000000;\n  *(undefined4 *)(this + 0x7c) = 0;\n  *(undefined4 *)(this + 0x80) = 0;\n  *(undefined4 *)(this + 0x84) = 0;\n  *(undefined4 *)(this + 0x88) = 0;\n  *(undefined4 *)(this + 0x8c) = 0x40000000;\n  __aeabi_memclr8(this + 0x90,0x18);\n  *(undefined4 *)(this + 0xa8) = 0xbf800000;\n  *(undefined4 *)(this + 0xac) = 0xbf800000;\n  *(undefined4 *)(this + 0xb0) = 0;\n  *(undefined4 *)(this + 0xb4) = 0x3f800000;\n  if ((*(int *)(this + 0x104) != 0) && (*(int *)(this + 0x100) != 0)) {\n    *(float *)(this + 0x78) = 2.0 / (float)(longlong)*(int *)(this + 0x100);\n    *(float *)(this + 0x8c) = 2.0 / (float)(longlong)*(int *)(this + 0x104);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.7011744976043701,
        "similarity_score_baseline_stripped": 0.6691746711730957
    },
    {
        "func_name": "decode_sib_address",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_0010fb20(uint param_1,int param_2)\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  switch(param_1 & 7) {\n  case 0:\n    iVar2 = _DAT_00323378;\n    break;\n  case 1:\n    iVar2 = _DAT_00323380;\n    break;\n  case 2:\n    iVar2 = DAT_00323384;\n    break;\n  case 3:\n    iVar2 = DAT_0032337c;\n    break;\n  case 5:\n    if (param_2 == 0) {\n      iVar2 = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n      DAT_00323398 = DAT_00323398 + 4;\n      break;\n    }\n  case 4:\n    DAT_003233ac = DAT_003233ac | 1;\n    iVar2 = _DAT_00323388;\n    break;\n  case 6:\n    iVar2 = DAT_00323390;\n    break;\n  case 7:\n    iVar2 = DAT_00323394;\n  }\n  bVar1 = (byte)((int)param_1 >> 6);\n  switch((int)param_1 >> 3 & 7) {\n  case 0:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323378;\n  case 1:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323380;\n  case 2:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323384;\n  case 3:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032337c;\n  case 4:\n    iVar3 = 0;\n    break;\n  case 5:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032338c;\n  case 6:\n    iVar3 = (1 << (bVar1 & 3)) * DAT_00323390;\n    break;\n  case 7:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323394;\n  }\n  return iVar2 + iVar3;\n}",
        "output": "```c\nint FUN_0010fb20(uint param_1, int param_2) {\n    int result;\n    int additionalValue = 0;\n\n    switch(param_1 & 7) {\n        case 0:\n            result = _DAT_00323378;\n            break;\n        case 1:\n            result = _DAT_00323380;\n            break;\n        case 2:\n            result = DAT_00323384;\n            break;\n        case 3:\n            result = DAT_0032337c;\n            break;\n        case 4:\n            DAT_003233ac |= 1;\n            result = _DAT_00323388;\n            break;\n        case 5:\n            if (param_2 == 0) {\n                result = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n                DAT_00323398 += 4;\n                break;\n            }\n            // Fall through to case 6\n        case 6:\n            result = DAT_00323390;\n            break;\n        case 7:\n            result = DAT_00323394;\n            break;\n    }\n\n    byte shiftValue = (byte)((int)param_1 >> 6);\n    switch((int)param_1 >> 3 & 7) {\n        case 0:\n            return result + (1 << (shiftValue & 3)) * _DAT_00323378;\n        case 1:\n            return result + (1 << (shiftValue & 3)) * _DAT_00323380;\n        case 2:\n            return result + (1 << (shiftValue & 3)) * DAT_00323384;\n        case 3:\n            return result + (1 << (shiftValue & 3)) * DAT_0032337c;\n        case 4:\n            additionalValue = 0;\n            break;\n        case 5:\n            return result + (1 << (shiftValue & 3)) * DAT_0032338c;\n        case 6:\n            additionalValue = (1 << (shiftValue & 3)) * DAT_00323390;\n            break;\n        case 7:\n            return result + (1 << (shiftValue & 3)) * DAT_00323394;\n    }\n\n    return result + additionalValue;\n}\n```",
        "normed_func_sha256": "74b135bce90d50efa45fe04a912714fb565c7b76973ffef47e435c514a8773aa",
        "source_code": "u32\ndecode_sib_address(int sib, int mod)\n{\n    u32 base = 0, i = 0, scale = 1;\n\n    switch (sib & 0x07) {\n    case 0:\n        DECODE_PRINTF(\"[EAX]\");\n        base = M.x86.R_EAX;\n        break;\n    case 1:\n        DECODE_PRINTF(\"[ECX]\");\n        base = M.x86.R_ECX;\n        break;\n    case 2:\n        DECODE_PRINTF(\"[EDX]\");\n        base = M.x86.R_EDX;\n        break;\n    case 3:\n        DECODE_PRINTF(\"[EBX]\");\n        base = M.x86.R_EBX;\n        break;\n    case 4:\n        DECODE_PRINTF(\"[ESP]\");\n        base = M.x86.R_ESP;\n        M.x86.mode |= SYSMODE_SEG_DS_SS;\n        break;\n    case 5:\n        if (mod == 0) {\n            base = fetch_long_imm();\n            DECODE_PRINTF2(\"%08x\", base);\n        }\n        else {\n            DECODE_PRINTF(\"[EBP]\");\n            base = M.x86.R_ESP;\n            M.x86.mode |= SYSMODE_SEG_DS_SS;\n        }\n        break;\n    case 6:\n        DECODE_PRINTF(\"[ESI]\");\n        base = M.x86.R_ESI;\n        break;\n    case 7:\n        DECODE_PRINTF(\"[EDI]\");\n        base = M.x86.R_EDI;\n        break;\n    }\n    switch ((sib >> 3) & 0x07) {\n    case 0:\n        DECODE_PRINTF(\"[EAX\");\n        i = M.x86.R_EAX;\n        break;\n    case 1:\n        DECODE_PRINTF(\"[ECX\");\n        i = M.x86.R_ECX;\n        break;\n    case 2:\n        DECODE_PRINTF(\"[EDX\");\n        i = M.x86.R_EDX;\n        break;\n    case 3:\n        DECODE_PRINTF(\"[EBX\");\n        i = M.x86.R_EBX;\n        break;\n    case 4:\n        i = 0;\n        break;\n    case 5:\n        DECODE_PRINTF(\"[EBP\");\n        i = M.x86.R_EBP;\n        break;\n    case 6:\n        DECODE_PRINTF(\"[ESI\");\n        i = M.x86.R_ESI;\n        break;\n    case 7:\n        DECODE_PRINTF(\"[EDI\");\n        i = M.x86.R_EDI;\n        break;\n    }\n    scale = 1 << ((sib >> 6) & 0x03);\n    if (((sib >> 3) & 0x07) != 4) {\n        if (scale == 1) {\n            DECODE_PRINTF(\"]\");\n        }\n        else {\n            DECODE_PRINTF2(\"*%d]\", scale);\n        }\n    }\n    return base + (i * scale);\n}",
        "parsed_output": "int FUN_0010fb20(uint param_1, int param_2) {\n    int result;\n    int additionalValue = 0;\n\n    switch(param_1 & 7) {\n        case 0:\n            result = _DAT_00323378;\n            break;\n        case 1:\n            result = _DAT_00323380;\n            break;\n        case 2:\n            result = DAT_00323384;\n            break;\n        case 3:\n            result = DAT_0032337c;\n            break;\n        case 4:\n            DAT_003233ac |= 1;\n            result = _DAT_00323388;\n            break;\n        case 5:\n            if (param_2 == 0) {\n                result = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n                DAT_00323398 += 4;\n                break;\n            }\n            // Fall through to case 6\n        case 6:\n            result = DAT_00323390;\n            break;\n        case 7:\n            result = DAT_00323394;\n            break;\n    }\n\n    byte shiftValue = (byte)((int)param_1 >> 6);\n    switch((int)param_1 >> 3 & 7) {\n        case 0:\n            return result + (1 << (shiftValue & 3)) * _DAT_00323378;\n        case 1:\n            return result + (1 << (shiftValue & 3)) * _DAT_00323380;\n        case 2:\n            return result + (1 << (shiftValue & 3)) * DAT_00323384;\n        case 3:\n            return result + (1 << (shiftValue & 3)) * DAT_0032337c;\n        case 4:\n            additionalValue = 0;\n            break;\n        case 5:\n            return result + (1 << (shiftValue & 3)) * DAT_0032338c;\n        case 6:\n            additionalValue = (1 << (shiftValue & 3)) * DAT_00323390;\n            break;\n        case 7:\n            return result + (1 << (shiftValue & 3)) * DAT_00323394;\n    }\n\n    return result + additionalValue;\n}",
        "baseline_code_stripped": "int FUN_0010fb20(uint param_1,int param_2)\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  switch(param_1 & 7) {\n  case 0:\n    iVar2 = _DAT_00323378;\n    break;\n  case 1:\n    iVar2 = _DAT_00323380;\n    break;\n  case 2:\n    iVar2 = DAT_00323384;\n    break;\n  case 3:\n    iVar2 = DAT_0032337c;\n    break;\n  case 5:\n    if (param_2 == 0) {\n      iVar2 = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n      DAT_00323398 = DAT_00323398 + 4;\n      break;\n    }\n  case 4:\n    DAT_003233ac = DAT_003233ac | 1;\n    iVar2 = _DAT_00323388;\n    break;\n  case 6:\n    iVar2 = DAT_00323390;\n    break;\n  case 7:\n    iVar2 = DAT_00323394;\n  }\n  bVar1 = (byte)((int)param_1 >> 6);\n  switch((int)param_1 >> 3 & 7) {\n  case 0:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323378;\n  case 1:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323380;\n  case 2:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323384;\n  case 3:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032337c;\n  case 4:\n    iVar3 = 0;\n    break;\n  case 5:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032338c;\n  case 6:\n    iVar3 = (1 << (bVar1 & 3)) * DAT_00323390;\n    break;\n  case 7:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323394;\n  }\n  return iVar2 + iVar3;\n}",
        "similarity_score_unixcoder": 0.6485492587089539,
        "similarity_score_baseline_stripped": 0.5846819281578064
    },
    {
        "func_name": "m68k_op_move_16_tos_al",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00e28907(void)\n{\n  undefined4 uVar1;\n  if (DAT_03e4ce14 == 0) {\n    FUN_00de4420();\n  }\n  else {\n    uVar1 = FUN_00de3aef();\n    FUN_00de40bf(uVar1);\n  }\n  return;\n}",
        "output": "```c\nvoid executeFunction(void)\n{\n  undefined4 result;\n  \n  if (DAT_03e4ce14 == 0) {\n    callFunctionA();\n  }\n  else {\n    result = callFunctionB();\n    callFunctionC(result);\n  }\n  \n  return;\n}\n```",
        "normed_func_sha256": "bad3fcf49b58e1f1f5a12d5855427450193d1155115a7d1fe59121577ee083ca",
        "source_code": "static void m68k_op_move_16_tos_al(void)\n{\n\tif(FLAG_S)\n\t{\n\t\tuint new_sr = OPER_AL_16();\n\t\tm68ki_trace_t0();\t\t\t   /* auto-disable (see m68kcpu.h) */\n\t\tm68ki_set_sr(new_sr);\n\t\treturn;\n\t}\n\tm68ki_exception_privilege_violation();\n}",
        "parsed_output": "void executeFunction(void)\n{\n  undefined4 result;\n  \n  if (DAT_03e4ce14 == 0) {\n    callFunctionA();\n  }\n  else {\n    result = callFunctionB();\n    callFunctionC(result);\n  }\n  \n  return;\n}",
        "baseline_code_stripped": "void FUN_00e28907(void)\n{\n  undefined4 uVar1;\n  if (DAT_03e4ce14 == 0) {\n    FUN_00de4420();\n  }\n  else {\n    uVar1 = FUN_00de3aef();\n    FUN_00de40bf(uVar1);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.45236802101135254,
        "similarity_score_baseline_stripped": 0.4923078119754791
    },
    {
        "func_name": "ImageDataParameter::release_source",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall FUN_100e7930(MessageLite *param_1)\n{\n  uint *puVar1;\n  Arena *pAVar2;\n  puVar1 = (uint *)thunk_FUN_1008f9a0(0);\n  *puVar1 = *puVar1 | 1;\n  google::protobuf::MessageLite::GetArenaForAllocation(param_1);\n  pAVar2 = (Arena *)__RTC_CheckEsp();\n  google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(param_1 + 0x10),pAVar2);\n  __RTC_CheckEsp();\n  __RTC_CheckEsp();\n  return;\n}",
        "output": "```c\nvoid processMessageLite(MessageLite *message) {\n    uint *statusFlag;\n    Arena *currentArena;\n\n    statusFlag = (uint *)thunk_FUN_1008f9a0(0);\n    *statusFlag |= 1;\n\n    google::protobuf::MessageLite::GetArenaForAllocation(message);\n    currentArena = (Arena *)__RTC_CheckEsp();\n\n    google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(message + 0x10), currentArena);\n    \n    __RTC_CheckEsp();\n    __RTC_CheckEsp();\n}\n```",
        "normed_func_sha256": "737cbad3d711833c3121204f21422ae18966e99fe00aef7adee8545670e25d4a",
        "source_code": "inline std::string* ImageDataParameter::release_source() {\n  // @@protoc_insertion_point(field_release:opencv_caffe.ImageDataParameter.source)\n  if (!_internal_has_source()) {\n    return nullptr;\n  }\n  _has_bits_[0] &= ~0x00000001u;\n  auto* p = source_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());\n#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING\n  if (source_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {\n    source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), \"\", GetArenaForAllocation());\n  }\n#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING\n  return p;\n}",
        "parsed_output": "void processMessageLite(MessageLite *message) {\n    uint *statusFlag;\n    Arena *currentArena;\n\n    statusFlag = (uint *)thunk_FUN_1008f9a0(0);\n    *statusFlag |= 1;\n\n    google::protobuf::MessageLite::GetArenaForAllocation(message);\n    currentArena = (Arena *)__RTC_CheckEsp();\n\n    google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(message + 0x10), currentArena);\n    \n    __RTC_CheckEsp();\n    __RTC_CheckEsp();\n}",
        "baseline_code_stripped": "void __fastcall FUN_100e7930(MessageLite *param_1)\n{\n  uint *puVar1;\n  Arena *pAVar2;\n  puVar1 = (uint *)thunk_FUN_1008f9a0(0);\n  *puVar1 = *puVar1 | 1;\n  google::protobuf::MessageLite::GetArenaForAllocation(param_1);\n  pAVar2 = (Arena *)__RTC_CheckEsp();\n  google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(param_1 + 0x10),pAVar2);\n  __RTC_CheckEsp();\n  __RTC_CheckEsp();\n  return;\n}",
        "similarity_score_unixcoder": 0.4685244858264923,
        "similarity_score_baseline_stripped": 0.48968306183815
    },
    {
        "func_name": "OpmlParser::defaultEnd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid OpmlParser::defaultEnd(QSharedPointer *param_1,Thread *param_2)\n{\n  void *pvVar1;\n  int iVar2;\n  ulong uVar3;\n  QSharedPointer QVar4;\n  undefined8 local_20;\n  void *pvStack_18;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  ThreadWeaver::Job::defaultEnd(param_1 + 4,param_2);\n  uVar3 = (**(code **)(**(long **)param_2 + 0x48))();\n  QVar4 = (QSharedPointer)&local_20;\n  if ((uVar3 & 1) == 0) {\n    pvStack_18 = *(void **)(param_2 + 8);\n    local_20 = *(undefined8 *)param_2;\n    if (pvStack_18 != (void *)0x0) {\n      FUN_0032a300(&local_20);\n    }\n    failed((OpmlParser *)param_1,QVar4);\n    if (pvStack_18 != (void *)0x0) {\n      FUN_003441a0();\n    }\n  }\n  pvStack_18 = *(void **)(param_2 + 8);\n  local_20 = *(undefined8 *)param_2;\n  if (pvStack_18 != (void *)0x0) {\n    FUN_006e2be0(1);\n    FUN_006e2be0(1,(long)pvStack_18 + 4);\n  }\n  done((OpmlParser *)param_1,QVar4);\n  pvVar1 = pvStack_18;\n  if (pvStack_18 != (void *)0x0) {\n    iVar2 = FUN_006e2be0(0xffffffff,(long)pvStack_18 + 4);\n    if (iVar2 == 1) {\n      (**(code **)((long)pvVar1 + 8))(pvVar1);\n    }\n    iVar2 = FUN_006e2be0(0xffffffff,pvVar1);\n    if (iVar2 == 1) {\n      operator_delete(pvVar1);\n    }\n  }\n  if (local_8 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);\n}",
        "output": "```cpp\nvoid OpmlParser::defaultEnd(QSharedPointer *parserPtr, Thread *threadPtr)\n{\n    void *stackPointer;\n    int result;\n    ulong status;\n    QSharedPointer sharedPointer;\n    undefined8 localData;\n    void *threadData;\n    long stackGuard;\n    \n    stackGuard = ___stack_chk_guard;\n    ThreadWeaver::Job::defaultEnd(parserPtr + 4, threadPtr);\n    \n    status = (**(code **)(**(long **)threadPtr + 0x48))();\n    sharedPointer = (QSharedPointer)&localData;\n    \n    if ((status & 1) == 0) {\n        threadData = *(void **)(threadPtr + 8);\n        localData = *(undefined8 *)threadPtr;\n        \n        if (threadData != nullptr) {\n            FUN_0032a300(&localData);\n        }\n        \n        failed((OpmlParser *)parserPtr, sharedPointer);\n        \n        if (threadData != nullptr) {\n            FUN_003441a0();\n        }\n    }\n    \n    threadData = *(void **)(threadPtr + 8);\n    localData = *(undefined8 *)threadPtr;\n    \n    if (threadData != nullptr) {\n        FUN_006e2be0(1);\n        FUN_006e2be0(1, (long)threadData + 4);\n    }\n    \n    done((OpmlParser *)parserPtr, sharedPointer);\n    \n    if (threadData != nullptr) {\n        result = FUN_006e2be0(0xffffffff, (long)threadData + 4);\n        \n        if (result == 1) {\n            (**(code **)((long)threadData + 8))(threadData);\n        }\n        \n        result = FUN_006e2be0(0xffffffff, threadData);\n        \n        if (result == 1) {\n            operator_delete(threadData);\n        }\n    }\n    \n    if (stackGuard - ___stack_chk_guard == 0) {\n        return;\n    }\n    \n    __stack_chk_fail(&__stack_chk_guard, 0, stackGuard - ___stack_chk_guard);\n}\n```",
        "normed_func_sha256": "cf621c8237672c026956ee9cf7554f3fc184a1b1f28e29888c6096f512283f9b",
        "source_code": "void\nOpmlParser::defaultEnd(const ThreadWeaver::JobPointer& self, ThreadWeaver::Thread *thread)\n{\n    ThreadWeaver::Job::defaultEnd(self, thread);\n    if (!self->success()) {\n        Q_EMIT failed(self);\n    }\n    Q_EMIT done(self);\n}",
        "parsed_output": "pp\nvoid OpmlParser::defaultEnd(QSharedPointer *parserPtr, Thread *threadPtr)\n{\n    void *stackPointer;\n    int result;\n    ulong status;\n    QSharedPointer sharedPointer;\n    undefined8 localData;\n    void *threadData;\n    long stackGuard;\n    \n    stackGuard = ___stack_chk_guard;\n    ThreadWeaver::Job::defaultEnd(parserPtr + 4, threadPtr);\n    \n    status = (**(code **)(**(long **)threadPtr + 0x48))();\n    sharedPointer = (QSharedPointer)&localData;\n    \n    if ((status & 1) == 0) {\n        threadData = *(void **)(threadPtr + 8);\n        localData = *(undefined8 *)threadPtr;\n        \n        if (threadData != nullptr) {\n            FUN_0032a300(&localData);\n        }\n        \n        failed((OpmlParser *)parserPtr, sharedPointer);\n        \n        if (threadData != nullptr) {\n            FUN_003441a0();\n        }\n    }\n    \n    threadData = *(void **)(threadPtr + 8);\n    localData = *(undefined8 *)threadPtr;\n    \n    if (threadData != nullptr) {\n        FUN_006e2be0(1);\n        FUN_006e2be0(1, (long)threadData + 4);\n    }\n    \n    done((OpmlParser *)parserPtr, sharedPointer);\n    \n    if (threadData != nullptr) {\n        result = FUN_006e2be0(0xffffffff, (long)threadData + 4);\n        \n        if (result == 1) {\n            (**(code **)((long)threadData + 8))(threadData);\n        }\n        \n        result = FUN_006e2be0(0xffffffff, threadData);\n        \n        if (result == 1) {\n            operator_delete(threadData);\n        }\n    }\n    \n    if (stackGuard - ___stack_chk_guard == 0) {\n        return;\n    }\n    \n    __stack_chk_fail(&__stack_chk_guard, 0, stackGuard - ___stack_chk_guard);\n}",
        "baseline_code_stripped": "void OpmlParser::defaultEnd(QSharedPointer *param_1,Thread *param_2)\n{\n  void *pvVar1;\n  int iVar2;\n  ulong uVar3;\n  QSharedPointer QVar4;\n  undefined8 local_20;\n  void *pvStack_18;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  ThreadWeaver::Job::defaultEnd(param_1 + 4,param_2);\n  uVar3 = (**(code **)(**(long **)param_2 + 0x48))();\n  QVar4 = (QSharedPointer)&local_20;\n  if ((uVar3 & 1) == 0) {\n    pvStack_18 = *(void **)(param_2 + 8);\n    local_20 = *(undefined8 *)param_2;\n    if (pvStack_18 != (void *)0x0) {\n      FUN_0032a300(&local_20);\n    }\n    failed((OpmlParser *)param_1,QVar4);\n    if (pvStack_18 != (void *)0x0) {\n      FUN_003441a0();\n    }\n  }\n  pvStack_18 = *(void **)(param_2 + 8);\n  local_20 = *(undefined8 *)param_2;\n  if (pvStack_18 != (void *)0x0) {\n    FUN_006e2be0(1);\n    FUN_006e2be0(1,(long)pvStack_18 + 4);\n  }\n  done((OpmlParser *)param_1,QVar4);\n  pvVar1 = pvStack_18;\n  if (pvStack_18 != (void *)0x0) {\n    iVar2 = FUN_006e2be0(0xffffffff,(long)pvStack_18 + 4);\n    if (iVar2 == 1) {\n      (**(code **)((long)pvVar1 + 8))(pvVar1);\n    }\n    iVar2 = FUN_006e2be0(0xffffffff,pvVar1);\n    if (iVar2 == 1) {\n      operator_delete(pvVar1);\n    }\n  }\n  if (local_8 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);\n}",
        "similarity_score_unixcoder": 0.7338012456893921,
        "similarity_score_baseline_stripped": 0.5953972339630127
    },
    {
        "func_name": "sipQgsMapLayer::sipProtectVirt_decodedSource",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nQString * sipQgsMapLayer::sipProtectVirt_decodedSource\n                    (bool param_1,QString *param_2,QString *param_3,QgsReadWriteContext *param_4)\n{\n  long lVar1;\n  undefined7 in_register_00000039;\n  QString *pQVar2;\n  long in_FS_OFFSET;\n  pQVar2 = (QString *)CONCAT71(in_register_00000039,param_1);\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((char)param_3 == '\\0') {\n    (**(code **)(*(long *)param_2 + 0x260))(pQVar2);\n  }\n  else {\n    QgsMapLayer::decodedSource(pQVar2,param_2,param_4);\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pQVar2;\n  }\n  __stack_chk_fail();\n}",
        "output": "```cpp\nQString* sipQgsMapLayer::sipProtectVirt_decodedSource(bool isProtected, QString* source, QString* additionalSource, QgsReadWriteContext* context) {\n    long stackCheckValue;\n    QString* result = (QString*)CONCAT71(in_register_00000039, isProtected);\n    stackCheckValue = *(long*)(in_FS_OFFSET + 0x28);\n    \n    if ((char)additionalSource == '\\0') {\n        (**(code**)(*(long*)source + 0x260))(result);\n    } else {\n        QgsMapLayer::decodedSource(result, source, context);\n    }\n    \n    if (stackCheckValue == *(long*)(in_FS_OFFSET + 0x28)) {\n        return result;\n    }\n    \n    __stack_chk_fail();\n}\n```",
        "normed_func_sha256": "4c76efd72899d90139badcb6bbc0e4297c58126a1f2a435049d3f2114dd040ba",
        "source_code": "::QString sipQgsMapLayer::sipProtectVirt_decodedSource(bool sipSelfWasArg, const ::QString& a0, const ::QString& a1, const ::QgsReadWriteContext& a2) const\n{\n    return (sipSelfWasArg ? ::QgsMapLayer::decodedSource(a0, a1, a2) : decodedSource(a0, a1, a2));\n}",
        "parsed_output": "pp\nQString* sipQgsMapLayer::sipProtectVirt_decodedSource(bool isProtected, QString* source, QString* additionalSource, QgsReadWriteContext* context) {\n    long stackCheckValue;\n    QString* result = (QString*)CONCAT71(in_register_00000039, isProtected);\n    stackCheckValue = *(long*)(in_FS_OFFSET + 0x28);\n    \n    if ((char)additionalSource == '\\0') {\n        (**(code**)(*(long*)source + 0x260))(result);\n    } else {\n        QgsMapLayer::decodedSource(result, source, context);\n    }\n    \n    if (stackCheckValue == *(long*)(in_FS_OFFSET + 0x28)) {\n        return result;\n    }\n    \n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "QString * sipQgsMapLayer::sipProtectVirt_decodedSource\n                    (bool param_1,QString *param_2,QString *param_3,QgsReadWriteContext *param_4)\n{\n  long lVar1;\n  undefined7 in_register_00000039;\n  QString *pQVar2;\n  long in_FS_OFFSET;\n  pQVar2 = (QString *)CONCAT71(in_register_00000039,param_1);\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((char)param_3 == '\\0') {\n    (**(code **)(*(long *)param_2 + 0x260))(pQVar2);\n  }\n  else {\n    QgsMapLayer::decodedSource(pQVar2,param_2,param_4);\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pQVar2;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.7233865261077881,
        "similarity_score_baseline_stripped": 0.6999660134315491
    },
    {
        "func_name": "acquire_daemonlock",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00018ca0(int param_1)\n{\n  int unaff_r2;\n  __pid_t _Var1;\n  size_t __n;\n  size_t sVar2;\n  int *piVar3;\n  char *pcVar4;\n  int iVar5;\n  ssize_t sVar6;\n  int iVar7;\n  char *local_3028;\n  char acStack_3024 [12288];\n  int local_24;\n  local_24 = *(int *)(unaff_r2 + -0x7008);\n  if (param_1 == 0) {\n    if (_DAT_0006dea8 == -1) {\n      _DAT_0006dea8 = open(\"/var/run/crond.pid\",0x42,0x180);\n      if (_DAT_0006dea8 == -1) {\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t open or create %s: %s\",\"/var/run/crond.pid\",\n                      pcVar4);\n        __fprintf_chk(stderr,1,\"%s: %s\\n\",ProgramName,acStack_3024);\n        _Var1 = getpid();\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"DEATH\",acStack_3024);\n        exit(1);\n      }\n      iVar5 = flock(_DAT_0006dea8,6);\n      if (iVar5 < 0) {\n        piVar3 = __errno_location();\n        iVar5 = *piVar3;\n        memset(acStack_3024,0,0x3000);\n        sVar6 = read(_DAT_0006dea8,acStack_3024,0x2fff);\n        if (sVar6 < 1) {\n          iVar7 = -1;\n        }\n        else {\n          iVar7 = __strtol_internal(acStack_3024,&local_3028,10,0);\n          if ((((0 < iVar7) && (acStack_3024 != local_3028)) && (*local_3028 == '\\n')) &&\n             (iVar7 != 0x7fffffff)) {\n            pcVar4 = strerror(iVar5);\n            __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid may be %ld: %s\",\n                          \"/var/run/crond.pid\",iVar7,pcVar4);\n            goto LAB_00018f18;\n          }\n        }\n        pcVar4 = strerror(iVar5);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid unknown: %s\",\n                      \"/var/run/crond.pid\",pcVar4);\nLAB_00018f18:\n        pcVar4 = strerror(iVar5);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid may be %ld: %s\",\n                      \"/var/run/crond.pid\",iVar7,pcVar4);\n        __fprintf_chk(stderr,1,\"%s: %s\\n\",ProgramName,acStack_3024);\n        _Var1 = getpid();\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"DEATH\",acStack_3024);\n        exit(1);\n      }\n      fchmod(_DAT_0006dea8,0x1a4);\n      fcntl(_DAT_0006dea8,2,1);\n    }\n    _Var1 = getpid();\n    __sprintf_chk(acStack_3024,1,0x3000,\"%ld\\n\",_Var1);\n    lseek(_DAT_0006dea8,0,0);\n    __n = strlen(acStack_3024);\n    sVar2 = write(_DAT_0006dea8,acStack_3024,__n);\n    if (__n == sVar2) {\n      iVar5 = ftruncate(_DAT_0006dea8,__n);\n      if (iVar5 == -1) {\n        _Var1 = getpid();\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"ftruncate() failed:\",pcVar4);\n      }\n    }\n    else {\n      _Var1 = getpid();\n      piVar3 = __errno_location();\n      pcVar4 = strerror(*piVar3);\n      FUN_00018530(&DAT_0001bbd8,_Var1,\"write() failed:\",pcVar4);\n    }\n  }\n  else if (_DAT_0006dea8 != -1) {\n    close(_DAT_0006dea8);\n    _DAT_0006dea8 = -1;\n  }\n  if (local_24 == *(int *)(unaff_r2 + -0x7008)) {\n    return;\n  }\n  FUN_0001aef0();\n}",
        "output": "```c\nvoid FUN_00018ca0(int param_1)\n{\n    int unaff_r2;\n    __pid_t current_pid;\n    size_t write_length;\n    size_t bytes_written;\n    int *error_pointer;\n    char *error_message;\n    int flock_result;\n    ssize_t read_result;\n    int other_pid;\n    char *local_buffer;\n    char acStack_3024[12288];\n    int local_24;\n\n    local_24 = *(int *)(unaff_r2 + -0x7008);\n    \n    if (param_1 == 0) {\n        if (_DAT_0006dea8 == -1) {\n            _DAT_0006dea8 = open(\"/var/run/crond.pid\", O_CREAT | O_RDWR, 0x180);\n            if (_DAT_0006dea8 == -1) {\n                error_pointer = __errno_location();\n                error_message = strerror(*error_pointer);\n                __sprintf_chk(acStack_3024, 1, 0x3000, \"can't open or create %s: %s\", \"/var/run/crond.pid\", error_message);\n                __fprintf_chk(stderr, 1, \"%s: %s\\n\", ProgramName, acStack_3024);\n                current_pid = getpid();\n                FUN_00018530(&DAT_0001bbd8, current_pid, \"DEATH\", acStack_3024);\n                exit(1);\n            }\n            flock_result = flock(_DAT_0006dea8, LOCK_EX);\n            if (flock_result < 0) {\n                error_pointer = __errno_location();\n                int error_code = *error_pointer;\n                memset(acStack_3024, 0, 0x3000);\n                read_result = read(_DAT_0006dea8, acStack_3024, 0x2fff);\n                if (read_result < 1) {\n                    other_pid = -1;\n                } else {\n                    other_pid = __strtol_internal(acStack_3024, &local_buffer, 10, 0);\n                    if (other_pid > 0 && acStack_3024 != local_buffer && *local_buffer == '\\n' && other_pid != INT_MAX) {\n                        error_message = strerror(error_code);\n                        __sprintf_chk(acStack_3024, 1, 0x3000, \"can't lock %s, otherpid may be %ld: %s\", \"/var/run/crond.pid\", other_pid, error_message);\n                        goto error_handling;\n                    }\n                }\n                error_message = strerror(error_code);\n                __sprintf_chk(acStack_3024, 1, 0x3000, \"can't lock %s, otherpid unknown: %s\", \"/var/run/crond.pid\", error_message);\n            error_handling:\n                error_message = strerror(error_code);\n                __sprintf_chk(acStack_3024, 1, 0x3000, \"can't lock %s, otherpid may be %ld: %s\", \"/var/run/crond.pid\", other_pid, error_message);\n                __fprintf_chk(stderr, 1, \"%s: %s\\n\", ProgramName, acStack_3024);\n                current_pid = getpid();\n                FUN_00018530(&DAT_0001bbd8, current_pid, \"DEATH\", acStack_3024);\n                exit(1);\n            }\n            fchmod(_DAT_0006dea8, 0x1a4);\n            fcntl(_DAT_0006dea8, F_SETFD, FD_CLOEXEC);\n        }\n        \n        current_pid = getpid();\n        __sprintf_chk(acStack_3024, 1, 0x3000, \"%ld\\n\", current_pid);\n        lseek(_DAT_0006dea8, 0, SEEK_SET);\n        write_length = strlen(acStack_3024);\n        bytes_written = write(_DAT_0006dea8, acStack_3024, write_length);\n        \n        if (write_length == bytes_written) {\n            flock_result = ftruncate(_DAT_0006dea8, write_length);\n            if (flock_result == -1) {\n                current_pid = getpid();\n                error_pointer = __errno_location();\n                error_message = strerror(*error_pointer);\n                FUN_00018530(&DAT_0001bbd8, current_pid, \"ftruncate() failed:\", error_message);\n            }\n        } else {\n            current_pid = getpid();\n            error_pointer = __errno_location();\n            error_message = strerror(*error_pointer);\n            FUN_00018530(&DAT_0001bbd8, current_pid, \"write() failed:\", error_message);\n        }\n    } else if (_DAT_0006dea8 != -1) {\n        close(_DAT_0006dea8);\n        _DAT_0006dea8 = -1;\n    }\n    \n    if (local_24 == *(int *)(unaff_r2 + -0x7008)) {\n        return;\n    }\n    \n    FUN_0001aef0();\n}\n```",
        "normed_func_sha256": "c3da76d1bdc1bc0cda3854b90611fd5bba1e2e96b17a9f29f352d9a865adc815",
        "source_code": "void\nacquire_daemonlock(int closeflag) {\n\tstatic int fd = -1;\n\tchar buf[3*MAX_FNAME];\n\tconst char *pidfile;\n\tchar *ep;\n\tlong otherpid=-1;\n\tssize_t num, len;\n\n\tif (closeflag) {\n\t\t/* close stashed fd for child so we don't leak it. */\n\t\tif (fd != -1) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (fd == -1) {\n\t\tpidfile = _PATH_CRON_PID;\n\t\t/* Initial mode is 0600 to prevent flock() race/DoS. */\n\t\tif ((fd = open(pidfile, O_RDWR|O_CREAT, 0600)) == -1) {\n\t\t\tsprintf(buf, \"can't open or create %s: %s\",\n\t\t\t\tpidfile, strerror(errno));\n\t\t\tfprintf(stderr, \"%s: %s\\n\", ProgramName, buf);\n\t\t\tlog_it(\"CRON\", getpid(), \"DEATH\", buf);\n\t\t\texit(ERROR_EXIT);\n\t\t}\n\n\t\tif (flock(fd, LOCK_EX|LOCK_NB) < OK) {\n\t\t\tint save_errno = errno;\n\n\t\t\tbzero(buf, sizeof(buf));\n\t\t\tif ((num = read(fd, buf, sizeof(buf) - 1)) > 0 &&\n\t\t\t    (otherpid = strtol(buf, &ep, 10)) > 0 &&\n\t\t\t    ep != buf && *ep == '\\n' && otherpid != LONG_MAX) {\n\t\t\t\tsprintf(buf,\n\t\t\t\t    \"can't lock %s, otherpid may be %ld: %s\",\n\t\t\t\t    pidfile, otherpid, strerror(save_errno));\n\t\t\t} else {\n\t\t\t\tsprintf(buf,\n\t\t\t\t    \"can't lock %s, otherpid unknown: %s\",\n\t\t\t\t    pidfile, strerror(save_errno));\n\t\t\t}\n\t\t\tsprintf(buf, \"can't lock %s, otherpid may be %ld: %s\",\n\t\t\t\tpidfile, otherpid, strerror(save_errno));\n\t\t\tfprintf(stderr, \"%s: %s\\n\", ProgramName, buf);\n\t\t\tlog_it(\"CRON\", getpid(), \"DEATH\", buf);\n\t\t\texit(ERROR_EXIT);\n\t\t}\n\t\t(void) fchmod(fd, 0644);\n\t\t(void) fcntl(fd, F_SETFD, 1);\n\t}\n\n\tsprintf(buf, \"%ld\\n\", (long)getpid());\n\t(void) lseek(fd, (off_t)0, SEEK_SET);\n\tlen =  strlen(buf);\n\tif( (num = write(fd, buf, len)) != len )\n\t    log_it(\"CRON\", getpid(), \"write() failed:\", strerror(errno));\n\telse\n\t{\t    \n\t    if( ftruncate(fd, num) == -1 )\n\t\tlog_it(\"CRON\", getpid(), \"ftruncate() failed:\", strerror(errno));\n\t}\n\n\t/* abandon fd even though the file is open. we need to keep\n\t * it open and locked, but we don't need the handles elsewhere.\n\t */\n}",
        "parsed_output": "void FUN_00018ca0(int param_1)\n{\n    int unaff_r2;\n    __pid_t current_pid;\n    size_t write_length;\n    size_t bytes_written;\n    int *error_pointer;\n    char *error_message;\n    int flock_result;\n    ssize_t read_result;\n    int other_pid;\n    char *local_buffer;\n    char acStack_3024[12288];\n    int local_24;\n\n    local_24 = *(int *)(unaff_r2 + -0x7008);\n    \n    if (param_1 == 0) {\n        if (_DAT_0006dea8 == -1) {\n            _DAT_0006dea8 = open(\"/var/run/crond.pid\", O_CREAT | O_RDWR, 0x180);\n            if (_DAT_0006dea8 == -1) {\n                error_pointer = __errno_location();\n                error_message = strerror(*error_pointer);\n                __sprintf_chk(acStack_3024, 1, 0x3000, \"can't open or create %s: %s\", \"/var/run/crond.pid\", error_message);\n                __fprintf_chk(stderr, 1, \"%s: %s\\n\", ProgramName, acStack_3024);\n                current_pid = getpid();\n                FUN_00018530(&DAT_0001bbd8, current_pid, \"DEATH\", acStack_3024);\n                exit(1);\n            }\n            flock_result = flock(_DAT_0006dea8, LOCK_EX);\n            if (flock_result < 0) {\n                error_pointer = __errno_location();\n                int error_code = *error_pointer;\n                memset(acStack_3024, 0, 0x3000);\n                read_result = read(_DAT_0006dea8, acStack_3024, 0x2fff);\n                if (read_result < 1) {\n                    other_pid = -1;\n                } else {\n                    other_pid = __strtol_internal(acStack_3024, &local_buffer, 10, 0);\n                    if (other_pid > 0 && acStack_3024 != local_buffer && *local_buffer == '\\n' && other_pid != INT_MAX) {\n                        error_message = strerror(error_code);\n                        __sprintf_chk(acStack_3024, 1, 0x3000, \"can't lock %s, otherpid may be %ld: %s\", \"/var/run/crond.pid\", other_pid, error_message);\n                        goto error_handling;\n                    }\n                }\n                error_message = strerror(error_code);\n                __sprintf_chk(acStack_3024, 1, 0x3000, \"can't lock %s, otherpid unknown: %s\", \"/var/run/crond.pid\", error_message);\n            error_handling:\n                error_message = strerror(error_code);\n                __sprintf_chk(acStack_3024, 1, 0x3000, \"can't lock %s, otherpid may be %ld: %s\", \"/var/run/crond.pid\", other_pid, error_message);\n                __fprintf_chk(stderr, 1, \"%s: %s\\n\", ProgramName, acStack_3024);\n                current_pid = getpid();\n                FUN_00018530(&DAT_0001bbd8, current_pid, \"DEATH\", acStack_3024);\n                exit(1);\n            }\n            fchmod(_DAT_0006dea8, 0x1a4);\n            fcntl(_DAT_0006dea8, F_SETFD, FD_CLOEXEC);\n        }\n        \n        current_pid = getpid();\n        __sprintf_chk(acStack_3024, 1, 0x3000, \"%ld\\n\", current_pid);\n        lseek(_DAT_0006dea8, 0, SEEK_SET);\n        write_length = strlen(acStack_3024);\n        bytes_written = write(_DAT_0006dea8, acStack_3024, write_length);\n        \n        if (write_length == bytes_written) {\n            flock_result = ftruncate(_DAT_0006dea8, write_length);\n            if (flock_result == -1) {\n                current_pid = getpid();\n                error_pointer = __errno_location();\n                error_message = strerror(*error_pointer);\n                FUN_00018530(&DAT_0001bbd8, current_pid, \"ftruncate() failed:\", error_message);\n            }\n        } else {\n            current_pid = getpid();\n            error_pointer = __errno_location();\n            error_message = strerror(*error_pointer);\n            FUN_00018530(&DAT_0001bbd8, current_pid, \"write() failed:\", error_message);\n        }\n    } else if (_DAT_0006dea8 != -1) {\n        close(_DAT_0006dea8);\n        _DAT_0006dea8 = -1;\n    }\n    \n    if (local_24 == *(int *)(unaff_r2 + -0x7008)) {\n        return;\n    }\n    \n    FUN_0001aef0();\n}",
        "baseline_code_stripped": "void FUN_00018ca0(int param_1)\n{\n  int unaff_r2;\n  __pid_t _Var1;\n  size_t __n;\n  size_t sVar2;\n  int *piVar3;\n  char *pcVar4;\n  int iVar5;\n  ssize_t sVar6;\n  int iVar7;\n  char *local_3028;\n  char acStack_3024 [12288];\n  int local_24;\n  local_24 = *(int *)(unaff_r2 + -0x7008);\n  if (param_1 == 0) {\n    if (_DAT_0006dea8 == -1) {\n      _DAT_0006dea8 = open(\"/var/run/crond.pid\",0x42,0x180);\n      if (_DAT_0006dea8 == -1) {\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t open or create %s: %s\",\"/var/run/crond.pid\",\n                      pcVar4);\n        __fprintf_chk(stderr,1,\"%s: %s\\n\",ProgramName,acStack_3024);\n        _Var1 = getpid();\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"DEATH\",acStack_3024);\n        exit(1);\n      }\n      iVar5 = flock(_DAT_0006dea8,6);\n      if (iVar5 < 0) {\n        piVar3 = __errno_location();\n        iVar5 = *piVar3;\n        memset(acStack_3024,0,0x3000);\n        sVar6 = read(_DAT_0006dea8,acStack_3024,0x2fff);\n        if (sVar6 < 1) {\n          iVar7 = -1;\n        }\n        else {\n          iVar7 = __strtol_internal(acStack_3024,&local_3028,10,0);\n          if ((((0 < iVar7) && (acStack_3024 != local_3028)) && (*local_3028 == '\\n')) &&\n             (iVar7 != 0x7fffffff)) {\n            pcVar4 = strerror(iVar5);\n            __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid may be %ld: %s\",\n                          \"/var/run/crond.pid\",iVar7,pcVar4);\n            goto LAB_00018f18;\n          }\n        }\n        pcVar4 = strerror(iVar5);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid unknown: %s\",\n                      \"/var/run/crond.pid\",pcVar4);\nLAB_00018f18:\n        pcVar4 = strerror(iVar5);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid may be %ld: %s\",\n                      \"/var/run/crond.pid\",iVar7,pcVar4);\n        __fprintf_chk(stderr,1,\"%s: %s\\n\",ProgramName,acStack_3024);\n        _Var1 = getpid();\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"DEATH\",acStack_3024);\n        exit(1);\n      }\n      fchmod(_DAT_0006dea8,0x1a4);\n      fcntl(_DAT_0006dea8,2,1);\n    }\n    _Var1 = getpid();\n    __sprintf_chk(acStack_3024,1,0x3000,\"%ld\\n\",_Var1);\n    lseek(_DAT_0006dea8,0,0);\n    __n = strlen(acStack_3024);\n    sVar2 = write(_DAT_0006dea8,acStack_3024,__n);\n    if (__n == sVar2) {\n      iVar5 = ftruncate(_DAT_0006dea8,__n);\n      if (iVar5 == -1) {\n        _Var1 = getpid();\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"ftruncate() failed:\",pcVar4);\n      }\n    }\n    else {\n      _Var1 = getpid();\n      piVar3 = __errno_location();\n      pcVar4 = strerror(*piVar3);\n      FUN_00018530(&DAT_0001bbd8,_Var1,\"write() failed:\",pcVar4);\n    }\n  }\n  else if (_DAT_0006dea8 != -1) {\n    close(_DAT_0006dea8);\n    _DAT_0006dea8 = -1;\n  }\n  if (local_24 == *(int *)(unaff_r2 + -0x7008)) {\n    return;\n  }\n  FUN_0001aef0();\n}",
        "similarity_score_unixcoder": 0.7875388860702515,
        "similarity_score_baseline_stripped": 0.7211880683898926
    },
    {
        "func_name": "internal_create_group",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __regparm3 internal_create_group(undefined4 *param_1,int param_2,int *param_3)\n{\n  code *pcVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int *piVar5;\n  int local_18;\n  int *local_14;\n  if (param_1 != (undefined4 *)0x0) {\n    if (param_2 == 0) {\n      if (param_1[6] == 0) goto LAB_810c21d9;\n    }\n    else if (param_1[6] == 0) {\n      return -0x16;\n    }\n    if (param_3[2] == 0) {\n      pcVar1 = (code *)0x0;\n      if (*param_3 != 0) {\n        pcVar1 = FUN_8133905c;\n      }\n      warn_slowpath_fmt(\"/home/build/workspace/bst/contrib/kitkat/kernel/fs/sysfs/group.c\",0x48,\n                        \"sysfs: attrs not set by subsystem for group: %s/%s\\n\",*param_1,pcVar1);\n      return -0x16;\n    }\n    if (*param_3 == 0) {\n      local_14 = (int *)param_1[6];\n    }\n    else {\n      iVar2 = sysfs_create_subdir();\n      if (iVar2 != 0) {\n        return iVar2;\n      }\n    }\n    if (local_14 != (int *)0x0) {\n      if (*local_14 == 0) {\n        warn_slowpath_null();\n      }\n      *local_14 = *local_14 + 1;\n    }\n    local_18 = 0;\n    iVar2 = param_3[2];\n    piVar5 = local_14;\n    do {\n      if (*(int *)(iVar2 + local_18 * 4) == 0) {\n        iVar4 = 0;\nLAB_810c22ed:\n        if (local_14 == (int *)0x0) {\n          return iVar4;\n        }\n        *local_14 = *local_14 + -1;\n        if (*local_14 == 0) {\n          release_sysfs_dirent();\n          return iVar4;\n        }\n        return iVar4;\n      }\n      if (param_2 != 0) {\n        sysfs_hash_and_remove(param_2,iVar2,piVar5);\n      }\n      if ((code *)param_3[1] == (code *)0x0) {\n        uVar3 = 0;\nLAB_810c22b3:\n        iVar4 = sysfs_add_file_mode((uVar3 | *(uint *)(*(int *)(iVar2 + local_18 * 4) + 4)) & 0xffff\n                                   );\n        if (iVar4 != 0) {\n          for (piVar5 = (int *)param_3[2]; *piVar5 != 0; piVar5 = piVar5 + 1) {\n            sysfs_hash_and_remove();\n          }\n          if (*param_3 != 0) {\n            sysfs_remove_subdir();\n          }\n          goto LAB_810c22ed;\n        }\n      }\n      else {\n        uVar3 = (*(code *)param_3[1])();\n        if ((short)uVar3 != 0) goto LAB_810c22b3;\n      }\n      local_18 = local_18 + 1;\n    } while( true );\n  }\nLAB_810c21d9:\n  hd_UnplugBug();\n}",
        "output": "```c\nint internal_create_group(undefined4 *group_attributes, int flag, int *attribute_count) {\n    code *function_pointer;\n    int return_value;\n    uint mode_flags;\n    int index;\n    int *local_reference;\n    int local_counter;\n\n    if (group_attributes != NULL) {\n        if (flag == 0) {\n            if (group_attributes[6] == 0) {\n                goto handle_no_attributes;\n            }\n        } else if (group_attributes[6] == 0) {\n            return -0x16; // Error: attributes not set\n        }\n\n        if (attribute_count[2] == 0) {\n            function_pointer = NULL;\n            if (*attribute_count != 0) {\n                function_pointer = FUN_8133905c;\n            }\n            warn_slowpath_fmt(\"/home/build/workspace/bst/contrib/kitkat/kernel/fs/sysfs/group.c\", 0x48,\n                              \"sysfs: attrs not set by subsystem for group: %s/%s\\n\", *group_attributes, function_pointer);\n            return -0x16; // Error: attributes not set\n        }\n\n        if (*attribute_count == 0) {\n            local_reference = (int *)group_attributes[6];\n        } else {\n            return_value = sysfs_create_subdir();\n            if (return_value != 0) {\n                return return_value;\n            }\n        }\n\n        if (local_reference != NULL) {\n            if (*local_reference == 0) {\n                warn_slowpath_null();\n            }\n            *local_reference += 1;\n        }\n\n        local_counter = 0;\n        index = attribute_count[2];\n        int *current_reference = local_reference;\n\n        while (true) {\n            if (*(int *)(index + local_counter * 4) == 0) {\n                return_value = 0;\n                goto cleanup;\n            }\n\n            if (flag != 0) {\n                sysfs_hash_and_remove(flag, index, current_reference);\n            }\n\n            if ((code *)attribute_count[1] == NULL) {\n                mode_flags = 0;\n            } else {\n                mode_flags = (*(code *)attribute_count[1])();\n                if ((short)mode_flags != 0) {\n                    goto add_file_mode;\n                }\n            }\n\n            return_value = sysfs_add_file_mode((mode_flags | *(uint *)(*(int *)(index + local_counter * 4) + 4)) & 0xffff);\n            if (return_value != 0) {\n                for (current_reference = (int *)attribute_count[2]; *current_reference != 0; current_reference++) {\n                    sysfs_hash_and_remove();\n                }\n                if (*attribute_count != 0) {\n                    sysfs_remove_subdir();\n                }\n                goto cleanup;\n            }\n\n        add_file_mode:\n            local_counter++;\n        }\n    }\n\nhandle_no_attributes:\n    hd_UnplugBug();\n    return 0;\n\ncleanup:\n    if (local_reference != NULL) {\n        *local_reference -= 1;\n        if (*local_reference == 0) {\n            release_sysfs_dirent();\n        }\n    }\n    return return_value;\n}\n```",
        "normed_func_sha256": "39c901c2821d92209b8a3feade424fc15546c62547061722998ec1192813d077",
        "source_code": "static int internal_create_group(struct kobject *kobj, int update,\n\t\t\t\t const struct attribute_group *grp)\n{\n\tstruct sysfs_dirent *sd;\n\tint error;\n\n\tBUG_ON(!kobj || (!update && !kobj->sd));\n\n\t/* Updates may happen before the object has been instantiated */\n\tif (unlikely(update && !kobj->sd))\n\t\treturn -EINVAL;\n\tif (!grp->attrs) {\n\t\tWARN(1, \"sysfs: attrs not set by subsystem for group: %s/%s\\n\",\n\t\t\tkobj->name, grp->name ? \"\" : grp->name);\n\t\treturn -EINVAL;\n\t}\n\tif (grp->name) {\n\t\terror = sysfs_create_subdir(kobj, grp->name, &sd);\n\t\tif (error)\n\t\t\treturn error;\n\t} else\n\t\tsd = kobj->sd;\n\tsysfs_get(sd);\n\terror = create_files(sd, kobj, grp, update);\n\tif (error) {\n\t\tif (grp->name)\n\t\t\tsysfs_remove_subdir(sd);\n\t}\n\tsysfs_put(sd);\n\treturn error;\n}",
        "parsed_output": "int internal_create_group(undefined4 *group_attributes, int flag, int *attribute_count) {\n    code *function_pointer;\n    int return_value;\n    uint mode_flags;\n    int index;\n    int *local_reference;\n    int local_counter;\n\n    if (group_attributes != NULL) {\n        if (flag == 0) {\n            if (group_attributes[6] == 0) {\n                goto handle_no_attributes;\n            }\n        } else if (group_attributes[6] == 0) {\n            return -0x16; // Error: attributes not set\n        }\n\n        if (attribute_count[2] == 0) {\n            function_pointer = NULL;\n            if (*attribute_count != 0) {\n                function_pointer = FUN_8133905c;\n            }\n            warn_slowpath_fmt(\"/home/build/workspace/bst/contrib/kitkat/kernel/fs/sysfs/group.c\", 0x48,\n                              \"sysfs: attrs not set by subsystem for group: %s/%s\\n\", *group_attributes, function_pointer);\n            return -0x16; // Error: attributes not set\n        }\n\n        if (*attribute_count == 0) {\n            local_reference = (int *)group_attributes[6];\n        } else {\n            return_value = sysfs_create_subdir();\n            if (return_value != 0) {\n                return return_value;\n            }\n        }\n\n        if (local_reference != NULL) {\n            if (*local_reference == 0) {\n                warn_slowpath_null();\n            }\n            *local_reference += 1;\n        }\n\n        local_counter = 0;\n        index = attribute_count[2];\n        int *current_reference = local_reference;\n\n        while (true) {\n            if (*(int *)(index + local_counter * 4) == 0) {\n                return_value = 0;\n                goto cleanup;\n            }\n\n            if (flag != 0) {\n                sysfs_hash_and_remove(flag, index, current_reference);\n            }\n\n            if ((code *)attribute_count[1] == NULL) {\n                mode_flags = 0;\n            } else {\n                mode_flags = (*(code *)attribute_count[1])();\n                if ((short)mode_flags != 0) {\n                    goto add_file_mode;\n                }\n            }\n\n            return_value = sysfs_add_file_mode((mode_flags | *(uint *)(*(int *)(index + local_counter * 4) + 4)) & 0xffff);\n            if (return_value != 0) {\n                for (current_reference = (int *)attribute_count[2]; *current_reference != 0; current_reference++) {\n                    sysfs_hash_and_remove();\n                }\n                if (*attribute_count != 0) {\n                    sysfs_remove_subdir();\n                }\n                goto cleanup;\n            }\n\n        add_file_mode:\n            local_counter++;\n        }\n    }\n\nhandle_no_attributes:\n    hd_UnplugBug();\n    return 0;\n\ncleanup:\n    if (local_reference != NULL) {\n        *local_reference -= 1;\n        if (*local_reference == 0) {\n            release_sysfs_dirent();\n        }\n    }\n    return return_value;\n}",
        "baseline_code_stripped": "int __regparm3 internal_create_group(undefined4 *param_1,int param_2,int *param_3)\n{\n  code *pcVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int *piVar5;\n  int local_18;\n  int *local_14;\n  if (param_1 != (undefined4 *)0x0) {\n    if (param_2 == 0) {\n      if (param_1[6] == 0) goto LAB_810c21d9;\n    }\n    else if (param_1[6] == 0) {\n      return -0x16;\n    }\n    if (param_3[2] == 0) {\n      pcVar1 = (code *)0x0;\n      if (*param_3 != 0) {\n        pcVar1 = FUN_8133905c;\n      }\n      warn_slowpath_fmt(\"/home/build/workspace/bst/contrib/kitkat/kernel/fs/sysfs/group.c\",0x48,\n                        \"sysfs: attrs not set by subsystem for group: %s/%s\\n\",*param_1,pcVar1);\n      return -0x16;\n    }\n    if (*param_3 == 0) {\n      local_14 = (int *)param_1[6];\n    }\n    else {\n      iVar2 = sysfs_create_subdir();\n      if (iVar2 != 0) {\n        return iVar2;\n      }\n    }\n    if (local_14 != (int *)0x0) {\n      if (*local_14 == 0) {\n        warn_slowpath_null();\n      }\n      *local_14 = *local_14 + 1;\n    }\n    local_18 = 0;\n    iVar2 = param_3[2];\n    piVar5 = local_14;\n    do {\n      if (*(int *)(iVar2 + local_18 * 4) == 0) {\n        iVar4 = 0;\nLAB_810c22ed:\n        if (local_14 == (int *)0x0) {\n          return iVar4;\n        }\n        *local_14 = *local_14 + -1;\n        if (*local_14 == 0) {\n          release_sysfs_dirent();\n          return iVar4;\n        }\n        return iVar4;\n      }\n      if (param_2 != 0) {\n        sysfs_hash_and_remove(param_2,iVar2,piVar5);\n      }\n      if ((code *)param_3[1] == (code *)0x0) {\n        uVar3 = 0;\nLAB_810c22b3:\n        iVar4 = sysfs_add_file_mode((uVar3 | *(uint *)(*(int *)(iVar2 + local_18 * 4) + 4)) & 0xffff\n                                   );\n        if (iVar4 != 0) {\n          for (piVar5 = (int *)param_3[2]; *piVar5 != 0; piVar5 = piVar5 + 1) {\n            sysfs_hash_and_remove();\n          }\n          if (*param_3 != 0) {\n            sysfs_remove_subdir();\n          }\n          goto LAB_810c22ed;\n        }\n      }\n      else {\n        uVar3 = (*(code *)param_3[1])();\n        if ((short)uVar3 != 0) goto LAB_810c22b3;\n      }\n      local_18 = local_18 + 1;\n    } while( true );\n  }\nLAB_810c21d9:\n  hd_UnplugBug();\n}",
        "similarity_score_unixcoder": 0.6849727630615234,
        "similarity_score_baseline_stripped": 0.596930742263794
    },
    {
        "func_name": "s_forward",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nXY s_forward(LP lp,PJ_conflict56 *P)\n{\n  undefined8 extraout_RAX;\n  undefined8 uVar1;\n  undefined8 extraout_RAX_00;\n  undefined8 extraout_RDX;\n  undefined8 uVar2;\n  undefined8 extraout_RDX_00;\n  int iVar3;\n  double dVar4;\n  double p;\n  double dVar5;\n  double dVar6;\n  double dVar7;\n  double in_XMM1_Qa;\n  double dVar8;\n  double V;\n  double dVar9;\n  double r;\n  XY XVar10;\n  iVar3 = 10;\n  dVar4 = sin(in_XMM1_Qa);\n  dVar7 = P->B;\n  dVar8 = in_XMM1_Qa * 1.10265779;\n  while( true ) {\n    dVar5 = dVar8 * dVar8 + 1.0;\n    dVar9 = SQRT(dVar5);\n    if (dVar5 < 0.0) {\n      sqrt(dVar5);\n    }\n    dVar5 = P->A;\n    dVar6 = log(dVar9 + dVar8);\n    dVar5 = (((dVar5 - dVar9) * dVar8 - dVar6) - dVar4 * dVar7) / (P->A - (dVar9 + dVar9));\n    dVar8 = dVar8 - dVar5;\n    uVar1 = extraout_RAX;\n    uVar2 = extraout_RDX;\n    if ((double)((ulong)dVar5 & 0x7fffffffffffffff) < 1e-10) break;\n    iVar3 = iVar3 + -1;\n    if (iVar3 == 0) {\nLAB_0042e78a:\n      XVar10.y = (double)uVar2;\n      XVar10.x = (double)uVar1;\n      return XVar10;\n    }\n  }\n  dVar7 = dVar8 * dVar8 + 1.0;\n  if (dVar7 < 0.0) {\n    sqrt(dVar7);\n    uVar1 = extraout_RAX_00;\n    uVar2 = extraout_RDX_00;\n  }\n  goto LAB_0042e78a;\n}",
        "output": "```c\nXY s_forward(LP lp, PJ_conflict56 *P) {\n    int iteration_count = 10;\n    double sin_value = sin(in_XMM1_Qa);\n    double B_value = P->B;\n    double adjusted_input = in_XMM1_Qa * 1.10265779;\n    double adjustment;\n\n    while (true) {\n        double squared_adjusted_input = adjusted_input * adjusted_input + 1.0;\n        double sqrt_value = SQRT(squared_adjusted_input);\n\n        if (squared_adjusted_input < 0.0) {\n            sqrt(squared_adjusted_input);\n        }\n\n        double A_value = P->A;\n        double log_value = log(sqrt_value + adjusted_input);\n        adjustment = (((A_value - sqrt_value) * adjusted_input - log_value) - sin_value * B_value) / (A_value - (sqrt_value + sqrt_value));\n        adjusted_input -= adjustment;\n\n        if ((double)((ulong)adjustment & 0x7fffffffffffffff) < 1e-10) {\n            break;\n        }\n\n        iteration_count--;\n        if (iteration_count == 0) {\n            XY result;\n            result.y = (double)extraout_RDX;\n            result.x = (double)extraout_RAX;\n            return result;\n        }\n    }\n\n    double final_squared_value = adjusted_input * adjusted_input + 1.0;\n    if (final_squared_value < 0.0) {\n        sqrt(final_squared_value);\n    }\n\n    XY result;\n    result.y = (double)extraout_RDX_00;\n    result.x = (double)extraout_RAX_00;\n    return result;\n}\n```",
        "normed_func_sha256": "ee40c9a65acefd1731e6e43be0d81616867d5c1c4935994809e8e5b6e1c25fee",
        "source_code": "static PJ_XY s_forward (PJ_LP lp, PJ *P) {           /* Spheroidal, forward */\n    PJ_XY xy = {0.0,0.0};\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(P->opaque);\n    double p, r, V;\n    int i;\n\n    p = Q->B * sin(lp.phi);\n    lp.phi *=  1.10265779;\n    for (i = NITER; i ; --i) {\n        r = sqrt(1. + lp.phi * lp.phi);\n        lp.phi -= V = ( (Q->A - r) * lp.phi - log(lp.phi + r) - p ) /\n            (Q->A - 2. * r);\n        if (fabs(V) < EPS)\n            break;\n    }\n    if (!i)\n        lp.phi = p < 0. ? -CON_POLE : CON_POLE;\n    xy.x = Q->C_x * lp.lam * (Q->D - sqrt(1. + lp.phi * lp.phi));\n    xy.y = Q->C_y * lp.phi;\n\n    return xy;\n}",
        "parsed_output": "XY s_forward(LP lp, PJ_conflict56 *P) {\n    int iteration_count = 10;\n    double sin_value = sin(in_XMM1_Qa);\n    double B_value = P->B;\n    double adjusted_input = in_XMM1_Qa * 1.10265779;\n    double adjustment;\n\n    while (true) {\n        double squared_adjusted_input = adjusted_input * adjusted_input + 1.0;\n        double sqrt_value = SQRT(squared_adjusted_input);\n\n        if (squared_adjusted_input < 0.0) {\n            sqrt(squared_adjusted_input);\n        }\n\n        double A_value = P->A;\n        double log_value = log(sqrt_value + adjusted_input);\n        adjustment = (((A_value - sqrt_value) * adjusted_input - log_value) - sin_value * B_value) / (A_value - (sqrt_value + sqrt_value));\n        adjusted_input -= adjustment;\n\n        if ((double)((ulong)adjustment & 0x7fffffffffffffff) < 1e-10) {\n            break;\n        }\n\n        iteration_count--;\n        if (iteration_count == 0) {\n            XY result;\n            result.y = (double)extraout_RDX;\n            result.x = (double)extraout_RAX;\n            return result;\n        }\n    }\n\n    double final_squared_value = adjusted_input * adjusted_input + 1.0;\n    if (final_squared_value < 0.0) {\n        sqrt(final_squared_value);\n    }\n\n    XY result;\n    result.y = (double)extraout_RDX_00;\n    result.x = (double)extraout_RAX_00;\n    return result;\n}",
        "baseline_code_stripped": "XY s_forward(LP lp,PJ_conflict56 *P)\n{\n  undefined8 extraout_RAX;\n  undefined8 uVar1;\n  undefined8 extraout_RAX_00;\n  undefined8 extraout_RDX;\n  undefined8 uVar2;\n  undefined8 extraout_RDX_00;\n  int iVar3;\n  double dVar4;\n  double p;\n  double dVar5;\n  double dVar6;\n  double dVar7;\n  double in_XMM1_Qa;\n  double dVar8;\n  double V;\n  double dVar9;\n  double r;\n  XY XVar10;\n  iVar3 = 10;\n  dVar4 = sin(in_XMM1_Qa);\n  dVar7 = P->B;\n  dVar8 = in_XMM1_Qa * 1.10265779;\n  while( true ) {\n    dVar5 = dVar8 * dVar8 + 1.0;\n    dVar9 = SQRT(dVar5);\n    if (dVar5 < 0.0) {\n      sqrt(dVar5);\n    }\n    dVar5 = P->A;\n    dVar6 = log(dVar9 + dVar8);\n    dVar5 = (((dVar5 - dVar9) * dVar8 - dVar6) - dVar4 * dVar7) / (P->A - (dVar9 + dVar9));\n    dVar8 = dVar8 - dVar5;\n    uVar1 = extraout_RAX;\n    uVar2 = extraout_RDX;\n    if ((double)((ulong)dVar5 & 0x7fffffffffffffff) < 1e-10) break;\n    iVar3 = iVar3 + -1;\n    if (iVar3 == 0) {\nLAB_0042e78a:\n      XVar10.y = (double)uVar2;\n      XVar10.x = (double)uVar1;\n      return XVar10;\n    }\n  }\n  dVar7 = dVar8 * dVar8 + 1.0;\n  if (dVar7 < 0.0) {\n    sqrt(dVar7);\n    uVar1 = extraout_RAX_00;\n    uVar2 = extraout_RDX_00;\n  }\n  goto LAB_0042e78a;\n}",
        "similarity_score_unixcoder": 0.7254610061645508,
        "similarity_score_baseline_stripped": 0.5989173650741577
    },
    {
        "func_name": "height",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nulong WebCore::jsImageData_height(JSGlobalObject *param_1,long param_2,PropertyName param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(long *)(param_2 + 0x18) + 8);\n  if (-1 < (int)uVar1) {\n    return (long)(int)uVar1 | 0xfffe000000000000;\n  }\n  return (long)(double)(ulong)uVar1 + 0x2000000000000;\n}",
        "output": "```c\nulong WebCore::jsImageData_height(JSGlobalObject *globalObject, long imageDataPtr, PropertyName propertyName)\n{\n    uint height = *(uint *)(*(long *)(imageDataPtr + 0x18) + 8);\n    \n    if (height >= 0) {\n        return (long)(int)height | 0xfffe000000000000;\n    }\n    \n    return (long)(double)(ulong)height + 0x2000000000000;\n}\n```",
        "normed_func_sha256": "5d1f9df4664c91cd46d2740d85bdb4ef00d7987182ef1c16a6786e34bc2c586d",
        "source_code": "constexpr int height() const { return m_height; }",
        "parsed_output": "ulong WebCore::jsImageData_height(JSGlobalObject *globalObject, long imageDataPtr, PropertyName propertyName)\n{\n    uint height = *(uint *)(*(long *)(imageDataPtr + 0x18) + 8);\n    \n    if (height >= 0) {\n        return (long)(int)height | 0xfffe000000000000;\n    }\n    \n    return (long)(double)(ulong)height + 0x2000000000000;\n}",
        "baseline_code_stripped": "ulong WebCore::jsImageData_height(JSGlobalObject *param_1,long param_2,PropertyName param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(long *)(param_2 + 0x18) + 8);\n  if (-1 < (int)uVar1) {\n    return (long)(int)uVar1 | 0xfffe000000000000;\n  }\n  return (long)(double)(ulong)uVar1 + 0x2000000000000;\n}",
        "similarity_score_unixcoder": 0.5661007761955261,
        "similarity_score_baseline_stripped": 0.5196183323860168
    },
    {
        "func_name": "Sbk_QImageCaptureFunc_captureSession",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint * FUN_00043be8(_object *param_1)\n{\n  int iVar1;\n  void *pvVar2;\n  int *piVar3;\n  iVar1 = Shiboken::Object::isValid(param_1);\n  if (iVar1 != 0) {\n    Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_000a4c00 + 0x74),(SbkObject *)param_1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      pvVar2 = (void *)QImageCapture::captureSession();\n      piVar3 = (int *)Shiboken::Conversions::pointerToPython\n                                (*(_typeobject **)(DAT_000a4c00 + 0x84),pvVar2);\n      Shiboken::Object::setParent(param_1,(_object *)piVar3);\n      iVar1 = PyErr_Occurred();\n      if (iVar1 == 0) {\n        return piVar3;\n      }\n      if ((piVar3 != (int *)0x0) && (iVar1 = *piVar3, *piVar3 = iVar1 + -1, iVar1 + -1 == 0)) {\n        _Py_Dealloc(piVar3);\n      }\n    }\n    else {\n      PyErr_Occurred();\n    }\n  }\n  return (int *)0x0;\n}",
        "output": "```c\nint * FUN_00043be8(_object *param_1)\n{\n    int isValid;\n    void *captureSession;\n    int *pythonPointer;\n\n    isValid = Shiboken::Object::isValid(param_1);\n    if (isValid != 0) {\n        Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_000a4c00 + 0x74), (SbkObject *)param_1);\n        isValid = PyErr_Occurred();\n        \n        if (isValid == 0) {\n            captureSession = (void *)QImageCapture::captureSession();\n            pythonPointer = (int *)Shiboken::Conversions::pointerToPython(*(_typeobject **)(DAT_000a4c00 + 0x84), captureSession);\n            Shiboken::Object::setParent(param_1, (_object *)pythonPointer);\n            isValid = PyErr_Occurred();\n            \n            if (isValid == 0) {\n                return pythonPointer;\n            }\n            \n            if ((pythonPointer != (int *)0x0) && (isValid = *pythonPointer, *pythonPointer = isValid - 1, isValid - 1 == 0)) {\n                _Py_Dealloc(pythonPointer);\n            }\n        } else {\n            PyErr_Occurred();\n        }\n    }\n    \n    return (int *)0x0;\n}\n```",
        "normed_func_sha256": "3a8a92028ce3d53e3ec4fb73e267768b0a429ed5dd2ebb4956cf541cd1f1b84c",
        "source_code": "static PyObject *Sbk_QImageCaptureFunc_captureSession(PyObject *self)\n{\n    if (!Shiboken::Object::isValid(self))\n        return {};\n    auto *cppSelf = reinterpret_cast< ::QImageCapture *>(Shiboken::Conversions::cppPointer(SbkPySide6_QtMultimediaTypes[SBK_QIMAGECAPTURE_IDX], reinterpret_cast<SbkObject *>(self)));\n    SBK_UNUSED(cppSelf)\n    PyObject *pyResult{};\n\n    // Call function/method\n    {\n\n        if (!PyErr_Occurred()) {\n            // captureSession()const\n            QMediaCaptureSession * cppResult = const_cast<const ::QImageCapture *>(cppSelf)->captureSession();\n            pyResult = Shiboken::Conversions::pointerToPython(SbkPySide6_QtMultimediaTypes[SBK_QMEDIACAPTURESESSION_IDX], cppResult);\n            // Ownership transferences (return value heuristics).\n            Shiboken::Object::setParent(self, pyResult);\n        }\n    }\n\n    if (PyErr_Occurred() || !pyResult) {\n        Py_XDECREF(pyResult);\n        return {};\n    }\n    return pyResult;\n}",
        "parsed_output": "int * FUN_00043be8(_object *param_1)\n{\n    int isValid;\n    void *captureSession;\n    int *pythonPointer;\n\n    isValid = Shiboken::Object::isValid(param_1);\n    if (isValid != 0) {\n        Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_000a4c00 + 0x74), (SbkObject *)param_1);\n        isValid = PyErr_Occurred();\n        \n        if (isValid == 0) {\n            captureSession = (void *)QImageCapture::captureSession();\n            pythonPointer = (int *)Shiboken::Conversions::pointerToPython(*(_typeobject **)(DAT_000a4c00 + 0x84), captureSession);\n            Shiboken::Object::setParent(param_1, (_object *)pythonPointer);\n            isValid = PyErr_Occurred();\n            \n            if (isValid == 0) {\n                return pythonPointer;\n            }\n            \n            if ((pythonPointer != (int *)0x0) && (isValid = *pythonPointer, *pythonPointer = isValid - 1, isValid - 1 == 0)) {\n                _Py_Dealloc(pythonPointer);\n            }\n        } else {\n            PyErr_Occurred();\n        }\n    }\n    \n    return (int *)0x0;\n}",
        "baseline_code_stripped": "int * FUN_00043be8(_object *param_1)\n{\n  int iVar1;\n  void *pvVar2;\n  int *piVar3;\n  iVar1 = Shiboken::Object::isValid(param_1);\n  if (iVar1 != 0) {\n    Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_000a4c00 + 0x74),(SbkObject *)param_1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      pvVar2 = (void *)QImageCapture::captureSession();\n      piVar3 = (int *)Shiboken::Conversions::pointerToPython\n                                (*(_typeobject **)(DAT_000a4c00 + 0x84),pvVar2);\n      Shiboken::Object::setParent(param_1,(_object *)piVar3);\n      iVar1 = PyErr_Occurred();\n      if (iVar1 == 0) {\n        return piVar3;\n      }\n      if ((piVar3 != (int *)0x0) && (iVar1 = *piVar3, *piVar3 = iVar1 + -1, iVar1 + -1 == 0)) {\n        _Py_Dealloc(piVar3);\n      }\n    }\n    else {\n      PyErr_Occurred();\n    }\n  }\n  return (int *)0x0;\n}",
        "similarity_score_unixcoder": 0.7659510970115662,
        "similarity_score_baseline_stripped": 0.6691700220108032
    },
    {
        "func_name": "WLog_JournaldAppender_Open",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_0016bd00(long param_1,long param_2)\n{\n  undefined8 uVar1;\n  if ((param_1 != 0) && (param_2 != 0)) {\n    if (*(long *)(param_2 + 0xa8) != 0) {\n      return 1;\n    }\n    uVar1 = FUN_0016bc90(param_2);\n    return uVar1;\n  }\n  return 0;\n}",
        "output": "```c\nuint64_t check_parameters(long param_1, long param_2) {\n    if (param_1 != 0 && param_2 != 0) {\n        if (*(long *)(param_2 + 0xa8) != 0) {\n            return 1;\n        }\n        return FUN_0016bc90(param_2);\n    }\n    return 0;\n}\n```",
        "normed_func_sha256": "1dd3e8d936cbafc5f6816d19b94ec94c1cf2886c2b6ac4bc194ccf21c23464fc",
        "source_code": "static BOOL WLog_JournaldAppender_Open(wLog* log, wLogAppender* appender)\n{\n\tint fd;\n\twLogJournaldAppender *journaldAppender;\n\n\tif (!log || !appender)\n\t\treturn FALSE;\n\n\tjournaldAppender = (wLogJournaldAppender*)appender;\n\tif (journaldAppender->stream)\n\t\treturn TRUE;\n\n\tfd = sd_journal_stream_fd(journaldAppender->identifier, LOG_INFO, 1);\n\tif (fd < 0)\n\t\treturn FALSE;\n\n\tjournaldAppender->stream = fdopen(fd, \"w\");\n\tif (!journaldAppender->stream)\n\t{\n\t\tclose(fd);\n\t\treturn FALSE;\n\t}\n\n\tsetbuffer(journaldAppender->stream, NULL, 0);\n\treturn TRUE;\n}",
        "parsed_output": "uint64_t check_parameters(long param_1, long param_2) {\n    if (param_1 != 0 && param_2 != 0) {\n        if (*(long *)(param_2 + 0xa8) != 0) {\n            return 1;\n        }\n        return FUN_0016bc90(param_2);\n    }\n    return 0;\n}",
        "baseline_code_stripped": "undefined8 FUN_0016bd00(long param_1,long param_2)\n{\n  undefined8 uVar1;\n  if ((param_1 != 0) && (param_2 != 0)) {\n    if (*(long *)(param_2 + 0xa8) != 0) {\n      return 1;\n    }\n    uVar1 = FUN_0016bc90(param_2);\n    return uVar1;\n  }\n  return 0;\n}",
        "similarity_score_unixcoder": 0.3571893274784088,
        "similarity_score_baseline_stripped": 0.39779341220855713
    },
    {
        "func_name": "getOwnerMapEntry",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_1025e6a0(char *param_1)\n{\n  int iVar1;\n  undefined4 *local_c;\n  local_c = &DAT_10410960;\n  while ((local_c != (undefined4 *)\"XML-1.00\" &&\n         (iVar1 = strcmp(param_1,(char *)local_c[1]), iVar1 != 0))) {\n    local_c = local_c + 2;\n  }\n  __RTC_CheckEsp();\n  return;\n}",
        "output": "```c\nvoid checkXmlVersion(char *inputVersion) {\n    undefined4 *versionPointer = &DAT_10410960;\n\n    while (versionPointer != (undefined4 *)\"XML-1.00\" && \n           strcmp(inputVersion, (char *)versionPointer[1]) != 0) {\n        versionPointer += 2;\n    }\n\n    __RTC_CheckEsp();\n    return;\n}\n```",
        "normed_func_sha256": "3c8d100d28598420d1b1dc27264508985fadea02aec7b74919849025848d959e",
        "source_code": "static inline const OwnerMapEntry *getOwnerMapEntry(const char *name)\n{\n    for (const OwnerMapEntry &entry : ownerMap) {\n        if (strcmp(name, entry.name) == 0) {\n            return &entry;\n        }\n    }\n    return nullptr;\n}",
        "parsed_output": "void checkXmlVersion(char *inputVersion) {\n    undefined4 *versionPointer = &DAT_10410960;\n\n    while (versionPointer != (undefined4 *)\"XML-1.00\" && \n           strcmp(inputVersion, (char *)versionPointer[1]) != 0) {\n        versionPointer += 2;\n    }\n\n    __RTC_CheckEsp();\n    return;\n}",
        "baseline_code_stripped": "void FUN_1025e6a0(char *param_1)\n{\n  int iVar1;\n  undefined4 *local_c;\n  local_c = &DAT_10410960;\n  while ((local_c != (undefined4 *)\"XML-1.00\" &&\n         (iVar1 = strcmp(param_1,(char *)local_c[1]), iVar1 != 0))) {\n    local_c = local_c + 2;\n  }\n  __RTC_CheckEsp();\n  return;\n}",
        "similarity_score_unixcoder": 0.41448116302490234,
        "similarity_score_baseline_stripped": 0.3582296073436737
    },
    {
        "func_name": "gettime",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_0001bd34(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 uVar3;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  uStack_10 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  iVar1 = FUN_00029940(1,&uStack_10);\n  if (iVar1 < 0) {\n    puVar2 = (undefined4 *)FUN_000283d6(iVar1);\n    uVar3 = FUN_0002831c(*puVar2);\n    FUN_00017ef8(3,\"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\",uVar3);\n    uStack_10 = 0;\n  }\n  return uStack_10;\n}",
        "output": "```c\nundefined4 GetClockTime(undefined4 param_1, undefined4 param_2, undefined4 param_3) {\n    int result;\n    undefined4 *errorPtr;\n    undefined4 errorMessage;\n    undefined4 timeValue;\n\n    timeValue = param_1;\n    undefined4 clockType = param_2;\n    undefined4 additionalParam = param_3;\n\n    result = FUN_00029940(1, &timeValue);\n    if (result < 0) {\n        errorPtr = (undefined4 *)FUN_000283d6(result);\n        errorMessage = FUN_0002831c(*errorPtr);\n        FUN_00017ef8(3, \"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\", errorMessage);\n        timeValue = 0;\n    }\n    return timeValue;\n}\n```",
        "normed_func_sha256": "412011dd2933e049b60bbbb16f239d8d0e688a37ee59997a2060d613ff13fdec",
        "source_code": "static time_t gettime(void)\n{\n    struct timespec ts;\n    int ret;\n\n    ret = clock_gettime(CLOCK_MONOTONIC, &ts);\n    if (ret < 0) {\n        ERROR(\"clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\", strerror(errno));\n        return 0;\n    }\n\n    return ts.tv_sec;\n}",
        "parsed_output": "undefined4 GetClockTime(undefined4 param_1, undefined4 param_2, undefined4 param_3) {\n    int result;\n    undefined4 *errorPtr;\n    undefined4 errorMessage;\n    undefined4 timeValue;\n\n    timeValue = param_1;\n    undefined4 clockType = param_2;\n    undefined4 additionalParam = param_3;\n\n    result = FUN_00029940(1, &timeValue);\n    if (result < 0) {\n        errorPtr = (undefined4 *)FUN_000283d6(result);\n        errorMessage = FUN_0002831c(*errorPtr);\n        FUN_00017ef8(3, \"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\", errorMessage);\n        timeValue = 0;\n    }\n    return timeValue;\n}",
        "baseline_code_stripped": "undefined4 FUN_0001bd34(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 uVar3;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  uStack_10 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  iVar1 = FUN_00029940(1,&uStack_10);\n  if (iVar1 < 0) {\n    puVar2 = (undefined4 *)FUN_000283d6(iVar1);\n    uVar3 = FUN_0002831c(*puVar2);\n    FUN_00017ef8(3,\"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\",uVar3);\n    uStack_10 = 0;\n  }\n  return uStack_10;\n}",
        "similarity_score_unixcoder": 0.6501162052154541,
        "similarity_score_baseline_stripped": 0.43212634325027466
    },
    {
        "func_name": "get_origcol_name",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined * FUN_180025924(longlong param_1,int param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 *puVar1;\n  uint uVar2;\n  undefined *puVar3;\n  undefined *puVar4;\n  uVar2 = abs(param_2);\n  if ((((*(char *)(param_1 + 0x7c8) == '\\0') || (*(char *)(param_1 + 0x7ca) == '\\0')) ||\n      (puVar1 = *(undefined8 **)(*(longlong *)(param_1 + 0x8e0) + (longlong)(int)uVar2 * 8),\n      puVar1 == (undefined8 *)0x0)) || (puVar4 = (undefined *)*puVar1, puVar4 == (undefined *)0x0))\n  {\n    puVar3 = &DAT_18007904c;\n    if (-1 < param_2) {\n      puVar3 = &DAT_180079050;\n    }\n    puVar4 = &DAT_18009f6f8;\n    thunk_FUN_180007388(&DAT_18009f6f8,puVar3,(ulonglong)uVar2,param_4);\n  }\n  return puVar4;\n}",
        "output": "```c\nundefined * FUN_180025924(longlong param_1, int param_2, undefined8 param_3, undefined8 param_4) {\n    undefined8 *dataPointer;\n    uint absoluteParam2;\n    undefined *resultPointer;\n    undefined *fallbackPointer;\n\n    absoluteParam2 = abs(param_2);\n\n    if ((*(char *)(param_1 + 0x7c8) == '\\0') || \n        (*(char *)(param_1 + 0x7ca) == '\\0') || \n        (dataPointer = *(undefined8 **)(*(longlong *)(param_1 + 0x8e0) + (longlong)(int)absoluteParam2 * 8), \n         dataPointer == (undefined8 *)0x0) || \n        (fallbackPointer = (undefined *)*dataPointer, fallbackPointer == (undefined *)0x0)) {\n        \n        resultPointer = &DAT_18007904c;\n        if (param_2 >= 0) {\n            resultPointer = &DAT_180079050;\n        }\n        \n        fallbackPointer = &DAT_18009f6f8;\n        thunk_FUN_180007388(&DAT_18009f6f8, resultPointer, (ulonglong)absoluteParam2, param_4);\n    }\n    \n    return fallbackPointer;\n}\n```",
        "normed_func_sha256": "d8241c3295ea1b4e9eb02519639dbfe48eda6c6a7a10d246126bbda521ff0ede",
        "source_code": "char * __WINAPI get_origcol_name(lprec *lp, int colnr)\n{\n  MYBOOL newcol;\n  char   *ptr;\n\n  newcol = (MYBOOL) (colnr < 0);\n  colnr = abs(colnr);\n#ifdef Paranoia\n  if(((lp->presolve_undo->var_to_orig == NULL) && newcol) ||\n     (colnr > MAX(lp->columns, lp->presolve_undo->orig_columns))) {\n    report(lp, IMPORTANT, \"get_origcol_name: Column %d out of range\", colnr);\n    return(NULL);\n  }\n#endif\n\n  if(lp->names_used && lp->use_col_names && (lp->col_name[colnr] != NULL) && (lp->col_name[colnr]->name != NULL)) {\n#ifdef Paranoia\n    if(lp->col_name[colnr]->index != colnr)\n      report(lp, SEVERE, \"get_origcol_name: Inconsistent column ordinal %d vs %d\\n\",\n                         colnr, lp->col_name[colnr]->index);\n#endif\n    ptr = lp->col_name[colnr]->name;\n  }\n  else {\n    if(lp->rowcol_name == NULL)\n      if (!allocCHAR(lp, &lp->rowcol_name, 20, FALSE))\n        return(NULL);\n    ptr = lp->rowcol_name;\n    if(newcol)\n      sprintf(ptr, COLNAMEMASK2, colnr);\n    else\n      sprintf(ptr, COLNAMEMASK, colnr);\n  }\n  return(ptr);\n}",
        "parsed_output": "undefined * FUN_180025924(longlong param_1, int param_2, undefined8 param_3, undefined8 param_4) {\n    undefined8 *dataPointer;\n    uint absoluteParam2;\n    undefined *resultPointer;\n    undefined *fallbackPointer;\n\n    absoluteParam2 = abs(param_2);\n\n    if ((*(char *)(param_1 + 0x7c8) == '\\0') || \n        (*(char *)(param_1 + 0x7ca) == '\\0') || \n        (dataPointer = *(undefined8 **)(*(longlong *)(param_1 + 0x8e0) + (longlong)(int)absoluteParam2 * 8), \n         dataPointer == (undefined8 *)0x0) || \n        (fallbackPointer = (undefined *)*dataPointer, fallbackPointer == (undefined *)0x0)) {\n        \n        resultPointer = &DAT_18007904c;\n        if (param_2 >= 0) {\n            resultPointer = &DAT_180079050;\n        }\n        \n        fallbackPointer = &DAT_18009f6f8;\n        thunk_FUN_180007388(&DAT_18009f6f8, resultPointer, (ulonglong)absoluteParam2, param_4);\n    }\n    \n    return fallbackPointer;\n}",
        "baseline_code_stripped": "undefined * FUN_180025924(longlong param_1,int param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 *puVar1;\n  uint uVar2;\n  undefined *puVar3;\n  undefined *puVar4;\n  uVar2 = abs(param_2);\n  if ((((*(char *)(param_1 + 0x7c8) == '\\0') || (*(char *)(param_1 + 0x7ca) == '\\0')) ||\n      (puVar1 = *(undefined8 **)(*(longlong *)(param_1 + 0x8e0) + (longlong)(int)uVar2 * 8),\n      puVar1 == (undefined8 *)0x0)) || (puVar4 = (undefined *)*puVar1, puVar4 == (undefined *)0x0))\n  {\n    puVar3 = &DAT_18007904c;\n    if (-1 < param_2) {\n      puVar3 = &DAT_180079050;\n    }\n    puVar4 = &DAT_18009f6f8;\n    thunk_FUN_180007388(&DAT_18009f6f8,puVar3,(ulonglong)uVar2,param_4);\n  }\n  return puVar4;\n}",
        "similarity_score_unixcoder": 0.437406986951828,
        "similarity_score_baseline_stripped": 0.5044341087341309
    },
    {
        "func_name": "__pyx_f_11statsmodels_3tsa_10statespace_20_simulation_smoother_19zSimulationSmoother_generate_state",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8\nFUN_00112ce0(long param_1,int param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5)\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  int local_6c;\n  undefined4 local_64;\n  undefined4 local_60;\n  undefined4 local_5c;\n  undefined8 local_58;\n  undefined8 local_50;\n  long local_40;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = *(long *)(param_1 + 0x18);\n  local_64 = 1;\n  local_50 = 0;\n  local_60 = *(undefined4 *)(lVar1 + 0x20);\n  local_58 = 0x3ff0000000000000;\n  local_5c = *(undefined4 *)(lVar1 + 0x24);\n  if (*(int *)(lVar1 + 0xb8c) == 0) {\n    if (*(long *)(lVar1 + 0x1c8) != 0) {\n      lVar3 = 0;\n      if (1 < *(long *)(lVar1 + 0x1e0)) {\n        lVar3 = (long)param_2;\n      }\n      if (*(long *)(lVar1 + 0x6a8) != 0) {\n        local_6c = 0;\n        if (1 < *(long *)(lVar1 + 0x6c8)) {\n          local_6c = param_2;\n        }\n        if (*(long *)(lVar1 + 0x778) != 0) {\n          lVar2 = (long)param_2;\n          if (*(long *)(lVar1 + 0x798) < 2) {\n            lVar2 = (long)*(int *)(lVar1 + 0xb8c);\n          }\n          goto LAB_00112da5;\n        }\n      }\n    }\n  }\n  else if (*(long *)(lVar1 + 0x1c8) != 0) {\n    lVar3 = 0;\n    lVar2 = 0;\n    local_6c = 0;\nLAB_00112da5:\n    (*DAT_00192e58)(&local_60,lVar3 * *(long *)(lVar1 + 0x220) + *(long *)(lVar1 + 0x1d0),&local_64,\n                    param_3,&local_64);\n    lVar1 = *(long *)(param_1 + 0x18);\n    if (*(long *)(lVar1 + 0x778) != 0) {\n      (*DAT_00192e50)(\"N\",&local_60,&local_5c,&local_58,\n                      lVar2 * *(long *)(lVar1 + 0x7d8) + *(long *)(lVar1 + 0x780),&local_60,param_5,\n                      &local_64,&local_58,param_3,&local_64);\n      lVar1 = *(long *)(param_1 + 0x18);\n      if (*(int *)(lVar1 + 0xbac) != 0) {\n        (*DAT_00192e60)(&local_60,&local_58,param_4,&local_64,param_3,&local_64);\n        goto LAB_00112e5a;\n      }\n      if (*(long *)(lVar1 + 0x6a8) != 0) {\n        (*DAT_00192e50)(\"N\",&local_60,&local_60,&local_58,\n                        *(long *)(lVar1 + 0x6b0) + (long)local_6c * *(long *)(lVar1 + 0x708),\n                        &local_60,param_4,&local_64,&local_58,param_3,&local_64);\n        goto LAB_00112e5a;\n      }\n    }\n  }\n  PyErr_SetString(_PyExc_AttributeError,\"Memoryview is not initialized\");\n  FUN_00111da0(\"statsmodels.tsa.statespace._simulation_smoother.zSimulationSmoother.generate_state\")\n  ;\nLAB_00112e5a:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n  __stack_chk_fail(0,0);\n}",
        "output": "```c\nundefined8 FUN_00112ce0(long param_1, int param_2, undefined8 param_3, undefined8 param_4, undefined8 param_5) {\n    long lVar1;\n    long lVar2;\n    long lVar3;\n    long in_FS_OFFSET;\n    int local_6c;\n    undefined4 local_64;\n    undefined4 local_60;\n    undefined4 local_5c;\n    undefined8 local_58;\n    undefined8 local_50;\n    long local_40;\n\n    local_40 = *(long *)(in_FS_OFFSET + 0x28);\n    lVar1 = *(long *)(param_1 + 0x18);\n    local_64 = 1;\n    local_50 = 0;\n    local_60 = *(undefined4 *)(lVar1 + 0x20);\n    local_58 = 0x3ff0000000000000;\n    local_5c = *(undefined4 *)(lVar1 + 0x24);\n\n    if (*(int *)(lVar1 + 0xb8c) == 0) {\n        if (*(long *)(lVar1 + 0x1c8) != 0) {\n            lVar3 = (1 < *(long *)(lVar1 + 0x1e0)) ? (long)param_2 : 0;\n\n            if (*(long *)(lVar1 + 0x6a8) != 0) {\n                local_6c = (1 < *(long *)(lVar1 + 0x6c8)) ? param_2 : 0;\n\n                if (*(long *)(lVar1 + 0x778) != 0) {\n                    lVar2 = (long)param_2;\n                    if (*(long *)(lVar1 + 0x798) < 2) {\n                        lVar2 = (long)*(int *)(lVar1 + 0xb8c);\n                    }\n                    goto compute_values;\n                }\n            }\n        }\n    } else if (*(long *)(lVar1 + 0x1c8) != 0) {\n        lVar3 = 0;\n        lVar2 = 0;\n        local_6c = 0;\n\n    compute_values:\n        (*DAT_00192e58)(&local_60, lVar3 * *(long *)(lVar1 + 0x220) + *(long *)(lVar1 + 0x1d0), &local_64, param_3, &local_64);\n        lVar1 = *(long *)(param_1 + 0x18);\n\n        if (*(long *)(lVar1 + 0x778) != 0) {\n            (*DAT_00192e50)(\"N\", &local_60, &local_5c, &local_58, lVar2 * *(long *)(lVar1 + 0x7d8) + *(long *)(lVar1 + 0x780), &local_60, param_5, &local_64, &local_58, param_3, &local_64);\n            lVar1 = *(long *)(param_1 + 0x18);\n\n            if (*(int *)(lVar1 + 0xbac) != 0) {\n                (*DAT_00192e60)(&local_60, &local_58, param_4, &local_64, param_3, &local_64);\n                goto end_function;\n            }\n\n            if (*(long *)(lVar1 + 0x6a8) != 0) {\n                (*DAT_00192e50)(\"N\", &local_60, &local_60, &local_58, *(long *)(lVar1 + 0x6b0) + (long)local_6c * *(long *)(lVar1 + 0x708), &local_60, param_4, &local_64, &local_58, param_3, &local_64);\n                goto end_function;\n            }\n        }\n    }\n\n    PyErr_SetString(_PyExc_AttributeError, \"Memoryview is not initialized\");\n    FUN_00111da0(\"statsmodels.tsa.statespace._simulation_smoother.zSimulationSmoother.generate_state\");\n\nend_function:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return 0;\n    }\n    __stack_chk_fail(0, 0);\n}\n```",
        "normed_func_sha256": "c257f11ac8baf8d3db7ca911c3e8afd859d616c8686c764a4d7bcd46c6dce70d",
        "source_code": "static __pyx_t_double_complex __pyx_f_11statsmodels_3tsa_10statespace_20_simulation_smoother_19zSimulationSmoother_generate_state(struct __pyx_obj_11statsmodels_3tsa_10statespace_20_simulation_smoother_zSimulationSmoother *__pyx_v_self, int __pyx_v_t, __pyx_t_double_complex *__pyx_v_state, __pyx_t_double_complex *__pyx_v_input_state, __pyx_t_double_complex *__pyx_v_variates) {\n  int __pyx_v_inc;\n  int __pyx_v_k_states;\n  int __pyx_v_k_posdef;\n  int __pyx_v_state_intercept_t;\n  int __pyx_v_transition_t;\n  int __pyx_v_selection_t;\n  __pyx_t_double_complex __pyx_v_alpha;\n  __pyx_t_double_complex __pyx_r;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  int __pyx_t_2;\n  Py_ssize_t __pyx_t_3;\n  Py_ssize_t __pyx_t_4;\n  Py_ssize_t __pyx_t_5;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"generate_state\", 0);\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2317\n *     cdef np.complex128_t generate_state(self, int t, np.complex128_t * state, np.complex128_t * input_state, np.complex128_t * variates):\n *         cdef:\n *             int inc = 1             # <<<<<<<<<<<<<<\n *             int k_states = self.model.k_states\n *             int k_posdef = self.model.k_posdef\n */\n  __pyx_v_inc = 1;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2318\n *         cdef:\n *             int inc = 1\n *             int k_states = self.model.k_states             # <<<<<<<<<<<<<<\n *             int k_posdef = self.model.k_posdef\n *             int state_intercept_t = 0\n */\n  __pyx_t_1 = __pyx_v_self->model->k_states;\n  __pyx_v_k_states = __pyx_t_1;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2319\n *             int inc = 1\n *             int k_states = self.model.k_states\n *             int k_posdef = self.model.k_posdef             # <<<<<<<<<<<<<<\n *             int state_intercept_t = 0\n *             int transition_t = 0\n */\n  __pyx_t_1 = __pyx_v_self->model->k_posdef;\n  __pyx_v_k_posdef = __pyx_t_1;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2320\n *             int k_states = self.model.k_states\n *             int k_posdef = self.model.k_posdef\n *             int state_intercept_t = 0             # <<<<<<<<<<<<<<\n *             int transition_t = 0\n *             int selection_t = 0\n */\n  __pyx_v_state_intercept_t = 0;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2321\n *             int k_posdef = self.model.k_posdef\n *             int state_intercept_t = 0\n *             int transition_t = 0             # <<<<<<<<<<<<<<\n *             int selection_t = 0\n *         cdef:\n */\n  __pyx_v_transition_t = 0;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2322\n *             int state_intercept_t = 0\n *             int transition_t = 0\n *             int selection_t = 0             # <<<<<<<<<<<<<<\n *         cdef:\n *             np.complex128_t alpha = 1.0\n */\n  __pyx_v_selection_t = 0;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2324\n *             int selection_t = 0\n *         cdef:\n *             np.complex128_t alpha = 1.0             # <<<<<<<<<<<<<<\n * \n *         # Get indices for possibly time-varying arrays\n */\n  __pyx_v_alpha = __pyx_t_double_complex_from_parts(1.0, 0);\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2327\n * \n *         # Get indices for possibly time-varying arrays\n *         if not self.model.time_invariant:             # <<<<<<<<<<<<<<\n *             if self.model.state_intercept.shape[1] > 1:      state_intercept_t = t\n *             if self.model.transition.shape[2] > 1:           transition_t = t\n */\n  __pyx_t_2 = ((!(__pyx_v_self->model->time_invariant != 0)) != 0);\n  if (__pyx_t_2) {\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2328\n *         # Get indices for possibly time-varying arrays\n *         if not self.model.time_invariant:\n *             if self.model.state_intercept.shape[1] > 1:      state_intercept_t = t             # <<<<<<<<<<<<<<\n *             if self.model.transition.shape[2] > 1:           transition_t = t\n *             if self.model.selection.shape[2] > 1:            selection_t = t\n */\n    if (unlikely(!__pyx_v_self->model->state_intercept.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2328, __pyx_L1_error)}\n    __pyx_t_2 = (((__pyx_v_self->model->state_intercept.shape[1]) > 1) != 0);\n    if (__pyx_t_2) {\n      __pyx_v_state_intercept_t = __pyx_v_t;\n    }\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2329\n *         if not self.model.time_invariant:\n *             if self.model.state_intercept.shape[1] > 1:      state_intercept_t = t\n *             if self.model.transition.shape[2] > 1:           transition_t = t             # <<<<<<<<<<<<<<\n *             if self.model.selection.shape[2] > 1:            selection_t = t\n * \n */\n    if (unlikely(!__pyx_v_self->model->transition.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2329, __pyx_L1_error)}\n    __pyx_t_2 = (((__pyx_v_self->model->transition.shape[2]) > 1) != 0);\n    if (__pyx_t_2) {\n      __pyx_v_transition_t = __pyx_v_t;\n    }\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2330\n *             if self.model.state_intercept.shape[1] > 1:      state_intercept_t = t\n *             if self.model.transition.shape[2] > 1:           transition_t = t\n *             if self.model.selection.shape[2] > 1:            selection_t = t             # <<<<<<<<<<<<<<\n * \n *         # \\\\# = R_t eta_t + c_t\n */\n    if (unlikely(!__pyx_v_self->model->selection.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2330, __pyx_L1_error)}\n    __pyx_t_2 = (((__pyx_v_self->model->selection.shape[2]) > 1) != 0);\n    if (__pyx_t_2) {\n      __pyx_v_selection_t = __pyx_v_t;\n    }\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2327\n * \n *         # Get indices for possibly time-varying arrays\n *         if not self.model.time_invariant:             # <<<<<<<<<<<<<<\n *             if self.model.state_intercept.shape[1] > 1:      state_intercept_t = t\n *             if self.model.transition.shape[2] > 1:           transition_t = t\n */\n  }\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2333\n * \n *         # \\\\# = R_t eta_t + c_t\n *         blas.zcopy(&k_states, &self.model.state_intercept[0,state_intercept_t], &inc, state, &inc)             # <<<<<<<<<<<<<<\n *         blas.zgemv(\"N\", &k_states, &k_posdef,\n *                             &alpha, &self.model.selection[0,0,selection_t], &k_states,\n */\n  if (unlikely(!__pyx_v_self->model->state_intercept.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2333, __pyx_L1_error)}\n  __pyx_t_3 = 0;\n  __pyx_t_4 = __pyx_v_state_intercept_t;\n  __pyx_f_5scipy_6linalg_11cython_blas_zcopy((&__pyx_v_k_states), (&(*((__pyx_t_double_complex *) ( /* dim=1 */ (( /* dim=0 */ ((char *) (((__pyx_t_double_complex *) __pyx_v_self->model->state_intercept.data) + __pyx_t_3)) ) + __pyx_t_4 * __pyx_v_self->model->state_intercept.strides[1]) )))), (&__pyx_v_inc), __pyx_v_state, (&__pyx_v_inc));\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2335\n *         blas.zcopy(&k_states, &self.model.state_intercept[0,state_intercept_t], &inc, state, &inc)\n *         blas.zgemv(\"N\", &k_states, &k_posdef,\n *                             &alpha, &self.model.selection[0,0,selection_t], &k_states,             # <<<<<<<<<<<<<<\n *                                     variates, &inc,\n *                             &alpha, state, &inc)\n */\n  if (unlikely(!__pyx_v_self->model->selection.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2335, __pyx_L1_error)}\n  __pyx_t_4 = 0;\n  __pyx_t_3 = 0;\n  __pyx_t_5 = __pyx_v_selection_t;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2334\n *         # \\\\# = R_t eta_t + c_t\n *         blas.zcopy(&k_states, &self.model.state_intercept[0,state_intercept_t], &inc, state, &inc)\n *         blas.zgemv(\"N\", &k_states, &k_posdef,             # <<<<<<<<<<<<<<\n *                             &alpha, &self.model.selection[0,0,selection_t], &k_states,\n *                                     variates, &inc,\n */\n  __pyx_f_5scipy_6linalg_11cython_blas_zgemv(((char *)\"N\"), (&__pyx_v_k_states), (&__pyx_v_k_posdef), (&__pyx_v_alpha), (&(*((__pyx_t_double_complex *) ( /* dim=2 */ (( /* dim=1 */ (( /* dim=0 */ ((char *) (((__pyx_t_double_complex *) __pyx_v_self->model->selection.data) + __pyx_t_4)) ) + __pyx_t_3 * __pyx_v_self->model->selection.strides[1]) ) + __pyx_t_5 * __pyx_v_self->model->selection.strides[2]) )))), (&__pyx_v_k_states), __pyx_v_variates, (&__pyx_v_inc), (&__pyx_v_alpha), __pyx_v_state, (&__pyx_v_inc));\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2340\n * \n *         # alpha_{t+1} = T_t alpha_t + \\\\#\n *         if self.model.identity_transition:             # <<<<<<<<<<<<<<\n *             blas.zaxpy(&k_states, &alpha, input_state, &inc, state, &inc)\n *         else:\n */\n  __pyx_t_2 = (__pyx_v_self->model->identity_transition != 0);\n  if (__pyx_t_2) {\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2341\n *         # alpha_{t+1} = T_t alpha_t + \\\\#\n *         if self.model.identity_transition:\n *             blas.zaxpy(&k_states, &alpha, input_state, &inc, state, &inc)             # <<<<<<<<<<<<<<\n *         else:\n *             blas.zgemv(\"N\", &k_states, &k_states,\n */\n    __pyx_f_5scipy_6linalg_11cython_blas_zaxpy((&__pyx_v_k_states), (&__pyx_v_alpha), __pyx_v_input_state, (&__pyx_v_inc), __pyx_v_state, (&__pyx_v_inc));\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2340\n * \n *         # alpha_{t+1} = T_t alpha_t + \\\\#\n *         if self.model.identity_transition:             # <<<<<<<<<<<<<<\n *             blas.zaxpy(&k_states, &alpha, input_state, &inc, state, &inc)\n *         else:\n */\n    goto __pyx_L7;\n  }\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2343\n *             blas.zaxpy(&k_states, &alpha, input_state, &inc, state, &inc)\n *         else:\n *             blas.zgemv(\"N\", &k_states, &k_states,             # <<<<<<<<<<<<<<\n *                                 &alpha, &self.model.transition[0,0,transition_t], &k_states,\n *                                         input_state, &inc,\n */\n  /*else*/ {\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2344\n *         else:\n *             blas.zgemv(\"N\", &k_states, &k_states,\n *                                 &alpha, &self.model.transition[0,0,transition_t], &k_states,             # <<<<<<<<<<<<<<\n *                                         input_state, &inc,\n *                                 &alpha, state, &inc)\n */\n    if (unlikely(!__pyx_v_self->model->transition.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2344, __pyx_L1_error)}\n    __pyx_t_5 = 0;\n    __pyx_t_3 = 0;\n    __pyx_t_4 = __pyx_v_transition_t;\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2343\n *             blas.zaxpy(&k_states, &alpha, input_state, &inc, state, &inc)\n *         else:\n *             blas.zgemv(\"N\", &k_states, &k_states,             # <<<<<<<<<<<<<<\n *                                 &alpha, &self.model.transition[0,0,transition_t], &k_states,\n *                                         input_state, &inc,\n */\n    __pyx_f_5scipy_6linalg_11cython_blas_zgemv(((char *)\"N\"), (&__pyx_v_k_states), (&__pyx_v_k_states), (&__pyx_v_alpha), (&(*((__pyx_t_double_complex *) ( /* dim=2 */ (( /* dim=1 */ (( /* dim=0 */ ((char *) (((__pyx_t_double_complex *) __pyx_v_self->model->transition.data) + __pyx_t_5)) ) + __pyx_t_3 * __pyx_v_self->model->transition.strides[1]) ) + __pyx_t_4 * __pyx_v_self->model->transition.strides[2]) )))), (&__pyx_v_k_states), __pyx_v_input_state, (&__pyx_v_inc), (&__pyx_v_alpha), __pyx_v_state, (&__pyx_v_inc));\n  }\n  __pyx_L7:;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2315\n *                             &alpha, obs, &inc)\n * \n *     cdef np.complex128_t generate_state(self, int t, np.complex128_t * state, np.complex128_t * input_state, np.complex128_t * variates):             # <<<<<<<<<<<<<<\n *         cdef:\n *             int inc = 1\n */\n\n  /* function exit code */\n  __pyx_r = __pyx_t_double_complex_from_parts(0, 0);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_WriteUnraisable(\"statsmodels.tsa.statespace._simulation_smoother.zSimulationSmoother.generate_state\", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);\n  __pyx_r = __pyx_t_double_complex_from_parts(0, 0);\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}",
        "parsed_output": "undefined8 FUN_00112ce0(long param_1, int param_2, undefined8 param_3, undefined8 param_4, undefined8 param_5) {\n    long lVar1;\n    long lVar2;\n    long lVar3;\n    long in_FS_OFFSET;\n    int local_6c;\n    undefined4 local_64;\n    undefined4 local_60;\n    undefined4 local_5c;\n    undefined8 local_58;\n    undefined8 local_50;\n    long local_40;\n\n    local_40 = *(long *)(in_FS_OFFSET + 0x28);\n    lVar1 = *(long *)(param_1 + 0x18);\n    local_64 = 1;\n    local_50 = 0;\n    local_60 = *(undefined4 *)(lVar1 + 0x20);\n    local_58 = 0x3ff0000000000000;\n    local_5c = *(undefined4 *)(lVar1 + 0x24);\n\n    if (*(int *)(lVar1 + 0xb8c) == 0) {\n        if (*(long *)(lVar1 + 0x1c8) != 0) {\n            lVar3 = (1 < *(long *)(lVar1 + 0x1e0)) ? (long)param_2 : 0;\n\n            if (*(long *)(lVar1 + 0x6a8) != 0) {\n                local_6c = (1 < *(long *)(lVar1 + 0x6c8)) ? param_2 : 0;\n\n                if (*(long *)(lVar1 + 0x778) != 0) {\n                    lVar2 = (long)param_2;\n                    if (*(long *)(lVar1 + 0x798) < 2) {\n                        lVar2 = (long)*(int *)(lVar1 + 0xb8c);\n                    }\n                    goto compute_values;\n                }\n            }\n        }\n    } else if (*(long *)(lVar1 + 0x1c8) != 0) {\n        lVar3 = 0;\n        lVar2 = 0;\n        local_6c = 0;\n\n    compute_values:\n        (*DAT_00192e58)(&local_60, lVar3 * *(long *)(lVar1 + 0x220) + *(long *)(lVar1 + 0x1d0), &local_64, param_3, &local_64);\n        lVar1 = *(long *)(param_1 + 0x18);\n\n        if (*(long *)(lVar1 + 0x778) != 0) {\n            (*DAT_00192e50)(\"N\", &local_60, &local_5c, &local_58, lVar2 * *(long *)(lVar1 + 0x7d8) + *(long *)(lVar1 + 0x780), &local_60, param_5, &local_64, &local_58, param_3, &local_64);\n            lVar1 = *(long *)(param_1 + 0x18);\n\n            if (*(int *)(lVar1 + 0xbac) != 0) {\n                (*DAT_00192e60)(&local_60, &local_58, param_4, &local_64, param_3, &local_64);\n                goto end_function;\n            }\n\n            if (*(long *)(lVar1 + 0x6a8) != 0) {\n                (*DAT_00192e50)(\"N\", &local_60, &local_60, &local_58, *(long *)(lVar1 + 0x6b0) + (long)local_6c * *(long *)(lVar1 + 0x708), &local_60, param_4, &local_64, &local_58, param_3, &local_64);\n                goto end_function;\n            }\n        }\n    }\n\n    PyErr_SetString(_PyExc_AttributeError, \"Memoryview is not initialized\");\n    FUN_00111da0(\"statsmodels.tsa.statespace._simulation_smoother.zSimulationSmoother.generate_state\");\n\nend_function:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return 0;\n    }\n    __stack_chk_fail(0, 0);\n}",
        "baseline_code_stripped": "undefined8\nFUN_00112ce0(long param_1,int param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5)\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  int local_6c;\n  undefined4 local_64;\n  undefined4 local_60;\n  undefined4 local_5c;\n  undefined8 local_58;\n  undefined8 local_50;\n  long local_40;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = *(long *)(param_1 + 0x18);\n  local_64 = 1;\n  local_50 = 0;\n  local_60 = *(undefined4 *)(lVar1 + 0x20);\n  local_58 = 0x3ff0000000000000;\n  local_5c = *(undefined4 *)(lVar1 + 0x24);\n  if (*(int *)(lVar1 + 0xb8c) == 0) {\n    if (*(long *)(lVar1 + 0x1c8) != 0) {\n      lVar3 = 0;\n      if (1 < *(long *)(lVar1 + 0x1e0)) {\n        lVar3 = (long)param_2;\n      }\n      if (*(long *)(lVar1 + 0x6a8) != 0) {\n        local_6c = 0;\n        if (1 < *(long *)(lVar1 + 0x6c8)) {\n          local_6c = param_2;\n        }\n        if (*(long *)(lVar1 + 0x778) != 0) {\n          lVar2 = (long)param_2;\n          if (*(long *)(lVar1 + 0x798) < 2) {\n            lVar2 = (long)*(int *)(lVar1 + 0xb8c);\n          }\n          goto LAB_00112da5;\n        }\n      }\n    }\n  }\n  else if (*(long *)(lVar1 + 0x1c8) != 0) {\n    lVar3 = 0;\n    lVar2 = 0;\n    local_6c = 0;\nLAB_00112da5:\n    (*DAT_00192e58)(&local_60,lVar3 * *(long *)(lVar1 + 0x220) + *(long *)(lVar1 + 0x1d0),&local_64,\n                    param_3,&local_64);\n    lVar1 = *(long *)(param_1 + 0x18);\n    if (*(long *)(lVar1 + 0x778) != 0) {\n      (*DAT_00192e50)(\"N\",&local_60,&local_5c,&local_58,\n                      lVar2 * *(long *)(lVar1 + 0x7d8) + *(long *)(lVar1 + 0x780),&local_60,param_5,\n                      &local_64,&local_58,param_3,&local_64);\n      lVar1 = *(long *)(param_1 + 0x18);\n      if (*(int *)(lVar1 + 0xbac) != 0) {\n        (*DAT_00192e60)(&local_60,&local_58,param_4,&local_64,param_3,&local_64);\n        goto LAB_00112e5a;\n      }\n      if (*(long *)(lVar1 + 0x6a8) != 0) {\n        (*DAT_00192e50)(\"N\",&local_60,&local_60,&local_58,\n                        *(long *)(lVar1 + 0x6b0) + (long)local_6c * *(long *)(lVar1 + 0x708),\n                        &local_60,param_4,&local_64,&local_58,param_3,&local_64);\n        goto LAB_00112e5a;\n      }\n    }\n  }\n  PyErr_SetString(_PyExc_AttributeError,\"Memoryview is not initialized\");\n  FUN_00111da0(\"statsmodels.tsa.statespace._simulation_smoother.zSimulationSmoother.generate_state\")\n  ;\nLAB_00112e5a:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n  __stack_chk_fail(0,0);\n}",
        "similarity_score_unixcoder": 0.6704886555671692,
        "similarity_score_baseline_stripped": 0.675404965877533
    },
    {
        "func_name": "slot_QOcspResponse___hash__",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_00161c60(void)\n{\n  undefined4 uVar1;\n  QOcspResponse *pQVar2;\n  pQVar2 = (QOcspResponse *)(**(code **)(DAT_001ddbe0 + 0x2b8))();\n  uVar1 = 0;\n  if (pQVar2 != (QOcspResponse *)0x0) {\n    uVar1 = qHash(pQVar2,0);\n  }\n  return uVar1;\n}",
        "output": "```c\nuint32_t GetHashFromOcspResponse(void)\n{\n    uint32_t hashValue = 0;\n    QOcspResponse *ocspResponse = (QOcspResponse *)(**(code **)(DAT_001ddbe0 + 0x2b8))();\n    \n    if (ocspResponse != NULL) {\n        hashValue = qHash(ocspResponse, 0);\n    }\n    \n    return hashValue;\n}\n```",
        "normed_func_sha256": "0b296d92f8636ca7e86b4fecbd86eb21c738c9ac8e6b0314791c451819fecd54",
        "source_code": "static long slot_QOcspResponse___hash__(PyObject *sipSelf)\n{\n     ::QOcspResponse *sipCpp = reinterpret_cast< ::QOcspResponse *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf, sipType_QOcspResponse));\n\n    if (!sipCpp)\n        return 0L;\n\n\n    {\n        {\n            long sipRes = 0;\n\n#line 81 \"/home/abuild/rpmbuild/BUILD/PyQt5-5.15.9/sip/QtNetwork/qocspresponse.sip\"\n        sipRes = qHash(*sipCpp);\n#line 244 \"/home/abuild/rpmbuild/BUILD/PyQt5-5.15.9/build/QtNetwork/sipQtNetworkQOcspResponse.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    return 0;\n}",
        "parsed_output": "uint32_t GetHashFromOcspResponse(void)\n{\n    uint32_t hashValue = 0;\n    QOcspResponse *ocspResponse = (QOcspResponse *)(**(code **)(DAT_001ddbe0 + 0x2b8))();\n    \n    if (ocspResponse != NULL) {\n        hashValue = qHash(ocspResponse, 0);\n    }\n    \n    return hashValue;\n}",
        "baseline_code_stripped": "undefined4 FUN_00161c60(void)\n{\n  undefined4 uVar1;\n  QOcspResponse *pQVar2;\n  pQVar2 = (QOcspResponse *)(**(code **)(DAT_001ddbe0 + 0x2b8))();\n  uVar1 = 0;\n  if (pQVar2 != (QOcspResponse *)0x0) {\n    uVar1 = qHash(pQVar2,0);\n  }\n  return uVar1;\n}",
        "similarity_score_unixcoder": 0.5745093822479248,
        "similarity_score_baseline_stripped": 0.6350752115249634
    },
    {
        "func_name": "glColorSubTable",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid glColorSubTable(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                    undefined4 param_5,undefined4 param_6)\n{\n  int iVar1;\n  iVar1 = NtCurrentTeb();\n  iVar1 = *(int *)(iVar1 + 0xbe8);\n  if ((DAT_7a8e1a50 & 8) != 0) {\n    wine_dbg_log(3,&DAT_7a8e1a50,\"glColorSubTable\",\"(%d, %d, %d, %d, %d, %p)\\n\",param_1,param_2,\n                 param_3,param_4,param_5,param_6);\n  }\n  (**(code **)(iVar1 + 0x898))(param_1,param_2,param_3,param_4,param_5,param_6);\n  return;\n}",
        "output": "```c\nvoid glColorSubTable(uint32_t param_1, uint32_t param_2, uint32_t param_3, uint32_t param_4,\n                     uint32_t param_5, uint32_t param_6)\n{\n    int currentThreadEnvironmentBlock;\n    currentThreadEnvironmentBlock = NtCurrentTeb();\n    currentThreadEnvironmentBlock = *(int *)(currentThreadEnvironmentBlock + 0xbe8);\n    \n    if ((DAT_7a8e1a50 & 8) != 0) {\n        wine_dbg_log(3, &DAT_7a8e1a50, \"glColorSubTable\", \"(%d, %d, %d, %d, %d, %p)\\n\",\n                     param_1, param_2, param_3, param_4, param_5, param_6);\n    }\n    \n    ((void (*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))(*(void **)(currentThreadEnvironmentBlock + 0x898)))(\n        param_1, param_2, param_3, param_4, param_5, param_6);\n}\n```",
        "normed_func_sha256": "2364801c7017a6a794153dfddf4da5ab244b2c58ae079b057e0294d3611960fe",
        "source_code": "static void WINAPI glColorSubTable( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void* data ) {\n  const struct opengl_funcs *funcs = NtCurrentTeb()->glTable;\n  TRACE(\"(%d, %d, %d, %d, %d, %p)\\n\", target, start, count, format, type, data );\n  funcs->ext.p_glColorSubTable( target, start, count, format, type, data );\n}",
        "parsed_output": "void glColorSubTable(uint32_t param_1, uint32_t param_2, uint32_t param_3, uint32_t param_4,\n                     uint32_t param_5, uint32_t param_6)\n{\n    int currentThreadEnvironmentBlock;\n    currentThreadEnvironmentBlock = NtCurrentTeb();\n    currentThreadEnvironmentBlock = *(int *)(currentThreadEnvironmentBlock + 0xbe8);\n    \n    if ((DAT_7a8e1a50 & 8) != 0) {\n        wine_dbg_log(3, &DAT_7a8e1a50, \"glColorSubTable\", \"(%d, %d, %d, %d, %d, %p)\\n\",\n                     param_1, param_2, param_3, param_4, param_5, param_6);\n    }\n    \n    ((void (*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))(*(void **)(currentThreadEnvironmentBlock + 0x898)))(\n        param_1, param_2, param_3, param_4, param_5, param_6);\n}",
        "baseline_code_stripped": "void glColorSubTable(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                    undefined4 param_5,undefined4 param_6)\n{\n  int iVar1;\n  iVar1 = NtCurrentTeb();\n  iVar1 = *(int *)(iVar1 + 0xbe8);\n  if ((DAT_7a8e1a50 & 8) != 0) {\n    wine_dbg_log(3,&DAT_7a8e1a50,\"glColorSubTable\",\"(%d, %d, %d, %d, %d, %p)\\n\",param_1,param_2,\n                 param_3,param_4,param_5,param_6);\n  }\n  (**(code **)(iVar1 + 0x898))(param_1,param_2,param_3,param_4,param_5,param_6);\n  return;\n}",
        "similarity_score_unixcoder": 0.6069936156272888,
        "similarity_score_baseline_stripped": 0.5819120407104492
    },
    {
        "func_name": "dt_image_set_aspect_ratio_if_different",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid dt_image_set_aspect_ratio_if_different(float param_1,int param_2,int param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  if (param_1 <= 0.0) {\n    return;\n  }\n  lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x72);\n  if (0.1 < ABS(*(float *)(lVar1 + 0x420) - param_1)) {\n    dt_image_cache_read_release(DAT_005d3ad0);\n    lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x77);\n    uVar2 = DAT_005d3ad0;\n    *(float *)(lVar1 + 0x420) = param_1;\n    dt_image_cache_write_release(uVar2,lVar1,0);\n  }\n  else {\n    dt_image_cache_read_release(DAT_005d3ad0);\n  }\n  lVar1 = DAT_005d3af8;\n  if ((param_3 != 0) && (*(int *)(DAT_005d3af8 + 0x40) == 0xe)) {\n    uVar2 = g_list_prepend(0,(long)param_2);\n    dt_collection_update_query(lVar1,3,0x10,uVar2);\n    return;\n  }\n  return;\n}",
        "output": "```c\nvoid set_image_aspect_ratio_if_different(float new_aspect_ratio, int image_id, int collection_id) {\n    long image_cache_entry;\n    undefined8 cache_identifier;\n\n    if (new_aspect_ratio <= 0.0) {\n        return;\n    }\n\n    image_cache_entry = dt_image_cache_get(DAT_005d3ad0, image_id, 0x72);\n    \n    if (0.1 < ABS(*(float *)(image_cache_entry + 0x420) - new_aspect_ratio)) {\n        dt_image_cache_read_release(DAT_005d3ad0);\n        image_cache_entry = dt_image_cache_get(DAT_005d3ad0, image_id, 0x77);\n        cache_identifier = DAT_005d3ad0;\n        *(float *)(image_cache_entry + 0x420) = new_aspect_ratio;\n        dt_image_cache_write_release(cache_identifier, image_cache_entry, 0);\n    } else {\n        dt_image_cache_read_release(DAT_005d3ad0);\n    }\n\n    if ((collection_id != 0) && (*(int *)(DAT_005d3af8 + 0x40) == 0xe)) {\n        cache_identifier = g_list_prepend(0, (long)image_id);\n        dt_collection_update_query(DAT_005d3af8, 3, 0x10, cache_identifier);\n        return;\n    }\n}\n```",
        "normed_func_sha256": "30a3c39745c11eadde56c03c3e646d671a1f6c24ae560fcd2d0e4336fbbbb9b6",
        "source_code": "void dt_image_set_aspect_ratio_if_different(const int32_t imgid, const float aspect_ratio, const gboolean raise)\n{\n  if (aspect_ratio > .0f)\n  {\n    /* fetch image from cache */\n    dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'r');\n\n    /* set image aspect ratio */\n    if(fabs(image->aspect_ratio - aspect_ratio) > 0.1)\n    {\n      dt_image_cache_read_release(darktable.image_cache, image);\n      dt_image_t *wimage = dt_image_cache_get(darktable.image_cache, imgid, 'w');\n      wimage->aspect_ratio = aspect_ratio;\n      dt_image_cache_write_release(darktable.image_cache, wimage, DT_IMAGE_CACHE_SAFE);\n    }\n    else\n      dt_image_cache_read_release(darktable.image_cache, image);\n\n    if(raise && darktable.collection->params.sort == DT_COLLECTION_SORT_ASPECT_RATIO)\n      dt_collection_update_query(darktable.collection, DT_COLLECTION_CHANGE_RELOAD,\n                                 DT_COLLECTION_PROP_ASPECT_RATIO, g_list_prepend(NULL, GINT_TO_POINTER(imgid)));\n  }\n}",
        "parsed_output": "void set_image_aspect_ratio_if_different(float new_aspect_ratio, int image_id, int collection_id) {\n    long image_cache_entry;\n    undefined8 cache_identifier;\n\n    if (new_aspect_ratio <= 0.0) {\n        return;\n    }\n\n    image_cache_entry = dt_image_cache_get(DAT_005d3ad0, image_id, 0x72);\n    \n    if (0.1 < ABS(*(float *)(image_cache_entry + 0x420) - new_aspect_ratio)) {\n        dt_image_cache_read_release(DAT_005d3ad0);\n        image_cache_entry = dt_image_cache_get(DAT_005d3ad0, image_id, 0x77);\n        cache_identifier = DAT_005d3ad0;\n        *(float *)(image_cache_entry + 0x420) = new_aspect_ratio;\n        dt_image_cache_write_release(cache_identifier, image_cache_entry, 0);\n    } else {\n        dt_image_cache_read_release(DAT_005d3ad0);\n    }\n\n    if ((collection_id != 0) && (*(int *)(DAT_005d3af8 + 0x40) == 0xe)) {\n        cache_identifier = g_list_prepend(0, (long)image_id);\n        dt_collection_update_query(DAT_005d3af8, 3, 0x10, cache_identifier);\n        return;\n    }\n}",
        "baseline_code_stripped": "void dt_image_set_aspect_ratio_if_different(float param_1,int param_2,int param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  if (param_1 <= 0.0) {\n    return;\n  }\n  lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x72);\n  if (0.1 < ABS(*(float *)(lVar1 + 0x420) - param_1)) {\n    dt_image_cache_read_release(DAT_005d3ad0);\n    lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x77);\n    uVar2 = DAT_005d3ad0;\n    *(float *)(lVar1 + 0x420) = param_1;\n    dt_image_cache_write_release(uVar2,lVar1,0);\n  }\n  else {\n    dt_image_cache_read_release(DAT_005d3ad0);\n  }\n  lVar1 = DAT_005d3af8;\n  if ((param_3 != 0) && (*(int *)(DAT_005d3af8 + 0x40) == 0xe)) {\n    uVar2 = g_list_prepend(0,(long)param_2);\n    dt_collection_update_query(lVar1,3,0x10,uVar2);\n    return;\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.8336400985717773,
        "similarity_score_baseline_stripped": 0.7183497548103333
    }
]
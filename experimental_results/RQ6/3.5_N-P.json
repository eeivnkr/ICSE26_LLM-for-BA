[
    {
        "func_name": "meth_QMutexLocker___enter__",
        "normed_func_sha256": "8d84728ebb9bcb2866951b1edf4427363fa90ccb07f1f16e1981d2c04137e495",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid meth_QMutexLocker___enter__(int *param_1,undefined4 param_2)\n{\n  int iVar1;\n  int *piVar2;\n  int *local_24 [2];\n  undefined4 local_1c;\n  undefined auStack_18 [4];\n  int local_14;\n  local_14 = __stack_chk_guard;\n  local_1c = 0;\n  local_24[0] = param_1;\n  iVar1 = (**(code **)(DAT_0028fe00 + 0x140))\n                    (&local_1c,param_2,&DAT_00222c60,local_24,DAT_0028c910,auStack_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_0028fe00 + 0x150))\n              (local_1c,\"QMutexLocker\",\"__enter__\",\"__enter__(self) -> object\");\n    piVar2 = (int *)0x0;\n  }\n  else {\n    *local_24[0] = *local_24[0] + 1;\n    piVar2 = local_24[0];\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(piVar2);\n}",
        "output": "void enterMutexLocker(int *mutex, int param) {\n    int result;\n    int *localMutex;\n    int localGuard;\n    \n    localGuard = __stack_chk_guard;\n    result = (**(code **)(DAT_0028fe00 + 0x140))(&result, param, &DAT_00222c60, localMutex, DAT_0028c910, auStack_18);\n    \n    if (result == 0) {\n        (**(code **)(DAT_0028fe00 + 0x150))(result, \"QMutexLocker\", \"enterMutexLocker\", \"enterMutexLocker(self) -> object\");\n        localMutex = (int *)0x0;\n    } else {\n        *mutex = *mutex + 1;\n        localMutex = mutex;\n    }\n    \n    if (localGuard == __stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail(localMutex);\n}",
        "source_code": "static PyObject *meth_QMutexLocker___enter__(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n\n    {\n         ::QMutexLocker *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_QMutexLocker, &sipCpp))\n        {\n            PyObject * sipRes = SIP_NULLPTR;\n\n#line 37 \"/builddir/build/BUILD/PyQt5-5.13.2/armv7hl-redhat-linux-gnueabi-python3/sip/QtCore/qmutex.sip\"\n        // Just return a reference to self.\n        sipRes = sipSelf;\n        Py_INCREF(sipRes);\n#line 139 \"/builddir/build/BUILD/PyQt5-5.13.2/armv7hl-redhat-linux-gnueabi-python3/QtCore/sipQtCoreQMutexLocker.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QMutexLocker, sipName___enter__, doc_QMutexLocker___enter__);\n\n    return SIP_NULLPTR;\n}",
        "parsed_output": "void enterMutexLocker(int *mutex, int param) {\n    int result;\n    int *localMutex;\n    int localGuard;\n    \n    localGuard = __stack_chk_guard;\n    result = (**(code **)(DAT_0028fe00 + 0x140))(&result, param, &DAT_00222c60, localMutex, DAT_0028c910, auStack_18);\n    \n    if (result == 0) {\n        (**(code **)(DAT_0028fe00 + 0x150))(result, \"QMutexLocker\", \"enterMutexLocker\", \"enterMutexLocker(self) -> object\");\n        localMutex = (int *)0x0;\n    } else {\n        *mutex = *mutex + 1;\n        localMutex = mutex;\n    }\n    \n    if (localGuard == __stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail(localMutex);\n}",
        "baseline_code_stripped": "void meth_QMutexLocker___enter__(int *param_1,undefined4 param_2)\n{\n  int iVar1;\n  int *piVar2;\n  int *local_24 [2];\n  undefined4 local_1c;\n  undefined auStack_18 [4];\n  int local_14;\n  local_14 = __stack_chk_guard;\n  local_1c = 0;\n  local_24[0] = param_1;\n  iVar1 = (**(code **)(DAT_0028fe00 + 0x140))\n                    (&local_1c,param_2,&DAT_00222c60,local_24,DAT_0028c910,auStack_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_0028fe00 + 0x150))\n              (local_1c,\"QMutexLocker\",\"__enter__\",\"__enter__(self) -> object\");\n    piVar2 = (int *)0x0;\n  }\n  else {\n    *local_24[0] = *local_24[0] + 1;\n    piVar2 = local_24[0];\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(piVar2);\n}",
        "similarity_score_unixcoder": 0.5672353506088257,
        "similarity_score_baseline_stripped": 0.5935357809066772
    },
    {
        "func_name": "Bwd::exec",
        "normed_func_sha256": "bb57c5b030ae8b75e8aaf13ac5a79bc437f43836efc7e7ddef812955a7247cc1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00278250(void)\n{\n  long in_stack_00000038;\n  long in_stack_00000090;\n  long in_stack_00000098;\n  long in_stack_000000a0;\n  long in_stack_000000a8;\n  void *in_stack_00000140;\n  __cxa_guard_abort();\n  if (in_stack_00000140 != (void *)0x0) {\n    operator_delete(in_stack_00000140);\n  }\n  in_stack_000000a0 = in_stack_00000038 + 0x10;\n  if (in_stack_000000a8 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x000000a0);\n  }\n  in_stack_00000090 = in_stack_00000038 + 0x10;\n  if (in_stack_00000098 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x00000090);\n    FUN_0027820b();\n    return;\n  }\n  FUN_005f9e00();\n  _Unwind_Resume();\n}",
        "output": "void cleanupFunction(void)\n{\n    long localVar1;\n    long localVar2;\n    long localVar3;\n    long localVar4;\n    long localVar5;\n    void *ptr;\n\n    __cxa_guard_abort();\n\n    if (ptr != (void *)0x0) {\n        operator_delete(ptr);\n    }\n\n    localVar4 = localVar1 + 0x10;\n\n    if (localVar5 != 0) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&localVar4);\n    }\n\n    localVar2 = localVar1 + 0x10;\n\n    if (localVar3 != 0) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&localVar2);\n        cleanupFunction2();\n        return;\n    }\n\n    cleanupFunction3();\n    _Unwind_Resume();\n}",
        "source_code": "void Bwd::exec(\n        _megdnn_tensor_in data, _megdnn_tensor_in rois, _megdnn_tensor_in trans,\n        _megdnn_tensor_in out_diff, _megdnn_tensor_in out_count,\n        _megdnn_tensor_out data_diff, _megdnn_tensor_out trans_diff,\n        _megdnn_workspace workspace) {\n    check_exec(\n            data.layout, rois.layout, trans.layout, out_diff.layout, out_count.layout,\n            data_diff.layout, trans_diff.layout, workspace.size);\n    auto kern = [data, rois, trans, out_diff, out_count, data_diff,\n                 trans_diff](const DeformablePSROIPoolingBase::Param& param) {\n        bool no_trans = param.no_trans;\n        size_t pool_h = param.pooled_h, pool_w = param.pooled_w;\n        size_t part_sz = param.part_size, sample_per_part = param.sample_per_part;\n        float trans_std = param.trans_std, scale = param.spatial_scale;\n        size_t nr_bbox = rois.layout[0];\n        size_t nr_cls = no_trans ? 1 : trans.layout[1] / 2;\n        size_t IC = data.layout[1], IH = data.layout[2], IW = data.layout[3];\n        const float* data_ptr = data.ptr<float>();\n        const float* rois_ptr = rois.ptr<float>();\n        const float* trans_ptr = trans.ptr<float>();\n        const float* out_diff_ptr = out_diff.ptr<float>();\n        const float* out_count_ptr = out_count.ptr<float>();\n        float* data_diff_ptr = data_diff.ptr<float>();\n        float* trans_diff_ptr = trans_diff.ptr<float>();\n        auto&& data_diff_elems = data_diff.layout.total_nr_elems();\n        auto&& trans_diff_elems = trans_diff.layout.total_nr_elems();\n        size_t data_diff_bytes = sizeof(float[data_diff_elems]);\n        size_t trans_diff_bytes = sizeof(float[trans_diff_elems]);\n        memset(data_diff_ptr, 0, data_diff_bytes);\n        memset(trans_diff_ptr, 0, trans_diff_bytes);\n        deformable_ps_roi_pool_backward_acc_kernel(\n                data_ptr, rois_ptr, trans_ptr, out_diff_ptr, out_count_ptr,\n                data_diff_ptr, trans_diff_ptr, IC, IH, IW, no_trans, nr_bbox, nr_cls,\n                pool_h, pool_w, part_sz, sample_per_part, trans_std, scale);\n    };\n    MEGDNN_DISPATCH_CPU_KERN_OPR(kern(param()));\n    return;\n}",
        "parsed_output": "void cleanupFunction(void)\n{\n    long localVar1;\n    long localVar2;\n    long localVar3;\n    long localVar4;\n    long localVar5;\n    void *ptr;\n\n    __cxa_guard_abort();\n\n    if (ptr != (void *)0x0) {\n        operator_delete(ptr);\n    }\n\n    localVar4 = localVar1 + 0x10;\n\n    if (localVar5 != 0) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&localVar4);\n    }\n\n    localVar2 = localVar1 + 0x10;\n\n    if (localVar3 != 0) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&localVar2);\n        cleanupFunction2();\n        return;\n    }\n\n    cleanupFunction3();\n    _Unwind_Resume();\n}",
        "baseline_code_stripped": "void FUN_00278250(void)\n{\n  long in_stack_00000038;\n  long in_stack_00000090;\n  long in_stack_00000098;\n  long in_stack_000000a0;\n  long in_stack_000000a8;\n  void *in_stack_00000140;\n  __cxa_guard_abort();\n  if (in_stack_00000140 != (void *)0x0) {\n    operator_delete(in_stack_00000140);\n  }\n  in_stack_000000a0 = in_stack_00000038 + 0x10;\n  if (in_stack_000000a8 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x000000a0);\n  }\n  in_stack_00000090 = in_stack_00000038 + 0x10;\n  if (in_stack_00000098 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x00000090);\n    FUN_0027820b();\n    return;\n  }\n  FUN_005f9e00();\n  _Unwind_Resume();\n}",
        "similarity_score_unixcoder": 0.33056873083114624,
        "similarity_score_baseline_stripped": 0.41310906410217285
    },
    {
        "func_name": "ComponentAction::createWidget",
        "normed_func_sha256": "20cfc8978db3889b40b1b6f2ce20b86bd2c0fa4953543fc07d3890bbb64e0f62",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nQComboBox * FUN_002adc00(char *param_1,QWidget *param_2)\n{\n  QComboBox *this;\n  undefined8 uVar1;\n  int *local_28 [2];\n  this = (QComboBox *)operator_new(0x30);\n  QComboBox::QComboBox(this,param_2);\n  QWidget::setMinimumWidth((int)this);\n  QMetaObject::tr((char *)local_28,(char *)&PTR_staticMetaObject_006071e0,0x368dc0);\n  QWidget::setToolTip((QString *)this);\n  if (*local_28[0] != 0) {\n    if (*local_28[0] == -1) goto LAB_002adc7c;\n    LOCK();\n    *local_28[0] = *local_28[0] + -1;\n    UNLOCK();\n    if (*local_28[0] != 0) goto LAB_002adc7c;\n  }\n  QArrayData::deallocate((QArrayData *)local_28[0],2,8);\nLAB_002adc7c:\n  uVar1 = 0;\n  if ((*(long *)(param_1 + 0x10) != 0) && (*(int *)(*(long *)(param_1 + 0x10) + 4) != 0)) {\n    uVar1 = *(undefined8 *)(param_1 + 0x18);\n  }\n  FUN_002ae0f0(uVar1);\n  QComboBox::setModel((QAbstractItemModel *)this);\n  QComboBox::setCurrentIndex((int)this);\n  QObject::connect((QObject *)local_28,(char *)this,(QObject *)\"2activated(int)\",param_1,0x368df0);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  QObject::connect((QObject *)local_28,param_1,(QObject *)\"2currentIndexChanged(int)\",(char *)this,\n                   0x368e22);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  return this;\n}",
        "output": "```c\nQComboBox *createComboBox(char *param_1, QWidget *parent)\n{\n    QComboBox *comboBox = new QComboBox();\n    QComboBox::QComboBox(comboBox, parent);\n    QWidget::setMinimumWidth((int)comboBox);\n    \n    int *local_28[2];\n    QMetaObject::tr((char *)local_28, (char *)&PTR_staticMetaObject_006071e0, 0x368dc0);\n    \n    QWidget::setToolTip((QString *)comboBox);\n    \n    if (*local_28[0] != 0) {\n        if (*local_28[0] == -1) {\n            goto LAB_002adc7c;\n        }\n        \n        LOCK();\n        *local_28[0] = *local_28[0] + -1;\n        UNLOCK();\n        \n        if (*local_28[0] != 0) {\n            goto LAB_002adc7c;\n        }\n    }\n    \n    QArrayData::deallocate((QArrayData *)local_28[0], 2, 8);\n    \nLAB_002adc7c:\n    undefined8 uVar1 = 0;\n    \n    if ((*(long *)(param_1 + 0x10) != 0) && (*(int *)(*(long *)(param_1 + 0x10) + 4) != 0)) {\n        uVar1 = *(undefined8 *)(param_1 + 0x18);\n    }\n    \n    FUN_002ae0f0(uVar1);\n    QComboBox::setModel((QAbstractItemModel *)comboBox);\n    QComboBox::setCurrentIndex((int)comboBox);\n    \n    QObject::connect((QObject *)local_28, (char *)comboBox, (QObject *)\"2activated(int)\", param_1, 0x368df0);\n    QMetaObject::Connection::_Connection((Connection *)local_28);\n    \n    QObject::connect((QObject *)local_28, param_1, (QObject *)\"2currentIndexChanged(int)\", (char *)comboBox, 0x368e22);\n    QMetaObject::Connection::_Connection((Connection *)local_28);\n    \n    return comboBox;\n}\n```",
        "source_code": "QWidget  *ComponentAction::createWidget(QWidget *parent)\n{\n    QComboBox *comboBox = new QComboBox(parent);\n    comboBox->setMinimumWidth(120);\n    comboBox->setToolTip(tr(\"Edit sub components defined in this file.\"));\n    comboBox->setModel(m_componentView->standardItemModel());\n    comboBox->setCurrentIndex(-1);\n    connect(comboBox, SIGNAL(activated(int)), SLOT(emitCurrentComponentChanged(int)));\n    connect(this, SIGNAL(currentIndexChanged(int)), comboBox, SLOT(setCurrentIndex(int)));\n\n    return comboBox;\n}",
        "parsed_output": "QComboBox *createComboBox(char *param_1, QWidget *parent)\n{\n    QComboBox *comboBox = new QComboBox();\n    QComboBox::QComboBox(comboBox, parent);\n    QWidget::setMinimumWidth((int)comboBox);\n    \n    int *local_28[2];\n    QMetaObject::tr((char *)local_28, (char *)&PTR_staticMetaObject_006071e0, 0x368dc0);\n    \n    QWidget::setToolTip((QString *)comboBox);\n    \n    if (*local_28[0] != 0) {\n        if (*local_28[0] == -1) {\n            goto LAB_002adc7c;\n        }\n        \n        LOCK();\n        *local_28[0] = *local_28[0] + -1;\n        UNLOCK();\n        \n        if (*local_28[0] != 0) {\n            goto LAB_002adc7c;\n        }\n    }\n    \n    QArrayData::deallocate((QArrayData *)local_28[0], 2, 8);\n    \nLAB_002adc7c:\n    undefined8 uVar1 = 0;\n    \n    if ((*(long *)(param_1 + 0x10) != 0) && (*(int *)(*(long *)(param_1 + 0x10) + 4) != 0)) {\n        uVar1 = *(undefined8 *)(param_1 + 0x18);\n    }\n    \n    FUN_002ae0f0(uVar1);\n    QComboBox::setModel((QAbstractItemModel *)comboBox);\n    QComboBox::setCurrentIndex((int)comboBox);\n    \n    QObject::connect((QObject *)local_28, (char *)comboBox, (QObject *)\"2activated(int)\", param_1, 0x368df0);\n    QMetaObject::Connection::_Connection((Connection *)local_28);\n    \n    QObject::connect((QObject *)local_28, param_1, (QObject *)\"2currentIndexChanged(int)\", (char *)comboBox, 0x368e22);\n    QMetaObject::Connection::_Connection((Connection *)local_28);\n    \n    return comboBox;\n}",
        "baseline_code_stripped": "QComboBox * FUN_002adc00(char *param_1,QWidget *param_2)\n{\n  QComboBox *this;\n  undefined8 uVar1;\n  int *local_28 [2];\n  this = (QComboBox *)operator_new(0x30);\n  QComboBox::QComboBox(this,param_2);\n  QWidget::setMinimumWidth((int)this);\n  QMetaObject::tr((char *)local_28,(char *)&PTR_staticMetaObject_006071e0,0x368dc0);\n  QWidget::setToolTip((QString *)this);\n  if (*local_28[0] != 0) {\n    if (*local_28[0] == -1) goto LAB_002adc7c;\n    LOCK();\n    *local_28[0] = *local_28[0] + -1;\n    UNLOCK();\n    if (*local_28[0] != 0) goto LAB_002adc7c;\n  }\n  QArrayData::deallocate((QArrayData *)local_28[0],2,8);\nLAB_002adc7c:\n  uVar1 = 0;\n  if ((*(long *)(param_1 + 0x10) != 0) && (*(int *)(*(long *)(param_1 + 0x10) + 4) != 0)) {\n    uVar1 = *(undefined8 *)(param_1 + 0x18);\n  }\n  FUN_002ae0f0(uVar1);\n  QComboBox::setModel((QAbstractItemModel *)this);\n  QComboBox::setCurrentIndex((int)this);\n  QObject::connect((QObject *)local_28,(char *)this,(QObject *)\"2activated(int)\",param_1,0x368df0);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  QObject::connect((QObject *)local_28,param_1,(QObject *)\"2currentIndexChanged(int)\",(char *)this,\n                   0x368e22);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  return this;\n}",
        "similarity_score_unixcoder": 0.6267728805541992,
        "similarity_score_baseline_stripped": 0.600432276725769
    },
    {
        "func_name": "sipQgsCalloutWidget::sipProtectVirt_event",
        "normed_func_sha256": "ac69765da0ed4cf3151c8fbe35de79ff95d20beabfe09e2e7d72ebc0a4eb9190",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sipQgsCalloutWidget::sipProtectVirt_event(bool param_1,QEvent *param_2)\n{\n  undefined3 in_stack_00000005;\n  if ((char)param_2 == '\\0') {\n    (**(code **)(*_param_1 + 0x14))();\n    return;\n  }\n  QWidget::event((QEvent *)_param_1);\n  return;\n}",
        "output": "void sipQgsCalloutWidget::sipProtectVirt_event(bool param_1, QEvent *param_2)\n{\n    undefined3 in_stack_00000005;\n    \n    if ((char)param_2 == '\\0') {\n        (**(code **)(_param_1 + 0x14))();\n        return;\n    }\n    \n    QWidget::event((QEvent *)_param_1);\n    return;\n}",
        "source_code": "bool sipQgsCalloutWidget::sipProtectVirt_event(bool sipSelfWasArg, ::QEvent*a0)\n{\n    return (sipSelfWasArg ? ::QWidget::event(a0) : event(a0));\n}",
        "parsed_output": "void sipQgsCalloutWidget::sipProtectVirt_event(bool param_1, QEvent *param_2)\n{\n    undefined3 in_stack_00000005;\n    \n    if ((char)param_2 == '\\0') {\n        (**(code **)(_param_1 + 0x14))();\n        return;\n    }\n    \n    QWidget::event((QEvent *)_param_1);\n    return;\n}",
        "baseline_code_stripped": "void sipQgsCalloutWidget::sipProtectVirt_event(bool param_1,QEvent *param_2)\n{\n  undefined3 in_stack_00000005;\n  if ((char)param_2 == '\\0') {\n    (**(code **)(*_param_1 + 0x14))();\n    return;\n  }\n  QWidget::event((QEvent *)_param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.762726902961731,
        "similarity_score_baseline_stripped": 0.7690246105194092
    },
    {
        "func_name": "convertFrom_QList_0600QPair_0100QByteArray_0100QString",
        "normed_func_sha256": "7a3ea3592ffa9eb9b27f12647e5fec6fa8dd1743e7790265f6ed06bc19915040",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint * convertFrom_QList_0600QPair_0100QByteArray_0100QString(int *param_1,undefined4 param_2)\n{\n  bool bVar1;\n  int *piVar2;\n  int **ppiVar3;\n  int **ppiVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int *piVar9;\n  int iVar10;\n  int **ppiVar11;\n  piVar2 = (int *)PyList_New(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8));\n  if (piVar2 != (int *)0x0) {\n    iVar7 = *param_1;\n    iVar8 = *(int *)(iVar7 + 8);\n    if (0 < *(int *)(iVar7 + 0xc) - iVar8) {\n      iVar10 = 0;\n      do {\n        ppiVar11 = *(int ***)(iVar7 + (iVar8 + iVar10) * 4 + 0x14);\n        ppiVar3 = (int **)operator_new(4);\n        piVar9 = *ppiVar11;\n        *ppiVar3 = piVar9;\n        do {\n          bVar1 = (bool)hasExclusiveAccess(piVar9);\n        } while (!bVar1);\n        *piVar9 = *piVar9 + 1;\n        ppiVar4 = (int **)operator_new(4);\n        piVar9 = ppiVar11[1];\n        *ppiVar4 = piVar9;\n        do {\n          bVar1 = (bool)hasExclusiveAccess(piVar9);\n        } while (!bVar1);\n        *piVar9 = *piVar9 + 1;\n        iVar5 = (**(code **)(sipAPI_phonon + 0x1c))\n                          (0,&DAT_00063480,ppiVar3,sipImportedTypes_phonon_QtCore._4_4_,param_2,\n                           ppiVar4,sipImportedTypes_phonon_QtCore._56_4_,param_2);\n        if (iVar5 == 0) {\n          iVar7 = *piVar2;\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            (**(code **)(piVar2[1] + 0x18))(piVar2);\n          }\n          piVar2 = *ppiVar3;\n          do {\n            iVar7 = *piVar2;\n            bVar1 = (bool)hasExclusiveAccess(piVar2);\n          } while (!bVar1);\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            qFree(*ppiVar3);\n          }\n          operator_delete(ppiVar3,4);\n          piVar2 = *ppiVar4;\n          do {\n            iVar7 = *piVar2;\n            bVar1 = (bool)hasExclusiveAccess(piVar2);\n          } while (!bVar1);\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            QString::free((Data *)*ppiVar4);\n          }\n          operator_delete(ppiVar4,4);\n          return (int *)0x0;\n        }\n        iVar7 = *param_1;\n        iVar8 = *(int *)(iVar7 + 8);\n        iVar6 = *(int *)(iVar7 + 0xc);\n        *(int *)(piVar2[3] + iVar10 * 4) = iVar5;\n        iVar10 = iVar10 + 1;\n      } while (iVar10 < iVar6 - iVar8);\n    }\n  }\n  return piVar2;\n}",
        "output": "```c\nint * convertFrom_QList_QPair_QByteArray_QString(int *param_1, undefined4 param_2)\n{\n    bool bVar1;\n    int *result;\n    int **ppiVar3;\n    int **ppiVar4;\n    int iVar5;\n    int iVar6;\n    int iVar7;\n    int iVar8;\n    int *piVar9;\n    int iVar10;\n    int **ppiVar11;\n    \n    result = (int *)PyList_New(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8));\n    if (result != (int *)0x0) {\n        iVar7 = *param_1;\n        iVar8 = *(int *)(iVar7 + 8);\n        if (0 < *(int *)(iVar7 + 0xc) - iVar8) {\n            iVar10 = 0;\n            do {\n                ppiVar11 = *(int ***)(iVar7 + (iVar8 + iVar10) * 4 + 0x14);\n                ppiVar3 = (int **)operator_new(4);\n                piVar9 = *ppiVar11;\n                *ppiVar3 = piVar9;\n                do {\n                    bVar1 = (bool)hasExclusiveAccess(piVar9);\n                } while (!bVar1);\n                *piVar9 = *piVar9 + 1;\n                ppiVar4 = (int **)operator_new(4);\n                piVar9 = ppiVar11[1];\n                *ppiVar4 = piVar9;\n                do {\n                    bVar1 = (bool)hasExclusiveAccess(piVar9);\n                } while (!bVar1);\n                *piVar9 = *piVar9 + 1;\n                iVar5 = (**(code **)(sipAPI_phonon + 0x1c))(0, &DAT_00063480, ppiVar3, sipImportedTypes_phonon_QtCore._4_4_, param_2, ppiVar4, sipImportedTypes_phonon_QtCore._56_4_, param_2);\n                if (iVar5 == 0) {\n                    iVar7 = *result;\n                    *result = iVar7 - 1;\n                    if (iVar7 - 1 == 0) {\n                        (**(code **)(result[1] + 0x18))(result);\n                    }\n                    result = *ppiVar3;\n                    do {\n                        iVar7 = *result;\n                        bVar1 = (bool)hasExclusiveAccess(result);\n                    } while (!bVar1);\n                    *result = iVar7 - 1;\n                    if (iVar7 - 1 == 0) {\n                        qFree(*ppiVar3);\n                    }\n                    operator_delete(ppiVar3, 4);\n                    result = *ppiVar4;\n                    do {\n                        iVar7 = *result;\n                        bVar1 = (bool)hasExclusiveAccess(result);\n                    } while (!bVar1);\n                    *result = iVar7 - 1;\n                    if (iVar7 - 1 == 0) {\n                        QString::free((Data *)*ppiVar4);\n                    }\n                    operator_delete(ppiVar4, 4);\n                    return (int *)0x0;\n                }\n                iVar7 = *param_1;\n                iVar8 = *(int *)(iVar7 + 8);\n                iVar6 = *(int *)(iVar7 + 0xc);\n                *(int *)(result[3] + iVar10 * 4) = iVar5;\n                iVar10 = iVar10 + 1;\n            } while (iVar10 < iVar6 - iVar8);\n        }\n    }\n    return result;\n}\n```",
        "source_code": "static PyObject *convertFrom_QList_0600QPair_0100QByteArray_0100QString(void *sipCppV, PyObject *sipTransferObj)\n{\n   QList<QPair<QByteArray,QString> > *sipCpp = reinterpret_cast<QList<QPair<QByteArray,QString> > *>(sipCppV);\n\n#line 201 \"/usr/share/python3-sip/PyQt4/QtCore/qlist.sip\"\n    // Create the list.\n    PyObject *l;\n\n    if ((l = PyList_New(sipCpp->size())) == NULL)\n        return NULL;\n\n    // Set the list elements.\n    for (int i = 0; i < sipCpp->size(); ++i)\n    {\n        const QPair<QByteArray, QString> &p = sipCpp->at(i);\n        QByteArray *s1 = new QByteArray(p.first);\n        QString *s2 = new QString(p.second);\n        PyObject *pobj;\n\n        if ((pobj = sipBuildResult(NULL, \"(NN)\", s1, sipType_QByteArray, sipTransferObj, s2, sipType_QString, sipTransferObj)) == NULL)\n        {\n            Py_DECREF(l);\n            delete s1;\n            delete s2;\n\n            return NULL;\n        }\n\n        PyList_SET_ITEM(l, i, pobj);\n    }\n\n    return l;\n#line 1135 \"/builddir/build/BUILD/pykde4-4.14.3/armv7hl-python3/sip/phonon/sipphononpart1.cpp\"\n}",
        "parsed_output": "int * convertFrom_QList_QPair_QByteArray_QString(int *param_1, undefined4 param_2)\n{\n    bool bVar1;\n    int *result;\n    int **ppiVar3;\n    int **ppiVar4;\n    int iVar5;\n    int iVar6;\n    int iVar7;\n    int iVar8;\n    int *piVar9;\n    int iVar10;\n    int **ppiVar11;\n    \n    result = (int *)PyList_New(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8));\n    if (result != (int *)0x0) {\n        iVar7 = *param_1;\n        iVar8 = *(int *)(iVar7 + 8);\n        if (0 < *(int *)(iVar7 + 0xc) - iVar8) {\n            iVar10 = 0;\n            do {\n                ppiVar11 = *(int ***)(iVar7 + (iVar8 + iVar10) * 4 + 0x14);\n                ppiVar3 = (int **)operator_new(4);\n                piVar9 = *ppiVar11;\n                *ppiVar3 = piVar9;\n                do {\n                    bVar1 = (bool)hasExclusiveAccess(piVar9);\n                } while (!bVar1);\n                *piVar9 = *piVar9 + 1;\n                ppiVar4 = (int **)operator_new(4);\n                piVar9 = ppiVar11[1];\n                *ppiVar4 = piVar9;\n                do {\n                    bVar1 = (bool)hasExclusiveAccess(piVar9);\n                } while (!bVar1);\n                *piVar9 = *piVar9 + 1;\n                iVar5 = (**(code **)(sipAPI_phonon + 0x1c))(0, &DAT_00063480, ppiVar3, sipImportedTypes_phonon_QtCore._4_4_, param_2, ppiVar4, sipImportedTypes_phonon_QtCore._56_4_, param_2);\n                if (iVar5 == 0) {\n                    iVar7 = *result;\n                    *result = iVar7 - 1;\n                    if (iVar7 - 1 == 0) {\n                        (**(code **)(result[1] + 0x18))(result);\n                    }\n                    result = *ppiVar3;\n                    do {\n                        iVar7 = *result;\n                        bVar1 = (bool)hasExclusiveAccess(result);\n                    } while (!bVar1);\n                    *result = iVar7 - 1;\n                    if (iVar7 - 1 == 0) {\n                        qFree(*ppiVar3);\n                    }\n                    operator_delete(ppiVar3, 4);\n                    result = *ppiVar4;\n                    do {\n                        iVar7 = *result;\n                        bVar1 = (bool)hasExclusiveAccess(result);\n                    } while (!bVar1);\n                    *result = iVar7 - 1;\n                    if (iVar7 - 1 == 0) {\n                        QString::free((Data *)*ppiVar4);\n                    }\n                    operator_delete(ppiVar4, 4);\n                    return (int *)0x0;\n                }\n                iVar7 = *param_1;\n                iVar8 = *(int *)(iVar7 + 8);\n                iVar6 = *(int *)(iVar7 + 0xc);\n                *(int *)(result[3] + iVar10 * 4) = iVar5;\n                iVar10 = iVar10 + 1;\n            } while (iVar10 < iVar6 - iVar8);\n        }\n    }\n    return result;\n}",
        "baseline_code_stripped": "int * convertFrom_QList_0600QPair_0100QByteArray_0100QString(int *param_1,undefined4 param_2)\n{\n  bool bVar1;\n  int *piVar2;\n  int **ppiVar3;\n  int **ppiVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int *piVar9;\n  int iVar10;\n  int **ppiVar11;\n  piVar2 = (int *)PyList_New(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8));\n  if (piVar2 != (int *)0x0) {\n    iVar7 = *param_1;\n    iVar8 = *(int *)(iVar7 + 8);\n    if (0 < *(int *)(iVar7 + 0xc) - iVar8) {\n      iVar10 = 0;\n      do {\n        ppiVar11 = *(int ***)(iVar7 + (iVar8 + iVar10) * 4 + 0x14);\n        ppiVar3 = (int **)operator_new(4);\n        piVar9 = *ppiVar11;\n        *ppiVar3 = piVar9;\n        do {\n          bVar1 = (bool)hasExclusiveAccess(piVar9);\n        } while (!bVar1);\n        *piVar9 = *piVar9 + 1;\n        ppiVar4 = (int **)operator_new(4);\n        piVar9 = ppiVar11[1];\n        *ppiVar4 = piVar9;\n        do {\n          bVar1 = (bool)hasExclusiveAccess(piVar9);\n        } while (!bVar1);\n        *piVar9 = *piVar9 + 1;\n        iVar5 = (**(code **)(sipAPI_phonon + 0x1c))\n                          (0,&DAT_00063480,ppiVar3,sipImportedTypes_phonon_QtCore._4_4_,param_2,\n                           ppiVar4,sipImportedTypes_phonon_QtCore._56_4_,param_2);\n        if (iVar5 == 0) {\n          iVar7 = *piVar2;\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            (**(code **)(piVar2[1] + 0x18))(piVar2);\n          }\n          piVar2 = *ppiVar3;\n          do {\n            iVar7 = *piVar2;\n            bVar1 = (bool)hasExclusiveAccess(piVar2);\n          } while (!bVar1);\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            qFree(*ppiVar3);\n          }\n          operator_delete(ppiVar3,4);\n          piVar2 = *ppiVar4;\n          do {\n            iVar7 = *piVar2;\n            bVar1 = (bool)hasExclusiveAccess(piVar2);\n          } while (!bVar1);\n          *piVar2 = iVar7 + -1;\n          if (iVar7 + -1 == 0) {\n            QString::free((Data *)*ppiVar4);\n          }\n          operator_delete(ppiVar4,4);\n          return (int *)0x0;\n        }\n        iVar7 = *param_1;\n        iVar8 = *(int *)(iVar7 + 8);\n        iVar6 = *(int *)(iVar7 + 0xc);\n        *(int *)(piVar2[3] + iVar10 * 4) = iVar5;\n        iVar10 = iVar10 + 1;\n      } while (iVar10 < iVar6 - iVar8);\n    }\n  }\n  return piVar2;\n}",
        "similarity_score_unixcoder": 0.6980525255203247,
        "similarity_score_baseline_stripped": 0.6956297755241394
    },
    {
        "func_name": "deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0",
        "normed_func_sha256": "fe770ba5a4e665e092881b81fcb5444008a05e9be595e646a7286940b40a982e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(long param_1)\n{\n  int iVar1;\n  long lVar2;\n  lVar2 = 0;\n  do {\n    *(undefined8 *)(*(long *)(param_1 + 0x1c0) + lVar2) = 0;\n    lVar2 = lVar2 + 8;\n  } while (lVar2 != 0x2880);\n  iVar1 = *(int *)(param_1 + 0x33c);\n  if (0 < iVar1) {\n    lVar2 = param_1;\n    do {\n      deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq\n                (lVar2,*(undefined8 *)(param_1 + 0x1c0));\n      lVar2 = lVar2 + 0x340;\n    } while (lVar2 != ((ulong)(iVar1 - 1) + 1) * 0x340 + param_1);\n  }\n  lVar2 = *(long *)(param_1 + 0x1c0);\n  *(long *)(param_1 + 0x1d0) = lVar2 + 0x21c0;\n  *(long *)(param_1 + 0x1d8) = lVar2 + 0x1b00;\n  *(long *)(param_1 + 0x1e0) = lVar2 + 0x1440;\n  *(long *)(param_1 + 0x1e8) = lVar2 + 0xd80;\n  *(long *)(param_1 + 0x1f0) = lVar2 + 0x6c0;\n  *(long *)(param_1 + 0x1f8) = lVar2;\n  return;\n}",
        "output": "void initializeMemory(long param_1)\n{\n    long offset = 0;\n    \n    // Initialize memory block with zeros\n    do {\n        *(long *)(*(long *)(param_1 + 0x1c0) + offset) = 0;\n        offset += 8;\n    } while (offset != 0x2880);\n    \n    int numIterations = *(int *)(param_1 + 0x33c);\n    \n    // Perform necessary operations based on the number of iterations\n    if (numIterations > 0) {\n        long currentAddress = param_1;\n        \n        do {\n            performPrerequisiteOperation(currentAddress, *(long *)(param_1 + 0x1c0));\n            currentAddress += 0x340;\n        } while (currentAddress != ((ulong)(numIterations - 1) + 1) * 0x340 + param_1);\n    }\n    \n    // Set memory block offsets\n    long baseAddress = *(long *)(param_1 + 0x1c0);\n    *(long *)(param_1 + 0x1d0) = baseAddress + 0x21c0;\n    *(long *)(param_1 + 0x1d8) = baseAddress + 0x1b00;\n    *(long *)(param_1 + 0x1e0) = baseAddress + 0x1440;\n    *(long *)(param_1 + 0x1e8) = baseAddress + 0xd80;\n    *(long *)(param_1 + 0x1f0) = baseAddress + 0x6c0;\n    *(long *)(param_1 + 0x1f8) = baseAddress;\n}",
        "source_code": "void deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(const Libint_t* inteval) {\n\n_libint2_static_api_bzero_short_(inteval->stack+0*1,1296)\nconst int contrdepth = inteval->contrdepth;\n#ifdef __INTEL_COMPILER\n#pragma ivdep\n#endif\nfor(int c = 0; c<contrdepth; c++) {\nderiv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq(inteval+c, inteval->stack);\n}\n\nLIBINT2_REALTYPE*const  stack = inteval->stack;\n{\nconst int hsi = 0;\n{\nconst int lsi = 0;\n{\nconst int vi = 0;\n}\n}\n}\nconst int hsi = 0;\nconst int lsi = 0;\nconst int vi = 0;\ninteval->targets[0] = &(inteval->stack[((hsi*216+1080)*1+lsi)*1]);\ninteval->targets[1] = &(inteval->stack[((hsi*216+864)*1+lsi)*1]);\ninteval->targets[2] = &(inteval->stack[((hsi*216+648)*1+lsi)*1]);\ninteval->targets[3] = &(inteval->stack[((hsi*216+432)*1+lsi)*1]);\ninteval->targets[4] = &(inteval->stack[((hsi*216+216)*1+lsi)*1]);\ninteval->targets[5] = &(inteval->stack[((hsi*216+0)*1+lsi)*1]);\n/** Number of flops = 0 */\n}",
        "parsed_output": "void initializeMemory(long param_1)\n{\n    long offset = 0;\n    \n    // Initialize memory block with zeros\n    do {\n        *(long *)(*(long *)(param_1 + 0x1c0) + offset) = 0;\n        offset += 8;\n    } while (offset != 0x2880);\n    \n    int numIterations = *(int *)(param_1 + 0x33c);\n    \n    // Perform necessary operations based on the number of iterations\n    if (numIterations > 0) {\n        long currentAddress = param_1;\n        \n        do {\n            performPrerequisiteOperation(currentAddress, *(long *)(param_1 + 0x1c0));\n            currentAddress += 0x340;\n        } while (currentAddress != ((ulong)(numIterations - 1) + 1) * 0x340 + param_1);\n    }\n    \n    // Set memory block offsets\n    long baseAddress = *(long *)(param_1 + 0x1c0);\n    *(long *)(param_1 + 0x1d0) = baseAddress + 0x21c0;\n    *(long *)(param_1 + 0x1d8) = baseAddress + 0x1b00;\n    *(long *)(param_1 + 0x1e0) = baseAddress + 0x1440;\n    *(long *)(param_1 + 0x1e8) = baseAddress + 0xd80;\n    *(long *)(param_1 + 0x1f0) = baseAddress + 0x6c0;\n    *(long *)(param_1 + 0x1f8) = baseAddress;\n}",
        "baseline_code_stripped": "void deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(long param_1)\n{\n  int iVar1;\n  long lVar2;\n  lVar2 = 0;\n  do {\n    *(undefined8 *)(*(long *)(param_1 + 0x1c0) + lVar2) = 0;\n    lVar2 = lVar2 + 8;\n  } while (lVar2 != 0x2880);\n  iVar1 = *(int *)(param_1 + 0x33c);\n  if (0 < iVar1) {\n    lVar2 = param_1;\n    do {\n      deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq\n                (lVar2,*(undefined8 *)(param_1 + 0x1c0));\n      lVar2 = lVar2 + 0x340;\n    } while (lVar2 != ((ulong)(iVar1 - 1) + 1) * 0x340 + param_1);\n  }\n  lVar2 = *(long *)(param_1 + 0x1c0);\n  *(long *)(param_1 + 0x1d0) = lVar2 + 0x21c0;\n  *(long *)(param_1 + 0x1d8) = lVar2 + 0x1b00;\n  *(long *)(param_1 + 0x1e0) = lVar2 + 0x1440;\n  *(long *)(param_1 + 0x1e8) = lVar2 + 0xd80;\n  *(long *)(param_1 + 0x1f0) = lVar2 + 0x6c0;\n  *(long *)(param_1 + 0x1f8) = lVar2;\n  return;\n}",
        "similarity_score_unixcoder": 0.5376756191253662,
        "similarity_score_baseline_stripped": 0.6332758665084839
    },
    {
        "func_name": "nestingLevelsPop",
        "normed_func_sha256": "fed6f55e68b006614df7e0874e422ccaab85dd29f146fcb432636f524f024aac",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_003cfbf8(long param_1)\n{\n  long lVar1;\n  lVar1 = FUN_003cfc54(param_1);\n  if (lVar1 == 0) {\n    FUN_003cd9b6(\"Assert(nl != NULL) failed!\");\n  }\n  FUN_003e6e64(*(undefined8 *)(lVar1 + 8));\n  *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + -1;\n  return;\n}",
        "output": "void processParameter(long param_1)\n{\n    long result = calculateResult(param_1);\n    \n    if (result == 0) {\n        displayErrorMessage(\"Assert(nl != NULL) failed!\");\n    }\n    \n    processData(*(long *)(result + 8));\n    *(int *)(param_1 + 8) = *(int *)(param_1 + 8) - 1;\n}",
        "source_code": "extern void nestingLevelsPop(NestingLevels *nls)\n{\n\tconst NestingLevel *nl = nestingLevelsGetCurrent(nls);\n\n\tAssert (nl != NULL);\n\tvStringClear(nl->name);\n\tnls->n--;\n}",
        "parsed_output": "void processParameter(long param_1)\n{\n    long result = calculateResult(param_1);\n    \n    if (result == 0) {\n        displayErrorMessage(\"Assert(nl != NULL) failed!\");\n    }\n    \n    processData(*(long *)(result + 8));\n    *(int *)(param_1 + 8) = *(int *)(param_1 + 8) - 1;\n}",
        "baseline_code_stripped": "void FUN_003cfbf8(long param_1)\n{\n  long lVar1;\n  lVar1 = FUN_003cfc54(param_1);\n  if (lVar1 == 0) {\n    FUN_003cd9b6(\"Assert(nl != NULL) failed!\");\n  }\n  FUN_003e6e64(*(undefined8 *)(lVar1 + 8));\n  *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + -1;\n  return;\n}",
        "similarity_score_unixcoder": 0.3836105167865753,
        "similarity_score_baseline_stripped": 0.41622424125671387
    },
    {
        "func_name": "QHttpNetworkConnection::qt_metacall",
        "normed_func_sha256": "9624e51b8d35c33a2f7d4c3d677f91eabbf69d0e44328b8e4af290b708d5287e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_00060360(Call param_1,int param_2,void **param_3,undefined4 param_4)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall(param_1,param_2,param_3);\n  if ((-1 < iVar1) && (param_2 == 0)) {\n    if (iVar1 == 0) {\n      FUN_00060330(param_1,0,0,param_4);\n    }\n    iVar1 = iVar1 + -1;\n  }\n  return iVar1;\n}",
        "output": "int processFunction(Call call, int param2, void **param3, undefined4 param4) {\n    int result = QObject::qt_metacall(call, param2, param3);\n    \n    if (result >= 0 && param2 == 0) {\n        if (result == 0) {\n            customFunction(call, 0, 0, param4);\n        }\n        result--;\n    }\n    \n    return result;\n}",
        "source_code": "int QHttpNetworkConnection::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 1)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 1;\n    }\n    return _id;\n}",
        "parsed_output": "int processFunction(Call call, int param2, void **param3, undefined4 param4) {\n    int result = QObject::qt_metacall(call, param2, param3);\n    \n    if (result >= 0 && param2 == 0) {\n        if (result == 0) {\n            customFunction(call, 0, 0, param4);\n        }\n        result--;\n    }\n    \n    return result;\n}",
        "baseline_code_stripped": "int FUN_00060360(Call param_1,int param_2,void **param_3,undefined4 param_4)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall(param_1,param_2,param_3);\n  if ((-1 < iVar1) && (param_2 == 0)) {\n    if (iVar1 == 0) {\n      FUN_00060330(param_1,0,0,param_4);\n    }\n    iVar1 = iVar1 + -1;\n  }\n  return iVar1;\n}",
        "similarity_score_unixcoder": 0.6547756791114807,
        "similarity_score_baseline_stripped": 0.5951101779937744
    },
    {
        "func_name": "PythonQtWrapper_QTextInlineObject::qt_metacast",
        "normed_func_sha256": "52e45914ccb46f45a5c8374254562585c526c97b54779133ec2d5b88a0b516be",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall\nPythonQtWrapper_QTextInlineObject::qt_metacast\n          (PythonQtWrapper_QTextInlineObject *this,char *param_1)\n{\n  int iVar1;\n  if (param_1 == (char *)0x0) {\n    return;\n  }\n  iVar1 = strcmp(param_1,\"PythonQtWrapper_QTextInlineObject\");\n  if (iVar1 == 0) {\n    return;\n  }\n  QObject::qt_metacast((char *)this);\n  return;\n}",
        "output": "void __thiscall PythonQtWrapper_QTextInlineObject::qt_metacast(PythonQtWrapper_QTextInlineObject *this, char *param_1)\n{\n    if (param_1 == nullptr) {\n        return;\n    }\n    \n    if (strcmp(param_1, \"PythonQtWrapper_QTextInlineObject\") == 0) {\n        return;\n    }\n    \n    QObject::qt_metacast((char *)this);\n}",
        "source_code": "void *PythonQtWrapper_QTextInlineObject::qt_metacast(const char *_clname)\n{\n    if (!_clname) return 0;\n    if (!strcmp(_clname, qt_meta_stringdata_PythonQtWrapper_QTextInlineObject))\n        return static_cast<void*>(const_cast< PythonQtWrapper_QTextInlineObject*>(this));\n    return QObject::qt_metacast(_clname);\n}",
        "parsed_output": "void __thiscall PythonQtWrapper_QTextInlineObject::qt_metacast(PythonQtWrapper_QTextInlineObject *this, char *param_1)\n{\n    if (param_1 == nullptr) {\n        return;\n    }\n    \n    if (strcmp(param_1, \"PythonQtWrapper_QTextInlineObject\") == 0) {\n        return;\n    }\n    \n    QObject::qt_metacast((char *)this);\n}",
        "baseline_code_stripped": "void __thiscall\nPythonQtWrapper_QTextInlineObject::qt_metacast\n          (PythonQtWrapper_QTextInlineObject *this,char *param_1)\n{\n  int iVar1;\n  if (param_1 == (char *)0x0) {\n    return;\n  }\n  iVar1 = strcmp(param_1,\"PythonQtWrapper_QTextInlineObject\");\n  if (iVar1 == 0) {\n    return;\n  }\n  QObject::qt_metacast((char *)this);\n  return;\n}",
        "similarity_score_unixcoder": 0.850591242313385,
        "similarity_score_baseline_stripped": 0.8272057771682739
    },
    {
        "func_name": "visit",
        "normed_func_sha256": "ae88971c0f179255c3cfb93064a9d2d4bb4718c308e678b8275656461256d590",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0046c108(undefined8 param_1,undefined8 param_2)\n{\n  longlong lVar1;\n  FUN_0032d060(param_2,param_1);\n  lVar1 = FUN_00460d10(param_1,param_2);\n  if (lVar1 == 0) {\n    FUN_00454ffc(param_1,param_2);\n  }\n  return;\n}",
        "output": "```c\nvoid process_data(undefined8 data1, undefined8 data2)\n{\n    FUN_0032d060(data2, data1);\n    long long result = FUN_00460d10(data1, data2);\n    \n    if (result == 0) {\n        FUN_00454ffc(data1, data2);\n    }\n}\n```",
        "source_code": "void visit(AstIsUnbounded* nodep) override {\n        iterateChildren(nodep);\n        if (match_NodeUniop_0(nodep)) return;\n        if (match_IsUnbounded_0(nodep)) return;\n    }",
        "parsed_output": "void process_data(undefined8 data1, undefined8 data2)\n{\n    FUN_0032d060(data2, data1);\n    long long result = FUN_00460d10(data1, data2);\n    \n    if (result == 0) {\n        FUN_00454ffc(data1, data2);\n    }\n}",
        "baseline_code_stripped": "void FUN_0046c108(undefined8 param_1,undefined8 param_2)\n{\n  longlong lVar1;\n  FUN_0032d060(param_2,param_1);\n  lVar1 = FUN_00460d10(param_1,param_2);\n  if (lVar1 == 0) {\n    FUN_00454ffc(param_1,param_2);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.4657653868198395,
        "similarity_score_baseline_stripped": 0.4774513840675354
    },
    {
        "func_name": "==",
        "normed_func_sha256": "c750e63b0f21814df967a9bf10ce086aa010dac239cf3c1392cefdf2b2e407f9",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_0011c4e0(long *param_1,long *param_2)\n{\n  byte bVar1;\n  long lVar2;\n  long lVar3;\n  int iVar4;\n  undefined8 uVar5;\n  undefined4 extraout_var;\n  size_t sVar6;\n  uint uVar7;\n  uint uVar8;\n  uVar5 = 1;\n  lVar2 = *param_1;\n  lVar3 = *param_2;\n  if (lVar2 != lVar3) {\n    uVar8 = (uint)*(byte *)(lVar2 + 1);\n    if (*(byte *)(lVar2 + 1) == 0xff) {\n      sVar6 = strlen((char *)(lVar2 + 0x101));\n      bVar1 = *(byte *)(lVar3 + 1);\n      uVar8 = (int)sVar6 + 0xff;\n    }\n    else {\n      bVar1 = *(byte *)(lVar3 + 1);\n    }\n    if (bVar1 == 0xff) {\n      sVar6 = strlen((char *)(lVar3 + 0x101));\n      uVar7 = (int)sVar6 + 0xff;\n    }\n    else {\n      uVar7 = (uint)bVar1;\n    }\n    uVar5 = 0;\n    if (uVar7 == uVar8) {\n      iVar4 = memcmp((void *)(lVar2 + 2),(void *)(lVar3 + 2),(long)(int)uVar7);\n      return CONCAT71((int7)(CONCAT44(extraout_var,iVar4) >> 8),iVar4 == 0);\n    }\n  }\n  return uVar5;\n}",
        "output": "```c\nuint8_t compare_strings(long *str1, long *str2)\n{\n    uint8_t result = 1;\n    long addr1 = *str1;\n    long addr2 = *str2;\n    \n    if (addr1 != addr2) {\n        uint8_t byte1 = *(uint8_t *)(addr1 + 1);\n        uint8_t byte2 = *(uint8_t *)(addr2 + 1);\n        \n        if (byte1 == 0xff) {\n            size_t len1 = strlen((char *)(addr1 + 0x101));\n            byte1 = *(uint8_t *)(addr2 + 1);\n            byte1 = (int)len1 + 0xff;\n        }\n        \n        if (byte2 == 0xff) {\n            size_t len2 = strlen((char *)(addr2 + 0x101));\n            uint8_t temp = (int)len2 + 0xff;\n            byte2 = temp;\n        }\n        \n        result = 0;\n        \n        if (byte2 == byte1) {\n            int comparison = memcmp((void *)(addr1 + 2), (void *)(addr2 + 2), (int)byte2);\n            return (comparison == 0);\n        }\n    }\n    \n    return result;\n}\n```",
        "source_code": "bool operator == (const c4_String &a, const c4_String &b) {\n  return a._value == b._value || a.GetLength() == b.GetLength() && memcmp\n    (a.Data(), b.Data(), a.GetLength()) == 0;\n}",
        "parsed_output": "uint8_t compare_strings(long *str1, long *str2)\n{\n    uint8_t result = 1;\n    long addr1 = *str1;\n    long addr2 = *str2;\n    \n    if (addr1 != addr2) {\n        uint8_t byte1 = *(uint8_t *)(addr1 + 1);\n        uint8_t byte2 = *(uint8_t *)(addr2 + 1);\n        \n        if (byte1 == 0xff) {\n            size_t len1 = strlen((char *)(addr1 + 0x101));\n            byte1 = *(uint8_t *)(addr2 + 1);\n            byte1 = (int)len1 + 0xff;\n        }\n        \n        if (byte2 == 0xff) {\n            size_t len2 = strlen((char *)(addr2 + 0x101));\n            uint8_t temp = (int)len2 + 0xff;\n            byte2 = temp;\n        }\n        \n        result = 0;\n        \n        if (byte2 == byte1) {\n            int comparison = memcmp((void *)(addr1 + 2), (void *)(addr2 + 2), (int)byte2);\n            return (comparison == 0);\n        }\n    }\n    \n    return result;\n}",
        "baseline_code_stripped": "undefined8 FUN_0011c4e0(long *param_1,long *param_2)\n{\n  byte bVar1;\n  long lVar2;\n  long lVar3;\n  int iVar4;\n  undefined8 uVar5;\n  undefined4 extraout_var;\n  size_t sVar6;\n  uint uVar7;\n  uint uVar8;\n  uVar5 = 1;\n  lVar2 = *param_1;\n  lVar3 = *param_2;\n  if (lVar2 != lVar3) {\n    uVar8 = (uint)*(byte *)(lVar2 + 1);\n    if (*(byte *)(lVar2 + 1) == 0xff) {\n      sVar6 = strlen((char *)(lVar2 + 0x101));\n      bVar1 = *(byte *)(lVar3 + 1);\n      uVar8 = (int)sVar6 + 0xff;\n    }\n    else {\n      bVar1 = *(byte *)(lVar3 + 1);\n    }\n    if (bVar1 == 0xff) {\n      sVar6 = strlen((char *)(lVar3 + 0x101));\n      uVar7 = (int)sVar6 + 0xff;\n    }\n    else {\n      uVar7 = (uint)bVar1;\n    }\n    uVar5 = 0;\n    if (uVar7 == uVar8) {\n      iVar4 = memcmp((void *)(lVar2 + 2),(void *)(lVar3 + 2),(long)(int)uVar7);\n      return CONCAT71((int7)(CONCAT44(extraout_var,iVar4) >> 8),iVar4 == 0);\n    }\n  }\n  return uVar5;\n}",
        "similarity_score_unixcoder": 0.6917825937271118,
        "similarity_score_baseline_stripped": 0.5299978852272034
    },
    {
        "func_name": "gen_vec_unpacks_hi_v8qi",
        "normed_func_sha256": "aae7a297ccb133c32b068d5715c4c0574804a336d54ae23be9812b4b81fb8e43",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid gen_aarch64_addpv2si(rtx_def *param_1,rtx_def *param_2,rtx_def *param_3)\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  uVar1 = gen_rtvec(2);\n  iVar2 = rtx_alloc(0x14);\n  *(undefined *)(iVar2 + 2) = 0x42;\n  *(undefined4 *)(iVar2 + 8) = uVar1;\n  *(undefined4 *)(iVar2 + 0xc) = 0xd6;\n  iVar3 = rtx_alloc(0x19);\n  *(rtx_def **)(iVar3 + 8) = param_1;\n  *(undefined *)(iVar3 + 2) = 0;\n  *(int *)(iVar3 + 0xc) = iVar2;\n  return;\n}",
        "output": "void gen_aarch64_addpv2si(rtx_def *param_1, rtx_def *param_2, rtx_def *param_3)\n{\n    undefined4 uVar1;\n    int iVar2;\n    int iVar3;\n    \n    uVar1 = gen_rtvec(2);\n    iVar2 = rtx_alloc(0x14);\n    *(undefined *)(iVar2 + 2) = 0x42;\n    *(undefined4 *)(iVar2 + 8) = uVar1;\n    *(undefined4 *)(iVar2 + 0xc) = 0xd6;\n    \n    iVar3 = rtx_alloc(0x19);\n    *(rtx_def **)(iVar3 + 8) = param_1;\n    *(undefined *)(iVar3 + 2) = 0;\n    *(int *)(iVar3 + 0xc) = iVar2;\n    \n    return;\n}",
        "source_code": "rtx\ngen_vec_unpacks_hi_v8qi (rtx operand0,\n\trtx operand1)\n{\n  rtx_insn *_val = 0;\n  start_sequence ();\n  {\n    rtx operands[2];\n    operands[0] = operand0;\n    operands[1] = operand1;\n#define FAIL return (end_sequence (), _val)\n#define DONE return (_val = get_insns (), end_sequence (), _val)\n#line 799 \"../../gcc-10.2.1-20200826/gcc/config/mips/loongson-mmi.md\"\n{\n  mips_expand_vec_unpack (operands, false, true);\n  DONE;\n}\n#undef DONE\n#undef FAIL\n    operand0 = operands[0];\n    (void) operand0;\n    operand1 = operands[1];\n    (void) operand1;\n  }\n  emit (operand0, true);\n  emit (operand1, false);\n  _val = get_insns ();\n  end_sequence ();\n  return _val;\n}",
        "parsed_output": "void gen_aarch64_addpv2si(rtx_def *param_1, rtx_def *param_2, rtx_def *param_3)\n{\n    undefined4 uVar1;\n    int iVar2;\n    int iVar3;\n    \n    uVar1 = gen_rtvec(2);\n    iVar2 = rtx_alloc(0x14);\n    *(undefined *)(iVar2 + 2) = 0x42;\n    *(undefined4 *)(iVar2 + 8) = uVar1;\n    *(undefined4 *)(iVar2 + 0xc) = 0xd6;\n    \n    iVar3 = rtx_alloc(0x19);\n    *(rtx_def **)(iVar3 + 8) = param_1;\n    *(undefined *)(iVar3 + 2) = 0;\n    *(int *)(iVar3 + 0xc) = iVar2;\n    \n    return;\n}",
        "baseline_code_stripped": "void gen_aarch64_addpv2si(rtx_def *param_1,rtx_def *param_2,rtx_def *param_3)\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  uVar1 = gen_rtvec(2);\n  iVar2 = rtx_alloc(0x14);\n  *(undefined *)(iVar2 + 2) = 0x42;\n  *(undefined4 *)(iVar2 + 8) = uVar1;\n  *(undefined4 *)(iVar2 + 0xc) = 0xd6;\n  iVar3 = rtx_alloc(0x19);\n  *(rtx_def **)(iVar3 + 8) = param_1;\n  *(undefined *)(iVar3 + 2) = 0;\n  *(int *)(iVar3 + 0xc) = iVar2;\n  return;\n}",
        "similarity_score_unixcoder": 0.7078242301940918,
        "similarity_score_baseline_stripped": 0.6948696374893188
    },
    {
        "func_name": "DeliverPropertyEvent",
        "normed_func_sha256": "77620ddfa3768dbe89e4a1ce0e236b9da0899c6d79acb7632114f778d747d4a8",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 DeliverPropertyEvent(long param_1,long param_2)\n{\n  long **local_20 [2];\n  dixLookupResourceByType(local_20,*(undefined4 *)(param_1 + 4),RREventType,serverClient,1);\n  if (local_20[0] != (long **)0x0) {\n    for (local_20[0] = (long **)*local_20[0]; local_20[0] != (long **)0x0;\n        local_20[0] = (long **)*local_20[0]) {\n      while ((*(byte *)((long)local_20[0] + 0x1c) & 8) == 0) {\n        local_20[0] = (long **)*local_20[0];\n        if (local_20[0] == (long **)0x0) {\n          return 1;\n        }\n      }\n      *(undefined4 *)(param_2 + 4) = *(undefined4 *)((long)local_20[0][2] + 4);\n      WriteEventsToClient(local_20[0][1],1,param_2);\n    }\n  }\n  return 1;\n}",
        "output": "```c\nundefined8 DeliverPropertyEvent(long param_1, long param_2)\n{\n    long **resource;\n    dixLookupResourceByType(&resource, *(undefined4 *)(param_1 + 4), RREventType, serverClient, 1);\n    \n    if (resource != NULL) {\n        for (resource = (long **)*resource; resource != NULL; resource = (long **)*resource) {\n            while ((*(byte *)((long)resource + 0x1c) & 8) == 0) {\n                resource = (long **)*resource;\n                if (resource == NULL) {\n                    return 1;\n                }\n            }\n            *(undefined4 *)(param_2 + 4) = *(undefined4 *)((long)resource[2] + 4);\n            WriteEventsToClient(resource[1], 1, param_2);\n        }\n    }\n    \n    return 1;\n}\n```",
        "source_code": "static int\nDeliverPropertyEvent(WindowPtr pWin, void *value)\n{\n    xRROutputPropertyNotifyEvent *event = value;\n    RREventPtr *pHead, pRREvent;\n    dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,\n\t\t\t    RREventType, serverClient, DixReadAccess);\n    if (!pHead)\n\treturn WT_WALKCHILDREN;\n    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next)\n    {\n\tif (!(pRREvent->mask & RROutputPropertyNotifyMask))\n\t    continue;\n\tevent->window = pRREvent->window->drawable.id;\n\tWriteEventsToClient(pRREvent->client, 1, (xEvent *)event);\n    }\n    return WT_WALKCHILDREN;\n}",
        "parsed_output": "undefined8 DeliverPropertyEvent(long param_1, long param_2)\n{\n    long **resource;\n    dixLookupResourceByType(&resource, *(undefined4 *)(param_1 + 4), RREventType, serverClient, 1);\n    \n    if (resource != NULL) {\n        for (resource = (long **)*resource; resource != NULL; resource = (long **)*resource) {\n            while ((*(byte *)((long)resource + 0x1c) & 8) == 0) {\n                resource = (long **)*resource;\n                if (resource == NULL) {\n                    return 1;\n                }\n            }\n            *(undefined4 *)(param_2 + 4) = *(undefined4 *)((long)resource[2] + 4);\n            WriteEventsToClient(resource[1], 1, param_2);\n        }\n    }\n    \n    return 1;\n}",
        "baseline_code_stripped": "undefined8 DeliverPropertyEvent(long param_1,long param_2)\n{\n  long **local_20 [2];\n  dixLookupResourceByType(local_20,*(undefined4 *)(param_1 + 4),RREventType,serverClient,1);\n  if (local_20[0] != (long **)0x0) {\n    for (local_20[0] = (long **)*local_20[0]; local_20[0] != (long **)0x0;\n        local_20[0] = (long **)*local_20[0]) {\n      while ((*(byte *)((long)local_20[0] + 0x1c) & 8) == 0) {\n        local_20[0] = (long **)*local_20[0];\n        if (local_20[0] == (long **)0x0) {\n          return 1;\n        }\n      }\n      *(undefined4 *)(param_2 + 4) = *(undefined4 *)((long)local_20[0][2] + 4);\n      WriteEventsToClient(local_20[0][1],1,param_2);\n    }\n  }\n  return 1;\n}",
        "similarity_score_unixcoder": 0.7461923360824585,
        "similarity_score_baseline_stripped": 0.6649596691131592
    },
    {
        "func_name": "visit_log_not",
        "normed_func_sha256": "d3e5da4094df41f3d851e84818e97eff25511ef21ba31e2d4a46c387f5776cb3",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall WidthVisitor::visit(WidthVisitor *this,AstLogNot *param_1)\n{\n  basic_ostream *pbVar1;\n  if (*(int *)(param_1 + 0x10) != 0) {\n    V3Error::v3errorPrep(4);\n    std::__ostream_insert_char_std__char_traits_char__\n              ((basic_ostream *)&DAT_0064663c,\"../V3Width.cpp\",0xe);\n    std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c,\":\",1);\n    *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) =\n         *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) & 0xffffffb5 | 2;\n    pbVar1 = (basic_ostream *)\n             std::basic_ostream<char,std::char_traits<char>>::operator__\n                       ((basic_ostream_char_std__char_traits_char__ *)&DAT_0064663c,0xdd8);\n    std::__ostream_insert_char_std__char_traits_char__(pbVar1,\": \",2);\n    std::__ostream_insert_char_std__char_traits_char__(pbVar1,\"For unary ops only!\",0x13);\n    AstNode::v3errorEndFatal((basic_ostringstream *)param_1);\n  }\n  if ((*(uint *)(*(int *)(this + 0x20) + 4) & 1) == 0) {\n    return;\n  }\n  iterateCheckBool((AstNode *)this,(char *)param_1,(AstNode *)&DAT_0054410c,\n                   *(Stage *)(param_1 + 0xc));\n  AstNode::dtypeSetLogicBool((AstNode *)param_1);\n  return;\n}",
        "output": "void __thiscall WidthVisitor::visit(WidthVisitor *this, AstLogNot *param_1)\n{\n    basic_ostream *outputStream;\n\n    if (*(int *)(param_1 + 0x10) != 0) {\n        V3Error::v3errorPrep(4);\n        std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c, \"../V3Width.cpp\", 0xe);\n        std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c, \":\", 1);\n        *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) = *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) & 0xffffffb5 | 2;\n        outputStream = (basic_ostream *)std::basic_ostream<char, std::char_traits<char>>::operator__((basic_ostream_char_std__char_traits_char__ *)&DAT_0064663c, 0xdd8);\n        std::__ostream_insert_char_std__char_traits_char__(outputStream, \": \", 2);\n        std::__ostream_insert_char_std__char_traits_char__(outputStream, \"For unary ops only!\", 0x13);\n        AstNode::v3errorEndFatal((basic_ostringstream *)param_1);\n    }\n\n    if ((*(uint *)(*(int *)(this + 0x20) + 4) & 1) == 0) {\n        return;\n    }\n\n    iterateCheckBool((AstNode *)this, (char *)param_1, (AstNode *)&DAT_0054410c, *(Stage *)(param_1 + 0xc));\n    AstNode::dtypeSetLogicBool((AstNode *)param_1);\n    return;\n}",
        "source_code": "void visit_log_not(AstNode* nodep) {\n        // CALLER: LogNot\n        // Width-check: lhs 1 bit\n        // Real: Allowed; implicitly compares with zero\n        // We calculate the width of the UNDER expression.\n        // We then check its width to see if it's legal, and edit if not\n        // We finally set the width of our output\n        // IEEE-2012: Table 11-21 and 11.8.1 (same as RedAnd):\n        //   LHS is self-determined\n        //   Width: 1 bit out\n        //   Sign: unsigned out (11.8.1)\n        UASSERT_OBJ(!nodep->op2p(), nodep, \"For unary ops only!\");\n        if (m_vup->prelim()) {\n            iterateCheckBool(nodep, \"LHS\", nodep->op1p(), BOTH);\n            nodep->dtypeSetLogicBool();\n        }\n    }",
        "parsed_output": "void __thiscall WidthVisitor::visit(WidthVisitor *this, AstLogNot *param_1)\n{\n    basic_ostream *outputStream;\n\n    if (*(int *)(param_1 + 0x10) != 0) {\n        V3Error::v3errorPrep(4);\n        std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c, \"../V3Width.cpp\", 0xe);\n        std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c, \":\", 1);\n        *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) = *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) & 0xffffffb5 | 2;\n        outputStream = (basic_ostream *)std::basic_ostream<char, std::char_traits<char>>::operator__((basic_ostream_char_std__char_traits_char__ *)&DAT_0064663c, 0xdd8);\n        std::__ostream_insert_char_std__char_traits_char__(outputStream, \": \", 2);\n        std::__ostream_insert_char_std__char_traits_char__(outputStream, \"For unary ops only!\", 0x13);\n        AstNode::v3errorEndFatal((basic_ostringstream *)param_1);\n    }\n\n    if ((*(uint *)(*(int *)(this + 0x20) + 4) & 1) == 0) {\n        return;\n    }\n\n    iterateCheckBool((AstNode *)this, (char *)param_1, (AstNode *)&DAT_0054410c, *(Stage *)(param_1 + 0xc));\n    AstNode::dtypeSetLogicBool((AstNode *)param_1);\n    return;\n}",
        "baseline_code_stripped": "void __thiscall WidthVisitor::visit(WidthVisitor *this,AstLogNot *param_1)\n{\n  basic_ostream *pbVar1;\n  if (*(int *)(param_1 + 0x10) != 0) {\n    V3Error::v3errorPrep(4);\n    std::__ostream_insert_char_std__char_traits_char__\n              ((basic_ostream *)&DAT_0064663c,\"../V3Width.cpp\",0xe);\n    std::__ostream_insert_char_std__char_traits_char__((basic_ostream *)&DAT_0064663c,\":\",1);\n    *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) =\n         *(uint *)(&DAT_00646648 + *(int *)(DAT_0064663c + -0xc)) & 0xffffffb5 | 2;\n    pbVar1 = (basic_ostream *)\n             std::basic_ostream<char,std::char_traits<char>>::operator__\n                       ((basic_ostream_char_std__char_traits_char__ *)&DAT_0064663c,0xdd8);\n    std::__ostream_insert_char_std__char_traits_char__(pbVar1,\": \",2);\n    std::__ostream_insert_char_std__char_traits_char__(pbVar1,\"For unary ops only!\",0x13);\n    AstNode::v3errorEndFatal((basic_ostringstream *)param_1);\n  }\n  if ((*(uint *)(*(int *)(this + 0x20) + 4) & 1) == 0) {\n    return;\n  }\n  iterateCheckBool((AstNode *)this,(char *)param_1,(AstNode *)&DAT_0054410c,\n                   *(Stage *)(param_1 + 0xc));\n  AstNode::dtypeSetLogicBool((AstNode *)param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.6815871000289917,
        "similarity_score_baseline_stripped": 0.6429859399795532
    },
    {
        "func_name": "zfs_path_order",
        "normed_func_sha256": "8ecc29eef5c51f652c6c1d1a65848dc597bfee0aac2cc16b6e9e41f47f5b3017",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint zfs_path_order(char *param_1,int *param_2)\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s;\n  size_t sVar3;\n  long lVar4;\n  int iVar5;\n  pcVar2 = getenv(\"ZPOOL_IMPORT_PATH\");\n  if (pcVar2 == (char *)0x0) {\n    lVar4 = 0;\n    do {\n      pcVar2 = (&zpool_default_import_path)[lVar4];\n      sVar3 = strlen(pcVar2);\n      iVar5 = strncmp(param_1,pcVar2,sVar3);\n      if (iVar5 == 0) {\n        *param_2 = (int)lVar4;\n        return iVar5;\n      }\n      lVar4 = lVar4 + 1;\n    } while (lVar4 != 9);\n    return 2;\n  }\n  pcVar2 = strdup(pcVar2);\n  __s = strtok(pcVar2,\":\");\n  if (__s != (char *)0x0) {\n    iVar5 = 0;\n    do {\n      sVar3 = strlen(__s);\n      iVar1 = strncmp(param_1,__s,sVar3);\n      if (iVar1 == 0) {\n        *param_2 = iVar5;\n        iVar5 = 0;\n        goto LAB_00134212;\n      }\n      iVar5 = iVar5 + 1;\n      __s = strtok((char *)0x0,\":\");\n    } while (__s != (char *)0x0);\n  }\n  iVar5 = 2;\nLAB_00134212:\n  free(pcVar2);\n  return iVar5;\n}",
        "output": "```c\nint zfs_path_order(char *param_1, int *param_2) {\n    char *env_var = getenv(\"ZPOOL_IMPORT_PATH\");\n    \n    if (env_var == NULL) {\n        for (int i = 0; i < 9; i++) {\n            char *default_path = (&zpool_default_import_path)[i];\n            size_t len = strlen(default_path);\n            int cmp = strncmp(param_1, default_path, len);\n            if (cmp == 0) {\n                *param_2 = i;\n                return cmp;\n            }\n        }\n        return 2;\n    }\n    \n    char *path_copy = strdup(env_var);\n    char *token = strtok(path_copy, \":\");\n    \n    if (token != NULL) {\n        int index = 0;\n        do {\n            size_t len = strlen(token);\n            int cmp = strncmp(param_1, token, len);\n            if (cmp == 0) {\n                *param_2 = index;\n                return 0;\n            }\n            index++;\n            token = strtok(NULL, \":\");\n        } while (token != NULL);\n    }\n    \n    free(path_copy);\n    return 2;\n}\n```",
        "source_code": "int\nzfs_path_order(char *name, int *order)\n{\n\tint i = 0, error = ENOENT;\n\tchar *dir, *env, *envdup;\n\n\tenv = getenv(\"ZPOOL_IMPORT_PATH\");\n\tif (env) {\n\t\tenvdup = strdup(env);\n\t\tdir = strtok(envdup, \":\");\n\t\twhile (dir) {\n\t\t\tif (strncmp(name, dir, strlen(dir)) == 0) {\n\t\t\t\t*order = i;\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdir = strtok(NULL, \":\");\n\t\t\ti++;\n\t\t}\n\t\tfree(envdup);\n\t} else {\n\t\tfor (i = 0; i < DEFAULT_IMPORT_PATH_SIZE; i++) {\n\t\t\tif (strncmp(name, zpool_default_import_path[i],\n\t\t\t    strlen(zpool_default_import_path[i])) == 0) {\n\t\t\t\t*order = i;\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (error);\n}",
        "parsed_output": "int zfs_path_order(char *param_1, int *param_2) {\n    char *env_var = getenv(\"ZPOOL_IMPORT_PATH\");\n    \n    if (env_var == NULL) {\n        for (int i = 0; i < 9; i++) {\n            char *default_path = (&zpool_default_import_path)[i];\n            size_t len = strlen(default_path);\n            int cmp = strncmp(param_1, default_path, len);\n            if (cmp == 0) {\n                *param_2 = i;\n                return cmp;\n            }\n        }\n        return 2;\n    }\n    \n    char *path_copy = strdup(env_var);\n    char *token = strtok(path_copy, \":\");\n    \n    if (token != NULL) {\n        int index = 0;\n        do {\n            size_t len = strlen(token);\n            int cmp = strncmp(param_1, token, len);\n            if (cmp == 0) {\n                *param_2 = index;\n                return 0;\n            }\n            index++;\n            token = strtok(NULL, \":\");\n        } while (token != NULL);\n    }\n    \n    free(path_copy);\n    return 2;\n}",
        "baseline_code_stripped": "int zfs_path_order(char *param_1,int *param_2)\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s;\n  size_t sVar3;\n  long lVar4;\n  int iVar5;\n  pcVar2 = getenv(\"ZPOOL_IMPORT_PATH\");\n  if (pcVar2 == (char *)0x0) {\n    lVar4 = 0;\n    do {\n      pcVar2 = (&zpool_default_import_path)[lVar4];\n      sVar3 = strlen(pcVar2);\n      iVar5 = strncmp(param_1,pcVar2,sVar3);\n      if (iVar5 == 0) {\n        *param_2 = (int)lVar4;\n        return iVar5;\n      }\n      lVar4 = lVar4 + 1;\n    } while (lVar4 != 9);\n    return 2;\n  }\n  pcVar2 = strdup(pcVar2);\n  __s = strtok(pcVar2,\":\");\n  if (__s != (char *)0x0) {\n    iVar5 = 0;\n    do {\n      sVar3 = strlen(__s);\n      iVar1 = strncmp(param_1,__s,sVar3);\n      if (iVar1 == 0) {\n        *param_2 = iVar5;\n        iVar5 = 0;\n        goto LAB_00134212;\n      }\n      iVar5 = iVar5 + 1;\n      __s = strtok((char *)0x0,\":\");\n    } while (__s != (char *)0x0);\n  }\n  iVar5 = 2;\nLAB_00134212:\n  free(pcVar2);\n  return iVar5;\n}",
        "similarity_score_unixcoder": 0.7739477157592773,
        "similarity_score_baseline_stripped": 0.7060284614562988
    },
    {
        "func_name": "clusapi_dissect_ExecuteBatch_request",
        "normed_func_sha256": "55b0a3ad89538e6e87291546534ffaa4fa4c3d75ebfeac6a25c39903c0d8808d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_016d95d0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 int param_5,undefined4 param_6)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  undefined local_24 [4];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x16d95d9;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  *(char **)(param_5 + 0x40) = \"ExecuteBatch\";\n  FUN_01c10c80(param_4,param_5,param_6,DAT_04aab91c,0);\n  uVar1 = FUN_00e603b0(param_5,param_6);\n  if (*(int *)(param_5 + 0x14) == 0) {\n    if ((*(int *)(param_5 + 0x18) == 0) && ((uVar1 & 3) != 0)) {\n      uVar1 = (uVar1 + 4) - (int)uVar1 % 4;\n    }\n    dissect_dcerpc_uint32(param_1,uVar1,param_3,param_4,param_6,DAT_04aab918,local_24);\n  }\n  FUN_00e603b0(param_5,param_6);\n  DAT_043ed2c4 = 1;\n  if (*(int *)(param_5 + 0x14) == 0) {\n    FUN_00e618e0(param_4,param_5,param_6,FUN_016c1630,1,\"Pointer to LpData (uint8)\",DAT_04aab928,0,0\n                );\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    FUN_00e603b0();\n    return;\n  }\n  FUN_01e4ff70();\n}",
        "output": "void executeBatchFunction(undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4, int param_5, undefined4 param_6)\n{\n    uint uVar1;\n    int local_20;\n    char* functionName = \"ExecuteBatch\";\n    \n    uStack_14 = 0x16d95d9;\n    local_20 = *(int *)(in_GS_OFFSET + 0x14);\n    \n    *(char **)(param_5 + 0x40) = functionName;\n    \n    callFunction1(param_4, param_5, param_6, DAT_04aab91c, 0);\n    \n    uVar1 = callFunction2(param_5, param_6);\n    \n    if (*(int *)(param_5 + 0x14) == 0) {\n        if ((*(int *)(param_5 + 0x18) == 0) && ((uVar1 & 3) != 0)) {\n            uVar1 = (uVar1 + 4) - (int)uVar1 % 4;\n        }\n        \n        dissectDcerpcUint32(param_1, uVar1, param_3, param_4, param_6, DAT_04aab918, local_24);\n    }\n    \n    callFunction2(param_5, param_6);\n    \n    DAT_043ed2c4 = 1;\n    \n    if (*(int *)(param_5 + 0x14) == 0) {\n        callFunction3(param_4, param_5, param_6, FUN_016c1630, 1, \"Pointer to LpData (uint8)\", DAT_04aab928, 0, 0);\n    }\n    \n    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n        callFunction2();\n        return;\n    }\n    \n    callFunction4();\n}",
        "source_code": "static int\nclusapi_dissect_ExecuteBatch_request(tvbuff_t *tvb _U_, int offset _U_, packet_info *pinfo _U_, proto_tree *tree _U_, dcerpc_info* di _U_, guint8 *drep _U_)\n{\n\tdi->dcerpc_procedure_name=\"ExecuteBatch\";\n\toffset = clusapi_dissect_element_ExecuteBatch_hKey(tvb, offset, pinfo, tree, di, drep);\n\toffset = dissect_deferred_pointers(pinfo, tvb, offset, di, drep);\n\toffset = clusapi_dissect_element_ExecuteBatch_cbData(tvb, offset, pinfo, tree, di, drep);\n\toffset = dissect_deferred_pointers(pinfo, tvb, offset, di, drep);\n\toffset = clusapi_dissect_element_ExecuteBatch_lpData(tvb, offset, pinfo, tree, di, drep);\n\toffset = dissect_deferred_pointers(pinfo, tvb, offset, di, drep);\n\treturn offset;\n}",
        "parsed_output": "void executeBatchFunction(undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4, int param_5, undefined4 param_6)\n{\n    uint uVar1;\n    int local_20;\n    char* functionName = \"ExecuteBatch\";\n    \n    uStack_14 = 0x16d95d9;\n    local_20 = *(int *)(in_GS_OFFSET + 0x14);\n    \n    *(char **)(param_5 + 0x40) = functionName;\n    \n    callFunction1(param_4, param_5, param_6, DAT_04aab91c, 0);\n    \n    uVar1 = callFunction2(param_5, param_6);\n    \n    if (*(int *)(param_5 + 0x14) == 0) {\n        if ((*(int *)(param_5 + 0x18) == 0) && ((uVar1 & 3) != 0)) {\n            uVar1 = (uVar1 + 4) - (int)uVar1 % 4;\n        }\n        \n        dissectDcerpcUint32(param_1, uVar1, param_3, param_4, param_6, DAT_04aab918, local_24);\n    }\n    \n    callFunction2(param_5, param_6);\n    \n    DAT_043ed2c4 = 1;\n    \n    if (*(int *)(param_5 + 0x14) == 0) {\n        callFunction3(param_4, param_5, param_6, FUN_016c1630, 1, \"Pointer to LpData (uint8)\", DAT_04aab928, 0, 0);\n    }\n    \n    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n        callFunction2();\n        return;\n    }\n    \n    callFunction4();\n}",
        "baseline_code_stripped": "void FUN_016d95d0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 int param_5,undefined4 param_6)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  undefined local_24 [4];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x16d95d9;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  *(char **)(param_5 + 0x40) = \"ExecuteBatch\";\n  FUN_01c10c80(param_4,param_5,param_6,DAT_04aab91c,0);\n  uVar1 = FUN_00e603b0(param_5,param_6);\n  if (*(int *)(param_5 + 0x14) == 0) {\n    if ((*(int *)(param_5 + 0x18) == 0) && ((uVar1 & 3) != 0)) {\n      uVar1 = (uVar1 + 4) - (int)uVar1 % 4;\n    }\n    dissect_dcerpc_uint32(param_1,uVar1,param_3,param_4,param_6,DAT_04aab918,local_24);\n  }\n  FUN_00e603b0(param_5,param_6);\n  DAT_043ed2c4 = 1;\n  if (*(int *)(param_5 + 0x14) == 0) {\n    FUN_00e618e0(param_4,param_5,param_6,FUN_016c1630,1,\"Pointer to LpData (uint8)\",DAT_04aab928,0,0\n                );\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    FUN_00e603b0();\n    return;\n  }\n  FUN_01e4ff70();\n}",
        "similarity_score_unixcoder": 0.5416370034217834,
        "similarity_score_baseline_stripped": 0.5408616065979004
    },
    {
        "func_name": "i915_gem_get_caching_ioctl",
        "normed_func_sha256": "d7ca38517563582bcd295bdd7ad5d73df77006ef6d2006ea262eb5227919df61",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 i915_gem_get_caching_ioctl(void)\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  undefined8 uVar5;\n  uVar5 = __fentry__();\n  if ((*(byte *)((int)uVar5 + 0x1451) & 8) == 0) {\n    __rcu_read_lock();\n    iVar2 = idr_find();\n    if (iVar2 == 0) {\n      uVar4 = 0xfffffffe;\n    }\n    else {\n      bVar1 = *(byte *)(iVar2 + 0x150) & 7;\n      if (bVar1 < 3) {\n        uVar3 = (uint)(bVar1 != 0);\n      }\n      else {\n        uVar3 = (uint)(bVar1 == 3) * 2;\n      }\n      *(uint *)((int)((ulonglong)uVar5 >> 0x20) + 4) = uVar3;\n      uVar4 = 0;\n    }\n    __rcu_read_unlock();\n  }\n  else {\n    uVar4 = 0xffffffed;\n  }\n  return uVar4;\n}",
        "output": "```c\nuint32_t i915_gem_get_caching_ioctl(void)\n{\n    uint8_t caching_flag;\n    int idr_result;\n    uint32_t caching_value;\n    \n    caching_flag = *(uint8_t *)(current_thread + 0x1451) & 8;\n    \n    if (caching_flag == 0) {\n        __rcu_read_lock();\n        idr_result = idr_find();\n        \n        if (idr_result == 0) {\n            caching_value = 0xfffffffe;\n        } else {\n            uint8_t caching_type = *(uint8_t *)(idr_result + 0x150) & 7;\n            \n            if (caching_type < 3) {\n                caching_value = (uint32_t)(caching_type != 0);\n            } else {\n                caching_value = (uint32_t)(caching_type == 3) * 2;\n            }\n            \n            *(uint32_t *)((int)((uint64_t)current_thread >> 0x20) + 4) = caching_value;\n            caching_value = 0;\n        }\n        \n        __rcu_read_unlock();\n    } else {\n        caching_value = 0xffffffed;\n    }\n    \n    return caching_value;\n}\n```",
        "source_code": "int i915_gem_get_caching_ioctl(struct drm_device *dev, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct drm_i915_gem_caching *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tint err = 0;\n\n\tif (IS_DGFX(to_i915(dev)))\n\t\treturn -ENODEV;\n\n\trcu_read_lock();\n\tobj = i915_gem_object_lookup_rcu(file, args->handle);\n\tif (!obj) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tswitch (obj->cache_level) {\n\tcase I915_CACHE_LLC:\n\tcase I915_CACHE_L3_LLC:\n\t\targs->caching = I915_CACHING_CACHED;\n\t\tbreak;\n\n\tcase I915_CACHE_WT:\n\t\targs->caching = I915_CACHING_DISPLAY;\n\t\tbreak;\n\n\tdefault:\n\t\targs->caching = I915_CACHING_NONE;\n\t\tbreak;\n\t}\nout:\n\trcu_read_unlock();\n\treturn err;\n}",
        "parsed_output": "uint32_t i915_gem_get_caching_ioctl(void)\n{\n    uint8_t caching_flag;\n    int idr_result;\n    uint32_t caching_value;\n    \n    caching_flag = *(uint8_t *)(current_thread + 0x1451) & 8;\n    \n    if (caching_flag == 0) {\n        __rcu_read_lock();\n        idr_result = idr_find();\n        \n        if (idr_result == 0) {\n            caching_value = 0xfffffffe;\n        } else {\n            uint8_t caching_type = *(uint8_t *)(idr_result + 0x150) & 7;\n            \n            if (caching_type < 3) {\n                caching_value = (uint32_t)(caching_type != 0);\n            } else {\n                caching_value = (uint32_t)(caching_type == 3) * 2;\n            }\n            \n            *(uint32_t *)((int)((uint64_t)current_thread >> 0x20) + 4) = caching_value;\n            caching_value = 0;\n        }\n        \n        __rcu_read_unlock();\n    } else {\n        caching_value = 0xffffffed;\n    }\n    \n    return caching_value;\n}",
        "baseline_code_stripped": "undefined4 i915_gem_get_caching_ioctl(void)\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  undefined8 uVar5;\n  uVar5 = __fentry__();\n  if ((*(byte *)((int)uVar5 + 0x1451) & 8) == 0) {\n    __rcu_read_lock();\n    iVar2 = idr_find();\n    if (iVar2 == 0) {\n      uVar4 = 0xfffffffe;\n    }\n    else {\n      bVar1 = *(byte *)(iVar2 + 0x150) & 7;\n      if (bVar1 < 3) {\n        uVar3 = (uint)(bVar1 != 0);\n      }\n      else {\n        uVar3 = (uint)(bVar1 == 3) * 2;\n      }\n      *(uint *)((int)((ulonglong)uVar5 >> 0x20) + 4) = uVar3;\n      uVar4 = 0;\n    }\n    __rcu_read_unlock();\n  }\n  else {\n    uVar4 = 0xffffffed;\n  }\n  return uVar4;\n}",
        "similarity_score_unixcoder": 0.7257872819900513,
        "similarity_score_baseline_stripped": 0.561419665813446
    },
    {
        "func_name": "_wrap_SoSFInt32_getTypeId",
        "normed_func_sha256": "b59dcfe1e26cd0492e75f1eed33c276b3a0a700cf0cdbdea1768cca02339f945",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_0015fe10(undefined4 param_1,int param_2)\n{\n  int iVar1;\n  undefined2 *puVar2;\n  undefined4 uVar3;\n  undefined4 *puVar4;\n  int in_GS_OFFSET;\n  undefined4 uStack_30;\n  undefined auStack_2c [10];\n  undefined2 local_22;\n  undefined local_1e [10];\n  int *local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  local_14 = (int *)0x0;\n  if (param_2 != 0) {\n    iVar1 = FUN_004c32b0(0);\n    if (-1 < iVar1) {\n      (**(code **)(*local_14 + 8))(local_1e,local_14);\n      puVar2 = (undefined2 *)operator_new(2);\n      puVar4 = &uStack_30;\n      *puVar2 = local_22;\n      if (local_14 == *(int **)(in_GS_OFFSET + 0x14)) {\n        uVar3 = FUN_004c6e90();\n        return uVar3;\n      }\n      goto LAB_0015fee8;\n    }\n    uStack_30 = 0x15febf;\n    uVar3 = FUN_00107260();\n    PyErr_SetString(uVar3,\n                    \"in method \\'SoSFInt32_getTypeId\\', argument 1 of type \\'SoSFInt32 const *\\'\");\n  }\n  puVar4 = (undefined4 *)auStack_2c;\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return 0;\n  }\nLAB_0015fee8:\n  *(undefined **)((int)puVar4 + -4) = &UNK_0015feed;\n  FUN_004c9df0();\n}",
        "output": "```c\nundefined4 FUN_0015fe10(undefined4 param_1, int param_2)\n{\n    int iVar1;\n    undefined2 *puVar2;\n    undefined4 uVar3;\n    undefined4 *puVar4;\n    int in_GS_OFFSET;\n    undefined4 uStack_30;\n    undefined auStack_2c[10];\n    undefined2 local_22;\n    undefined local_1e[10];\n    int *local_14;\n    int local_10;\n\n    local_10 = *(int *)(in_GS_OFFSET + 0x14);\n    local_14 = (int *)0x0;\n\n    if (param_2 != 0) {\n        iVar1 = FUN_004c32b0(0);\n        if (-1 < iVar1) {\n            (**(code **)(*local_14 + 8))(local_1e, local_14);\n            puVar2 = (undefined2 *)operator_new(2);\n            puVar4 = &uStack_30;\n            *puVar2 = local_22;\n\n            if (local_14 == *(int **)(in_GS_OFFSET + 0x14)) {\n                uVar3 = FUN_004c6e90();\n                return uVar3;\n            }\n            goto LAB_0015fee8;\n        }\n\n        uStack_30 = 0x15febf;\n        uVar3 = FUN_00107260();\n        PyErr_SetString(uVar3, \"in method \\'SoSFInt32_getTypeId\\', argument 1 of type \\'SoSFInt32 const *\\'\");\n    }\n\n    puVar4 = (undefined4 *)auStack_2c;\n\n    if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n        return 0;\n    }\n\nLAB_0015fee8:\n    *(undefined **)((int)puVar4 - 4) = &UNK_0015feed;\n    FUN_004c9df0();\n}\n```",
        "source_code": "SWIGINTERN PyObject *_wrap_SoSFInt32_getTypeId(PyObject *self, PyObject *args) {\n  PyObject *resultobj = 0;\n  SoSFInt32 *arg1 = (SoSFInt32 *) 0 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  PyObject *swig_obj[1] ;\n  SoType result;\n  \n  if (!args) SWIG_fail;\n  swig_obj[0] = args;\n  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_SoSFInt32, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"SoSFInt32_getTypeId\" \"', argument \" \"1\"\" of type '\" \"SoSFInt32 const *\"\"'\"); \n  }\n  arg1 = reinterpret_cast< SoSFInt32 * >(argp1);\n  result = ((SoSFInt32 const *)arg1)->getTypeId();\n  resultobj = SWIG_NewPointerObj((new SoType(result)), SWIGTYPE_p_SoType, SWIG_POINTER_OWN |  0 );\n  return resultobj;\nfail:\n  return NULL;\n}",
        "parsed_output": "undefined4 FUN_0015fe10(undefined4 param_1, int param_2)\n{\n    int iVar1;\n    undefined2 *puVar2;\n    undefined4 uVar3;\n    undefined4 *puVar4;\n    int in_GS_OFFSET;\n    undefined4 uStack_30;\n    undefined auStack_2c[10];\n    undefined2 local_22;\n    undefined local_1e[10];\n    int *local_14;\n    int local_10;\n\n    local_10 = *(int *)(in_GS_OFFSET + 0x14);\n    local_14 = (int *)0x0;\n\n    if (param_2 != 0) {\n        iVar1 = FUN_004c32b0(0);\n        if (-1 < iVar1) {\n            (**(code **)(*local_14 + 8))(local_1e, local_14);\n            puVar2 = (undefined2 *)operator_new(2);\n            puVar4 = &uStack_30;\n            *puVar2 = local_22;\n\n            if (local_14 == *(int **)(in_GS_OFFSET + 0x14)) {\n                uVar3 = FUN_004c6e90();\n                return uVar3;\n            }\n            goto LAB_0015fee8;\n        }\n\n        uStack_30 = 0x15febf;\n        uVar3 = FUN_00107260();\n        PyErr_SetString(uVar3, \"in method \\'SoSFInt32_getTypeId\\', argument 1 of type \\'SoSFInt32 const *\\'\");\n    }\n\n    puVar4 = (undefined4 *)auStack_2c;\n\n    if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n        return 0;\n    }\n\nLAB_0015fee8:\n    *(undefined **)((int)puVar4 - 4) = &UNK_0015feed;\n    FUN_004c9df0();\n}",
        "baseline_code_stripped": "undefined4 FUN_0015fe10(undefined4 param_1,int param_2)\n{\n  int iVar1;\n  undefined2 *puVar2;\n  undefined4 uVar3;\n  undefined4 *puVar4;\n  int in_GS_OFFSET;\n  undefined4 uStack_30;\n  undefined auStack_2c [10];\n  undefined2 local_22;\n  undefined local_1e [10];\n  int *local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  local_14 = (int *)0x0;\n  if (param_2 != 0) {\n    iVar1 = FUN_004c32b0(0);\n    if (-1 < iVar1) {\n      (**(code **)(*local_14 + 8))(local_1e,local_14);\n      puVar2 = (undefined2 *)operator_new(2);\n      puVar4 = &uStack_30;\n      *puVar2 = local_22;\n      if (local_14 == *(int **)(in_GS_OFFSET + 0x14)) {\n        uVar3 = FUN_004c6e90();\n        return uVar3;\n      }\n      goto LAB_0015fee8;\n    }\n    uStack_30 = 0x15febf;\n    uVar3 = FUN_00107260();\n    PyErr_SetString(uVar3,\n                    \"in method \\'SoSFInt32_getTypeId\\', argument 1 of type \\'SoSFInt32 const *\\'\");\n  }\n  puVar4 = (undefined4 *)auStack_2c;\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return 0;\n  }\nLAB_0015fee8:\n  *(undefined **)((int)puVar4 + -4) = &UNK_0015feed;\n  FUN_004c9df0();\n}",
        "similarity_score_unixcoder": 0.6076355576515198,
        "similarity_score_baseline_stripped": 0.6062553524971008
    },
    {
        "func_name": "AreaSelectionWidget::updateSelectedAreaOnDragBottom",
        "normed_func_sha256": "34bbb36a2808605e71cc2ffe83d99a5f5ca014df23c7ad1523eebb95714c8276",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00122ca0(long param_1,long param_2)\n{\n  long lVar1;\n  double dVar2;\n  double dVar3;\n  double dVar4;\n  double dVar5;\n  lVar1 = *(long *)(param_1 + 0x38);\n  dVar4 = *(double *)(lVar1 + 0x110);\n  dVar3 = (double)*(int *)(param_2 + 4);\n  dVar5 = dVar4 + 6.0;\n  dVar2 = *(double *)(lVar1 + 0xe8) + *(double *)(lVar1 + 0xf8) + *(double *)(lVar1 + 0xb0);\n  if (dVar5 <= dVar3) {\n    if (dVar3 <= dVar2) {\n      dVar4 = dVar3 - dVar4;\n    }\n    else {\n      dVar4 = dVar2 - dVar4;\n    }\n  }\n  else {\n    dVar4 = dVar5 - dVar4;\n  }\n  if (*(char *)(lVar1 + 0x170) != '\\0') {\n    dVar3 = *(double *)(lVar1 + 0x168) * dVar4;\n    if ((dVar3 < dVar5) || (dVar2 < dVar3)) {\n      return;\n    }\n    *(double *)(lVar1 + 0x118) = dVar3;\n  }\n  *(double *)(lVar1 + 0x120) = dVar4;\n  FUN_00122ad0(param_1,1);\n  return;\n}",
        "output": "void calculateAndUpdateValues(long param_1, long param_2)\n{\n    long structPtr = *(long *)(param_1 + 0x38);\n    double value1 = *(double *)(structPtr + 0x110);\n    double value2 = (double)*(int *)(param_2 + 4);\n    double newValue = value1 + 6.0;\n    double sumValues = *(double *)(structPtr + 0xe8) + *(double *)(structPtr + 0xf8) + *(double *)(structPtr + 0xb0);\n    \n    if (newValue <= value2) {\n        if (value2 <= sumValues) {\n            value1 = value2 - value1;\n        }\n        else {\n            value1 = sumValues - value1;\n        }\n    }\n    else {\n        value1 = newValue - value1;\n    }\n    \n    if (*(char *)(structPtr + 0x170) != '\\0') {\n        double updatedValue = *(double *)(structPtr + 0x168) * value1;\n        if ((updatedValue < newValue) || (sumValues < updatedValue)) {\n            return;\n        }\n        *(double *)(structPtr + 0x118) = updatedValue;\n    }\n    \n    *(double *)(structPtr + 0x120) = value1;\n    updateStruct(param_1, 1);\n    return;\n}",
        "source_code": "void AreaSelectionWidget::updateSelectedAreaOnDragBottom(const QPoint& mousePosition)\n{\n    Q_D (AreaSelectionWidget);\n\n    // the drag handle size in the bounds calculations ensure that the\n    // box does not get too small to reach the drag handles with the mouse\n    const qreal topBound    = d->rectSelectedArea.y() + d->DRAG_HANDLE_SIZE;\n    const qreal bottomBound = d->rectDisplayArea.y() + d->rectDisplayArea.height() + d->outOfBoundsDisplayAreaMargin;\n    const qreal mouseY      = mousePosition.y();\n    qreal       newHeight   = 0.;\n\n    if (mouseY < topBound) {\n        newHeight = topBound - d->rectSelectedArea.y();\n    } else if (mouseY > bottomBound) {\n        newHeight = bottomBound - d->rectSelectedArea.y();\n    } else {\n        newHeight = mouseY - d->rectSelectedArea.y();\n    }\n\n    if (d->proportionsLocked) {\n        const auto newWidth = newHeight * d->proportions;\n        if (newWidth < topBound || newWidth > bottomBound) return;\n        d->rectSelectedArea.setWidth(newWidth);\n    }\n    d->rectSelectedArea.setHeight(newHeight);\n\n    updateSelectedAreaSize(true);\n}",
        "parsed_output": "void calculateAndUpdateValues(long param_1, long param_2)\n{\n    long structPtr = *(long *)(param_1 + 0x38);\n    double value1 = *(double *)(structPtr + 0x110);\n    double value2 = (double)*(int *)(param_2 + 4);\n    double newValue = value1 + 6.0;\n    double sumValues = *(double *)(structPtr + 0xe8) + *(double *)(structPtr + 0xf8) + *(double *)(structPtr + 0xb0);\n    \n    if (newValue <= value2) {\n        if (value2 <= sumValues) {\n            value1 = value2 - value1;\n        }\n        else {\n            value1 = sumValues - value1;\n        }\n    }\n    else {\n        value1 = newValue - value1;\n    }\n    \n    if (*(char *)(structPtr + 0x170) != '\\0') {\n        double updatedValue = *(double *)(structPtr + 0x168) * value1;\n        if ((updatedValue < newValue) || (sumValues < updatedValue)) {\n            return;\n        }\n        *(double *)(structPtr + 0x118) = updatedValue;\n    }\n    \n    *(double *)(structPtr + 0x120) = value1;\n    updateStruct(param_1, 1);\n    return;\n}",
        "baseline_code_stripped": "void FUN_00122ca0(long param_1,long param_2)\n{\n  long lVar1;\n  double dVar2;\n  double dVar3;\n  double dVar4;\n  double dVar5;\n  lVar1 = *(long *)(param_1 + 0x38);\n  dVar4 = *(double *)(lVar1 + 0x110);\n  dVar3 = (double)*(int *)(param_2 + 4);\n  dVar5 = dVar4 + 6.0;\n  dVar2 = *(double *)(lVar1 + 0xe8) + *(double *)(lVar1 + 0xf8) + *(double *)(lVar1 + 0xb0);\n  if (dVar5 <= dVar3) {\n    if (dVar3 <= dVar2) {\n      dVar4 = dVar3 - dVar4;\n    }\n    else {\n      dVar4 = dVar2 - dVar4;\n    }\n  }\n  else {\n    dVar4 = dVar5 - dVar4;\n  }\n  if (*(char *)(lVar1 + 0x170) != '\\0') {\n    dVar3 = *(double *)(lVar1 + 0x168) * dVar4;\n    if ((dVar3 < dVar5) || (dVar2 < dVar3)) {\n      return;\n    }\n    *(double *)(lVar1 + 0x118) = dVar3;\n  }\n  *(double *)(lVar1 + 0x120) = dVar4;\n  FUN_00122ad0(param_1,1);\n  return;\n}",
        "similarity_score_unixcoder": 0.48461419343948364,
        "similarity_score_baseline_stripped": 0.37720635533332825
    },
    {
        "func_name": "sipwxScrolledWindow::AcceptsFocusRecursively",
        "normed_func_sha256": "fa24614a30142c5737effbb6f084ebc4d2f5db768ef04caf8f87f137e4ac80c8",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall sipwxScrolledWindow::AcceptsFocusRecursively(sipwxScrolledWindow *this)\n{\n  _object *p_Var1;\n  int iVar2;\n  PyGILState_STATE local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__core + 0x164))\n                     (&local_18,this + 0x223,*(undefined4 *)(this + 0x200),0,\n                      \"AcceptsFocusRecursively\");\n  if (p_Var1 == (_object *)0x0) {\n    iVar2 = wxControlContainerBase::AcceptsFocus();\n    if ((iVar2 == 0) && (this[0x19d] != (sipwxScrolledWindow)0x0)) {\n      wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n    }\n  }\n  else {\n    sipVH__core_5(local_18,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0,\n                  *(_sipSimpleWrapper **)(this + 0x200),p_Var1);\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nvoid __thiscall sipwxScrolledWindow::AcceptsFocusRecursively(sipwxScrolledWindow *this)\n{\n    _object *result;\n    int acceptsFocusResult;\n    PyGILState_STATE gilState;\n    int stackGuard;\n\n    stackGuard = __stack_chk_guard;\n    result = (_object *)(**(code **)(sipAPI__core + 0x164))(&gilState, this + 0x223, *(undefined4 *)(this + 0x200), 0, \"AcceptsFocusRecursively\");\n\n    if (result == (_object *)0x0) {\n        acceptsFocusResult = wxControlContainerBase::AcceptsFocus();\n        if (acceptsFocusResult == 0 && this[0x19d] != (sipwxScrolledWindow)0x0) {\n            wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n        }\n    } else {\n        sipVH__core_5(gilState, (_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0, *(_sipSimpleWrapper **)(this + 0x200), result);\n    }\n\n    if (stackGuard == __stack_chk_guard) {\n        return;\n    }\n\n    __stack_chk_fail();\n}\n```",
        "source_code": "bool sipwxScrolledWindow::AcceptsFocusRecursively() const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[31]),sipPySelf,SIP_NULLPTR,sipName_AcceptsFocusRecursively);\n\n    if (!sipMeth)\n        return  ::wxScrolledWindow::AcceptsFocusRecursively();\n\n    extern bool sipVH__core_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);\n\n    return sipVH__core_5(sipGILState, 0, sipPySelf, sipMeth);\n}",
        "parsed_output": "void __thiscall sipwxScrolledWindow::AcceptsFocusRecursively(sipwxScrolledWindow *this)\n{\n    _object *result;\n    int acceptsFocusResult;\n    PyGILState_STATE gilState;\n    int stackGuard;\n\n    stackGuard = __stack_chk_guard;\n    result = (_object *)(**(code **)(sipAPI__core + 0x164))(&gilState, this + 0x223, *(undefined4 *)(this + 0x200), 0, \"AcceptsFocusRecursively\");\n\n    if (result == (_object *)0x0) {\n        acceptsFocusResult = wxControlContainerBase::AcceptsFocus();\n        if (acceptsFocusResult == 0 && this[0x19d] != (sipwxScrolledWindow)0x0) {\n            wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n        }\n    } else {\n        sipVH__core_5(gilState, (_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0, *(_sipSimpleWrapper **)(this + 0x200), result);\n    }\n\n    if (stackGuard == __stack_chk_guard) {\n        return;\n    }\n\n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "void __thiscall sipwxScrolledWindow::AcceptsFocusRecursively(sipwxScrolledWindow *this)\n{\n  _object *p_Var1;\n  int iVar2;\n  PyGILState_STATE local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__core + 0x164))\n                     (&local_18,this + 0x223,*(undefined4 *)(this + 0x200),0,\n                      \"AcceptsFocusRecursively\");\n  if (p_Var1 == (_object *)0x0) {\n    iVar2 = wxControlContainerBase::AcceptsFocus();\n    if ((iVar2 == 0) && (this[0x19d] != (sipwxScrolledWindow)0x0)) {\n      wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n    }\n  }\n  else {\n    sipVH__core_5(local_18,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0,\n                  *(_sipSimpleWrapper **)(this + 0x200),p_Var1);\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.805806040763855,
        "similarity_score_baseline_stripped": 0.8062808513641357
    },
    {
        "func_name": "toBool",
        "normed_func_sha256": "7ec5d43968c90a4dc27df463804ea0459a2ee282096f73d2cbda4ec442f1c684",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 dart::utils::toBool(basic_string *param_1)\n{\n  int iVar1;\n  undefined8 uVar2;\n  basic_ostream *pbVar3;\n  long in_FS_OFFSET;\n  locale local_80 [8];\n  undefined *local_78 [2];\n  undefined local_68 [16];\n  undefined *local_58 [2];\n  undefined local_48 [24];\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  std::locale::locale(local_80);\n  local_58[0] = local_48;\n  FUN_00198f80(local_58,*(long *)param_1,local_80,*(long *)(param_1 + 8) + *(long *)param_1);\n  iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                    ((char *)local_58);\n  if (iVar1 != 0) {\n    iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                      ((char *)param_1);\n    if (iVar1 != 0) {\n      if (local_58[0] == local_48) {\n        std::locale::_locale(local_80);\n      }\n      else {\n        operator_delete(local_58[0]);\n        std::locale::_locale(local_80);\n      }\n      std::locale::locale(local_80);\n      local_58[0] = local_48;\n      FUN_00198f80(local_58,*(long *)param_1,local_80,*(long *)(param_1 + 8) + *(long *)param_1);\n      iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                        ((char *)local_58);\n      if (iVar1 == 0) {\nLAB_00177a71:\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n          std::locale::_locale(local_80);\n          uVar2 = 0;\n          goto LAB_001779dc;\n        }\n        std::locale::_locale(local_80);\n      }\n      else {\n        iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n                compare((char *)param_1);\n        if (iVar1 == 0) goto LAB_00177a71;\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n        }\n        std::locale::_locale(local_80);\n        FUN_00198c10(local_78,\"/home/abuild/rpmbuild/BUILD/dart-4.3.7/dart/utils/Parser.cpp\");\n        FUN_00198c10(local_58,\"Error\");\n        pbVar3 = (basic_ostream *)\n                 dart::common::colorErr((basic_string *)local_58,(basic_string *)local_78,0x7b,0x1f)\n        ;\n        std::__ostream_insert_char_std__char_traits_char__(pbVar3,\"value [\",7);\n        pbVar3 = std::__ostream_insert_char_std__char_traits_char__\n                           (pbVar3,*(char **)param_1,*(long *)(param_1 + 8));\n        std::__ostream_insert_char_std__char_traits_char__\n                  (pbVar3,\"] is not a valid boolean type. \",0x1f);\n        std::__ostream_insert_char_std__char_traits_char__(pbVar3,\"Retuning false.\",0xf);\n        std::endl_char_std__char_traits_char__(pbVar3);\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n        }\n        if (local_78[0] != local_68) {\n          operator_delete(local_78[0]);\n          uVar2 = 0;\n          goto LAB_001779dc;\n        }\n      }\n      uVar2 = 0;\n      goto LAB_001779dc;\n    }\n  }\n  if (local_58[0] == local_48) {\n    std::locale::_locale(local_80);\n    uVar2 = 1;\n  }\n  else {\n    operator_delete(local_58[0]);\n    std::locale::_locale(local_80);\n    uVar2 = 1;\n  }\nLAB_001779dc:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nbool dart::utils::toBool(std::string* param_1) {\n    std::locale local_80;\n    char local_48[24];\n    char local_68[16];\n    char* local_58[2];\n    char* local_78[2];\n    \n    std::locale::locale(local_80);\n    local_58[0] = local_48;\n    FUN_00198f80(local_58, param_1->c_str(), local_80, param_1->size() + param_1->c_str());\n    \n    int iVar1 = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char*)local_58);\n    \n    if (iVar1 != 0) {\n        iVar1 = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char*)param_1);\n        \n        if (iVar1 != 0) {\n            if (local_58[0] == local_48) {\n                std::locale::_locale(local_80);\n            } else {\n                operator_delete(local_58[0]);\n                std::locale::_locale(local_80);\n            }\n            \n            std::locale::locale(local_80);\n            local_58[0] = local_48;\n            FUN_00198f80(local_58, param_1->c_str(), local_80, param_1->size() + param_1->c_str());\n            iVar1 = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char*)local_58);\n            \n            if (iVar1 == 0) {\n                goto LAB_00177a71;\n            } else {\n                iVar1 = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char*)param_1);\n                \n                if (iVar1 == 0) {\n                    goto LAB_00177a71;\n                }\n                \n                if (local_58[0] != local_48) {\n                    operator_delete(local_58[0]);\n                }\n                \n                std::locale::_locale(local_80);\n                FUN_00198c10(local_78, \"/home/abuild/rpmbuild/BUILD/dart-4.3.7/dart/utils/Parser.cpp\");\n                FUN_00198c10(local_58, \"Error\");\n                basic_ostream* pbVar3 = (basic_ostream*)dart::common::colorErr((std::string*)local_58, (std::string*)local_78, 0x7b, 0x1f);\n                std::__ostream_insert_char_std__char_traits_char__(pbVar3, \"value [\", 7);\n                pbVar3 = std::__ostream_insert_char_std__char_traits_char__(pbVar3, param_1->c_str(), param_1->size());\n                std::__ostream_insert_char_std__char_traits_char__(pbVar3, \"] is not a valid boolean type. \", 0x1f);\n                std::__ostream_insert_char_std__char_traits_char__(pbVar3, \"Retuning false.\", 0xf);\n                std::endl_char_std__char_traits_char__(pbVar3);\n                \n                if (local_58[0] != local_48) {\n                    operator_delete(local_58[0]);\n                }\n                \n                if (local_78[0] != local_68) {\n                    operator_delete(local_78[0]);\n                    return false;\n                }\n            }\n            \n            return false;\n        }\n    }\n    \n    if (local_58[0] == local_48) {\n        std::locale::_locale(local_80);\n        return true;\n    } else {\n        operator_delete(local_58[0]);\n        std::locale::_locale(local_80);\n        return true;\n    }\n    \nLAB_00177a71:\n    if (local_58[0] != local_48) {\n        operator_delete(local_58[0]);\n        std::locale::_locale(local_80);\n        return false;\n    }\n    \n    std::locale::_locale(local_80);\n    return true;\n}\n```",
        "source_code": "bool toBool(const std::string& _str)\n{\n    if (boost::to_upper_copy(_str) == \"TRUE\" || _str == \"1\")\n        return true;\n    else if (boost::to_upper_copy(_str) == \"FALSE\" || _str == \"0\")\n        return false;\n    else\n    {\n        dterr << \"value [\"\n              << _str\n              << \"] is not a valid boolean type. \"\n              << \"Retuning false.\"\n              << std::endl;\n        return false;\n        assert(0);\n    }\n}",
        "parsed_output": "bool dart::utils::toBool(std::string* param_1) {\n    std::locale local_80;\n    char local_48[24];\n    char local_68[16];\n    char* local_58[2];\n    char* local_78[2];\n    \n    std::locale::locale(local_80);\n    local_58[0] = local_48;\n    FUN_00198f80(local_58, param_1->c_str(), local_80, param_1->size() + param_1->c_str());\n    \n    int iVar1 = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char*)local_58);\n    \n    if (iVar1 != 0) {\n        iVar1 = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char*)param_1);\n        \n        if (iVar1 != 0) {\n            if (local_58[0] == local_48) {\n                std::locale::_locale(local_80);\n            } else {\n                operator_delete(local_58[0]);\n                std::locale::_locale(local_80);\n            }\n            \n            std::locale::locale(local_80);\n            local_58[0] = local_48;\n            FUN_00198f80(local_58, param_1->c_str(), local_80, param_1->size() + param_1->c_str());\n            iVar1 = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char*)local_58);\n            \n            if (iVar1 == 0) {\n                goto LAB_00177a71;\n            } else {\n                iVar1 = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::compare((char*)param_1);\n                \n                if (iVar1 == 0) {\n                    goto LAB_00177a71;\n                }\n                \n                if (local_58[0] != local_48) {\n                    operator_delete(local_58[0]);\n                }\n                \n                std::locale::_locale(local_80);\n                FUN_00198c10(local_78, \"/home/abuild/rpmbuild/BUILD/dart-4.3.7/dart/utils/Parser.cpp\");\n                FUN_00198c10(local_58, \"Error\");\n                basic_ostream* pbVar3 = (basic_ostream*)dart::common::colorErr((std::string*)local_58, (std::string*)local_78, 0x7b, 0x1f);\n                std::__ostream_insert_char_std__char_traits_char__(pbVar3, \"value [\", 7);\n                pbVar3 = std::__ostream_insert_char_std__char_traits_char__(pbVar3, param_1->c_str(), param_1->size());\n                std::__ostream_insert_char_std__char_traits_char__(pbVar3, \"] is not a valid boolean type. \", 0x1f);\n                std::__ostream_insert_char_std__char_traits_char__(pbVar3, \"Retuning false.\", 0xf);\n                std::endl_char_std__char_traits_char__(pbVar3);\n                \n                if (local_58[0] != local_48) {\n                    operator_delete(local_58[0]);\n                }\n                \n                if (local_78[0] != local_68) {\n                    operator_delete(local_78[0]);\n                    return false;\n                }\n            }\n            \n            return false;\n        }\n    }\n    \n    if (local_58[0] == local_48) {\n        std::locale::_locale(local_80);\n        return true;\n    } else {\n        operator_delete(local_58[0]);\n        std::locale::_locale(local_80);\n        return true;\n    }\n    \nLAB_00177a71:\n    if (local_58[0] != local_48) {\n        operator_delete(local_58[0]);\n        std::locale::_locale(local_80);\n        return false;\n    }\n    \n    std::locale::_locale(local_80);\n    return true;\n}",
        "baseline_code_stripped": "undefined8 dart::utils::toBool(basic_string *param_1)\n{\n  int iVar1;\n  undefined8 uVar2;\n  basic_ostream *pbVar3;\n  long in_FS_OFFSET;\n  locale local_80 [8];\n  undefined *local_78 [2];\n  undefined local_68 [16];\n  undefined *local_58 [2];\n  undefined local_48 [24];\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  std::locale::locale(local_80);\n  local_58[0] = local_48;\n  FUN_00198f80(local_58,*(long *)param_1,local_80,*(long *)(param_1 + 8) + *(long *)param_1);\n  iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                    ((char *)local_58);\n  if (iVar1 != 0) {\n    iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                      ((char *)param_1);\n    if (iVar1 != 0) {\n      if (local_58[0] == local_48) {\n        std::locale::_locale(local_80);\n      }\n      else {\n        operator_delete(local_58[0]);\n        std::locale::_locale(local_80);\n      }\n      std::locale::locale(local_80);\n      local_58[0] = local_48;\n      FUN_00198f80(local_58,*(long *)param_1,local_80,*(long *)(param_1 + 8) + *(long *)param_1);\n      iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::compare\n                        ((char *)local_58);\n      if (iVar1 == 0) {\nLAB_00177a71:\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n          std::locale::_locale(local_80);\n          uVar2 = 0;\n          goto LAB_001779dc;\n        }\n        std::locale::_locale(local_80);\n      }\n      else {\n        iVar1 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n                compare((char *)param_1);\n        if (iVar1 == 0) goto LAB_00177a71;\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n        }\n        std::locale::_locale(local_80);\n        FUN_00198c10(local_78,\"/home/abuild/rpmbuild/BUILD/dart-4.3.7/dart/utils/Parser.cpp\");\n        FUN_00198c10(local_58,\"Error\");\n        pbVar3 = (basic_ostream *)\n                 dart::common::colorErr((basic_string *)local_58,(basic_string *)local_78,0x7b,0x1f)\n        ;\n        std::__ostream_insert_char_std__char_traits_char__(pbVar3,\"value [\",7);\n        pbVar3 = std::__ostream_insert_char_std__char_traits_char__\n                           (pbVar3,*(char **)param_1,*(long *)(param_1 + 8));\n        std::__ostream_insert_char_std__char_traits_char__\n                  (pbVar3,\"] is not a valid boolean type. \",0x1f);\n        std::__ostream_insert_char_std__char_traits_char__(pbVar3,\"Retuning false.\",0xf);\n        std::endl_char_std__char_traits_char__(pbVar3);\n        if (local_58[0] != local_48) {\n          operator_delete(local_58[0]);\n        }\n        if (local_78[0] != local_68) {\n          operator_delete(local_78[0]);\n          uVar2 = 0;\n          goto LAB_001779dc;\n        }\n      }\n      uVar2 = 0;\n      goto LAB_001779dc;\n    }\n  }\n  if (local_58[0] == local_48) {\n    std::locale::_locale(local_80);\n    uVar2 = 1;\n  }\n  else {\n    operator_delete(local_58[0]);\n    std::locale::_locale(local_80);\n    uVar2 = 1;\n  }\nLAB_001779dc:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.6278330087661743,
        "similarity_score_baseline_stripped": 0.6206889152526855
    },
    {
        "func_name": "list_proxy",
        "normed_func_sha256": "a8dcc98c790ab023e80287e34d6bada9230b6bc50b21ad8c3133ef0ea80b47d0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0010bf30(undefined8 param_1,undefined8 param_2,undefined8 *param_3)\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  char *pcVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  long in_FS_OFFSET;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  byte *local_28;\n  long local_20;\n  bVar9 = 0;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar4 = \"anonymous\";\n  if (DAT_0011ae88 != 0) {\n    pcVar4 = DAT_0011ae90;\n  }\n  lVar2 = FUN_001108f0(param_1,&PTR_DAT_0011a020,pcVar4,&DAT_0011a480,&DAT_0011a488,0,DAT_0011ae68);\n  if (lVar2 != 0) {\n    prot_printf(*(undefined8 *)(lVar2 + 0x960),\"LIST %s %s\\r\\n\",*param_3,param_3[1]);\n    iVar1 = FUN_0010bea0(lVar2,&local_28);\n    bVar7 = false;\n    bVar8 = iVar1 == 0;\n    if (bVar8) {\n      lVar3 = 4;\n      pbVar5 = local_28;\n      pbVar6 = &DAT_0011446a;\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar5 < *pbVar6;\n        bVar8 = *pbVar5 == *pbVar6;\n        pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n        pbVar6 = pbVar6 + (ulong)bVar9 * -2 + 1;\n      } while (bVar8);\n      if ((!bVar7 && !bVar8) == bVar7) {\n        iVar1 = FUN_0010bea0(lVar2,&local_28);\n        while ((iVar1 == 0 && (*local_28 != 0x2e))) {\n          prot_printf(DAT_0011ae70,\"%s\");\n          iVar1 = FUN_0010bea0(lVar2,&local_28);\n        }\n      }\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nvoid process_data(undefined8 param_1, undefined8 param_2, undefined8 *param_3)\n{\n    int iVar1;\n    long lVar2;\n    long lVar3;\n    char *pcVar4;\n    byte *pbVar5;\n    byte *pbVar6;\n    long local_20;\n    byte bVar9 = 0;\n    bool bVar7;\n    bool bVar8;\n\n    local_20 = *(long *)(in_FS_OFFSET + 0x28);\n    pcVar4 = \"anonymous\";\n    \n    if (DAT_0011ae88 != 0) {\n        pcVar4 = DAT_0011ae90;\n    }\n    \n    lVar2 = FUN_001108f0(param_1, &PTR_DAT_0011a020, pcVar4, &DAT_0011a480, &DAT_0011a488, 0, DAT_0011ae68);\n    \n    if (lVar2 != 0) {\n        prot_printf(*(undefined8 *)(lVar2 + 0x960), \"LIST %s %s\\r\\n\", *param_3, param_3[1]);\n        iVar1 = FUN_0010bea0(lVar2, &local_28);\n        bVar7 = false;\n        bVar8 = iVar1 == 0;\n        \n        if (bVar8) {\n            lVar3 = 4;\n            pbVar5 = local_28;\n            pbVar6 = &DAT_0011446a;\n            \n            do {\n                if (lVar3 == 0) break;\n                lVar3 = lVar3 - 1;\n                bVar7 = *pbVar5 < *pbVar6;\n                bVar8 = *pbVar5 == *pbVar6;\n                pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n                pbVar6 = pbVar6 + (ulong)bVar9 * -2 + 1;\n            } while (bVar8);\n            \n            if ((!bVar7 && !bVar8) == bVar7) {\n                iVar1 = FUN_0010bea0(lVar2, &local_28);\n                \n                while ((iVar1 == 0 && (*local_28 != 0x2e))) {\n                    prot_printf(DAT_0011ae70, \"%s\");\n                    iVar1 = FUN_0010bea0(lVar2, &local_28);\n                }\n            }\n        }\n    }\n    \n    if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}\n```",
        "source_code": "static void list_proxy(const char *server,\n                       void *data __attribute__((unused)), void *rock)\n{\n    struct enum_rock *erock = (struct enum_rock *) rock;\n    struct backend *be;\n    int r;\n    char *result;\n    be = proxy_findserver(server, &nntp_protocol,\n                          nntp_authstate ? nntp_userid : \"anonymous\",\n                          &backend_cached, &backend_current, NULL, nntp_in);\n    if (!be) return;\n    prot_printf(be->out, \"LIST %s %s\\r\\n\", erock->cmd, erock->wild);\n    r = read_response(be, 0, &result);\n    if (!r && !strncmp(result, \"215 \", 4)) {\n        while (!(r = read_response(be, 0, &result)) && result[0] != '.') {\n            prot_printf(nntp_out, \"%s\", result);\n        }\n    }\n}",
        "parsed_output": "void process_data(undefined8 param_1, undefined8 param_2, undefined8 *param_3)\n{\n    int iVar1;\n    long lVar2;\n    long lVar3;\n    char *pcVar4;\n    byte *pbVar5;\n    byte *pbVar6;\n    long local_20;\n    byte bVar9 = 0;\n    bool bVar7;\n    bool bVar8;\n\n    local_20 = *(long *)(in_FS_OFFSET + 0x28);\n    pcVar4 = \"anonymous\";\n    \n    if (DAT_0011ae88 != 0) {\n        pcVar4 = DAT_0011ae90;\n    }\n    \n    lVar2 = FUN_001108f0(param_1, &PTR_DAT_0011a020, pcVar4, &DAT_0011a480, &DAT_0011a488, 0, DAT_0011ae68);\n    \n    if (lVar2 != 0) {\n        prot_printf(*(undefined8 *)(lVar2 + 0x960), \"LIST %s %s\\r\\n\", *param_3, param_3[1]);\n        iVar1 = FUN_0010bea0(lVar2, &local_28);\n        bVar7 = false;\n        bVar8 = iVar1 == 0;\n        \n        if (bVar8) {\n            lVar3 = 4;\n            pbVar5 = local_28;\n            pbVar6 = &DAT_0011446a;\n            \n            do {\n                if (lVar3 == 0) break;\n                lVar3 = lVar3 - 1;\n                bVar7 = *pbVar5 < *pbVar6;\n                bVar8 = *pbVar5 == *pbVar6;\n                pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n                pbVar6 = pbVar6 + (ulong)bVar9 * -2 + 1;\n            } while (bVar8);\n            \n            if ((!bVar7 && !bVar8) == bVar7) {\n                iVar1 = FUN_0010bea0(lVar2, &local_28);\n                \n                while ((iVar1 == 0 && (*local_28 != 0x2e))) {\n                    prot_printf(DAT_0011ae70, \"%s\");\n                    iVar1 = FUN_0010bea0(lVar2, &local_28);\n                }\n            }\n        }\n    }\n    \n    if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "void FUN_0010bf30(undefined8 param_1,undefined8 param_2,undefined8 *param_3)\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  char *pcVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  long in_FS_OFFSET;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  byte *local_28;\n  long local_20;\n  bVar9 = 0;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar4 = \"anonymous\";\n  if (DAT_0011ae88 != 0) {\n    pcVar4 = DAT_0011ae90;\n  }\n  lVar2 = FUN_001108f0(param_1,&PTR_DAT_0011a020,pcVar4,&DAT_0011a480,&DAT_0011a488,0,DAT_0011ae68);\n  if (lVar2 != 0) {\n    prot_printf(*(undefined8 *)(lVar2 + 0x960),\"LIST %s %s\\r\\n\",*param_3,param_3[1]);\n    iVar1 = FUN_0010bea0(lVar2,&local_28);\n    bVar7 = false;\n    bVar8 = iVar1 == 0;\n    if (bVar8) {\n      lVar3 = 4;\n      pbVar5 = local_28;\n      pbVar6 = &DAT_0011446a;\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar5 < *pbVar6;\n        bVar8 = *pbVar5 == *pbVar6;\n        pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n        pbVar6 = pbVar6 + (ulong)bVar9 * -2 + 1;\n      } while (bVar8);\n      if ((!bVar7 && !bVar8) == bVar7) {\n        iVar1 = FUN_0010bea0(lVar2,&local_28);\n        while ((iVar1 == 0 && (*local_28 != 0x2e))) {\n          prot_printf(DAT_0011ae70,\"%s\");\n          iVar1 = FUN_0010bea0(lVar2,&local_28);\n        }\n      }\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.5947511196136475,
        "similarity_score_baseline_stripped": 0.5603045225143433
    },
    {
        "func_name": "z_IU0UpdateEsRequest",
        "normed_func_sha256": "68d09c49886cae7e8e65ad55265ee18bd1804c387eecca61a19eda360ddaad4a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nulong z_IU0UpdateEsRequest(long param_1,long *param_2,undefined4 param_3,undefined8 param_4)\n{\n  int iVar1;\n  ulong uVar2;\n  iVar1 = odr_sequence_begin(param_1,param_2,0x10);\n  if (iVar1 == 0) {\n    uVar2 = odr_missing(param_1,param_3,param_4);\n    if ((int)uVar2 != 0) {\n      uVar2 = (ulong)(*(int *)(param_1 + 4) == 0);\n    }\n  }\n  else {\n    iVar1 = odr_constructed_begin(param_1,*param_2,2,1,0);\n    if (iVar1 == 0) {\n      uVar2 = odr_missing(param_1,0,\"toKeep\");\n      iVar1 = (int)uVar2;\n    }\n    else {\n      uVar2 = z_IU0OriginPartToKeep(param_1,*param_2,0,\"toKeep\");\n      if ((int)uVar2 == 0) {\n        return uVar2;\n      }\n      uVar2 = odr_constructed_end(param_1);\n      iVar1 = (int)uVar2;\n    }\n    if (iVar1 != 0) {\n      iVar1 = odr_constructed_begin(param_1,*param_2 + 8,2,2,0);\n      if (iVar1 == 0) {\n        uVar2 = odr_missing(param_1,0,\"notToKeep\");\n        iVar1 = (int)uVar2;\n      }\n      else {\n        uVar2 = z_IU0OriginPartNotToKeep(param_1,*param_2 + 8,0,\"notToKeep\");\n        if ((int)uVar2 == 0) {\n          return uVar2;\n        }\n        uVar2 = odr_constructed_end(param_1);\n        iVar1 = (int)uVar2;\n      }\n      if (iVar1 != 0) {\n        iVar1 = odr_sequence_end(param_1);\n        uVar2 = (ulong)(iVar1 != 0);\n      }\n    }\n  }\n  return uVar2;\n}",
        "output": "```c\nulong z_IU0UpdateEsRequest(long param_1, long *param_2, undefined4 param_3, undefined8 param_4)\n{\n    int result = 0;\n    \n    if (odr_sequence_begin(param_1, param_2, 0x10) == 0)\n    {\n        result = odr_missing(param_1, param_3, param_4);\n        \n        if (result != 0)\n        {\n            result = (*(int *)(param_1 + 4) == 0);\n        }\n    }\n    else\n    {\n        if (odr_constructed_begin(param_1, *param_2, 2, 1, 0) == 0)\n        {\n            result = odr_missing(param_1, 0, \"toKeep\");\n        }\n        else\n        {\n            result = z_IU0OriginPartToKeep(param_1, *param_2, 0, \"toKeep\");\n            \n            if (result == 0)\n            {\n                return result;\n            }\n            \n            result = odr_constructed_end(param_1);\n        }\n        \n        if (result != 0)\n        {\n            if (odr_constructed_begin(param_1, *param_2 + 8, 2, 2, 0) == 0)\n            {\n                result = odr_missing(param_1, 0, \"notToKeep\");\n            }\n            else\n            {\n                result = z_IU0OriginPartNotToKeep(param_1, *param_2 + 8, 0, \"notToKeep\");\n                \n                if (result == 0)\n                {\n                    return result;\n                }\n                \n                result = odr_constructed_end(param_1);\n            }\n            \n            if (result != 0)\n            {\n                result = odr_sequence_end(param_1);\n            }\n        }\n    }\n    \n    return result;\n}\n```",
        "source_code": "int z_IU0UpdateEsRequest (ODR o, Z_IU0UpdateEsRequest **p, int opt, const char *name)\n{\n\tif (!odr_sequence_begin (o, p, sizeof(**p), name))\n\t\treturn odr_missing(o, opt, name) && odr_ok (o);\n\treturn\n\t\todr_explicit_tag (o, z_IU0OriginPartToKeep,\n\t\t\t&(*p)->toKeep, ODR_CONTEXT, 1, 0, \"toKeep\") &&\n\t\todr_explicit_tag (o, z_IU0OriginPartNotToKeep,\n\t\t\t&(*p)->notToKeep, ODR_CONTEXT, 2, 0, \"notToKeep\") &&\n\t\todr_sequence_end (o);\n}",
        "parsed_output": "ulong z_IU0UpdateEsRequest(long param_1, long *param_2, undefined4 param_3, undefined8 param_4)\n{\n    int result = 0;\n    \n    if (odr_sequence_begin(param_1, param_2, 0x10) == 0)\n    {\n        result = odr_missing(param_1, param_3, param_4);\n        \n        if (result != 0)\n        {\n            result = (*(int *)(param_1 + 4) == 0);\n        }\n    }\n    else\n    {\n        if (odr_constructed_begin(param_1, *param_2, 2, 1, 0) == 0)\n        {\n            result = odr_missing(param_1, 0, \"toKeep\");\n        }\n        else\n        {\n            result = z_IU0OriginPartToKeep(param_1, *param_2, 0, \"toKeep\");\n            \n            if (result == 0)\n            {\n                return result;\n            }\n            \n            result = odr_constructed_end(param_1);\n        }\n        \n        if (result != 0)\n        {\n            if (odr_constructed_begin(param_1, *param_2 + 8, 2, 2, 0) == 0)\n            {\n                result = odr_missing(param_1, 0, \"notToKeep\");\n            }\n            else\n            {\n                result = z_IU0OriginPartNotToKeep(param_1, *param_2 + 8, 0, \"notToKeep\");\n                \n                if (result == 0)\n                {\n                    return result;\n                }\n                \n                result = odr_constructed_end(param_1);\n            }\n            \n            if (result != 0)\n            {\n                result = odr_sequence_end(param_1);\n            }\n        }\n    }\n    \n    return result;\n}",
        "baseline_code_stripped": "ulong z_IU0UpdateEsRequest(long param_1,long *param_2,undefined4 param_3,undefined8 param_4)\n{\n  int iVar1;\n  ulong uVar2;\n  iVar1 = odr_sequence_begin(param_1,param_2,0x10);\n  if (iVar1 == 0) {\n    uVar2 = odr_missing(param_1,param_3,param_4);\n    if ((int)uVar2 != 0) {\n      uVar2 = (ulong)(*(int *)(param_1 + 4) == 0);\n    }\n  }\n  else {\n    iVar1 = odr_constructed_begin(param_1,*param_2,2,1,0);\n    if (iVar1 == 0) {\n      uVar2 = odr_missing(param_1,0,\"toKeep\");\n      iVar1 = (int)uVar2;\n    }\n    else {\n      uVar2 = z_IU0OriginPartToKeep(param_1,*param_2,0,\"toKeep\");\n      if ((int)uVar2 == 0) {\n        return uVar2;\n      }\n      uVar2 = odr_constructed_end(param_1);\n      iVar1 = (int)uVar2;\n    }\n    if (iVar1 != 0) {\n      iVar1 = odr_constructed_begin(param_1,*param_2 + 8,2,2,0);\n      if (iVar1 == 0) {\n        uVar2 = odr_missing(param_1,0,\"notToKeep\");\n        iVar1 = (int)uVar2;\n      }\n      else {\n        uVar2 = z_IU0OriginPartNotToKeep(param_1,*param_2 + 8,0,\"notToKeep\");\n        if ((int)uVar2 == 0) {\n          return uVar2;\n        }\n        uVar2 = odr_constructed_end(param_1);\n        iVar1 = (int)uVar2;\n      }\n      if (iVar1 != 0) {\n        iVar1 = odr_sequence_end(param_1);\n        uVar2 = (ulong)(iVar1 != 0);\n      }\n    }\n  }\n  return uVar2;\n}",
        "similarity_score_unixcoder": 0.7551242709159851,
        "similarity_score_baseline_stripped": 0.7265185713768005
    },
    {
        "func_name": "asctime",
        "normed_func_sha256": "47a2f0d4bb63f8a5ccab2fdabca313e0f4241a226c98e4f6b714ec58c505420e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar * p9asctime(Tm *t)\n{\n  int iVar1;\n  cbuf_0._24_2_ = 0x3931;\n  cbuf_0._28_2_ = 10;\n  cbuf_0[3] = 0x20;\n  cbuf_0._0_3_ = *(undefined3 *)(\"SunMonTueWedThuFriSat\" + t->wday * 3);\n  cbuf_0[7] = 0x20;\n  cbuf_0._4_3_ = *(undefined3 *)(\"JanFebMarAprMayJunJulAugSepOctNovDec\" + t->mon * 3);\n  iVar1 = t->mday;\n  if (iVar1 < 10) {\n    cbuf_0._8_4_ = 0x30203120;\n  }\n  else {\n    cbuf_0._9_3_ = 0x302031;\n    cbuf_0[8] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0._8_2_ = CONCAT11((char)iVar1 + (char)(iVar1 / 10) * -10 + '0',cbuf_0[8]);\n  iVar1 = t->hour + 100;\n  if (iVar1 < 10) {\n    cbuf_0[11] = 0x20;\n  }\n  else {\n    cbuf_0[11] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0._13_3_ = 0x30303a;\n  cbuf_0[12] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  iVar1 = t->min + 100;\n  if (iVar1 < 10) {\n    cbuf_0[14] = 0x20;\n  }\n  else {\n    cbuf_0[14] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0[15] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  iVar1 = t->sec + 100;\n  if (iVar1 < 10) {\n    cbuf_0._16_2_ = 0x203a;\n  }\n  else {\n    cbuf_0[17] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n    cbuf_0[16] = 0x3a;\n  }\n  cbuf_0._16_3_ = CONCAT12((char)iVar1 + (char)(iVar1 / 10) * -10 + '0',cbuf_0._16_2_);\n  cbuf_0._19_5_ = 0x20544d4720;\n  cbuf_0._16_6_ = CONCAT24(*(undefined2 *)t->zone,cbuf_0._16_4_);\n  cbuf_0._16_7_ = CONCAT16(t->zone[2],cbuf_0._16_6_);\n  cbuf_0[23] = 0x20;\n  iVar1 = t->year;\n  if (99 < iVar1) {\n    cbuf_0._24_2_ = 0x3032;\n    iVar1 = t->year;\n  }\n  iVar1 = iVar1 + 100;\n  if (iVar1 < 10) {\n    cbuf_0[26] = 0x20;\n  }\n  else {\n    cbuf_0[26] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0[27] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  return cbuf_0;\n}",
        "output": "```c\nchar * p9asctime(Tm *t)\n{\n  int iVar1;\n  \n  cbuf_0._24_2_ = 0x3931;\n  cbuf_0._28_2_ = 10;\n  cbuf_0[3] = 0x20;\n  \n  cbuf_0._0_3_ = *(undefined3 *)(\"SunMonTueWedThuFriSat\" + t->wday * 3);\n  cbuf_0[7] = 0x20;\n  cbuf_0._4_3_ = *(undefined3 *)(\"JanFebMarAprMayJunJulAugSepOctNovDec\" + t->mon * 3);\n  \n  iVar1 = t->mday;\n  if (iVar1 < 10) {\n    cbuf_0._8_4_ = 0x30203120;\n  }\n  else {\n    cbuf_0._9_3_ = 0x302031;\n    cbuf_0[8] = (char)(iVar1 / 10) + '0';\n    cbuf_0._8_2_ = (char)(iVar1 % 10) + '0';\n  }\n  \n  iVar1 = t->hour + 100;\n  if (iVar1 < 10) {\n    cbuf_0[11] = 0x20;\n  }\n  else {\n    cbuf_0[11] = (char)(iVar1 / 10) + '0';\n  }\n  cbuf_0[12] = (char)(iVar1 % 10) + '0';\n  \n  iVar1 = t->min + 100;\n  if (iVar1 < 10) {\n    cbuf_0[14] = 0x20;\n  }\n  else {\n    cbuf_0[14] = (char)(iVar1 / 10) + '0';\n  }\n  cbuf_0[15] = (char)(iVar1 % 10) + '0';\n  \n  iVar1 = t->sec + 100;\n  if (iVar1 < 10) {\n    cbuf_0._16_2_ = 0x203a;\n  }\n  else {\n    cbuf_0[17] = (char)(iVar1 / 10) + '0';\n    cbuf_0[16] = 0x3a;\n  }\n  cbuf_0._16_3_ = (char)(iVar1 % 10) + '0';\n  \n  cbuf_0._19_5_ = 0x20544d4720;\n  cbuf_0._16_6_ = *(undefined2 *)t->zone;\n  cbuf_0._16_7_ = t->zone[2];\n  cbuf_0[23] = 0x20;\n  \n  iVar1 = t->year;\n  if (99 < iVar1) {\n    cbuf_0._24_2_ = 0x3032;\n  }\n  iVar1 += 100;\n  if (iVar1 < 10) {\n    cbuf_0[26] = 0x20;\n  }\n  else {\n    cbuf_0[26] = (char)(iVar1 / 10) + '0';\n  }\n  cbuf_0[27] = (char)(iVar1 % 10) + '0';\n  \n  return cbuf_0;\n}\n```",
        "source_code": "char*\nasctime(Tm *t)\n{\n\tchar *ncp;\n\tstatic char cbuf[30];\n\tstrcpy(cbuf, \"Thu Jan 01 00:00:00 GMT 1970\\n\");\n\tncp = &\"SunMonTueWedThuFriSat\"[t->wday*3];\n\tcbuf[0] = *ncp++;\n\tcbuf[1] = *ncp++;\n\tcbuf[2] = *ncp;\n\tncp = &\"JanFebMarAprMayJunJulAugSepOctNovDec\"[t->mon*3];\n\tcbuf[4] = *ncp++;\n\tcbuf[5] = *ncp++;\n\tcbuf[6] = *ncp;\n\tct_numb(cbuf+8, t->mday);\n\tct_numb(cbuf+11, t->hour+100);\n\tct_numb(cbuf+14, t->min+100);\n\tct_numb(cbuf+17, t->sec+100);\n\tncp = t->zone;\n\tcbuf[20] = *ncp++;\n\tcbuf[21] = *ncp++;\n\tcbuf[22] = *ncp;\n\tif(t->year >= 100) {\n\t\tcbuf[24] = '2';\n\t\tcbuf[25] = '0';\n\t}\n\tct_numb(cbuf+26, t->year+100);\n\treturn cbuf;\n}",
        "parsed_output": "char * p9asctime(Tm *t)\n{\n  int iVar1;\n  \n  cbuf_0._24_2_ = 0x3931;\n  cbuf_0._28_2_ = 10;\n  cbuf_0[3] = 0x20;\n  \n  cbuf_0._0_3_ = *(undefined3 *)(\"SunMonTueWedThuFriSat\" + t->wday * 3);\n  cbuf_0[7] = 0x20;\n  cbuf_0._4_3_ = *(undefined3 *)(\"JanFebMarAprMayJunJulAugSepOctNovDec\" + t->mon * 3);\n  \n  iVar1 = t->mday;\n  if (iVar1 < 10) {\n    cbuf_0._8_4_ = 0x30203120;\n  }\n  else {\n    cbuf_0._9_3_ = 0x302031;\n    cbuf_0[8] = (char)(iVar1 / 10) + '0';\n    cbuf_0._8_2_ = (char)(iVar1 % 10) + '0';\n  }\n  \n  iVar1 = t->hour + 100;\n  if (iVar1 < 10) {\n    cbuf_0[11] = 0x20;\n  }\n  else {\n    cbuf_0[11] = (char)(iVar1 / 10) + '0';\n  }\n  cbuf_0[12] = (char)(iVar1 % 10) + '0';\n  \n  iVar1 = t->min + 100;\n  if (iVar1 < 10) {\n    cbuf_0[14] = 0x20;\n  }\n  else {\n    cbuf_0[14] = (char)(iVar1 / 10) + '0';\n  }\n  cbuf_0[15] = (char)(iVar1 % 10) + '0';\n  \n  iVar1 = t->sec + 100;\n  if (iVar1 < 10) {\n    cbuf_0._16_2_ = 0x203a;\n  }\n  else {\n    cbuf_0[17] = (char)(iVar1 / 10) + '0';\n    cbuf_0[16] = 0x3a;\n  }\n  cbuf_0._16_3_ = (char)(iVar1 % 10) + '0';\n  \n  cbuf_0._19_5_ = 0x20544d4720;\n  cbuf_0._16_6_ = *(undefined2 *)t->zone;\n  cbuf_0._16_7_ = t->zone[2];\n  cbuf_0[23] = 0x20;\n  \n  iVar1 = t->year;\n  if (99 < iVar1) {\n    cbuf_0._24_2_ = 0x3032;\n  }\n  iVar1 += 100;\n  if (iVar1 < 10) {\n    cbuf_0[26] = 0x20;\n  }\n  else {\n    cbuf_0[26] = (char)(iVar1 / 10) + '0';\n  }\n  cbuf_0[27] = (char)(iVar1 % 10) + '0';\n  \n  return cbuf_0;\n}",
        "baseline_code_stripped": "char * p9asctime(Tm *t)\n{\n  int iVar1;\n  cbuf_0._24_2_ = 0x3931;\n  cbuf_0._28_2_ = 10;\n  cbuf_0[3] = 0x20;\n  cbuf_0._0_3_ = *(undefined3 *)(\"SunMonTueWedThuFriSat\" + t->wday * 3);\n  cbuf_0[7] = 0x20;\n  cbuf_0._4_3_ = *(undefined3 *)(\"JanFebMarAprMayJunJulAugSepOctNovDec\" + t->mon * 3);\n  iVar1 = t->mday;\n  if (iVar1 < 10) {\n    cbuf_0._8_4_ = 0x30203120;\n  }\n  else {\n    cbuf_0._9_3_ = 0x302031;\n    cbuf_0[8] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0._8_2_ = CONCAT11((char)iVar1 + (char)(iVar1 / 10) * -10 + '0',cbuf_0[8]);\n  iVar1 = t->hour + 100;\n  if (iVar1 < 10) {\n    cbuf_0[11] = 0x20;\n  }\n  else {\n    cbuf_0[11] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0._13_3_ = 0x30303a;\n  cbuf_0[12] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  iVar1 = t->min + 100;\n  if (iVar1 < 10) {\n    cbuf_0[14] = 0x20;\n  }\n  else {\n    cbuf_0[14] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0[15] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  iVar1 = t->sec + 100;\n  if (iVar1 < 10) {\n    cbuf_0._16_2_ = 0x203a;\n  }\n  else {\n    cbuf_0[17] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n    cbuf_0[16] = 0x3a;\n  }\n  cbuf_0._16_3_ = CONCAT12((char)iVar1 + (char)(iVar1 / 10) * -10 + '0',cbuf_0._16_2_);\n  cbuf_0._19_5_ = 0x20544d4720;\n  cbuf_0._16_6_ = CONCAT24(*(undefined2 *)t->zone,cbuf_0._16_4_);\n  cbuf_0._16_7_ = CONCAT16(t->zone[2],cbuf_0._16_6_);\n  cbuf_0[23] = 0x20;\n  iVar1 = t->year;\n  if (99 < iVar1) {\n    cbuf_0._24_2_ = 0x3032;\n    iVar1 = t->year;\n  }\n  iVar1 = iVar1 + 100;\n  if (iVar1 < 10) {\n    cbuf_0[26] = 0x20;\n  }\n  else {\n    cbuf_0[26] = (char)(iVar1 / 10) + (char)((uint)(iVar1 / 10) / 10) * -10 + '0';\n  }\n  cbuf_0[27] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';\n  return cbuf_0;\n}",
        "similarity_score_unixcoder": 0.8212804198265076,
        "similarity_score_baseline_stripped": 0.8135940432548523
    },
    {
        "func_name": "R_swig_FbcAnd_getAssociation__SWIG_1",
        "normed_func_sha256": "163478e34f4a479021cd20133268322d1faaa79a581ed237cad4937ed8b97982",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 R_swig_FbcAnd_getAssociation__SWIG_1(undefined4 param_1,undefined4 param_2)\n{\n  FbcAnd *this;\n  undefined4 uVar1;\n  int iVar2;\n  uint uVar3;\n  SBase *pSVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  FbcAnd *local_40;\n  int *local_3c;\n  undefined4 local_38;\n  int local_34 [4];\n  int local_24;\n  local_24 = __stack_chk_guard;\n  local_40 = (FbcAnd *)0x0;\n  uVar1 = vmaxget();\n  iVar2 = SWIG_R_ConvertPtr_lto_priv_0(param_1,&local_40,DAT_00c20584,0);\n  this = local_40;\n  if (iVar2 < 0) {\n    if (iVar2 == -1) {\n      iVar2 = -5;\n    }\n    SWIG_Error_lto_priv_0\n              (iVar2,\"in method \\'FbcAnd_getAssociation\\', argument 1 of type \\'FbcAnd const *\\'\");\n    uVar1 = SWIG_ErrorType_lto_priv_0(DAT_00c20adc);\n    Rf_error(\"%s %s\",uVar1,&DAT_00c20ae0);\n  }\n  uVar3 = Rf_asInteger(param_2);\n  pSVar4 = (SBase *)FbcAnd::getAssociation(this,uVar3);\n  local_34[0] = 0x636266;\n  local_38 = 3;\n  local_3c = local_34;\n  uVar5 = GetDowncastSwigTypeForPackage(pSVar4,(basic_string *)&local_3c);\n  uVar6 = R_NilValue;\n  if (pSVar4 != (SBase *)0x0) {\n    uVar6 = R_MakeExternalPtr(uVar5,R_NilValue,R_NilValue);\n    uVar6 = R_MakeExternalPtr(pSVar4,uVar6,R_NilValue);\n    SET_S4_OBJECT();\n  }\n  if (local_3c != local_34) {\n    operator_delete(local_3c,local_34[0] + 1);\n  }\n  vmaxset(uVar1);\n  if (local_24 == __stack_chk_guard) {\n    return uVar6;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nundefined4 R_swig_FbcAnd_getAssociation__SWIG_1(undefined4 param_1, undefined4 param_2)\n{\n    FbcAnd *this;\n    undefined4 uVar1;\n    int iVar2;\n    uint uVar3;\n    SBase *pSVar4;\n    undefined4 uVar5;\n    undefined4 uVar6;\n    FbcAnd *local_40;\n    int *local_3c;\n    undefined4 local_38;\n    int local_34[4];\n    int local_24;\n\n    local_24 = __stack_chk_guard;\n    local_40 = (FbcAnd *)0x0;\n    uVar1 = vmaxget();\n    iVar2 = SWIG_R_ConvertPtr_lto_priv_0(param_1, &local_40, DAT_00c20584, 0);\n    this = local_40;\n\n    if (iVar2 < 0) {\n        if (iVar2 == -1) {\n            iVar2 = -5;\n        }\n        SWIG_Error_lto_priv_0(iVar2, \"in method \\'FbcAnd_getAssociation\\', argument 1 of type \\'FbcAnd const *\\'\");\n        uVar1 = SWIG_ErrorType_lto_priv_0(DAT_00c20adc);\n        Rf_error(\"%s %s\", uVar1, &DAT_00c20ae0);\n    }\n\n    uVar3 = Rf_asInteger(param_2);\n    pSVar4 = (SBase *)FbcAnd::getAssociation(this, uVar3);\n    local_34[0] = 0x636266;\n    local_38 = 3;\n    local_3c = local_34;\n    uVar5 = GetDowncastSwigTypeForPackage(pSVar4, (basic_string *)&local_3c);\n    uVar6 = R_NilValue;\n\n    if (pSVar4 != (SBase *)0x0) {\n        uVar6 = R_MakeExternalPtr(uVar5, R_NilValue, R_NilValue);\n        uVar6 = R_MakeExternalPtr(pSVar4, uVar6, R_NilValue);\n        SET_S4_OBJECT();\n    }\n\n    if (local_3c != local_34) {\n        operator_delete(local_3c, local_34[0] + 1);\n    }\n\n    vmaxset(uVar1);\n\n    if (local_24 == __stack_chk_guard) {\n        return uVar6;\n    }\n\n    __stack_chk_fail();\n}\n```",
        "source_code": "SWIGEXPORT SEXP\nR_swig_FbcAnd_getAssociation__SWIG_1 ( SEXP self, SEXP n)\n{\n  FbcAssociation *result = 0 ;\n  FbcAnd *arg1 = (FbcAnd *) 0 ;\n  unsigned int arg2 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  int val2 ;\n  int ecode2 = 0 ;\n  unsigned int r_nprotect = 0;\n  SEXP r_ans = R_NilValue ;\n  VMAXTYPE r_vmax = vmaxget() ;\n  \n  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_FbcAnd, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"FbcAnd_getAssociation\" \"', argument \" \"1\"\" of type '\" \"FbcAnd const *\"\"'\"); \n  }\n  arg1 = reinterpret_cast< FbcAnd * >(argp1);\n  ecode2 = SWIG_AsVal_int(n, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"FbcAnd_getAssociation\" \"', argument \" \"2\"\" of type '\" \"unsigned int\"\"'\");\n  } \n  arg2 = static_cast< unsigned int >(val2);\n  result = (FbcAssociation *)((FbcAnd const *)arg1)->getAssociation(arg2);\n  {\n    r_ans = SWIG_R_NewPointerObj(result, GetDowncastSwigTypeForPackage(result, \"fbc\"), 0 |  0 );\n  }\n  vmaxset(r_vmax);\n  if(r_nprotect)  Rf_unprotect(r_nprotect);\n  \n  return r_ans;\n  fail: SWIGUNUSED;\n  Rf_error(\"%s %s\", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);\n  return R_NilValue;\n}",
        "parsed_output": "undefined4 R_swig_FbcAnd_getAssociation__SWIG_1(undefined4 param_1, undefined4 param_2)\n{\n    FbcAnd *this;\n    undefined4 uVar1;\n    int iVar2;\n    uint uVar3;\n    SBase *pSVar4;\n    undefined4 uVar5;\n    undefined4 uVar6;\n    FbcAnd *local_40;\n    int *local_3c;\n    undefined4 local_38;\n    int local_34[4];\n    int local_24;\n\n    local_24 = __stack_chk_guard;\n    local_40 = (FbcAnd *)0x0;\n    uVar1 = vmaxget();\n    iVar2 = SWIG_R_ConvertPtr_lto_priv_0(param_1, &local_40, DAT_00c20584, 0);\n    this = local_40;\n\n    if (iVar2 < 0) {\n        if (iVar2 == -1) {\n            iVar2 = -5;\n        }\n        SWIG_Error_lto_priv_0(iVar2, \"in method \\'FbcAnd_getAssociation\\', argument 1 of type \\'FbcAnd const *\\'\");\n        uVar1 = SWIG_ErrorType_lto_priv_0(DAT_00c20adc);\n        Rf_error(\"%s %s\", uVar1, &DAT_00c20ae0);\n    }\n\n    uVar3 = Rf_asInteger(param_2);\n    pSVar4 = (SBase *)FbcAnd::getAssociation(this, uVar3);\n    local_34[0] = 0x636266;\n    local_38 = 3;\n    local_3c = local_34;\n    uVar5 = GetDowncastSwigTypeForPackage(pSVar4, (basic_string *)&local_3c);\n    uVar6 = R_NilValue;\n\n    if (pSVar4 != (SBase *)0x0) {\n        uVar6 = R_MakeExternalPtr(uVar5, R_NilValue, R_NilValue);\n        uVar6 = R_MakeExternalPtr(pSVar4, uVar6, R_NilValue);\n        SET_S4_OBJECT();\n    }\n\n    if (local_3c != local_34) {\n        operator_delete(local_3c, local_34[0] + 1);\n    }\n\n    vmaxset(uVar1);\n\n    if (local_24 == __stack_chk_guard) {\n        return uVar6;\n    }\n\n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "undefined4 R_swig_FbcAnd_getAssociation__SWIG_1(undefined4 param_1,undefined4 param_2)\n{\n  FbcAnd *this;\n  undefined4 uVar1;\n  int iVar2;\n  uint uVar3;\n  SBase *pSVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  FbcAnd *local_40;\n  int *local_3c;\n  undefined4 local_38;\n  int local_34 [4];\n  int local_24;\n  local_24 = __stack_chk_guard;\n  local_40 = (FbcAnd *)0x0;\n  uVar1 = vmaxget();\n  iVar2 = SWIG_R_ConvertPtr_lto_priv_0(param_1,&local_40,DAT_00c20584,0);\n  this = local_40;\n  if (iVar2 < 0) {\n    if (iVar2 == -1) {\n      iVar2 = -5;\n    }\n    SWIG_Error_lto_priv_0\n              (iVar2,\"in method \\'FbcAnd_getAssociation\\', argument 1 of type \\'FbcAnd const *\\'\");\n    uVar1 = SWIG_ErrorType_lto_priv_0(DAT_00c20adc);\n    Rf_error(\"%s %s\",uVar1,&DAT_00c20ae0);\n  }\n  uVar3 = Rf_asInteger(param_2);\n  pSVar4 = (SBase *)FbcAnd::getAssociation(this,uVar3);\n  local_34[0] = 0x636266;\n  local_38 = 3;\n  local_3c = local_34;\n  uVar5 = GetDowncastSwigTypeForPackage(pSVar4,(basic_string *)&local_3c);\n  uVar6 = R_NilValue;\n  if (pSVar4 != (SBase *)0x0) {\n    uVar6 = R_MakeExternalPtr(uVar5,R_NilValue,R_NilValue);\n    uVar6 = R_MakeExternalPtr(pSVar4,uVar6,R_NilValue);\n    SET_S4_OBJECT();\n  }\n  if (local_3c != local_34) {\n    operator_delete(local_3c,local_34[0] + 1);\n  }\n  vmaxset(uVar1);\n  if (local_24 == __stack_chk_guard) {\n    return uVar6;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.7524803280830383,
        "similarity_score_baseline_stripped": 0.7560738921165466
    },
    {
        "func_name": "pyvte_register_classes",
        "normed_func_sha256": "4bd35d7a33e51270fa4b586a0ac2f1582f9738d197f34693497f65563c03b29e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid pyvte_register_classes(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  iVar1 = PyImport_ImportModule(&DAT_00019d94);\n  if (iVar1 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"could not import gtk\");\n    return;\n  }\n  uVar2 = PyModule_GetDict();\n  _DAT_0002b6b4 = PyDict_GetItemString(uVar2,\"MenuShell\");\n  if (_DAT_0002b6b4 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name MenuShell from gtk\");\n    return;\n  }\n  _DAT_0002b6b0 = PyDict_GetItemString(uVar2,\"Widget\");\n  if (_DAT_0002b6b0 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name Widget from gtk\");\n    return;\n  }\n  iVar1 = PyImport_ImportModule(\"gtk.gdk\");\n  if (iVar1 != 0) {\n    uVar2 = PyModule_GetDict();\n    _DAT_0002b6b8 = PyDict_GetItemString(uVar2,\"Pixbuf\");\n    if (_DAT_0002b6b8 == 0) {\n      PyErr_SetString(_PyExc_ImportError,\"cannot import name Pixbuf from gtk.gdk\");\n    }\n    else {\n      pcVar4 = *_PyGObject_API;\n      uVar2 = vte_terminal_get_type();\n      uVar3 = Py_BuildValue(&DAT_00019e64,_DAT_0002b6b0);\n      (*pcVar4)(param_1,\"VteTerminal\",uVar2,PyVteTerminal_Type,uVar3);\n    }\n    return;\n  }\n  PyErr_SetString(_PyExc_ImportError,\"could not import gtk.gdk\");\n  return;\n}",
        "output": "void pyvte_register_classes(undefined4 param_1)\n{\n    int module_gtk = PyImport_ImportModule(&DAT_00019d94);\n    \n    if (module_gtk == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"could not import gtk\");\n        return;\n    }\n    \n    undefined4 module_dict = PyModule_GetDict();\n    \n    _DAT_0002b6b4 = PyDict_GetItemString(module_dict, \"MenuShell\");\n    \n    if (_DAT_0002b6b4 == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"cannot import name MenuShell from gtk\");\n        return;\n    }\n    \n    _DAT_0002b6b0 = PyDict_GetItemString(module_dict, \"Widget\");\n    \n    if (_DAT_0002b6b0 == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"cannot import name Widget from gtk\");\n        return;\n    }\n    \n    int module_gtk_gdk = PyImport_ImportModule(\"gtk.gdk\");\n    \n    if (module_gtk_gdk != 0) {\n        module_dict = PyModule_GetDict();\n        _DAT_0002b6b8 = PyDict_GetItemString(module_dict, \"Pixbuf\");\n        \n        if (_DAT_0002b6b8 == 0) {\n            PyErr_SetString(_PyExc_ImportError, \"cannot import name Pixbuf from gtk.gdk\");\n        }\n        else {\n            code *gobject_api = *_PyGObject_API;\n            undefined4 terminal_type = vte_terminal_get_type();\n            undefined4 terminal_value = Py_BuildValue(&DAT_00019e64, _DAT_0002b6b0);\n            (*gobject_api)(param_1, \"VteTerminal\", terminal_type, PyVteTerminal_Type, terminal_value);\n        }\n        return;\n    }\n    \n    PyErr_SetString(_PyExc_ImportError, \"could not import gtk.gdk\");\n    return;\n}",
        "source_code": "void\npyvte_register_classes(PyObject *d)\n{\n    PyObject *module;\n\n    if ((module = PyImport_ImportModule(\"gtk\")) != NULL) {\n        PyObject *moddict = PyModule_GetDict(module);\n\n        _PyGtkMenuShell_Type = (PyTypeObject *)PyDict_GetItemString(moddict, \"MenuShell\");\n        if (_PyGtkMenuShell_Type == NULL) {\n            PyErr_SetString(PyExc_ImportError,\n                \"cannot import name MenuShell from gtk\");\n            return;\n        }\n        _PyGtkWidget_Type = (PyTypeObject *)PyDict_GetItemString(moddict, \"Widget\");\n        if (_PyGtkWidget_Type == NULL) {\n            PyErr_SetString(PyExc_ImportError,\n                \"cannot import name Widget from gtk\");\n            return;\n        }\n    } else {\n        PyErr_SetString(PyExc_ImportError,\n            \"could not import gtk\");\n        return;\n    }\n    if ((module = PyImport_ImportModule(\"gtk.gdk\")) != NULL) {\n        PyObject *moddict = PyModule_GetDict(module);\n\n        _PyGdkPixbuf_Type = (PyTypeObject *)PyDict_GetItemString(moddict, \"Pixbuf\");\n        if (_PyGdkPixbuf_Type == NULL) {\n            PyErr_SetString(PyExc_ImportError,\n                \"cannot import name Pixbuf from gtk.gdk\");\n            return;\n        }\n    } else {\n        PyErr_SetString(PyExc_ImportError,\n            \"could not import gtk.gdk\");\n        return;\n    }\n\n\n#line 1540 \"vte.c\"\n    pygobject_register_class(d, \"VteTerminal\", VTE_TYPE_TERMINAL, &PyVteTerminal_Type, Py_BuildValue(\"(O)\", &PyGtkWidget_Type));\n}",
        "parsed_output": "void pyvte_register_classes(undefined4 param_1)\n{\n    int module_gtk = PyImport_ImportModule(&DAT_00019d94);\n    \n    if (module_gtk == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"could not import gtk\");\n        return;\n    }\n    \n    undefined4 module_dict = PyModule_GetDict();\n    \n    _DAT_0002b6b4 = PyDict_GetItemString(module_dict, \"MenuShell\");\n    \n    if (_DAT_0002b6b4 == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"cannot import name MenuShell from gtk\");\n        return;\n    }\n    \n    _DAT_0002b6b0 = PyDict_GetItemString(module_dict, \"Widget\");\n    \n    if (_DAT_0002b6b0 == 0) {\n        PyErr_SetString(_PyExc_ImportError, \"cannot import name Widget from gtk\");\n        return;\n    }\n    \n    int module_gtk_gdk = PyImport_ImportModule(\"gtk.gdk\");\n    \n    if (module_gtk_gdk != 0) {\n        module_dict = PyModule_GetDict();\n        _DAT_0002b6b8 = PyDict_GetItemString(module_dict, \"Pixbuf\");\n        \n        if (_DAT_0002b6b8 == 0) {\n            PyErr_SetString(_PyExc_ImportError, \"cannot import name Pixbuf from gtk.gdk\");\n        }\n        else {\n            code *gobject_api = *_PyGObject_API;\n            undefined4 terminal_type = vte_terminal_get_type();\n            undefined4 terminal_value = Py_BuildValue(&DAT_00019e64, _DAT_0002b6b0);\n            (*gobject_api)(param_1, \"VteTerminal\", terminal_type, PyVteTerminal_Type, terminal_value);\n        }\n        return;\n    }\n    \n    PyErr_SetString(_PyExc_ImportError, \"could not import gtk.gdk\");\n    return;\n}",
        "baseline_code_stripped": "void pyvte_register_classes(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  iVar1 = PyImport_ImportModule(&DAT_00019d94);\n  if (iVar1 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"could not import gtk\");\n    return;\n  }\n  uVar2 = PyModule_GetDict();\n  _DAT_0002b6b4 = PyDict_GetItemString(uVar2,\"MenuShell\");\n  if (_DAT_0002b6b4 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name MenuShell from gtk\");\n    return;\n  }\n  _DAT_0002b6b0 = PyDict_GetItemString(uVar2,\"Widget\");\n  if (_DAT_0002b6b0 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name Widget from gtk\");\n    return;\n  }\n  iVar1 = PyImport_ImportModule(\"gtk.gdk\");\n  if (iVar1 != 0) {\n    uVar2 = PyModule_GetDict();\n    _DAT_0002b6b8 = PyDict_GetItemString(uVar2,\"Pixbuf\");\n    if (_DAT_0002b6b8 == 0) {\n      PyErr_SetString(_PyExc_ImportError,\"cannot import name Pixbuf from gtk.gdk\");\n    }\n    else {\n      pcVar4 = *_PyGObject_API;\n      uVar2 = vte_terminal_get_type();\n      uVar3 = Py_BuildValue(&DAT_00019e64,_DAT_0002b6b0);\n      (*pcVar4)(param_1,\"VteTerminal\",uVar2,PyVteTerminal_Type,uVar3);\n    }\n    return;\n  }\n  PyErr_SetString(_PyExc_ImportError,\"could not import gtk.gdk\");\n  return;\n}",
        "similarity_score_unixcoder": 0.8404698967933655,
        "similarity_score_baseline_stripped": 0.7555392980575562
    },
    {
        "func_name": "snd_emu10k1_free",
        "normed_func_sha256": "7916cc23f04be8d9309dac74c5a2d12fe29e327d0cb85d34a8ecca374c1f4b56",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 snd_emu10k1_free(int *param_1)\n{\n  char cVar1;\n  if (*(long *)(param_1 + 2) == 0) {\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  else {\n    snd_emu10k1_fx8010_tram_setup(param_1,0);\n    snd_emu10k1_done(param_1);\n    snd_emu10k1_free_efx(param_1);\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  if (cVar1 == '\\x01') {\n    snd_emu1010_fpga_write(param_1,4,0);\n  }\n  cancel_delayed_work_sync(param_1 + 0x468);\n  release_firmware(*(undefined8 *)(param_1 + 2000));\n  release_firmware(*(undefined8 *)(param_1 + 0x7d2));\n  if (-1 < *param_1) {\n    free_irq(*param_1,param_1);\n  }\n  if (*(long *)(param_1 + 0x3e) != 0) {\n    snd_emu10k1_synth_free(param_1);\n    *(undefined8 *)(param_1 + 0x3e) = 0;\n  }\n  snd_util_memhdr_free(*(undefined8 *)(param_1 + 0x3c));\n  if (*(long *)(param_1 + 0x18) != 0) {\n    snd_dma_free_pages(param_1 + 0x14);\n  }\n  if (*(long *)(param_1 + 0x24) != 0) {\n    snd_dma_free_pages(param_1 + 0x20);\n  }\n  vfree(*(undefined8 *)(param_1 + 0x48));\n  vfree(*(undefined8 *)(param_1 + 0x4a));\n  vfree(*(undefined8 *)(param_1 + 0x7d4));\n  snd_emu10k1_efx_free_pm_buffer(param_1);\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free_pm_buffer(param_1);\n  }\n  if (*(long *)(param_1 + 2) != 0) {\n    pci_release_regions(*(undefined8 *)(param_1 + 0x19c));\n  }\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free(param_1);\n  }\n  pci_disable_device(*(undefined8 *)(param_1 + 0x19c));\n  kfree(param_1);\n  return 0;\n}",
        "output": "```c\nundefined8 snd_emu10k1_free(int *param_1)\n{\n    char cVar1;\n    \n    if (*(long *)(param_1 + 2) == 0) {\n        cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n    } else {\n        snd_emu10k1_fx8010_tram_setup(param_1, 0);\n        snd_emu10k1_done(param_1);\n        snd_emu10k1_free_efx(param_1);\n        cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n    }\n    \n    if (cVar1 == '\\x01') {\n        snd_emu1010_fpga_write(param_1, 4, 0);\n    }\n    \n    cancel_delayed_work_sync(param_1 + 0x468);\n    release_firmware(*(undefined8 *)(param_1 + 2000));\n    release_firmware(*(undefined8 *)(param_1 + 0x7d2));\n    \n    if (-1 < *param_1) {\n        free_irq(*param_1, param_1);\n    }\n    \n    if (*(long *)(param_1 + 0x3e) != 0) {\n        snd_emu10k1_synth_free(param_1);\n        *(undefined8 *)(param_1 + 0x3e) = 0;\n    }\n    \n    snd_util_memhdr_free(*(undefined8 *)(param_1 + 0x3c));\n    \n    if (*(long *)(param_1 + 0x18) != 0) {\n        snd_dma_free_pages(param_1 + 0x14);\n    }\n    \n    if (*(long *)(param_1 + 0x24) != 0) {\n        snd_dma_free_pages(param_1 + 0x20);\n    }\n    \n    vfree(*(undefined8 *)(param_1 + 0x48));\n    vfree(*(undefined8 *)(param_1 + 0x4a));\n    vfree(*(undefined8 *)(param_1 + 0x7d4));\n    snd_emu10k1_efx_free_pm_buffer(param_1);\n    \n    if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n        snd_p16v_free_pm_buffer(param_1);\n    }\n    \n    if (*(long *)(param_1 + 2) != 0) {\n        pci_release_regions(*(undefined8 *)(param_1 + 0x19c));\n    }\n    \n    if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n        snd_p16v_free(param_1);\n    }\n    \n    pci_disable_device(*(undefined8 *)(param_1 + 0x19c));\n    kfree(param_1);\n    \n    return 0;\n}\n```",
        "source_code": "static int snd_emu10k1_free(struct snd_emu10k1 *emu)\n{\n\tif (emu->port) {\t/* avoid access to already used hardware */\n\t\tsnd_emu10k1_fx8010_tram_setup(emu, 0);\n\t\tsnd_emu10k1_done(emu);\n\t\tsnd_emu10k1_free_efx(emu);\n\t}\n\tif (emu->card_capabilities->emu_model == EMU_MODEL_EMU1010) {\n\t\t/* Disable 48Volt power to Audio Dock */\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_PWR, 0);\n\t}\n\tcancel_delayed_work_sync(&emu->emu1010.firmware_work);\n\trelease_firmware(emu->firmware);\n\trelease_firmware(emu->dock_fw);\n\tif (emu->irq >= 0)\n\t\tfree_irq(emu->irq, emu);\n\t/* remove reserved page */\n\tif (emu->reserved_page) {\n\t\tsnd_emu10k1_synth_free(emu,\n\t\t\t(struct snd_util_memblk *)emu->reserved_page);\n\t\temu->reserved_page = NULL;\n\t}\n\tsnd_util_memhdr_free(emu->memhdr);\n\tif (emu->silent_page.area)\n\t\tsnd_dma_free_pages(&emu->silent_page);\n\tif (emu->ptb_pages.area)\n\t\tsnd_dma_free_pages(&emu->ptb_pages);\n\tvfree(emu->page_ptr_table);\n\tvfree(emu->page_addr_table);\n#ifdef CONFIG_PM_SLEEP\n\tfree_pm_buffer(emu);\n#endif\n\tif (emu->port)\n\t\tpci_release_regions(emu->pci);\n\tif (emu->card_capabilities->ca0151_chip) /* P16V */\n\t\tsnd_p16v_free(emu);\n\tpci_disable_device(emu->pci);\n\tkfree(emu);\n\treturn 0;\n}",
        "parsed_output": "undefined8 snd_emu10k1_free(int *param_1)\n{\n    char cVar1;\n    \n    if (*(long *)(param_1 + 2) == 0) {\n        cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n    } else {\n        snd_emu10k1_fx8010_tram_setup(param_1, 0);\n        snd_emu10k1_done(param_1);\n        snd_emu10k1_free_efx(param_1);\n        cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n    }\n    \n    if (cVar1 == '\\x01') {\n        snd_emu1010_fpga_write(param_1, 4, 0);\n    }\n    \n    cancel_delayed_work_sync(param_1 + 0x468);\n    release_firmware(*(undefined8 *)(param_1 + 2000));\n    release_firmware(*(undefined8 *)(param_1 + 0x7d2));\n    \n    if (-1 < *param_1) {\n        free_irq(*param_1, param_1);\n    }\n    \n    if (*(long *)(param_1 + 0x3e) != 0) {\n        snd_emu10k1_synth_free(param_1);\n        *(undefined8 *)(param_1 + 0x3e) = 0;\n    }\n    \n    snd_util_memhdr_free(*(undefined8 *)(param_1 + 0x3c));\n    \n    if (*(long *)(param_1 + 0x18) != 0) {\n        snd_dma_free_pages(param_1 + 0x14);\n    }\n    \n    if (*(long *)(param_1 + 0x24) != 0) {\n        snd_dma_free_pages(param_1 + 0x20);\n    }\n    \n    vfree(*(undefined8 *)(param_1 + 0x48));\n    vfree(*(undefined8 *)(param_1 + 0x4a));\n    vfree(*(undefined8 *)(param_1 + 0x7d4));\n    snd_emu10k1_efx_free_pm_buffer(param_1);\n    \n    if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n        snd_p16v_free_pm_buffer(param_1);\n    }\n    \n    if (*(long *)(param_1 + 2) != 0) {\n        pci_release_regions(*(undefined8 *)(param_1 + 0x19c));\n    }\n    \n    if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n        snd_p16v_free(param_1);\n    }\n    \n    pci_disable_device(*(undefined8 *)(param_1 + 0x19c));\n    kfree(param_1);\n    \n    return 0;\n}",
        "baseline_code_stripped": "undefined8 snd_emu10k1_free(int *param_1)\n{\n  char cVar1;\n  if (*(long *)(param_1 + 2) == 0) {\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  else {\n    snd_emu10k1_fx8010_tram_setup(param_1,0);\n    snd_emu10k1_done(param_1);\n    snd_emu10k1_free_efx(param_1);\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  if (cVar1 == '\\x01') {\n    snd_emu1010_fpga_write(param_1,4,0);\n  }\n  cancel_delayed_work_sync(param_1 + 0x468);\n  release_firmware(*(undefined8 *)(param_1 + 2000));\n  release_firmware(*(undefined8 *)(param_1 + 0x7d2));\n  if (-1 < *param_1) {\n    free_irq(*param_1,param_1);\n  }\n  if (*(long *)(param_1 + 0x3e) != 0) {\n    snd_emu10k1_synth_free(param_1);\n    *(undefined8 *)(param_1 + 0x3e) = 0;\n  }\n  snd_util_memhdr_free(*(undefined8 *)(param_1 + 0x3c));\n  if (*(long *)(param_1 + 0x18) != 0) {\n    snd_dma_free_pages(param_1 + 0x14);\n  }\n  if (*(long *)(param_1 + 0x24) != 0) {\n    snd_dma_free_pages(param_1 + 0x20);\n  }\n  vfree(*(undefined8 *)(param_1 + 0x48));\n  vfree(*(undefined8 *)(param_1 + 0x4a));\n  vfree(*(undefined8 *)(param_1 + 0x7d4));\n  snd_emu10k1_efx_free_pm_buffer(param_1);\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free_pm_buffer(param_1);\n  }\n  if (*(long *)(param_1 + 2) != 0) {\n    pci_release_regions(*(undefined8 *)(param_1 + 0x19c));\n  }\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free(param_1);\n  }\n  pci_disable_device(*(undefined8 *)(param_1 + 0x19c));\n  kfree(param_1);\n  return 0;\n}",
        "similarity_score_unixcoder": 0.837684690952301,
        "similarity_score_baseline_stripped": 0.8360658884048462
    },
    {
        "func_name": "convertFrom_QList_0100QDnsHostAddressRecord",
        "normed_func_sha256": "6cadc0caffb7273788f1974ca5bb6effe345d68f63efb69a004f9417d034c88f",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nlong * convertFrom_QList_0100QDnsHostAddressRecord(long *param_1,undefined8 param_2)\n{\n  int iVar1;\n  int iVar2;\n  long *plVar3;\n  QDnsHostAddressRecord *this;\n  long lVar4;\n  long lVar5;\n  plVar3 = (long *)PyList_New((long)(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8)));\n  if (plVar3 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  lVar4 = *param_1;\n  iVar1 = *(int *)(lVar4 + 8);\n  if (0 < *(int *)(lVar4 + 0xc) - iVar1) {\n    lVar5 = 0;\n    do {\n      this = (QDnsHostAddressRecord *)operator_new(8);\n      QDnsHostAddressRecord::QDnsHostAddressRecord\n                (this,(QDnsHostAddressRecord *)(lVar4 + 0x10 + (iVar1 + lVar5) * 8));\n      lVar4 = (**(code **)(DAT_003be900 + 0x88))\n                        (this,*(undefined8 *)(PTR_PTR_DAT_003acda0 + 0x68),param_2);\n      if (lVar4 == 0) {\n        QDnsHostAddressRecord::_QDnsHostAddressRecord(this);\n        operator_delete(this);\n        *plVar3 = *plVar3 + -1;\n        if (*plVar3 != 0) {\n          return (long *)0x0;\n        }\n        (**(code **)(plVar3[1] + 0x30))(plVar3);\n        return (long *)0x0;\n      }\n      iVar2 = (int)lVar5;\n      *(long *)(plVar3[3] + lVar5 * 8) = lVar4;\n      lVar4 = *param_1;\n      lVar5 = lVar5 + 1;\n      iVar1 = *(int *)(lVar4 + 8);\n    } while (iVar2 + 1 < *(int *)(lVar4 + 0xc) - iVar1);\n  }\n  return plVar3;\n}",
        "output": "```c\nlong * convertFrom_QList_0100QDnsHostAddressRecord(long *param_1, undefined8 param_2)\n{\n    int start_index = *(int *)(*param_1 + 8);\n    int end_index = *(int *)(*param_1 + 0xc);\n    \n    long *result = (long *)PyList_New((long)(end_index - start_index));\n    \n    if (result == (long *)0x0) {\n        return (long *)0x0;\n    }\n    \n    long base_address = *param_1;\n    \n    if (end_index - start_index > 0) {\n        for (int i = 0; i < end_index - start_index; i++) {\n            QDnsHostAddressRecord *record = (QDnsHostAddressRecord *)operator_new(8);\n            QDnsHostAddressRecord::QDnsHostAddressRecord(record, (QDnsHostAddressRecord *)(base_address + 0x10 + (start_index + i) * 8));\n            \n            long address = (**(code **)(DAT_003be900 + 0x88))(record, *(undefined8 *)(PTR_PTR_DAT_003acda0 + 0x68), param_2);\n            \n            if (address == 0) {\n                QDnsHostAddressRecord::_QDnsHostAddressRecord(record);\n                operator_delete(record);\n                *result = *result + -1;\n                \n                if (*result != 0) {\n                    return (long *)0x0;\n                }\n                \n                (**(code **)(result[1] + 0x30))(result);\n                return (long *)0x0;\n            }\n            \n            *(long *)(result[3] + i * 8) = address;\n        }\n    }\n    \n    return result;\n}\n```",
        "source_code": "static PyObject *convertFrom_QList_0100QDnsHostAddressRecord(void *sipCppV, PyObject *sipTransferObj)\n{\n   QList<QDnsHostAddressRecord> *sipCpp = reinterpret_cast<QList<QDnsHostAddressRecord> *>(sipCppV);\n\n#line 40 \"sip/QtCore/qpycore_qlist.sip\"\n    PyObject *l = PyList_New(sipCpp->size());\n\n    if (!l)\n        return 0;\n\n    for (int i = 0; i < sipCpp->size(); ++i)\n    {\n        QDnsHostAddressRecord *t = new QDnsHostAddressRecord(sipCpp->at(i));\n        PyObject *tobj = sipConvertFromNewType(t, sipType_QDnsHostAddressRecord,\n                sipTransferObj);\n\n        if (!tobj)\n        {\n            delete t;\n            Py_DECREF(l);\n\n            return 0;\n        }\n\n        PyList_SET_ITEM(l, i, tobj);\n    }\n\n    return l;\n#line 175 \"/builddir/build/BUILD/PyQt-gpl-5.4.1/QtNetwork/sipQtNetworkQList0100QDnsHostAddressRecord.cpp\"\n}",
        "parsed_output": "long * convertFrom_QList_0100QDnsHostAddressRecord(long *param_1, undefined8 param_2)\n{\n    int start_index = *(int *)(*param_1 + 8);\n    int end_index = *(int *)(*param_1 + 0xc);\n    \n    long *result = (long *)PyList_New((long)(end_index - start_index));\n    \n    if (result == (long *)0x0) {\n        return (long *)0x0;\n    }\n    \n    long base_address = *param_1;\n    \n    if (end_index - start_index > 0) {\n        for (int i = 0; i < end_index - start_index; i++) {\n            QDnsHostAddressRecord *record = (QDnsHostAddressRecord *)operator_new(8);\n            QDnsHostAddressRecord::QDnsHostAddressRecord(record, (QDnsHostAddressRecord *)(base_address + 0x10 + (start_index + i) * 8));\n            \n            long address = (**(code **)(DAT_003be900 + 0x88))(record, *(undefined8 *)(PTR_PTR_DAT_003acda0 + 0x68), param_2);\n            \n            if (address == 0) {\n                QDnsHostAddressRecord::_QDnsHostAddressRecord(record);\n                operator_delete(record);\n                *result = *result + -1;\n                \n                if (*result != 0) {\n                    return (long *)0x0;\n                }\n                \n                (**(code **)(result[1] + 0x30))(result);\n                return (long *)0x0;\n            }\n            \n            *(long *)(result[3] + i * 8) = address;\n        }\n    }\n    \n    return result;\n}",
        "baseline_code_stripped": "long * convertFrom_QList_0100QDnsHostAddressRecord(long *param_1,undefined8 param_2)\n{\n  int iVar1;\n  int iVar2;\n  long *plVar3;\n  QDnsHostAddressRecord *this;\n  long lVar4;\n  long lVar5;\n  plVar3 = (long *)PyList_New((long)(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8)));\n  if (plVar3 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  lVar4 = *param_1;\n  iVar1 = *(int *)(lVar4 + 8);\n  if (0 < *(int *)(lVar4 + 0xc) - iVar1) {\n    lVar5 = 0;\n    do {\n      this = (QDnsHostAddressRecord *)operator_new(8);\n      QDnsHostAddressRecord::QDnsHostAddressRecord\n                (this,(QDnsHostAddressRecord *)(lVar4 + 0x10 + (iVar1 + lVar5) * 8));\n      lVar4 = (**(code **)(DAT_003be900 + 0x88))\n                        (this,*(undefined8 *)(PTR_PTR_DAT_003acda0 + 0x68),param_2);\n      if (lVar4 == 0) {\n        QDnsHostAddressRecord::_QDnsHostAddressRecord(this);\n        operator_delete(this);\n        *plVar3 = *plVar3 + -1;\n        if (*plVar3 != 0) {\n          return (long *)0x0;\n        }\n        (**(code **)(plVar3[1] + 0x30))(plVar3);\n        return (long *)0x0;\n      }\n      iVar2 = (int)lVar5;\n      *(long *)(plVar3[3] + lVar5 * 8) = lVar4;\n      lVar4 = *param_1;\n      lVar5 = lVar5 + 1;\n      iVar1 = *(int *)(lVar4 + 8);\n    } while (iVar2 + 1 < *(int *)(lVar4 + 0xc) - iVar1);\n  }\n  return plVar3;\n}",
        "similarity_score_unixcoder": 0.6302326321601868,
        "similarity_score_baseline_stripped": 0.5882964134216309
    },
    {
        "func_name": "lanczos_sum",
        "normed_func_sha256": "aa926806698568afe804827d3a7e0634e6e70b210e8b7d1b88bdb9f046cdbad7",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_004b6e60(void)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 local_c4 [48];\n  puVar2 = local_c4;\n  for (iVar1 = 0x30; iVar1 != 0; iVar1 = iVar1 + -1) {\n    *puVar2 = 0xcccccccc;\n    puVar2 = puVar2 + 1;\n  }\n  return DAT_0067f96c;\n}",
        "output": "```c\nundefined4 FUN_004b6e60(void)\n{\n    int iVar1;\n    undefined4 *puVar2;\n    undefined4 local_c4[48];\n    \n    puVar2 = local_c4;\n    \n    for (iVar1 = 0x30; iVar1 != 0; iVar1--) {\n        *puVar2 = 0xcccccccc;\n        puVar2++;\n    }\n    \n    return DAT_0067f96c;\n}\n```",
        "source_code": "static T lanczos_sum(const T& z)\n   {\n      lanczos_initializer<lanczos31UDT, T>::force_instantiate(); // Ensure our constants get initialized before main()\n      static const T num[31] = {\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.2579646553333513328235723061836959833277e46)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.2444796504337453845497419271639377138264e46)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.1119885499016017172212179730662673475329e46)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.3301983829072723658949204487793889113715e45)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.7041171040503851585152895336505379417066e44)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.1156687509001223855125097826246939403504e44)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1522559363393940883866575697565974893306000)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 164914363507650839510801418717701057005700)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 14978522943127593263654178827041568394060)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1156707153701375383907746879648168666774)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 76739431129980851159755403434593664173.2)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 4407916278928188620282281495575981079.306)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 220487883931812802092792125175269667.3004)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 9644828280794966468052381443992828.433924)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 369996467042247229310044531282837.6549068)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 12468380890717344610932904378961.13494291)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 369289245210898235894444657859.0529720075)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 9607992460262594951559461829.34885209022)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 219225935074853412540086410.981421315799)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 4374309943598658046326340.720767382079549)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 76008779092264509404014.10530947173485581)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1143503533822162444712.335663112617754987)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 14779233719977576920.37884890049671578409)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 162409028440678302.9992838032166348069916)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1496561553388385.733407609544964535634135)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 11347624460661.81008311053190661436107043)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 68944915931.32004991941950530448472223832)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 322701221.6391432296123937035480931903651)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1092364.213992634267819050120261755371294)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 2380.151399852411512711176940867823024864)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 2.506628274631000502415765284811045253007)),\n      };\n      static const T denom[31] = {\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.8841761993739701954543616e31)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.3502799997985980526649278464e32)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.622621928420356134910574592e32)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 66951000306085302338993639424000)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 49361465831621147825759587123200)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 26751280755793398822580822142976)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 11139316913434780466101123891200)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 3674201658710345201899117607040)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 981347603630155088295475765440)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 215760462268683520394805979744)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 39539238727270799376544542000)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 6097272817323042122728617800)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 796974693974455191377937300)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 88776380550648116217781890)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 8459574446076318147830625)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 691254538651580660999025)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 48487623689430693038025)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 2918939500751087661105)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 150566737512021319125)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 6634460278534540725)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 248526574856284725)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 7860403394108265)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 207912996295875)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 4539323721075)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 80328850875)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1122686019)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 11921175)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 90335)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 435)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1)),\n      };\n      return boost::math::tools::evaluate_rational(num, denom, z, 31);\n   }",
        "parsed_output": "undefined4 FUN_004b6e60(void)\n{\n    int iVar1;\n    undefined4 *puVar2;\n    undefined4 local_c4[48];\n    \n    puVar2 = local_c4;\n    \n    for (iVar1 = 0x30; iVar1 != 0; iVar1--) {\n        *puVar2 = 0xcccccccc;\n        puVar2++;\n    }\n    \n    return DAT_0067f96c;\n}",
        "baseline_code_stripped": "undefined4 FUN_004b6e60(void)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 local_c4 [48];\n  puVar2 = local_c4;\n  for (iVar1 = 0x30; iVar1 != 0; iVar1 = iVar1 + -1) {\n    *puVar2 = 0xcccccccc;\n    puVar2 = puVar2 + 1;\n  }\n  return DAT_0067f96c;\n}",
        "similarity_score_unixcoder": 0.4303520917892456,
        "similarity_score_baseline_stripped": 0.44867292046546936
    },
    {
        "func_name": "f_13576",
        "normed_func_sha256": "f19258ac0f7d10f978bc48a10be9d2a0a304f0d67a4220eac22a7c83851526c7",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid f_13576(int param_1,code *param_2,int param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  undefined4 local_58;\n  code *local_54;\n  undefined4 local_50;\n  code *pcStack_4c;\n  int local_48;\n  undefined4 local_44;\n  code *local_40;\n  undefined4 *local_3c;\n  undefined4 local_38;\n  undefined4 local_34;\n  undefined4 local_30;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  local_1c = __stack_chk_guard;\n  if ((int)&local_40 - C_stack_limit < 0x39) {\n    local_48 = param_3;\n    C_save_and_reclaim_args(trf_13576,3,param_1);\n  }\n  if (param_3 != 0xe) goto LAB_0009a088;\n  uVar2 = 2;\n  local_3c = (undefined4 *)&DAT_00000006;\n  pcVar1 = *(code **)(param_2 + 4);\n  local_40 = param_2;\n  do {\n    param_2 = pcVar1;\n    (*param_2)(uVar2,&local_40);\nLAB_0009a088:\n    local_58 = 0x24000005;\n    local_54 = f_13586;\n    local_50 = *(undefined4 *)(param_1 + 8);\n    local_44 = *(undefined4 *)(param_1 + 0xc);\n    pcStack_4c = param_2;\n    local_48 = param_3;\n    local_28 = C_i_caar(param_3);\n    local_38 = *(undefined4 *)(param_1 + 0x10);\n    local_24 = *(undefined4 *)(*(int *)(param_3 + 4) + 8);\n    local_40 = *(code **)(DAT_00214554 + 4);\n    local_34 = *(undefined4 *)(param_1 + 0x14);\n    local_30 = *(undefined4 *)(param_1 + 8);\n    local_20 = *(undefined4 *)(param_1 + 0x1c);\n    local_2c = *(undefined4 *)(param_1 + 0x18);\n    uVar2 = 9;\n    pcVar1 = *(code **)(local_40 + 4);\n    local_3c = &local_58;\n  } while( true );\n}",
        "output": "```c\nvoid f_13576(int param_1, code *param_2, int param_3)\n{\n    code *next_func;\n    int arg_3;\n    code *saved_func;\n    int arg_1;\n    code *current_func;\n    int arg_2;\n    int *stack_guard;\n\n    stack_guard = &local_1c;\n    if ((int)&local_40 - C_stack_limit < 0x39) {\n        arg_1 = param_3;\n        C_save_and_reclaim_args(trf_13576, 3, param_1);\n    }\n    if (param_3 != 0xe) {\n        goto LAB_0009a088;\n    }\n    uVar2 = 2;\n    arg_2 = 6;\n    next_func = *(code **)(param_2 + 4);\n    saved_func = param_2;\n    do {\n        param_2 = next_func;\n        (*param_2)(uVar2, &saved_func);\n    LAB_0009a088:\n        local_58 = 0x24000005;\n        local_54 = f_13586;\n        local_50 = *(undefined4 *)(param_1 + 8);\n        local_44 = *(undefined4 *)(param_1 + 0xc);\n        pcStack_4c = param_2;\n        arg_1 = param_3;\n        local_28 = C_i_caar(param_3);\n        local_38 = *(undefined4 *)(param_1 + 0x10);\n        local_24 = *(undefined4 *)(*(int *)(param_3 + 4) + 8);\n        saved_func = *(code **)(DAT_00214554 + 4);\n        local_34 = *(undefined4 *)(param_1 + 0x14);\n        local_30 = *(undefined4 *)(param_1 + 8);\n        local_20 = *(undefined4 *)(param_1 + 0x1c);\n        local_2c = *(undefined4 *)(param_1 + 0x18);\n        uVar2 = 9;\n        next_func = *(code **)(saved_func + 4);\n        stack_guard = &local_58;\n    } while (true);\n}\n```",
        "source_code": "static void C_fcall f_13576(C_word t0,C_word t1,C_word t2){\nC_word tmp;\nC_word t3;\nC_word t4;\nC_word t5;\nC_word t6;\nC_word t7;\nC_word t8;\nC_word *a;\nif(C_unlikely(!C_demand(C_calculate_demand(6,0,8)))){\nC_save_and_reclaim_args((void *)trf_13576,3,t0,t1,t2);}\na=C_alloc(6);\nif(C_truep(C_i_nullp(t2))){\nt3=t1;{\nC_word av2[2];\nav2[0]=t3;\nav2[1]=C_SCHEME_FALSE;\n((C_proc)(void*)(*((C_word*)t3+1)))(2,av2);}}\nelse{\nt3=(*a=C_CLOSURE_TYPE|5,a[1]=(C_word)f_13586,a[2]=((C_word*)t0)[2],a[3]=t1,a[4]=t2,a[5]=((C_word*)t0)[3],tmp=(C_word)a,a+=6,tmp);\nt4=C_i_caar(t2);\nt5=t2;\nt6=C_u_i_car(t5);\nt7=C_u_i_cdr(t6);\n/* optimizer.scm:614: simplify-named-call */\nt8=*((C_word*)lf[142]+1);{\nC_word av2[9];\nav2[0]=t8;\nav2[1]=t3;\nav2[2]=((C_word*)t0)[4];\nav2[3]=((C_word*)t0)[5];\nav2[4]=((C_word*)t0)[2];\nav2[5]=((C_word*)t0)[6];\nav2[6]=t4;\nav2[7]=t7;\nav2[8]=((C_word*)t0)[7];\n((C_proc)(void*)(*((C_word*)t8+1)))(9,av2);}}}",
        "parsed_output": "void f_13576(int param_1, code *param_2, int param_3)\n{\n    code *next_func;\n    int arg_3;\n    code *saved_func;\n    int arg_1;\n    code *current_func;\n    int arg_2;\n    int *stack_guard;\n\n    stack_guard = &local_1c;\n    if ((int)&local_40 - C_stack_limit < 0x39) {\n        arg_1 = param_3;\n        C_save_and_reclaim_args(trf_13576, 3, param_1);\n    }\n    if (param_3 != 0xe) {\n        goto LAB_0009a088;\n    }\n    uVar2 = 2;\n    arg_2 = 6;\n    next_func = *(code **)(param_2 + 4);\n    saved_func = param_2;\n    do {\n        param_2 = next_func;\n        (*param_2)(uVar2, &saved_func);\n    LAB_0009a088:\n        local_58 = 0x24000005;\n        local_54 = f_13586;\n        local_50 = *(undefined4 *)(param_1 + 8);\n        local_44 = *(undefined4 *)(param_1 + 0xc);\n        pcStack_4c = param_2;\n        arg_1 = param_3;\n        local_28 = C_i_caar(param_3);\n        local_38 = *(undefined4 *)(param_1 + 0x10);\n        local_24 = *(undefined4 *)(*(int *)(param_3 + 4) + 8);\n        saved_func = *(code **)(DAT_00214554 + 4);\n        local_34 = *(undefined4 *)(param_1 + 0x14);\n        local_30 = *(undefined4 *)(param_1 + 8);\n        local_20 = *(undefined4 *)(param_1 + 0x1c);\n        local_2c = *(undefined4 *)(param_1 + 0x18);\n        uVar2 = 9;\n        next_func = *(code **)(saved_func + 4);\n        stack_guard = &local_58;\n    } while (true);\n}",
        "baseline_code_stripped": "void f_13576(int param_1,code *param_2,int param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  undefined4 local_58;\n  code *local_54;\n  undefined4 local_50;\n  code *pcStack_4c;\n  int local_48;\n  undefined4 local_44;\n  code *local_40;\n  undefined4 *local_3c;\n  undefined4 local_38;\n  undefined4 local_34;\n  undefined4 local_30;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  local_1c = __stack_chk_guard;\n  if ((int)&local_40 - C_stack_limit < 0x39) {\n    local_48 = param_3;\n    C_save_and_reclaim_args(trf_13576,3,param_1);\n  }\n  if (param_3 != 0xe) goto LAB_0009a088;\n  uVar2 = 2;\n  local_3c = (undefined4 *)&DAT_00000006;\n  pcVar1 = *(code **)(param_2 + 4);\n  local_40 = param_2;\n  do {\n    param_2 = pcVar1;\n    (*param_2)(uVar2,&local_40);\nLAB_0009a088:\n    local_58 = 0x24000005;\n    local_54 = f_13586;\n    local_50 = *(undefined4 *)(param_1 + 8);\n    local_44 = *(undefined4 *)(param_1 + 0xc);\n    pcStack_4c = param_2;\n    local_48 = param_3;\n    local_28 = C_i_caar(param_3);\n    local_38 = *(undefined4 *)(param_1 + 0x10);\n    local_24 = *(undefined4 *)(*(int *)(param_3 + 4) + 8);\n    local_40 = *(code **)(DAT_00214554 + 4);\n    local_34 = *(undefined4 *)(param_1 + 0x14);\n    local_30 = *(undefined4 *)(param_1 + 8);\n    local_20 = *(undefined4 *)(param_1 + 0x1c);\n    local_2c = *(undefined4 *)(param_1 + 0x18);\n    uVar2 = 9;\n    pcVar1 = *(code **)(local_40 + 4);\n    local_3c = &local_58;\n  } while( true );\n}",
        "similarity_score_unixcoder": 0.6794668436050415,
        "similarity_score_baseline_stripped": 0.727569580078125
    },
    {
        "func_name": "_file_lock_resource",
        "normed_func_sha256": "d0fba9e85cb6773ff43f667f15fe8c48cfefc9fd71efc7d106be2fcc253667fa",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_0026ef42(undefined8 param_1,long param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_1018 [4104];\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = is_orphan_vg(param_2);\n  if (iVar1 == 0) {\n    iVar1 = is_global_vg(param_2);\n    if (iVar1 != 0) goto LAB_0026efa1;\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/V_%s\",&DAT_003a8f80,param_2);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x37,0xffffffff,\"Too long locking filename %s/V_%s.\",\n                &DAT_003a8f80,param_2);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  else {\nLAB_0026efa1:\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/P_%s\",&DAT_003a8f80,param_2 + 1);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x32,0xffffffff,\"Too long locking filename %s/P_%s.\",\n                &DAT_003a8f80,param_2 + 1);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  iVar1 = lock_file(local_1018,param_3);\n  if (iVar1 == 0) {\n    print_log(7,\"locking/file_locking.c\",0x3c,0,\"<backtrace>\");\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 1;\n  }\nLAB_0026f0f0:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return uVar2;\n}",
        "output": "```c\nundefined8 file_locking_function(undefined8 param_1, long param_2, undefined4 param_3)\n{\n    int result;\n    undefined8 return_value;\n    long local_variable;\n    undefined local_array[4104];\n\n    local_variable = *(long *)(in_FS_OFFSET + 0x28);\n    \n    if (is_orphan_vg(param_2) == 0) {\n        if (is_global_vg(param_2) != 0) {\n            result = dm_snprintf(local_array, 0x1000, \"%s/V_%s\", &DAT_003a8f80, param_2);\n            if (result < 0) {\n                print_log(3, \"locking/file_locking.c\", 0x37, 0xffffffff, \"Too long locking filename %s/V_%s.\", &DAT_003a8f80, param_2);\n                return_value = 0;\n                goto LAB_0026f0f0;\n            }\n        } else {\n            result = dm_snprintf(local_array, 0x1000, \"%s/P_%s\", &DAT_003a8f80, param_2 + 1);\n            if (result < 0) {\n                print_log(3, \"locking/file_locking.c\", 0x32, 0xffffffff, \"Too long locking filename %s/P_%s.\", &DAT_003a8f80, param_2 + 1);\n                return_value = 0;\n                goto LAB_0026f0f0;\n            }\n        }\n    } else {\n        result = dm_snprintf(local_array, 0x1000, \"%s/P_%s\", &DAT_003a8f80, param_2 + 1);\n        if (result < 0) {\n            print_log(3, \"locking/file_locking.c\", 0x32, 0xffffffff, \"Too long locking filename %s/P_%s.\", &DAT_003a8f80, param_2 + 1);\n            return_value = 0;\n            goto LAB_0026f0f0;\n        }\n    }\n    \n    result = lock_file(local_array, param_3);\n    \n    if (result == 0) {\n        print_log(7, \"locking/file_locking.c\", 0x3c, 0, \"<backtrace>\");\n        return_value = 0;\n    } else {\n        return_value = 1;\n    }\n    \nLAB_0026f0f0:\n    \n    if (local_variable != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n    \n    return return_value;\n}\n```",
        "source_code": "static int _file_lock_resource(struct cmd_context *cmd, const char *resource,\n\t\t\t       uint32_t flags, const struct logical_volume *lv)\n{\n\tchar lockfile[PATH_MAX];\n\tif (is_orphan_vg(resource) || is_global_vg(resource)) {\n\t\tif (dm_snprintf(lockfile, sizeof(lockfile),\n\t\t\t\t\"%s/P_%s\", _lock_dir, resource + 1) < 0) {\n\t\t\tlog_error(\"Too long locking filename %s/P_%s.\", _lock_dir, resource + 1);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tif (dm_snprintf(lockfile, sizeof(lockfile), \"%s/V_%s\", _lock_dir, resource) < 0) {\n\t\t\tlog_error(\"Too long locking filename %s/V_%s.\", _lock_dir, resource);\n\t\t\treturn 0;\n\t\t}\n\tif (!lock_file(lockfile, flags))\n\t\treturn_0;\n\treturn 1;\n}",
        "parsed_output": "undefined8 file_locking_function(undefined8 param_1, long param_2, undefined4 param_3)\n{\n    int result;\n    undefined8 return_value;\n    long local_variable;\n    undefined local_array[4104];\n\n    local_variable = *(long *)(in_FS_OFFSET + 0x28);\n    \n    if (is_orphan_vg(param_2) == 0) {\n        if (is_global_vg(param_2) != 0) {\n            result = dm_snprintf(local_array, 0x1000, \"%s/V_%s\", &DAT_003a8f80, param_2);\n            if (result < 0) {\n                print_log(3, \"locking/file_locking.c\", 0x37, 0xffffffff, \"Too long locking filename %s/V_%s.\", &DAT_003a8f80, param_2);\n                return_value = 0;\n                goto LAB_0026f0f0;\n            }\n        } else {\n            result = dm_snprintf(local_array, 0x1000, \"%s/P_%s\", &DAT_003a8f80, param_2 + 1);\n            if (result < 0) {\n                print_log(3, \"locking/file_locking.c\", 0x32, 0xffffffff, \"Too long locking filename %s/P_%s.\", &DAT_003a8f80, param_2 + 1);\n                return_value = 0;\n                goto LAB_0026f0f0;\n            }\n        }\n    } else {\n        result = dm_snprintf(local_array, 0x1000, \"%s/P_%s\", &DAT_003a8f80, param_2 + 1);\n        if (result < 0) {\n            print_log(3, \"locking/file_locking.c\", 0x32, 0xffffffff, \"Too long locking filename %s/P_%s.\", &DAT_003a8f80, param_2 + 1);\n            return_value = 0;\n            goto LAB_0026f0f0;\n        }\n    }\n    \n    result = lock_file(local_array, param_3);\n    \n    if (result == 0) {\n        print_log(7, \"locking/file_locking.c\", 0x3c, 0, \"<backtrace>\");\n        return_value = 0;\n    } else {\n        return_value = 1;\n    }\n    \nLAB_0026f0f0:\n    \n    if (local_variable != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n    \n    return return_value;\n}",
        "baseline_code_stripped": "undefined8 FUN_0026ef42(undefined8 param_1,long param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_1018 [4104];\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = is_orphan_vg(param_2);\n  if (iVar1 == 0) {\n    iVar1 = is_global_vg(param_2);\n    if (iVar1 != 0) goto LAB_0026efa1;\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/V_%s\",&DAT_003a8f80,param_2);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x37,0xffffffff,\"Too long locking filename %s/V_%s.\",\n                &DAT_003a8f80,param_2);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  else {\nLAB_0026efa1:\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/P_%s\",&DAT_003a8f80,param_2 + 1);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x32,0xffffffff,\"Too long locking filename %s/P_%s.\",\n                &DAT_003a8f80,param_2 + 1);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  iVar1 = lock_file(local_1018,param_3);\n  if (iVar1 == 0) {\n    print_log(7,\"locking/file_locking.c\",0x3c,0,\"<backtrace>\");\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 1;\n  }\nLAB_0026f0f0:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return uVar2;\n}",
        "similarity_score_unixcoder": 0.6758820414543152,
        "similarity_score_baseline_stripped": 0.6461790204048157
    },
    {
        "func_name": "cGuiSet::OnMouseDown",
        "normed_func_sha256": "60ce5c70e10a015ca74b3b579492663bb3293a83f61e0be91776df7f6a0b4822",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_14019f6d0(longlong param_1,longlong param_2)\n{\n  longlong lVar1;\n  longlong *plVar2;\n  longlong *plVar3;\n  undefined8 *puVar4;\n  char cVar5;\n  uint uVar6;\n  longlong *plVar7;\n  longlong lVar8;\n  undefined auStack_a8 [32];\n  undefined local_88;\n  undefined4 local_78;\n  undefined4 local_74;\n  undefined4 local_70;\n  undefined4 local_6c;\n  undefined4 local_68;\n  undefined8 local_64;\n  undefined4 local_5c;\n  undefined4 local_58;\n  undefined4 uStack_54;\n  undefined4 uStack_50;\n  undefined4 uStack_4c;\n  undefined4 local_48;\n  undefined8 local_40;\n  undefined4 local_38;\n  ulonglong local_28;\n  local_28 = DAT_14062a040 ^ (ulonglong)auStack_a8;\n  uVar6 = FUN_1401ade30(*(undefined4 *)(param_2 + 0x10));\n  *(uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)uVar6 >> 5) * 4) =\n       *(uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)uVar6 >> 5) * 4) |\n       1 << (uVar6 & 0x1f);\n  local_68 = *(undefined4 *)(param_2 + 0x10);\n  local_70 = *(undefined4 *)(param_2 + 8);\n  local_6c = *(undefined4 *)(param_2 + 0xc);\n  lVar1 = *(longlong *)(param_1 + 0x68);\n  local_5c = *(undefined4 *)(param_2 + 0x1c);\n  local_64 = *(undefined8 *)(param_2 + 0x14);\n  local_40 = *(undefined8 *)(param_2 + 0x38);\n  local_58 = *(undefined4 *)(param_2 + 0x20);\n  uStack_54 = *(undefined4 *)(param_2 + 0x24);\n  uStack_50 = *(undefined4 *)(param_2 + 0x28);\n  uStack_4c = *(undefined4 *)(param_2 + 0x2c);\n  local_38 = *(undefined4 *)(param_2 + 0x40);\n  local_48 = *(undefined4 *)(param_2 + 0x30);\n  local_78 = *(undefined4 *)(param_1 + 0x160);\n  local_74 = *(undefined4 *)(param_1 + 0x164);\n  plVar7 = (longlong *)**(longlong **)(param_1 + 0x88);\n  if (plVar7 != *(longlong **)(param_1 + 0x88)) {\n    do {\n      plVar2 = (longlong *)plVar7[2];\n      lVar8 = plVar2[0x1c];\n      if (((((lVar8 == 0) || (cVar5 = FUN_1401d56a0(lVar8), cVar5 != '\\0')) &&\n           (*(char *)((longlong)plVar2 + 0xf9) != '\\0')) &&\n          (((plVar3 = *(longlong **)(param_1 + 0x50), plVar3 == (longlong *)0x0 ||\n            (plVar3 == plVar2)) ||\n           ((lVar8 != 0 && (cVar5 = FUN_1401d5ba0(lVar8,plVar3,0), cVar5 != '\\0')))))) &&\n         (*(char *)((longlong)plVar2 + 0x10c) != '\\0')) {\n        if ((*(longlong **)(param_1 + 0x68) != plVar2) &&\n           (cVar5 = (**(code **)(*plVar2 + 0xd0))(plVar2,&local_78), cVar5 != '\\0')) {\n          *(longlong **)(param_1 + 0x68) = plVar2;\n        }\n        local_88 = 0;\n        cVar5 = FUN_1401d4ea0(plVar2,1);\n        if (cVar5 != '\\0') goto LAB_14019f859;\n      }\n      plVar7 = (longlong *)*plVar7;\n    } while (plVar7 != (longlong *)*(longlong *)(param_1 + 0x88));\n  }\n  *(undefined8 *)(param_1 + 0x68) = 0;\nLAB_14019f859:\n  if ((*(longlong *)(param_1 + 0x68) != lVar1) && (lVar1 != 0)) {\n    for (puVar4 = (undefined8 *)**(undefined8 **)(param_1 + 0x88);\n        puVar4 != *(undefined8 **)(param_1 + 0x88); puVar4 = (undefined8 *)*puVar4) {\n      if (puVar4[2] == lVar1) {\n        local_88 = 1;\n        FUN_1401d4ea0(lVar1,8,&local_78,1);\n        break;\n      }\n    }\n  }\n  FUN_1404d6060(local_28 ^ (ulonglong)auStack_a8);\n  return;\n}",
        "output": "```c\nvoid process_data(longlong param_1, longlong param_2)\n{\n    uint uVar6;\n    longlong *plVar7;\n    longlong lVar8;\n    longlong lVar1;\n    longlong *plVar2;\n    longlong *plVar3;\n    undefined8 *puVar4;\n    char cVar5;\n    \n    // Extract data from param_2\n    uVar6 = get_data_offset(param_2 + 0x10);\n    \n    // Update values in param_1 based on extracted data\n    uint *ptr = (uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)uVar6 >> 5) * 4);\n    *ptr = *ptr | (1 << (uVar6 & 0x1f));\n    \n    // Extract more data from param_2\n    local_68 = *(undefined4 *)(param_2 + 0x10);\n    local_70 = *(undefined4 *)(param_2 + 8);\n    local_6c = *(undefined4 *)(param_2 + 0xc);\n    lVar1 = *(longlong *)(param_1 + 0x68);\n    local_5c = *(undefined4 *)(param_2 + 0x1c);\n    local_64 = *(undefined8 *)(param_2 + 0x14);\n    local_40 = *(undefined8 *)(param_2 + 0x38);\n    local_58 = *(undefined4 *)(param_2 + 0x20);\n    uStack_54 = *(undefined4 *)(param_2 + 0x24);\n    uStack_50 = *(undefined4 *)(param_2 + 0x28);\n    uStack_4c = *(undefined4 *)(param_2 + 0x2c);\n    local_38 = *(undefined4 *)(param_2 + 0x40);\n    local_48 = *(undefined4 *)(param_2 + 0x30);\n    local_78 = *(undefined4 *)(param_1 + 0x160);\n    local_74 = *(undefined4 *)(param_1 + 0x164);\n    \n    // Process data in a loop\n    plVar7 = (longlong *)**(longlong **)(param_1 + 0x88);\n    if (plVar7 != *(longlong **)(param_1 + 0x88)) {\n        do {\n            plVar2 = (longlong *)plVar7[2];\n            lVar8 = plVar2[0x1c];\n            if (((lVar8 == 0 || (cVar5 = check_data(lVar8), cVar5 != '\\0')) &&\n                (*(char *)((longlong)plVar2 + 0xf9) != '\\0') &&\n                ((plVar3 = *(longlong **)(param_1 + 0x50), plVar3 == (longlong *)0x0 ||\n                (plVar3 == plVar2) || (lVar8 != 0 && (cVar5 = check_data(lVar8, plVar3, 0), cVar5 != '\\0'))) &&\n                (*(char *)((longlong)plVar2 + 0x10c) != '\\0'))) {\n                if ((*(longlong **)(param_1 + 0x68) != plVar2) &&\n                    (cVar5 = (**(code **)(*plVar2 + 0xd0))(plVar2, &local_78), cVar5 != '\\0')) {\n                    *(longlong **)(param_1 + 0x68) = plVar2;\n                }\n                local_88 = 0;\n                cVar5 = process_data(plVar2, 1);\n                if (cVar5 != '\\0') {\n                    goto LAB_14019f859;\n                }\n            }\n            plVar7 = (longlong *)*plVar7;\n        } while (plVar7 != (longlong *)*(longlong *)(param_1 + 0x88));\n    }\n    \n    // Update values in param_1 based on processed data\n    *(undefined8 *)(param_1 + 0x68) = 0;\n    \nLAB_14019f859:\n    if ((*(longlong *)(param_1 + 0x68) != lVar1) && (lVar1 != 0)) {\n        for (puVar4 = (undefined8 *)**(undefined8 **)(param_1 + 0x88);\n            puVar4 != *(undefined8 **)(param_1 + 0x88); puVar4 = (undefined8 *)*puVar4) {\n            if (puVar4[2] == lVar1) {\n                local_88 = 1;\n                process_data(lVar1, 8, &local_78, 1);\n                break;\n            }\n        }\n    }\n    \n    // Final processing\n    process_final_data(local_28 ^ (ulonglong)auStack_a8);\n    return;\n}\n```",
        "source_code": "bool cGuiSet::OnMouseDown(cGuiMessageData &aData)\n\t{\n\t\t///////////////////////////\n\t\t//Set up variables\n\t\tmvMouseDown[cMath::Log2ToInt(aData.mlVal)] = true;\n\n\t\taData.mvPos = mvMousePos;\n\n\t\tiWidget *pOldFocus = mpFocusedWidget;\n\n\t\t///////////////////////////\n\t\t//Call widgets\n\t\tbool bRet = false;\n\t\ttWidgetListIt it = mlstWidgets.begin();\n\t\tfor(; it != mlstWidgets.end(); ++it)\n\t\t{\n\t\t\tiWidget *pWidget = *it;\n\n\t\t\t//If these is an attention set, do send clicks to any other widgets\n\t\t\tif(mpAttentionWidget && pWidget->IsConnectedTo(mpAttentionWidget)==false) \n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(pWidget->GetMouseIsOver())\n\t\t\t{\n\t\t\t\tif(mpFocusedWidget != pWidget)\n\t\t\t\t{\n\t\t\t\t\tif(pWidget->ProcessMessage(eGuiMessage_GotFocus, aData))\n\t\t\t\t\t{\n\t\t\t\t\t\tmpFocusedWidget = pWidget;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmpFocusedWidget = pWidget;\n\t\t\t\t}\n\n\t\t\t\t//Log(\"Got focus %d\\n\",pWidget);\n\n\t\t\t\tif(pWidget->ProcessMessage(eGuiMessage_MouseDown, aData))\n\t\t\t\t{\n\t\t\t\t\tbRet = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Se if anything was clicked\n\t\tif(bRet == false)\n\t\t{\n\t\t\tmpFocusedWidget = NULL;\n\t\t}\n\n\t\t//Lost focus callback\n\t\tif(mpFocusedWidget != pOldFocus)\n\t\t{\n\t\t\t//Log(\"Lost focus %d\\n\",pOldFocus);\n\t\t\tif(pOldFocus) pOldFocus->ProcessMessage(eGuiMessage_LostFocus, aData);\n\t\t\t\n\t\t}\n\n\t\treturn bRet;\n\t}",
        "parsed_output": "void process_data(longlong param_1, longlong param_2)\n{\n    uint uVar6;\n    longlong *plVar7;\n    longlong lVar8;\n    longlong lVar1;\n    longlong *plVar2;\n    longlong *plVar3;\n    undefined8 *puVar4;\n    char cVar5;\n    \n    // Extract data from param_2\n    uVar6 = get_data_offset(param_2 + 0x10);\n    \n    // Update values in param_1 based on extracted data\n    uint *ptr = (uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)uVar6 >> 5) * 4);\n    *ptr = *ptr | (1 << (uVar6 & 0x1f));\n    \n    // Extract more data from param_2\n    local_68 = *(undefined4 *)(param_2 + 0x10);\n    local_70 = *(undefined4 *)(param_2 + 8);\n    local_6c = *(undefined4 *)(param_2 + 0xc);\n    lVar1 = *(longlong *)(param_1 + 0x68);\n    local_5c = *(undefined4 *)(param_2 + 0x1c);\n    local_64 = *(undefined8 *)(param_2 + 0x14);\n    local_40 = *(undefined8 *)(param_2 + 0x38);\n    local_58 = *(undefined4 *)(param_2 + 0x20);\n    uStack_54 = *(undefined4 *)(param_2 + 0x24);\n    uStack_50 = *(undefined4 *)(param_2 + 0x28);\n    uStack_4c = *(undefined4 *)(param_2 + 0x2c);\n    local_38 = *(undefined4 *)(param_2 + 0x40);\n    local_48 = *(undefined4 *)(param_2 + 0x30);\n    local_78 = *(undefined4 *)(param_1 + 0x160);\n    local_74 = *(undefined4 *)(param_1 + 0x164);\n    \n    // Process data in a loop\n    plVar7 = (longlong *)**(longlong **)(param_1 + 0x88);\n    if (plVar7 != *(longlong **)(param_1 + 0x88)) {\n        do {\n            plVar2 = (longlong *)plVar7[2];\n            lVar8 = plVar2[0x1c];\n            if (((lVar8 == 0 || (cVar5 = check_data(lVar8), cVar5 != '\\0')) &&\n                (*(char *)((longlong)plVar2 + 0xf9) != '\\0') &&\n                ((plVar3 = *(longlong **)(param_1 + 0x50), plVar3 == (longlong *)0x0 ||\n                (plVar3 == plVar2) || (lVar8 != 0 && (cVar5 = check_data(lVar8, plVar3, 0), cVar5 != '\\0'))) &&\n                (*(char *)((longlong)plVar2 + 0x10c) != '\\0'))) {\n                if ((*(longlong **)(param_1 + 0x68) != plVar2) &&\n                    (cVar5 = (**(code **)(*plVar2 + 0xd0))(plVar2, &local_78), cVar5 != '\\0')) {\n                    *(longlong **)(param_1 + 0x68) = plVar2;\n                }\n                local_88 = 0;\n                cVar5 = process_data(plVar2, 1);\n                if (cVar5 != '\\0') {\n                    goto LAB_14019f859;\n                }\n            }\n            plVar7 = (longlong *)*plVar7;\n        } while (plVar7 != (longlong *)*(longlong *)(param_1 + 0x88));\n    }\n    \n    // Update values in param_1 based on processed data\n    *(undefined8 *)(param_1 + 0x68) = 0;\n    \nLAB_14019f859:\n    if ((*(longlong *)(param_1 + 0x68) != lVar1) && (lVar1 != 0)) {\n        for (puVar4 = (undefined8 *)**(undefined8 **)(param_1 + 0x88);\n            puVar4 != *(undefined8 **)(param_1 + 0x88); puVar4 = (undefined8 *)*puVar4) {\n            if (puVar4[2] == lVar1) {\n                local_88 = 1;\n                process_data(lVar1, 8, &local_78, 1);\n                break;\n            }\n        }\n    }\n    \n    // Final processing\n    process_final_data(local_28 ^ (ulonglong)auStack_a8);\n    return;\n}",
        "baseline_code_stripped": "void FUN_14019f6d0(longlong param_1,longlong param_2)\n{\n  longlong lVar1;\n  longlong *plVar2;\n  longlong *plVar3;\n  undefined8 *puVar4;\n  char cVar5;\n  uint uVar6;\n  longlong *plVar7;\n  longlong lVar8;\n  undefined auStack_a8 [32];\n  undefined local_88;\n  undefined4 local_78;\n  undefined4 local_74;\n  undefined4 local_70;\n  undefined4 local_6c;\n  undefined4 local_68;\n  undefined8 local_64;\n  undefined4 local_5c;\n  undefined4 local_58;\n  undefined4 uStack_54;\n  undefined4 uStack_50;\n  undefined4 uStack_4c;\n  undefined4 local_48;\n  undefined8 local_40;\n  undefined4 local_38;\n  ulonglong local_28;\n  local_28 = DAT_14062a040 ^ (ulonglong)auStack_a8;\n  uVar6 = FUN_1401ade30(*(undefined4 *)(param_2 + 0x10));\n  *(uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)uVar6 >> 5) * 4) =\n       *(uint *)(*(longlong *)(param_1 + 0x140) + ((ulonglong)(longlong)(int)uVar6 >> 5) * 4) |\n       1 << (uVar6 & 0x1f);\n  local_68 = *(undefined4 *)(param_2 + 0x10);\n  local_70 = *(undefined4 *)(param_2 + 8);\n  local_6c = *(undefined4 *)(param_2 + 0xc);\n  lVar1 = *(longlong *)(param_1 + 0x68);\n  local_5c = *(undefined4 *)(param_2 + 0x1c);\n  local_64 = *(undefined8 *)(param_2 + 0x14);\n  local_40 = *(undefined8 *)(param_2 + 0x38);\n  local_58 = *(undefined4 *)(param_2 + 0x20);\n  uStack_54 = *(undefined4 *)(param_2 + 0x24);\n  uStack_50 = *(undefined4 *)(param_2 + 0x28);\n  uStack_4c = *(undefined4 *)(param_2 + 0x2c);\n  local_38 = *(undefined4 *)(param_2 + 0x40);\n  local_48 = *(undefined4 *)(param_2 + 0x30);\n  local_78 = *(undefined4 *)(param_1 + 0x160);\n  local_74 = *(undefined4 *)(param_1 + 0x164);\n  plVar7 = (longlong *)**(longlong **)(param_1 + 0x88);\n  if (plVar7 != *(longlong **)(param_1 + 0x88)) {\n    do {\n      plVar2 = (longlong *)plVar7[2];\n      lVar8 = plVar2[0x1c];\n      if (((((lVar8 == 0) || (cVar5 = FUN_1401d56a0(lVar8), cVar5 != '\\0')) &&\n           (*(char *)((longlong)plVar2 + 0xf9) != '\\0')) &&\n          (((plVar3 = *(longlong **)(param_1 + 0x50), plVar3 == (longlong *)0x0 ||\n            (plVar3 == plVar2)) ||\n           ((lVar8 != 0 && (cVar5 = FUN_1401d5ba0(lVar8,plVar3,0), cVar5 != '\\0')))))) &&\n         (*(char *)((longlong)plVar2 + 0x10c) != '\\0')) {\n        if ((*(longlong **)(param_1 + 0x68) != plVar2) &&\n           (cVar5 = (**(code **)(*plVar2 + 0xd0))(plVar2,&local_78), cVar5 != '\\0')) {\n          *(longlong **)(param_1 + 0x68) = plVar2;\n        }\n        local_88 = 0;\n        cVar5 = FUN_1401d4ea0(plVar2,1);\n        if (cVar5 != '\\0') goto LAB_14019f859;\n      }\n      plVar7 = (longlong *)*plVar7;\n    } while (plVar7 != (longlong *)*(longlong *)(param_1 + 0x88));\n  }\n  *(undefined8 *)(param_1 + 0x68) = 0;\nLAB_14019f859:\n  if ((*(longlong *)(param_1 + 0x68) != lVar1) && (lVar1 != 0)) {\n    for (puVar4 = (undefined8 *)**(undefined8 **)(param_1 + 0x88);\n        puVar4 != *(undefined8 **)(param_1 + 0x88); puVar4 = (undefined8 *)*puVar4) {\n      if (puVar4[2] == lVar1) {\n        local_88 = 1;\n        FUN_1401d4ea0(lVar1,8,&local_78,1);\n        break;\n      }\n    }\n  }\n  FUN_1404d6060(local_28 ^ (ulonglong)auStack_a8);\n  return;\n}",
        "similarity_score_unixcoder": 0.28802141547203064,
        "similarity_score_baseline_stripped": 0.2520110011100769
    },
    {
        "func_name": "dealloc_KMJobManager_JobFilter",
        "normed_func_sha256": "5427e3fe5bc20e178b28086e6103e14e942871ba7b85af2009f0b13e6f84fe7e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00021390(int param_1)\n{\n  if ((*(byte *)(param_1 + 0x10) & 4) == 0) {\n    return;\n  }\n  FUN_00021360(*(undefined4 *)(param_1 + 0xc),0);\n  return;\n}",
        "output": "void process_data(int data_address)\n{\n    if ((*(byte *)(data_address + 0x10) & 0x04) == 0) {\n        return;\n    }\n    \n    execute_function(*(int *)(data_address + 0x0C), 0);\n    return;\n}",
        "source_code": "static void dealloc_KMJobManager_JobFilter(sipWrapper *sipSelf)\n{\n    if (sipIsPyOwned(sipSelf))\n    {\n        release_KMJobManager_JobFilter(sipSelf->u.cppPtr,0);\n    }\n}",
        "parsed_output": "void process_data(int data_address)\n{\n    if ((*(byte *)(data_address + 0x10) & 0x04) == 0) {\n        return;\n    }\n    \n    execute_function(*(int *)(data_address + 0x0C), 0);\n    return;\n}",
        "baseline_code_stripped": "void FUN_00021390(int param_1)\n{\n  if ((*(byte *)(param_1 + 0x10) & 4) == 0) {\n    return;\n  }\n  FUN_00021360(*(undefined4 *)(param_1 + 0xc),0);\n  return;\n}",
        "similarity_score_unixcoder": 0.227098286151886,
        "similarity_score_baseline_stripped": 0.3705351948738098
    },
    {
        "func_name": "read_some_at",
        "normed_func_sha256": "22876c97c441a52ff8f9c3a58ad5158f419a006f145da58c42f0cb8924fab1e4",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nulong __thiscall\nCOleDropTarget::OnDragEnter\n          (COleDropTarget *this,CWnd *param_1,COleDataObject *param_2,ulong param_3,CPoint param_4)\n{\n  ulong uVar1;\n  uVar1 = OnDragEnter(this,param_1,param_2,param_3,param_4);\n  return uVar1;\n}",
        "output": "```c\nulong __thiscall COleDropTarget::OnDragEnter(COleDropTarget *this, CWnd *param_1, COleDataObject *param_2, ulong param_3, CPoint param_4)\n{\n  ulong result = OnDragEnter(this, param_1, param_2, param_3, param_4);\n  return result;\n}\n```",
        "source_code": "size_t read_some_at(implementation_type& impl, uint64_t offset,\r\n      const MutableBufferSequence& buffers, boost::system::error_code& ec)\r\n  {\r\n    boost::asio::mutable_buffer buffer =\r\n      buffer_sequence_adapter<boost::asio::mutable_buffer,\r\n        MutableBufferSequence>::first(buffers);\r\n    return do_read(impl, offset, buffer, ec);\r\n  }",
        "parsed_output": "ulong __thiscall COleDropTarget::OnDragEnter(COleDropTarget *this, CWnd *param_1, COleDataObject *param_2, ulong param_3, CPoint param_4)\n{\n  ulong result = OnDragEnter(this, param_1, param_2, param_3, param_4);\n  return result;\n}",
        "baseline_code_stripped": "ulong __thiscall\nCOleDropTarget::OnDragEnter\n          (COleDropTarget *this,CWnd *param_1,COleDataObject *param_2,ulong param_3,CPoint param_4)\n{\n  ulong uVar1;\n  uVar1 = OnDragEnter(this,param_1,param_2,param_3,param_4);\n  return uVar1;\n}",
        "similarity_score_unixcoder": 0.24490128457546234,
        "similarity_score_baseline_stripped": 0.2316918671131134
    },
    {
        "func_name": "StaticTextCtrl::StaticTextCtrl",
        "normed_func_sha256": "b30b4b23d208d2c99bdf6e365198061ac71e7015514c50d54d008f172a3f42af",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall\nlomse::StaticTextCtrl::StaticTextCtrl\n          (StaticTextCtrl *this,LibraryScope *param_1,Control *param_2,Document *param_3,\n          basic_string *param_4,float param_5,float param_6,ImoStyle *param_7)\n{\n  StaticTextCtrl *pSVar1;\n  IdAssigner *this_00;\n  _List_node_base *p_Var2;\n  *(undefined **)this = &DAT_00753518;\n  *(undefined **)(this + 8) = &DAT_007535a8;\n  pSVar1 = this + 0x60;\n  *(LibraryScope **)(this + 0x10) = param_1;\n  *(Document **)(this + 0x18) = param_3;\n  *(Control **)(this + 0x20) = param_2;\n  *(undefined4 *)(this + 0x28) = 0xffffffff;\n  *(StaticTextCtrl **)(this + 0x30) = this + 0x40;\n  *(undefined8 *)(this + 0x38) = 0;\n  this[0x40] = (StaticTextCtrl)0x0;\n  this_00 = *(IdAssigner **)(param_3 + 0x70);\n  *(undefined8 *)(this + 0x50) = 0;\n  *(undefined2 *)(this + 0x58) = 0x101;\n  *(undefined4 *)(this + 0x5c) = 0xffffffff;\n  *(StaticTextCtrl **)pSVar1 = pSVar1;\n  *(StaticTextCtrl **)(this + 0x68) = pSVar1;\n  *(undefined8 *)(this + 0x70) = 0;\n  IdAssigner::assign_id(this_00,(Control *)this);\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_assign\n            ((basic_string *)(this + 0x30));\n  *(undefined ***)this = &PTR_FUN_0071d488;\n  *(undefined ***)(this + 8) = &PTR_FUN_0071d518;\n  *(StaticTextCtrl **)(this + 0x78) = this + 0x88;\n  FUN_0060b9a0(this + 0x78,*(long *)param_4,*(long *)param_4 + *(long *)(param_4 + 8));\n  *(undefined8 *)(this + 0x98) = 0;\n  *(undefined8 *)(this + 0xa0) = 0;\n  *(undefined8 *)(this + 0xb0) = 0;\n  *(float *)(this + 0xa8) = param_5;\n  *(float *)(this + 0xac) = param_6;\n  if (param_7 == (ImoStyle *)0x0) {\n    param_7 = (ImoStyle *)Document::get_default_style(*(Document **)(this + 0x18));\n  }\n  *(ImoStyle **)(this + 0x50) = param_7;\n  measure(this);\n  if (param_2 != (Control *)0x0) {\n    p_Var2 = (_List_node_base *)operator_new(0x18);\n    *(StaticTextCtrl **)(p_Var2 + 0x10) = this;\n    std::__detail::_List_node_base::_M_hook(p_Var2);\n    *(long *)(param_2 + 0x70) = *(long *)(param_2 + 0x70) + 1;\n  }\n  return;\n}",
        "output": "void __thiscall lomse::StaticTextCtrl::StaticTextCtrl(StaticTextCtrl *this, LibraryScope *param_1, Control *param_2, Document *param_3, basic_string *param_4, float param_5, float param_6, ImoStyle *param_7)\n{\n    StaticTextCtrl *pSVar1;\n    IdAssigner *this_00;\n    _List_node_base *p_Var2;\n    \n    *(undefined **)this = &DAT_00753518;\n    *(undefined **)(this + 8) = &DAT_007535a8;\n    \n    pSVar1 = this + 0x60;\n    *(LibraryScope **)(this + 0x10) = param_1;\n    *(Document **)(this + 0x18) = param_3;\n    *(Control **)(this + 0x20) = param_2;\n    *(undefined4 *)(this + 0x28) = 0xffffffff;\n    *(StaticTextCtrl **)(this + 0x30) = this + 0x40;\n    *(undefined8 *)(this + 0x38) = 0;\n    this[0x40] = (StaticTextCtrl)0x0;\n    \n    this_00 = *(IdAssigner **)(param_3 + 0x70);\n    *(undefined8 *)(this + 0x50) = 0;\n    *(undefined2 *)(this + 0x58) = 0x101;\n    *(undefined4 *)(this + 0x5c) = 0xffffffff;\n    *(StaticTextCtrl **)pSVar1 = pSVar1;\n    *(StaticTextCtrl **)(this + 0x68) = pSVar1;\n    *(undefined8 *)(this + 0x70) = 0;\n    \n    IdAssigner::assign_id(this_00, (Control *)this);\n    std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_assign((basic_string *)(this + 0x30));\n    \n    *(undefined ***)this = &PTR_FUN_0071d488;\n    *(undefined ***)(this + 8) = &PTR_FUN_0071d518;\n    *(StaticTextCtrl **)(this + 0x78) = this + 0x88;\n    \n    FUN_0060b9a0(this + 0x78, *(long *)param_4, *(long *)param_4 + *(long *)(param_4 + 8));\n    \n    *(undefined8 *)(this + 0x98) = 0;\n    *(undefined8 *)(this + 0xa0) = 0;\n    *(undefined8 *)(this + 0xb0) = 0;\n    *(float *)(this + 0xa8) = param_5;\n    *(float *)(this + 0xac) = param_6;\n    \n    if (param_7 == (ImoStyle *)0x0) {\n        param_7 = (ImoStyle *)Document::get_default_style(*(Document **)(this + 0x18));\n    }\n    \n    *(ImoStyle **)(this + 0x50) = param_7;\n    \n    measure(this);\n    \n    if (param_2 != (Control *)0x0) {\n        p_Var2 = (_List_node_base *)operator_new(0x18);\n        *(StaticTextCtrl **)(p_Var2 + 0x10) = this;\n        std::__detail::_List_node_base::_M_hook(p_Var2);\n        *(long *)(param_2 + 0x70) = *(long *)(param_2 + 0x70) + 1;\n    }\n    \n    return;\n}",
        "source_code": "StaticTextCtrl::StaticTextCtrl(LibraryScope& libScope, Control* pParent,\n                               Document* pDoc, const string& label,\n                               LUnits width, LUnits height, ImoStyle* pStyle)\n    : Control(libScope, pDoc, pParent)\n    , m_label(label)\n    , m_pMainBox(nullptr)\n    , m_width(width)\n    , m_height(height)\n    , m_xCenter(0.0f)\n    , m_yCenter(0.0f)\n{\n    m_style = (pStyle == nullptr ? create_default_style() : pStyle);\n\n    measure();\n\n    if (pParent)\n        pParent->take_ownership_of(this);\n}",
        "parsed_output": "void __thiscall lomse::StaticTextCtrl::StaticTextCtrl(StaticTextCtrl *this, LibraryScope *param_1, Control *param_2, Document *param_3, basic_string *param_4, float param_5, float param_6, ImoStyle *param_7)\n{\n    StaticTextCtrl *pSVar1;\n    IdAssigner *this_00;\n    _List_node_base *p_Var2;\n    \n    *(undefined **)this = &DAT_00753518;\n    *(undefined **)(this + 8) = &DAT_007535a8;\n    \n    pSVar1 = this + 0x60;\n    *(LibraryScope **)(this + 0x10) = param_1;\n    *(Document **)(this + 0x18) = param_3;\n    *(Control **)(this + 0x20) = param_2;\n    *(undefined4 *)(this + 0x28) = 0xffffffff;\n    *(StaticTextCtrl **)(this + 0x30) = this + 0x40;\n    *(undefined8 *)(this + 0x38) = 0;\n    this[0x40] = (StaticTextCtrl)0x0;\n    \n    this_00 = *(IdAssigner **)(param_3 + 0x70);\n    *(undefined8 *)(this + 0x50) = 0;\n    *(undefined2 *)(this + 0x58) = 0x101;\n    *(undefined4 *)(this + 0x5c) = 0xffffffff;\n    *(StaticTextCtrl **)pSVar1 = pSVar1;\n    *(StaticTextCtrl **)(this + 0x68) = pSVar1;\n    *(undefined8 *)(this + 0x70) = 0;\n    \n    IdAssigner::assign_id(this_00, (Control *)this);\n    std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_assign((basic_string *)(this + 0x30));\n    \n    *(undefined ***)this = &PTR_FUN_0071d488;\n    *(undefined ***)(this + 8) = &PTR_FUN_0071d518;\n    *(StaticTextCtrl **)(this + 0x78) = this + 0x88;\n    \n    FUN_0060b9a0(this + 0x78, *(long *)param_4, *(long *)param_4 + *(long *)(param_4 + 8));\n    \n    *(undefined8 *)(this + 0x98) = 0;\n    *(undefined8 *)(this + 0xa0) = 0;\n    *(undefined8 *)(this + 0xb0) = 0;\n    *(float *)(this + 0xa8) = param_5;\n    *(float *)(this + 0xac) = param_6;\n    \n    if (param_7 == (ImoStyle *)0x0) {\n        param_7 = (ImoStyle *)Document::get_default_style(*(Document **)(this + 0x18));\n    }\n    \n    *(ImoStyle **)(this + 0x50) = param_7;\n    \n    measure(this);\n    \n    if (param_2 != (Control *)0x0) {\n        p_Var2 = (_List_node_base *)operator_new(0x18);\n        *(StaticTextCtrl **)(p_Var2 + 0x10) = this;\n        std::__detail::_List_node_base::_M_hook(p_Var2);\n        *(long *)(param_2 + 0x70) = *(long *)(param_2 + 0x70) + 1;\n    }\n    \n    return;\n}",
        "baseline_code_stripped": "void __thiscall\nlomse::StaticTextCtrl::StaticTextCtrl\n          (StaticTextCtrl *this,LibraryScope *param_1,Control *param_2,Document *param_3,\n          basic_string *param_4,float param_5,float param_6,ImoStyle *param_7)\n{\n  StaticTextCtrl *pSVar1;\n  IdAssigner *this_00;\n  _List_node_base *p_Var2;\n  *(undefined **)this = &DAT_00753518;\n  *(undefined **)(this + 8) = &DAT_007535a8;\n  pSVar1 = this + 0x60;\n  *(LibraryScope **)(this + 0x10) = param_1;\n  *(Document **)(this + 0x18) = param_3;\n  *(Control **)(this + 0x20) = param_2;\n  *(undefined4 *)(this + 0x28) = 0xffffffff;\n  *(StaticTextCtrl **)(this + 0x30) = this + 0x40;\n  *(undefined8 *)(this + 0x38) = 0;\n  this[0x40] = (StaticTextCtrl)0x0;\n  this_00 = *(IdAssigner **)(param_3 + 0x70);\n  *(undefined8 *)(this + 0x50) = 0;\n  *(undefined2 *)(this + 0x58) = 0x101;\n  *(undefined4 *)(this + 0x5c) = 0xffffffff;\n  *(StaticTextCtrl **)pSVar1 = pSVar1;\n  *(StaticTextCtrl **)(this + 0x68) = pSVar1;\n  *(undefined8 *)(this + 0x70) = 0;\n  IdAssigner::assign_id(this_00,(Control *)this);\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_assign\n            ((basic_string *)(this + 0x30));\n  *(undefined ***)this = &PTR_FUN_0071d488;\n  *(undefined ***)(this + 8) = &PTR_FUN_0071d518;\n  *(StaticTextCtrl **)(this + 0x78) = this + 0x88;\n  FUN_0060b9a0(this + 0x78,*(long *)param_4,*(long *)param_4 + *(long *)(param_4 + 8));\n  *(undefined8 *)(this + 0x98) = 0;\n  *(undefined8 *)(this + 0xa0) = 0;\n  *(undefined8 *)(this + 0xb0) = 0;\n  *(float *)(this + 0xa8) = param_5;\n  *(float *)(this + 0xac) = param_6;\n  if (param_7 == (ImoStyle *)0x0) {\n    param_7 = (ImoStyle *)Document::get_default_style(*(Document **)(this + 0x18));\n  }\n  *(ImoStyle **)(this + 0x50) = param_7;\n  measure(this);\n  if (param_2 != (Control *)0x0) {\n    p_Var2 = (_List_node_base *)operator_new(0x18);\n    *(StaticTextCtrl **)(p_Var2 + 0x10) = this;\n    std::__detail::_List_node_base::_M_hook(p_Var2);\n    *(long *)(param_2 + 0x70) = *(long *)(param_2 + 0x70) + 1;\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.6781673431396484,
        "similarity_score_baseline_stripped": 0.6728370189666748
    },
    {
        "func_name": "lock_sec_rec_cons_read_sees",
        "normed_func_sha256": "a26d76f3057dd92f798a56ff71f5a80a588fd4e6d8f8570c1f04c4b84f408f6d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nuint FUN_00c80530(uint param_1,int param_2,int param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(int *)(param_2 + 0x10) + 0x24) >> 0xb & 1;\n  if (uVar1 != 0) {\n    return uVar1;\n  }\n  param_1 = param_1 & -_DAT_01715a4c;\n  if ((param_1 & 0xfff) == 0) {\n    uVar1 = 1;\n    if (*(uint *)(param_3 + 8) <= *(uint *)(param_1 + 0x38)) {\n      if ((*(uint *)(param_3 + 8) == *(uint *)(param_1 + 0x38)) &&\n         (*(uint *)(param_1 + 0x3c) < *(uint *)(param_3 + 0xc))) {\n        uVar1 = 1;\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n    return uVar1;\n  }\n  __assert_fail(\"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n                \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\",0x22,\n                \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\");\n}",
        "output": "uint FUN_00c80530(uint param_1, int param_2, int param_3)\n{\n    uint uVar1;\n    \n    uVar1 = *(uint *)(*(int *)(param_2 + 0x10) + 0x24) >> 0xb & 1;\n    \n    if (uVar1 != 0) {\n        return uVar1;\n    }\n    \n    param_1 = param_1 & -_DAT_01715a4c;\n    \n    if ((param_1 & 0xfff) == 0) {\n        uVar1 = 1;\n        \n        if (*(uint *)(param_3 + 8) <= *(uint *)(param_1 + 0x38)) {\n            if ((*(uint *)(param_3 + 8) == *(uint *)(param_1 + 0x38)) &&\n                (*(uint *)(param_1 + 0x3c) < *(uint *)(param_3 + 0xc))) {\n                uVar1 = 1;\n            }\n            else {\n                uVar1 = 0;\n            }\n        }\n        \n        return uVar1;\n    }\n    \n    __assert_fail(\"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n                  \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\", 0x22,\n                  \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\");\n}",
        "source_code": "bool\nlock_sec_rec_cons_read_sees(\n/*========================*/\n\tconst rec_t*\t\trec,\t/*!< in: user record which\n\t\t\t\t\tshould be read or passed over\n\t\t\t\t\tby a read cursor */\n\tconst dict_index_t*\tindex,\t/*!< in: index */\n\tconst ReadView*\tview)\t/*!< in: consistent read view */\n{\n\tut_ad(page_rec_is_user_rec(rec));\n\tut_ad(!index->is_primary());\n\tut_ad(!rec_is_metadata(rec, *index));\n\n\t/* NOTE that we might call this function while holding the search\n\tsystem latch. */\n\n\tif (index->table->is_temporary()) {\n\n\t\t/* Temp-tables are not shared across connections and multiple\n\t\ttransactions from different connections cannot simultaneously\n\t\toperate on same temp-table and so read of temp-table is\n\t\talways consistent read. */\n\n\t\treturn(true);\n\t}\n\n\ttrx_id_t\tmax_trx_id = page_get_max_trx_id(page_align(rec));\n\n\tut_ad(max_trx_id > 0);\n\n\treturn(view->sees(max_trx_id));\n}",
        "parsed_output": "uint FUN_00c80530(uint param_1, int param_2, int param_3)\n{\n    uint uVar1;\n    \n    uVar1 = *(uint *)(*(int *)(param_2 + 0x10) + 0x24) >> 0xb & 1;\n    \n    if (uVar1 != 0) {\n        return uVar1;\n    }\n    \n    param_1 = param_1 & -_DAT_01715a4c;\n    \n    if ((param_1 & 0xfff) == 0) {\n        uVar1 = 1;\n        \n        if (*(uint *)(param_3 + 8) <= *(uint *)(param_1 + 0x38)) {\n            if ((*(uint *)(param_3 + 8) == *(uint *)(param_1 + 0x38)) &&\n                (*(uint *)(param_1 + 0x3c) < *(uint *)(param_3 + 0xc))) {\n                uVar1 = 1;\n            }\n            else {\n                uVar1 = 0;\n            }\n        }\n        \n        return uVar1;\n    }\n    \n    __assert_fail(\"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n                  \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\", 0x22,\n                  \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\");\n}",
        "baseline_code_stripped": "uint FUN_00c80530(uint param_1,int param_2,int param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(int *)(param_2 + 0x10) + 0x24) >> 0xb & 1;\n  if (uVar1 != 0) {\n    return uVar1;\n  }\n  param_1 = param_1 & -_DAT_01715a4c;\n  if ((param_1 & 0xfff) == 0) {\n    uVar1 = 1;\n    if (*(uint *)(param_3 + 8) <= *(uint *)(param_1 + 0x38)) {\n      if ((*(uint *)(param_3 + 8) == *(uint *)(param_1 + 0x38)) &&\n         (*(uint *)(param_1 + 0x3c) < *(uint *)(param_3 + 0xc))) {\n        uVar1 = 1;\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n    return uVar1;\n  }\n  __assert_fail(\"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n                \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\",0x22,\n                \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\");\n}",
        "similarity_score_unixcoder": 0.5697965025901794,
        "similarity_score_baseline_stripped": 0.562998354434967
    },
    {
        "func_name": "dino_entities_call_set_id",
        "normed_func_sha256": "e8c587dc368c66bdda52014c3bdeaea5cb523d64e123325b3f623b49dfe9ad4f",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid dino_entities_call_set_id(int param_1,int param_2)\n{\n  undefined4 uVar1;\n  int iVar2;\n  if (param_1 == 0) {\n    g_return_if_fail_warning(\"libdino\",\"dino_entities_call_set_id\",\"self != NULL\");\n    return;\n  }\n  iVar2 = dino_entities_call_get_id();\n  uVar1 = DAT_00104078;\n  if (iVar2 == param_2) {\n    return;\n  }\n  **(int **)(param_1 + 0xc) = param_2;\n  g_object_notify_by_pspec(param_1,uVar1);\n  return;\n}",
        "output": "void dino_entities_call_set_id(int entity, int id)\n{\n    if (entity == 0) {\n        g_return_if_fail_warning(\"libdino\", \"dino_entities_call_set_id\", \"entity != NULL\");\n        return;\n    }\n    \n    int currentId = dino_entities_call_get_id();\n    \n    if (currentId == id) {\n        return;\n    }\n    \n    *(int **)(entity + 0xc) = id;\n    g_object_notify_by_pspec(entity, DAT_00104078);\n}",
        "source_code": "void\ndino_entities_call_set_id (DinoEntitiesCall* self,\n                           gint value)\n{\n\tgint old_value;\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\tg_return_if_fail (self != NULL);\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\told_value = dino_entities_call_get_id (self);\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\tif (old_value != value) {\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\t\tself->priv->_id = value;\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\t\tg_object_notify_by_pspec ((GObject *) self, dino_entities_call_properties[DINO_ENTITIES_CALL_ID_PROPERTY]);\n#line 1849 \"call.c\"\n\t}\n}",
        "parsed_output": "void dino_entities_call_set_id(int entity, int id)\n{\n    if (entity == 0) {\n        g_return_if_fail_warning(\"libdino\", \"dino_entities_call_set_id\", \"entity != NULL\");\n        return;\n    }\n    \n    int currentId = dino_entities_call_get_id();\n    \n    if (currentId == id) {\n        return;\n    }\n    \n    *(int **)(entity + 0xc) = id;\n    g_object_notify_by_pspec(entity, DAT_00104078);\n}",
        "baseline_code_stripped": "void dino_entities_call_set_id(int param_1,int param_2)\n{\n  undefined4 uVar1;\n  int iVar2;\n  if (param_1 == 0) {\n    g_return_if_fail_warning(\"libdino\",\"dino_entities_call_set_id\",\"self != NULL\");\n    return;\n  }\n  iVar2 = dino_entities_call_get_id();\n  uVar1 = DAT_00104078;\n  if (iVar2 == param_2) {\n    return;\n  }\n  **(int **)(param_1 + 0xc) = param_2;\n  g_object_notify_by_pspec(param_1,uVar1);\n  return;\n}",
        "similarity_score_unixcoder": 0.7704121470451355,
        "similarity_score_baseline_stripped": 0.7299197912216187
    },
    {
        "func_name": "pattern1200",
        "normed_func_sha256": "cb1a269f014b9c94858235ab51b55d30b45163cd1841f98f0ebfd8cb93647c70",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_00e9f69c(long param_1,uint param_2)\n{\n  char cVar1;\n  byte bVar2;\n  cVar1 = FUN_01175500(DAT_01f6e6a0);\n  if (cVar1 != '\\0') {\n    bVar2 = *(byte *)(param_1 + 2);\n    if ((((bVar2 == param_2) && (cVar1 = FUN_01568900(DAT_01f6e6a8,(uint)bVar2), cVar1 != '\\0')) &&\n        (cVar1 = FUN_012fad90(DAT_01f6e6b0,bVar2), cVar1 != '\\0')) &&\n       (cVar1 = FUN_01175500(DAT_01f6e6b8,bVar2), cVar1 != '\\0')) {\n      bVar2 = FUN_01175a40(DAT_01f6e6c0,bVar2);\n      return bVar2 - 1;\n    }\n  }\n  return -1;\n}",
        "output": "```c\nint check_condition(long param_1, uint param_2)\n{\n    char result = get_value(DAT_01f6e6a0);\n    \n    if (result != '\\0') {\n        byte value = *(byte *)(param_1 + 2);\n        \n        if (((value == param_2) && (result = check_value(DAT_01f6e6a8, (uint)value), result != '\\0')) &&\n            (result = check_data(DAT_01f6e6b0, value), result != '\\0') &&\n            (result = get_value(DAT_01f6e6b8, value), result != '\\0')) {\n            value = process_data(DAT_01f6e6c0, value);\n            return value - 1;\n        }\n    }\n    \n    return -1;\n}\n```",
        "source_code": "static int\npattern1200 (rtx x1, machine_mode i1)\n{\n  rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\n  int res ATTRIBUTE_UNUSED;\n  if (!register_operand (operands[0], i1)\n      || GET_MODE (x1) != i1\n      || !float_vector_all_ones_operand (operands[1], i1)\n      || !const0_operand (operands[2], i1)\n      || !register_operand (operands[3], i1)\n      || !nonimmediate_operand (operands[4], i1))\n    return -1;\n  return 0;\n}",
        "parsed_output": "int check_condition(long param_1, uint param_2)\n{\n    char result = get_value(DAT_01f6e6a0);\n    \n    if (result != '\\0') {\n        byte value = *(byte *)(param_1 + 2);\n        \n        if (((value == param_2) && (result = check_value(DAT_01f6e6a8, (uint)value), result != '\\0')) &&\n            (result = check_data(DAT_01f6e6b0, value), result != '\\0') &&\n            (result = get_value(DAT_01f6e6b8, value), result != '\\0')) {\n            value = process_data(DAT_01f6e6c0, value);\n            return value - 1;\n        }\n    }\n    \n    return -1;\n}",
        "baseline_code_stripped": "int FUN_00e9f69c(long param_1,uint param_2)\n{\n  char cVar1;\n  byte bVar2;\n  cVar1 = FUN_01175500(DAT_01f6e6a0);\n  if (cVar1 != '\\0') {\n    bVar2 = *(byte *)(param_1 + 2);\n    if ((((bVar2 == param_2) && (cVar1 = FUN_01568900(DAT_01f6e6a8,(uint)bVar2), cVar1 != '\\0')) &&\n        (cVar1 = FUN_012fad90(DAT_01f6e6b0,bVar2), cVar1 != '\\0')) &&\n       (cVar1 = FUN_01175500(DAT_01f6e6b8,bVar2), cVar1 != '\\0')) {\n      bVar2 = FUN_01175a40(DAT_01f6e6c0,bVar2);\n      return bVar2 - 1;\n    }\n  }\n  return -1;\n}",
        "similarity_score_unixcoder": 0.5167391300201416,
        "similarity_score_baseline_stripped": 0.422084778547287
    },
    {
        "func_name": "kernel_interface_create",
        "normed_func_sha256": "eaf17ed6fe181162b2bb7cdef83f79adfa393b826d5fbecc885f8653b47e9e34",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid kernel_interface_create(void)\n{\n  code **__s;\n  code *pcVar1;\n  code *pcVar2;\n  code *pcVar3;\n  code *pcVar4;\n  int iVar5;\n  code **ppcVar6;\n  undefined4 uVar7;\n  int iVar8;\n  undefined4 local_30;\n  int local_2c;\n  local_2c = __stack_chk_guard;\n  __s = (code **)malloc(200);\n  pcVar1 = (code *)mutex_create(0);\n  pcVar2 = (code *)linked_list_create();\n  pcVar3 = (code *)mutex_create(0);\n  pcVar4 = (code *)linked_list_create();\n  memset(__s,0,200);\n  *__s = get_features;\n  __s[1] = get_spi;\n  __s[2] = get_cpi;\n  __s[3] = add_sa;\n  __s[4] = update_sa;\n  __s[5] = query_sa;\n  __s[6] = del_sa;\n  __s[7] = flush_sas;\n  __s[8] = add_policy;\n  __s[9] = query_policy;\n  __s[10] = del_policy;\n  __s[0xb] = flush_policies;\n  __s[0xc] = get_source_addr;\n  __s[0xd] = get_nexthop;\n  __s[0xe] = get_interface;\n  __s[0xf] = create_address_enumerator;\n  __s[0x10] = add_ip;\n  __s[0x11] = del_ip;\n  __s[0x12] = add_route;\n  __s[0x13] = del_route;\n  __s[0x14] = bypass_socket;\n  __s[0x15] = enable_udp_decap;\n  __s[0x16] = is_interface_usable;\n  __s[0x17] = all_interfaces_usable;\n  __s[0x18] = get_address_by_ts;\n  __s[0x19] = add_ipsec_interface;\n  __s[0x1a] = remove_ipsec_interface;\n  __s[0x1b] = add_net_interface;\n  __s[0x1c] = remove_net_interface;\n  __s[0x1d] = add_listener;\n  __s[0x1e] = remove_listener;\n  __s[0x1f] = acquire;\n  __s[0x20] = expire;\n  __s[0x2c] = pcVar1;\n  __s[0x2d] = pcVar2;\n  __s[0x2f] = pcVar4;\n  __s[0x21] = mapping;\n  __s[0x2e] = pcVar3;\n  __s[0x27] = destroy;\n  __s[0x22] = migrate;\n  __s[0x23] = roam;\n  __s[0x24] = tun;\n  __s[0x25] = register_algorithm;\n  __s[0x26] = lookup_algorithm;\n  iVar5 = (***(code ***)(lib + 0x50))\n                    (*(code ***)(lib + 0x50),\"%s.interfaces_use\",0,*(undefined4 *)(lib + 8));\n  iVar8 = lib;\n  if (iVar5 == 0) {\n    *(undefined *)(__s + 0x31) = 1;\n    ppcVar6 = *(code ***)(iVar8 + 0x50);\n    iVar5 = (**ppcVar6)(ppcVar6,\"%s.interfaces_ignore\",0,*(undefined4 *)(iVar8 + 8));\n    if (iVar5 == 0) goto LAB_000141bc;\n  }\n  ppcVar6 = (code **)enumerator_create_token(iVar5,&DAT_00014a60,&DAT_00014a5c);\n  while (iVar8 = (**ppcVar6)(ppcVar6,&local_30), iVar8 != 0) {\n    pcVar1 = __s[0x30];\n    if (pcVar1 == (code *)0x0) {\n      pcVar1 = (code *)linked_list_create();\n      __s[0x30] = pcVar1;\n    }\n    pcVar2 = *(code **)(pcVar1 + 0x24);\n    uVar7 = __strdup(local_30);\n    (*pcVar2)(pcVar1,uVar7);\n  }\n  (*ppcVar6[1])(ppcVar6);\nLAB_000141bc:\n  if (local_2c != __stack_chk_guard) {\n    __stack_chk_fail(__s);\n  }\n  return;\n}",
        "output": "```c\nvoid kernel_interface_create(void)\n{\n    code **interface_functions;\n    code *mutex1;\n    code *linked_list1;\n    code *mutex2;\n    code *linked_list2;\n    int result;\n    code **enumerator;\n    undefined4 strdup_result;\n    int stack_guard;\n\n    stack_guard = __stack_chk_guard;\n    interface_functions = (code **)malloc(200);\n    mutex1 = (code *)mutex_create(0);\n    linked_list1 = (code *)linked_list_create();\n    mutex2 = (code *)mutex_create(0);\n    linked_list2 = (code *)linked_list_create();\n    memset(interface_functions, 0, 200);\n    interface_functions[0] = get_features;\n    interface_functions[1] = get_spi;\n    interface_functions[2] = get_cpi;\n    interface_functions[3] = add_sa;\n    interface_functions[4] = update_sa;\n    interface_functions[5] = query_sa;\n    interface_functions[6] = del_sa;\n    interface_functions[7] = flush_sas;\n    interface_functions[8] = add_policy;\n    interface_functions[9] = query_policy;\n    interface_functions[10] = del_policy;\n    interface_functions[11] = flush_policies;\n    interface_functions[12] = get_source_addr;\n    interface_functions[13] = get_nexthop;\n    interface_functions[14] = get_interface;\n    interface_functions[15] = create_address_enumerator;\n    interface_functions[16] = add_ip;\n    interface_functions[17] = del_ip;\n    interface_functions[18] = add_route;\n    interface_functions[19] = del_route;\n    interface_functions[20] = bypass_socket;\n    interface_functions[21] = enable_udp_decap;\n    interface_functions[22] = is_interface_usable;\n    interface_functions[23] = all_interfaces_usable;\n    interface_functions[24] = get_address_by_ts;\n    interface_functions[25] = add_ipsec_interface;\n    interface_functions[26] = remove_ipsec_interface;\n    interface_functions[27] = add_net_interface;\n    interface_functions[28] = remove_net_interface;\n    interface_functions[29] = add_listener;\n    interface_functions[30] = remove_listener;\n    interface_functions[31] = acquire;\n    interface_functions[32] = expire;\n    interface_functions[44] = mutex1;\n    interface_functions[45] = linked_list1;\n    interface_functions[47] = linked_list2;\n    interface_functions[33] = mapping;\n    interface_functions[46] = mutex2;\n    interface_functions[39] = destroy;\n    interface_functions[34] = migrate;\n    interface_functions[35] = roam;\n    interface_functions[36] = tun;\n    interface_functions[37] = register_algorithm;\n    interface_functions[38] = lookup_algorithm;\n    result = (***(code ***)(lib + 80))(*(code ***)(lib + 80), \"%s.interfaces_use\", 0, *(undefined4 *)(lib + 8));\n    if (result == 0) {\n        *(undefined *)(interface_functions + 49) = 1;\n        code **func_ptr = *(code ***)(lib + 80);\n        result = (**func_ptr)(func_ptr, \"%s.interfaces_ignore\", 0, *(undefined4 *)(lib + 8));\n        if (result == 0) {\n            goto LAB_000141bc;\n        }\n    }\n    enumerator = (code **)enumerator_create_token(result, &DAT_00014a60, &DAT_00014a5c);\n    while (result = (**enumerator)(enumerator, &local_30), result != 0) {\n        code *func = interface_functions[48];\n        if (func == (code *)0x0) {\n            func = (code *)linked_list_create();\n            interface_functions[48] = func;\n        }\n        code *func_ptr = *(code **)(func + 36);\n        strdup_result = __strdup(local_30);\n        (*func_ptr)(func, strdup_result);\n    }\n    (*enumerator[1])(enumerator);\nLAB_000141bc:\n    if (stack_guard != __stack_chk_guard) {\n        __stack_chk_fail(interface_functions);\n    }\n    return;\n}\n```",
        "source_code": "kernel_interface_t *kernel_interface_create()\n{\n\tprivate_kernel_interface_t *this;\n\tchar *ifaces;\n\n\tINIT(this,\n\t\t.public = {\n\t\t\t.get_features = _get_features,\n\t\t\t.get_spi = _get_spi,\n\t\t\t.get_cpi = _get_cpi,\n\t\t\t.add_sa = _add_sa,\n\t\t\t.update_sa = _update_sa,\n\t\t\t.query_sa = _query_sa,\n\t\t\t.del_sa = _del_sa,\n\t\t\t.flush_sas = _flush_sas,\n\t\t\t.add_policy = _add_policy,\n\t\t\t.query_policy = _query_policy,\n\t\t\t.del_policy = _del_policy,\n\t\t\t.flush_policies = _flush_policies,\n\t\t\t.get_source_addr = _get_source_addr,\n\t\t\t.get_nexthop = _get_nexthop,\n\t\t\t.get_interface = _get_interface,\n\t\t\t.create_address_enumerator = _create_address_enumerator,\n\t\t\t.add_ip = _add_ip,\n\t\t\t.del_ip = _del_ip,\n\t\t\t.add_route = _add_route,\n\t\t\t.del_route = _del_route,\n\t\t\t.bypass_socket = _bypass_socket,\n\t\t\t.enable_udp_decap = _enable_udp_decap,\n\n\t\t\t.is_interface_usable = _is_interface_usable,\n\t\t\t.all_interfaces_usable = _all_interfaces_usable,\n\t\t\t.get_address_by_ts = _get_address_by_ts,\n\t\t\t.add_ipsec_interface = _add_ipsec_interface,\n\t\t\t.remove_ipsec_interface = _remove_ipsec_interface,\n\t\t\t.add_net_interface = _add_net_interface,\n\t\t\t.remove_net_interface = _remove_net_interface,\n\n\t\t\t.add_listener = _add_listener,\n\t\t\t.remove_listener = _remove_listener,\n\t\t\t.register_algorithm = _register_algorithm,\n\t\t\t.lookup_algorithm = _lookup_algorithm,\n\t\t\t.acquire = _acquire,\n\t\t\t.expire = _expire,\n\t\t\t.mapping = _mapping,\n\t\t\t.migrate = _migrate,\n\t\t\t.roam = _roam,\n\t\t\t.tun = _tun,\n\t\t\t.destroy = _destroy,\n\t\t},\n\t\t.mutex = mutex_create(MUTEX_TYPE_DEFAULT),\n\t\t.listeners = linked_list_create(),\n\t\t.mutex_algs = mutex_create(MUTEX_TYPE_DEFAULT),\n\t\t.algorithms = linked_list_create(),\n\t);\n\n\tifaces = lib->settings->get_str(lib->settings,\n\t\t\t\t\t\t\t\t\t\"%s.interfaces_use\", NULL, lib->ns);\n\tif (!ifaces)\n\t{\n\t\tthis->ifaces_exclude = TRUE;\n\t\tifaces = lib->settings->get_str(lib->settings,\n\t\t\t\t\t\t\t\t\t\"%s.interfaces_ignore\", NULL, lib->ns);\n\t}\n\tif (ifaces)\n\t{\n\t\tenumerator_t *enumerator;\n\t\tchar *iface;\n\n\t\tenumerator = enumerator_create_token(ifaces, \",\", \" \");\n\t\twhile (enumerator->enumerate(enumerator, &iface))\n\t\t{\n\t\t\tif (!this->ifaces_filter)\n\t\t\t{\n\t\t\t\tthis->ifaces_filter = linked_list_create();\n\t\t\t}\n\t\t\tthis->ifaces_filter->insert_last(this->ifaces_filter,\n\t\t\t\t\t\t\t\t\t\t\t strdup(iface));\n\t\t}\n\t\tenumerator->destroy(enumerator);\n\t}\n\n\treturn &this->public;\n}",
        "parsed_output": "void kernel_interface_create(void)\n{\n    code **interface_functions;\n    code *mutex1;\n    code *linked_list1;\n    code *mutex2;\n    code *linked_list2;\n    int result;\n    code **enumerator;\n    undefined4 strdup_result;\n    int stack_guard;\n\n    stack_guard = __stack_chk_guard;\n    interface_functions = (code **)malloc(200);\n    mutex1 = (code *)mutex_create(0);\n    linked_list1 = (code *)linked_list_create();\n    mutex2 = (code *)mutex_create(0);\n    linked_list2 = (code *)linked_list_create();\n    memset(interface_functions, 0, 200);\n    interface_functions[0] = get_features;\n    interface_functions[1] = get_spi;\n    interface_functions[2] = get_cpi;\n    interface_functions[3] = add_sa;\n    interface_functions[4] = update_sa;\n    interface_functions[5] = query_sa;\n    interface_functions[6] = del_sa;\n    interface_functions[7] = flush_sas;\n    interface_functions[8] = add_policy;\n    interface_functions[9] = query_policy;\n    interface_functions[10] = del_policy;\n    interface_functions[11] = flush_policies;\n    interface_functions[12] = get_source_addr;\n    interface_functions[13] = get_nexthop;\n    interface_functions[14] = get_interface;\n    interface_functions[15] = create_address_enumerator;\n    interface_functions[16] = add_ip;\n    interface_functions[17] = del_ip;\n    interface_functions[18] = add_route;\n    interface_functions[19] = del_route;\n    interface_functions[20] = bypass_socket;\n    interface_functions[21] = enable_udp_decap;\n    interface_functions[22] = is_interface_usable;\n    interface_functions[23] = all_interfaces_usable;\n    interface_functions[24] = get_address_by_ts;\n    interface_functions[25] = add_ipsec_interface;\n    interface_functions[26] = remove_ipsec_interface;\n    interface_functions[27] = add_net_interface;\n    interface_functions[28] = remove_net_interface;\n    interface_functions[29] = add_listener;\n    interface_functions[30] = remove_listener;\n    interface_functions[31] = acquire;\n    interface_functions[32] = expire;\n    interface_functions[44] = mutex1;\n    interface_functions[45] = linked_list1;\n    interface_functions[47] = linked_list2;\n    interface_functions[33] = mapping;\n    interface_functions[46] = mutex2;\n    interface_functions[39] = destroy;\n    interface_functions[34] = migrate;\n    interface_functions[35] = roam;\n    interface_functions[36] = tun;\n    interface_functions[37] = register_algorithm;\n    interface_functions[38] = lookup_algorithm;\n    result = (***(code ***)(lib + 80))(*(code ***)(lib + 80), \"%s.interfaces_use\", 0, *(undefined4 *)(lib + 8));\n    if (result == 0) {\n        *(undefined *)(interface_functions + 49) = 1;\n        code **func_ptr = *(code ***)(lib + 80);\n        result = (**func_ptr)(func_ptr, \"%s.interfaces_ignore\", 0, *(undefined4 *)(lib + 8));\n        if (result == 0) {\n            goto LAB_000141bc;\n        }\n    }\n    enumerator = (code **)enumerator_create_token(result, &DAT_00014a60, &DAT_00014a5c);\n    while (result = (**enumerator)(enumerator, &local_30), result != 0) {\n        code *func = interface_functions[48];\n        if (func == (code *)0x0) {\n            func = (code *)linked_list_create();\n            interface_functions[48] = func;\n        }\n        code *func_ptr = *(code **)(func + 36);\n        strdup_result = __strdup(local_30);\n        (*func_ptr)(func, strdup_result);\n    }\n    (*enumerator[1])(enumerator);\nLAB_000141bc:\n    if (stack_guard != __stack_chk_guard) {\n        __stack_chk_fail(interface_functions);\n    }\n    return;\n}",
        "baseline_code_stripped": "void kernel_interface_create(void)\n{\n  code **__s;\n  code *pcVar1;\n  code *pcVar2;\n  code *pcVar3;\n  code *pcVar4;\n  int iVar5;\n  code **ppcVar6;\n  undefined4 uVar7;\n  int iVar8;\n  undefined4 local_30;\n  int local_2c;\n  local_2c = __stack_chk_guard;\n  __s = (code **)malloc(200);\n  pcVar1 = (code *)mutex_create(0);\n  pcVar2 = (code *)linked_list_create();\n  pcVar3 = (code *)mutex_create(0);\n  pcVar4 = (code *)linked_list_create();\n  memset(__s,0,200);\n  *__s = get_features;\n  __s[1] = get_spi;\n  __s[2] = get_cpi;\n  __s[3] = add_sa;\n  __s[4] = update_sa;\n  __s[5] = query_sa;\n  __s[6] = del_sa;\n  __s[7] = flush_sas;\n  __s[8] = add_policy;\n  __s[9] = query_policy;\n  __s[10] = del_policy;\n  __s[0xb] = flush_policies;\n  __s[0xc] = get_source_addr;\n  __s[0xd] = get_nexthop;\n  __s[0xe] = get_interface;\n  __s[0xf] = create_address_enumerator;\n  __s[0x10] = add_ip;\n  __s[0x11] = del_ip;\n  __s[0x12] = add_route;\n  __s[0x13] = del_route;\n  __s[0x14] = bypass_socket;\n  __s[0x15] = enable_udp_decap;\n  __s[0x16] = is_interface_usable;\n  __s[0x17] = all_interfaces_usable;\n  __s[0x18] = get_address_by_ts;\n  __s[0x19] = add_ipsec_interface;\n  __s[0x1a] = remove_ipsec_interface;\n  __s[0x1b] = add_net_interface;\n  __s[0x1c] = remove_net_interface;\n  __s[0x1d] = add_listener;\n  __s[0x1e] = remove_listener;\n  __s[0x1f] = acquire;\n  __s[0x20] = expire;\n  __s[0x2c] = pcVar1;\n  __s[0x2d] = pcVar2;\n  __s[0x2f] = pcVar4;\n  __s[0x21] = mapping;\n  __s[0x2e] = pcVar3;\n  __s[0x27] = destroy;\n  __s[0x22] = migrate;\n  __s[0x23] = roam;\n  __s[0x24] = tun;\n  __s[0x25] = register_algorithm;\n  __s[0x26] = lookup_algorithm;\n  iVar5 = (***(code ***)(lib + 0x50))\n                    (*(code ***)(lib + 0x50),\"%s.interfaces_use\",0,*(undefined4 *)(lib + 8));\n  iVar8 = lib;\n  if (iVar5 == 0) {\n    *(undefined *)(__s + 0x31) = 1;\n    ppcVar6 = *(code ***)(iVar8 + 0x50);\n    iVar5 = (**ppcVar6)(ppcVar6,\"%s.interfaces_ignore\",0,*(undefined4 *)(iVar8 + 8));\n    if (iVar5 == 0) goto LAB_000141bc;\n  }\n  ppcVar6 = (code **)enumerator_create_token(iVar5,&DAT_00014a60,&DAT_00014a5c);\n  while (iVar8 = (**ppcVar6)(ppcVar6,&local_30), iVar8 != 0) {\n    pcVar1 = __s[0x30];\n    if (pcVar1 == (code *)0x0) {\n      pcVar1 = (code *)linked_list_create();\n      __s[0x30] = pcVar1;\n    }\n    pcVar2 = *(code **)(pcVar1 + 0x24);\n    uVar7 = __strdup(local_30);\n    (*pcVar2)(pcVar1,uVar7);\n  }\n  (*ppcVar6[1])(ppcVar6);\nLAB_000141bc:\n  if (local_2c != __stack_chk_guard) {\n    __stack_chk_fail(__s);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.7983641028404236,
        "similarity_score_baseline_stripped": 0.7532832026481628
    },
    {
        "func_name": "soap_PATCH__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes",
        "normed_func_sha256": "39820e1ced6d0c6b58d860554c52e53553b6efdb70d792e512a65c71fc8766f9",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_016adba6(undefined8 param_1,undefined8 param_2,long *param_3)\n{\n  code *pcVar1;\n  bool bVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  FUN_01aca350(param_1);\n  iVar3 = FUN_01add460(param_1,param_2,0,\"text/xml; charset=utf-8\");\n  if (iVar3 == 0) {\n    (**(code **)(*param_3 + 0x10))(param_3,param_1);\n    pcVar1 = *(code **)(*param_3 + 0x18);\n    lVar4 = (**(code **)*param_3)(param_3);\n    if (lVar4 == 0xe37) {\n      puVar6 = &DAT_01fe53c0;\n    }\n    else {\n      puVar6 = (undefined *)0x0;\n    }\n    iVar3 = (*pcVar1)(param_3,param_1,\"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\",puVar6);\n    if (iVar3 == 0) {\n      iVar3 = FUN_01adabd0(param_1);\n      if (iVar3 == 0) {\n        iVar3 = FUN_01ae4850(param_1);\n        if (iVar3 == 0) {\n          bVar2 = false;\n          goto LAB_016adc98;\n        }\n      }\n    }\n  }\n  bVar2 = true;\nLAB_016adc98:\n  if (bVar2) {\n    uVar5 = FUN_01ac5ad0(param_1);\n  }\n  else {\n    uVar5 = 0;\n  }\n  return uVar5;\n}",
        "output": "```c\nundefined8 process_data(undefined8 param_1, undefined8 param_2, long *param_3)\n{\n    code *callback_func;\n    bool success;\n    int result;\n    long status;\n    undefined8 return_value;\n    undefined *data_ptr;\n\n    initialize_connection(param_1);\n    result = send_request(param_1, param_2, 0, \"text/xml; charset=utf-8\");\n    \n    if (result == 0) {\n        (**(code **)(*param_3 + 0x10))(param_3, param_1);\n        callback_func = *(code **)(*param_3 + 0x18);\n        status = (**(code **)*param_3)(param_3);\n        \n        if (status == 0xe37) {\n            data_ptr = &release_notes_data;\n        } else {\n            data_ptr = (undefined *)0x0;\n        }\n        \n        result = (*callback_func)(param_3, param_1, \"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\", data_ptr);\n        \n        if (result == 0) {\n            result = process_data(param_1);\n            \n            if (result == 0) {\n                result = additional_processing(param_1);\n                \n                if (result == 0) {\n                    success = false;\n                    goto END_PROCESSING;\n                }\n            }\n        }\n    }\n    \n    success = true;\n    \nEND_PROCESSING:\n    \n    if (success) {\n        return_value = get_data(param_1);\n    } else {\n        return_value = 0;\n    }\n    \n    return return_value;\n}\n```",
        "source_code": "int soap_PATCH__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes(struct soap *soap, const char *URL, _vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes const*p)\n{\n\tsoap_free_temp(soap);\n\tif (soap_PATCH(soap, URL, NULL, \"text/xml; charset=utf-8\") || (p->soap_serialize(soap), 0) || p->soap_put(soap, \"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\", p->soap_type() == SOAP_TYPE__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes ? \"\" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))\n\t\treturn soap_closesock(soap);\n\treturn SOAP_OK;\n}",
        "parsed_output": "undefined8 process_data(undefined8 param_1, undefined8 param_2, long *param_3)\n{\n    code *callback_func;\n    bool success;\n    int result;\n    long status;\n    undefined8 return_value;\n    undefined *data_ptr;\n\n    initialize_connection(param_1);\n    result = send_request(param_1, param_2, 0, \"text/xml; charset=utf-8\");\n    \n    if (result == 0) {\n        (**(code **)(*param_3 + 0x10))(param_3, param_1);\n        callback_func = *(code **)(*param_3 + 0x18);\n        status = (**(code **)*param_3)(param_3);\n        \n        if (status == 0xe37) {\n            data_ptr = &release_notes_data;\n        } else {\n            data_ptr = (undefined *)0x0;\n        }\n        \n        result = (*callback_func)(param_3, param_1, \"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\", data_ptr);\n        \n        if (result == 0) {\n            result = process_data(param_1);\n            \n            if (result == 0) {\n                result = additional_processing(param_1);\n                \n                if (result == 0) {\n                    success = false;\n                    goto END_PROCESSING;\n                }\n            }\n        }\n    }\n    \n    success = true;\n    \nEND_PROCESSING:\n    \n    if (success) {\n        return_value = get_data(param_1);\n    } else {\n        return_value = 0;\n    }\n    \n    return return_value;\n}",
        "baseline_code_stripped": "undefined8 FUN_016adba6(undefined8 param_1,undefined8 param_2,long *param_3)\n{\n  code *pcVar1;\n  bool bVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  FUN_01aca350(param_1);\n  iVar3 = FUN_01add460(param_1,param_2,0,\"text/xml; charset=utf-8\");\n  if (iVar3 == 0) {\n    (**(code **)(*param_3 + 0x10))(param_3,param_1);\n    pcVar1 = *(code **)(*param_3 + 0x18);\n    lVar4 = (**(code **)*param_3)(param_3);\n    if (lVar4 == 0xe37) {\n      puVar6 = &DAT_01fe53c0;\n    }\n    else {\n      puVar6 = (undefined *)0x0;\n    }\n    iVar3 = (*pcVar1)(param_3,param_1,\"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\",puVar6);\n    if (iVar3 == 0) {\n      iVar3 = FUN_01adabd0(param_1);\n      if (iVar3 == 0) {\n        iVar3 = FUN_01ae4850(param_1);\n        if (iVar3 == 0) {\n          bVar2 = false;\n          goto LAB_016adc98;\n        }\n      }\n    }\n  }\n  bVar2 = true;\nLAB_016adc98:\n  if (bVar2) {\n    uVar5 = FUN_01ac5ad0(param_1);\n  }\n  else {\n    uVar5 = 0;\n  }\n  return uVar5;\n}",
        "similarity_score_unixcoder": 0.5994818806648254,
        "similarity_score_baseline_stripped": 0.4740559458732605
    },
    {
        "func_name": "MyMoneyFile::attachStorage",
        "normed_func_sha256": "fa7ed3d52628e77b93a6b04997335646c7adfe772f062278c34366b3115d5033",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall MyMoneyFile::attachStorage(MyMoneyFile *this,MyMoneyStorageMgr *param_1)\n{\n  bool bVar1;\n  int iVar2;\n  MyMoneyStorageMgr *pMVar3;\n  undefined8 *this_00;\n  MyMoneyStorageMgr *pMVar4;\n  MyMoneyStorageMgr **ppMVar5;\n  int *piVar6;\n  MyMoneySecurity aMStack_58 [8];\n  MyMoneyStorageMgr *local_50;\n  MyMoneyStorageMgr *local_40;\n  longlong local_38;\n  ppMVar5 = *(MyMoneyStorageMgr ***)(this + 0x10);\n  local_38 = ___stack_chk_guard;\n  if (*ppMVar5 != (MyMoneyStorageMgr *)0x0) {\n    this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n    std::runtime_error::runtime_error\n              ((runtime_error *)this_00,\n               \"Storage already attached /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:333\"\n              );\nLAB_001567dc:\n    *this_00 = &PTR_FUN_002a2ab0;\n    __cxa_throw(this_00,&MyMoneyException::typeinfo,FUN_0013f5a0);\n  }\n  if (param_1 == (MyMoneyStorageMgr *)0x0) {\n    this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n    std::runtime_error::runtime_error\n              ((runtime_error *)this_00,\n               \"Storage must not be 0 /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:336\"\n              );\n    goto LAB_001567dc;\n  }\n  *ppMVar5 = param_1;\n  MyMoneySecurity::MyMoneySecurity(aMStack_58);\n  pMVar4 = ppMVar5[3];\n  pMVar3 = ppMVar5[5];\n  ppMVar5[3] = local_50;\n  ppMVar5[5] = local_40;\n  local_50 = pMVar4;\n  local_40 = pMVar3;\n  MyMoneySecurity::_MyMoneySecurity(aMStack_58);\n  MyMoneyBalanceCache::clear((MyMoneyBalanceCache *)(*(longlong *)(this + 0x10) + 0x38));\n  piVar6 = *(int **)(*(longlong *)(this + 0x10) + 0x30);\n  *(undefined8 **)(*(longlong *)(this + 0x10) + 0x30) = &QMapDataBase::shared_null;\n  if (*piVar6 == 0) {\nLAB_00156728:\n    if (*(longlong *)(piVar6 + 4) != 0) {\n      FUN_00183cf8();\n      QMapDataBase::freeTree((QMapNodeBase *)piVar6,(int)*(undefined8 *)(piVar6 + 4));\n    }\n    QMapDataBase::freeData((QMapDataBase *)piVar6);\n  }\n  else if (*piVar6 != -1) {\n    SYNC(0);\n    iVar2 = *piVar6;\n    *piVar6 = iVar2 + -1;\n    SYNC(0);\n    if (iVar2 == 1) goto LAB_00156728;\n  }\n  if ((int)QMapDataBase::shared_null != 0) {\n    if ((int)QMapDataBase::shared_null == -1) goto LAB_001566dc;\n    SYNC(0);\n    iVar2 = (int)QMapDataBase::shared_null + -1;\n    SYNC(0);\n    bVar1 = (int)QMapDataBase::shared_null != 1;\n    QMapDataBase::shared_null._0_4_ = iVar2;\n    if (bVar1) goto LAB_001566dc;\n  }\n  if (__Init != 0) {\n    FUN_00183cf8();\n    QMapDataBase::freeTree((QMapNodeBase *)&QMapDataBase::shared_null,(int)__Init);\n  }\n  QMapDataBase::freeData((QMapDataBase *)&QMapDataBase::shared_null);\nLAB_001566dc:\n  beginChangeNotification(this);\n  dataChanged(this);\n  endChangeNotification(this);\n  if (local_38 != ___stack_chk_guard) {\n    __stack_chk_fail();\n  }\n  return;\n}",
        "output": "```c\nvoid __thiscall MyMoneyFile::attachStorage(MyMoneyFile *this, MyMoneyStorageMgr *param_1)\n{\n    bool bVar1;\n    int iVar2;\n    MyMoneyStorageMgr *pMVar3;\n    undefined8 *this_00;\n    MyMoneyStorageMgr *pMVar4;\n    MyMoneyStorageMgr **ppMVar5;\n    int *piVar6;\n    MyMoneySecurity aMStack_58[8];\n    MyMoneyStorageMgr *local_50;\n    MyMoneyStorageMgr *local_40;\n    long long local_38;\n    \n    ppMVar5 = *(MyMoneyStorageMgr ***)(this + 0x10);\n    local_38 = ___stack_chk_guard;\n    \n    if (*ppMVar5 != (MyMoneyStorageMgr *)0x0) {\n        this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n        std::runtime_error::runtime_error((runtime_error *)this_00, \"Storage already attached /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:333\");\n        goto LAB_001567dc;\n    }\n    \n    if (param_1 == (MyMoneyStorageMgr *)0x0) {\n        this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n        std::runtime_error::runtime_error((runtime_error *)this_00, \"Storage must not be 0 /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:336\");\n        goto LAB_001567dc;\n    }\n    \n    *ppMVar5 = param_1;\n    MyMoneySecurity::MyMoneySecurity(aMStack_58);\n    pMVar4 = ppMVar5[3];\n    pMVar3 = ppMVar5[5];\n    ppMVar5[3] = local_50;\n    ppMVar5[5] = local_40;\n    local_50 = pMVar4;\n    local_40 = pMVar3;\n    MyMoneySecurity::_MyMoneySecurity(aMStack_58);\n    MyMoneyBalanceCache::clear((MyMoneyBalanceCache *)(*(long long *)(this + 0x10) + 0x38));\n    piVar6 = *(int **)(*(long long *)(this + 0x10) + 0x30);\n    *(undefined8 **)(*(long long *)(this + 0x10) + 0x30) = &QMapDataBase::shared_null;\n    \n    if (*piVar6 == 0) {\n        goto LAB_00156728;\n    }\n    else if (*piVar6 != -1) {\n        SYNC(0);\n        iVar2 = *piVar6;\n        *piVar6 = iVar2 - 1;\n        SYNC(0);\n        if (iVar2 == 1) {\n            goto LAB_00156728;\n        }\n    }\n    \n    if ((int)QMapDataBase::shared_null != 0) {\n        if ((int)QMapDataBase::shared_null == -1) {\n            goto LAB_001566dc;\n        }\n        SYNC(0);\n        iVar2 = (int)QMapDataBase::shared_null - 1;\n        SYNC(0);\n        bVar1 = (int)QMapDataBase::shared_null != 1;\n        QMapDataBase::shared_null._0_4_ = iVar2;\n        if (bVar1) {\n            goto LAB_001566dc;\n        }\n    }\n    \n    if (__Init != 0) {\n        FUN_00183cf8();\n        QMapDataBase::freeTree((QMapNodeBase *)&QMapDataBase::shared_null, (int)__Init);\n    }\n    \n    QMapDataBase::freeData((QMapDataBase *)&QMapDataBase::shared_null);\n    \nLAB_001566dc:\n    beginChangeNotification(this);\n    dataChanged(this);\n    endChangeNotification(this);\n    \n    if (local_38 != ___stack_chk_guard) {\n        __stack_chk_fail();\n    }\n    \n    return;\n}\n```",
        "source_code": "void MyMoneyFile::attachStorage(IMyMoneyStorage* const storage)\n{\n  if (d->m_storage != 0)\n    throw MYMONEYEXCEPTION(\"Storage already attached\");\n  if (storage == 0)\n    throw MYMONEYEXCEPTION(\"Storage must not be 0\");\n  d->m_storage = storage;\n  d->m_baseCurrency = MyMoneySecurity();\n  d->m_balanceCache.clear();\n  d->m_cache.clear(storage);\n  d->m_priceCache.clear();\n  preloadCache();\n  emit beginChangeNotification();\n  emit dataChanged();\n  emit endChangeNotification();\n}",
        "parsed_output": "void __thiscall MyMoneyFile::attachStorage(MyMoneyFile *this, MyMoneyStorageMgr *param_1)\n{\n    bool bVar1;\n    int iVar2;\n    MyMoneyStorageMgr *pMVar3;\n    undefined8 *this_00;\n    MyMoneyStorageMgr *pMVar4;\n    MyMoneyStorageMgr **ppMVar5;\n    int *piVar6;\n    MyMoneySecurity aMStack_58[8];\n    MyMoneyStorageMgr *local_50;\n    MyMoneyStorageMgr *local_40;\n    long long local_38;\n    \n    ppMVar5 = *(MyMoneyStorageMgr ***)(this + 0x10);\n    local_38 = ___stack_chk_guard;\n    \n    if (*ppMVar5 != (MyMoneyStorageMgr *)0x0) {\n        this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n        std::runtime_error::runtime_error((runtime_error *)this_00, \"Storage already attached /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:333\");\n        goto LAB_001567dc;\n    }\n    \n    if (param_1 == (MyMoneyStorageMgr *)0x0) {\n        this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n        std::runtime_error::runtime_error((runtime_error *)this_00, \"Storage must not be 0 /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:336\");\n        goto LAB_001567dc;\n    }\n    \n    *ppMVar5 = param_1;\n    MyMoneySecurity::MyMoneySecurity(aMStack_58);\n    pMVar4 = ppMVar5[3];\n    pMVar3 = ppMVar5[5];\n    ppMVar5[3] = local_50;\n    ppMVar5[5] = local_40;\n    local_50 = pMVar4;\n    local_40 = pMVar3;\n    MyMoneySecurity::_MyMoneySecurity(aMStack_58);\n    MyMoneyBalanceCache::clear((MyMoneyBalanceCache *)(*(long long *)(this + 0x10) + 0x38));\n    piVar6 = *(int **)(*(long long *)(this + 0x10) + 0x30);\n    *(undefined8 **)(*(long long *)(this + 0x10) + 0x30) = &QMapDataBase::shared_null;\n    \n    if (*piVar6 == 0) {\n        goto LAB_00156728;\n    }\n    else if (*piVar6 != -1) {\n        SYNC(0);\n        iVar2 = *piVar6;\n        *piVar6 = iVar2 - 1;\n        SYNC(0);\n        if (iVar2 == 1) {\n            goto LAB_00156728;\n        }\n    }\n    \n    if ((int)QMapDataBase::shared_null != 0) {\n        if ((int)QMapDataBase::shared_null == -1) {\n            goto LAB_001566dc;\n        }\n        SYNC(0);\n        iVar2 = (int)QMapDataBase::shared_null - 1;\n        SYNC(0);\n        bVar1 = (int)QMapDataBase::shared_null != 1;\n        QMapDataBase::shared_null._0_4_ = iVar2;\n        if (bVar1) {\n            goto LAB_001566dc;\n        }\n    }\n    \n    if (__Init != 0) {\n        FUN_00183cf8();\n        QMapDataBase::freeTree((QMapNodeBase *)&QMapDataBase::shared_null, (int)__Init);\n    }\n    \n    QMapDataBase::freeData((QMapDataBase *)&QMapDataBase::shared_null);\n    \nLAB_001566dc:\n    beginChangeNotification(this);\n    dataChanged(this);\n    endChangeNotification(this);\n    \n    if (local_38 != ___stack_chk_guard) {\n        __stack_chk_fail();\n    }\n    \n    return;\n}",
        "baseline_code_stripped": "void __thiscall MyMoneyFile::attachStorage(MyMoneyFile *this,MyMoneyStorageMgr *param_1)\n{\n  bool bVar1;\n  int iVar2;\n  MyMoneyStorageMgr *pMVar3;\n  undefined8 *this_00;\n  MyMoneyStorageMgr *pMVar4;\n  MyMoneyStorageMgr **ppMVar5;\n  int *piVar6;\n  MyMoneySecurity aMStack_58 [8];\n  MyMoneyStorageMgr *local_50;\n  MyMoneyStorageMgr *local_40;\n  longlong local_38;\n  ppMVar5 = *(MyMoneyStorageMgr ***)(this + 0x10);\n  local_38 = ___stack_chk_guard;\n  if (*ppMVar5 != (MyMoneyStorageMgr *)0x0) {\n    this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n    std::runtime_error::runtime_error\n              ((runtime_error *)this_00,\n               \"Storage already attached /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:333\"\n              );\nLAB_001567dc:\n    *this_00 = &PTR_FUN_002a2ab0;\n    __cxa_throw(this_00,&MyMoneyException::typeinfo,FUN_0013f5a0);\n  }\n  if (param_1 == (MyMoneyStorageMgr *)0x0) {\n    this_00 = (undefined8 *)__cxa_allocate_exception(0x10);\n    std::runtime_error::runtime_error\n              ((runtime_error *)this_00,\n               \"Storage must not be 0 /build/kmymoney-q4hyVB/kmymoney-5.0.8/kmymoney/mymoney/mymoneyfile.cpp:336\"\n              );\n    goto LAB_001567dc;\n  }\n  *ppMVar5 = param_1;\n  MyMoneySecurity::MyMoneySecurity(aMStack_58);\n  pMVar4 = ppMVar5[3];\n  pMVar3 = ppMVar5[5];\n  ppMVar5[3] = local_50;\n  ppMVar5[5] = local_40;\n  local_50 = pMVar4;\n  local_40 = pMVar3;\n  MyMoneySecurity::_MyMoneySecurity(aMStack_58);\n  MyMoneyBalanceCache::clear((MyMoneyBalanceCache *)(*(longlong *)(this + 0x10) + 0x38));\n  piVar6 = *(int **)(*(longlong *)(this + 0x10) + 0x30);\n  *(undefined8 **)(*(longlong *)(this + 0x10) + 0x30) = &QMapDataBase::shared_null;\n  if (*piVar6 == 0) {\nLAB_00156728:\n    if (*(longlong *)(piVar6 + 4) != 0) {\n      FUN_00183cf8();\n      QMapDataBase::freeTree((QMapNodeBase *)piVar6,(int)*(undefined8 *)(piVar6 + 4));\n    }\n    QMapDataBase::freeData((QMapDataBase *)piVar6);\n  }\n  else if (*piVar6 != -1) {\n    SYNC(0);\n    iVar2 = *piVar6;\n    *piVar6 = iVar2 + -1;\n    SYNC(0);\n    if (iVar2 == 1) goto LAB_00156728;\n  }\n  if ((int)QMapDataBase::shared_null != 0) {\n    if ((int)QMapDataBase::shared_null == -1) goto LAB_001566dc;\n    SYNC(0);\n    iVar2 = (int)QMapDataBase::shared_null + -1;\n    SYNC(0);\n    bVar1 = (int)QMapDataBase::shared_null != 1;\n    QMapDataBase::shared_null._0_4_ = iVar2;\n    if (bVar1) goto LAB_001566dc;\n  }\n  if (__Init != 0) {\n    FUN_00183cf8();\n    QMapDataBase::freeTree((QMapNodeBase *)&QMapDataBase::shared_null,(int)__Init);\n  }\n  QMapDataBase::freeData((QMapDataBase *)&QMapDataBase::shared_null);\nLAB_001566dc:\n  beginChangeNotification(this);\n  dataChanged(this);\n  endChangeNotification(this);\n  if (local_38 != ___stack_chk_guard) {\n    __stack_chk_fail();\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.5718264579772949,
        "similarity_score_baseline_stripped": 0.5502229928970337
    },
    {
        "func_name": "mono_test_marshal_bool_ref_as_I1_U1",
        "normed_func_sha256": "883222a1f9789eb5ed2f3567257066381e091ed36407d9a1c3ccdee575d45922",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint mono_test_marshal_bool_ref_as_I1_U1(char *bTrue,char *bFalse)\n{\n  int iVar1;\n  if ((bTrue == (char *)0x0) || (bFalse == (char *)0x0)) {\n    iVar1 = 4;\n  }\n  else {\n    iVar1 = 5;\n    if ((*bTrue != '\\0') && (iVar1 = 6, *bFalse == '\\0')) {\n      *bFalse = '\\x01';\n      *bTrue = '\\0';\n      return 0;\n    }\n  }\n  return iVar1;\n}",
        "output": "```c\nint mono_test_marshal_bool_ref_as_I1_U1(char *bTrue, char *bFalse)\n{\n    int result = 4;\n    \n    if (bTrue != NULL && bFalse != NULL) {\n        result = 5;\n        \n        if (*bTrue != '\\0' && *bFalse == '\\0') {\n            *bFalse = '\\x01';\n            *bTrue = '\\0';\n            return 0;\n        }\n    }\n    \n    return result;\n}\n```",
        "source_code": "STDCALL \nmono_test_marshal_bool_ref_as_I1_U1 (char* bTrue, char* bFalse)\n{\n\tif (!bTrue || !bFalse)\n                return 4;\n\tif (!(*bTrue))\n                return 5;\n        if (*bFalse)\n                return 6;\n\t*bFalse = 1;\n        *bTrue = 0;\n\treturn 0;\n}",
        "parsed_output": "int mono_test_marshal_bool_ref_as_I1_U1(char *bTrue, char *bFalse)\n{\n    int result = 4;\n    \n    if (bTrue != NULL && bFalse != NULL) {\n        result = 5;\n        \n        if (*bTrue != '\\0' && *bFalse == '\\0') {\n            *bFalse = '\\x01';\n            *bTrue = '\\0';\n            return 0;\n        }\n    }\n    \n    return result;\n}",
        "baseline_code_stripped": "int mono_test_marshal_bool_ref_as_I1_U1(char *bTrue,char *bFalse)\n{\n  int iVar1;\n  if ((bTrue == (char *)0x0) || (bFalse == (char *)0x0)) {\n    iVar1 = 4;\n  }\n  else {\n    iVar1 = 5;\n    if ((*bTrue != '\\0') && (iVar1 = 6, *bFalse == '\\0')) {\n      *bFalse = '\\x01';\n      *bTrue = '\\0';\n      return 0;\n    }\n  }\n  return iVar1;\n}",
        "similarity_score_unixcoder": 0.887354850769043,
        "similarity_score_baseline_stripped": 0.8568769097328186
    },
    {
        "func_name": "RestoreBkpBlocks",
        "normed_func_sha256": "a87ad1997447015e66b2f0e41db7eef191b7f77433afad4e4507aec39344d5a1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid RestoreBkpBlocks(int param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  int iVar2;\n  undefined4 extraout_ECX;\n  undefined4 *puVar3;\n  undefined4 *puVar4;\n  undefined4 *puVar5;\n  undefined8 uVar6;\n  undefined4 uVar7;\n  int local_48;\n  undefined4 local_3c [4];\n  undefined4 local_2c;\n  puVar3 = (undefined4 *)(*(ushort *)(param_1 + 0x1c) + 0x20 + param_1);\n  local_48 = 0;\n  do {\n    if ((8 >> ((byte)local_48 & 0x1f) & (uint)*(byte *)(param_1 + 0x1e)) != 0) {\n      puVar4 = puVar3;\n      puVar5 = local_3c;\n      for (iVar2 = 5; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n      }\n      iVar2 = XLogOpenRelation(1,*(undefined *)(param_1 + 0x1f),local_3c[2],local_3c[3]);\n      if (iVar2 != 0) {\n        uVar6 = XLogReadBuffer(1,iVar2,local_2c,extraout_ECX);\n        iVar2 = (int)((ulonglong)uVar6 >> 0x20);\n        iVar1 = (int)uVar6;\n        if (iVar1 < 0) {\n          if (SBORROW4(iVar1,-NLocBuffer) == iVar1 + NLocBuffer < 0) {\nLAB_0808f040:\n            if (iVar1 < 0) {\n              puVar4 = *(undefined4 **)(LocalBufferBlockPointers + -4 + iVar1 * -4);\n              iVar2 = LocalBufferBlockPointers;\n            }\n            else {\n              puVar4 = *(undefined4 **)(BufferBlockPointers + -4 + iVar1 * 4);\n            }\n            uVar7 = 0x2000;\n            memcpy(puVar4,puVar3 + 5,0x2000);\n            puVar4[1] = param_3;\n            *puVar4 = param_2;\n            puVar4[2] = ThisStartUpID;\n            LockBuffer(iVar1,0,uVar7,iVar2);\n            WriteBuffer(iVar1);\n          }\n        }\n        else if ((0 < iVar1) && (iVar1 <= NBuffers)) goto LAB_0808f040;\n      }\n      puVar3 = puVar3 + 0x805;\n    }\n    local_48 = local_48 + 1;\n    if (2 < local_48) {\n      return;\n    }\n  } while( true );\n}",
        "output": "void RestoreBkpBlocks(int param_1, undefined4 param_2, undefined4 param_3)\n{\n    int iVar1;\n    int iVar2;\n    undefined4 extraout_ECX;\n    undefined4 *puVar3;\n    undefined4 *puVar4;\n    undefined4 *puVar5;\n    undefined8 uVar6;\n    undefined4 uVar7;\n    int local_48;\n    undefined4 local_3c[4];\n    undefined4 local_2c;\n    \n    puVar3 = (undefined4 *)(*(ushort *)(param_1 + 0x1c) + 0x20 + param_1);\n    local_48 = 0;\n    \n    do {\n        if ((8 >> ((byte)local_48 & 0x1f) & (uint)*(byte *)(param_1 + 0x1e)) != 0) {\n            puVar4 = puVar3;\n            puVar5 = local_3c;\n            \n            for (iVar2 = 5; iVar2 != 0; iVar2--) {\n                *puVar5 = *puVar4;\n                puVar4++;\n                puVar5++;\n            }\n            \n            iVar2 = XLogOpenRelation(1, *(undefined *)(param_1 + 0x1f), local_3c[2], local_3c[3]);\n            \n            if (iVar2 != 0) {\n                uVar6 = XLogReadBuffer(1, iVar2, local_2c, extraout_ECX);\n                iVar2 = (int)((ulonglong)uVar6 >> 0x20);\n                iVar1 = (int)uVar6;\n                \n                if (iVar1 < 0) {\n                    if (SBORROW4(iVar1, -NLocBuffer) == iVar1 + NLocBuffer < 0) {\n                        if (iVar1 < 0) {\n                            puVar4 = *(undefined4 **)(LocalBufferBlockPointers + -4 + iVar1 * -4);\n                            iVar2 = LocalBufferBlockPointers;\n                        }\n                        else {\n                            puVar4 = *(undefined4 **)(BufferBlockPointers + -4 + iVar1 * 4);\n                        }\n                        \n                        uVar7 = 0x2000;\n                        memcpy(puVar4, puVar3 + 5, 0x2000);\n                        puVar4[1] = param_3;\n                        *puVar4 = param_2;\n                        puVar4[2] = ThisStartUpID;\n                        LockBuffer(iVar1, 0, uVar7, iVar2);\n                        WriteBuffer(iVar1);\n                    }\n                }\n                else if ((0 < iVar1) && (iVar1 <= NBuffers)) {\n                    goto LAB_0808f040;\n                }\n            }\n            \n            puVar3 += 0x805;\n        }\n        \n        local_48++;\n        \n        if (local_48 > 2) {\n            return;\n        }\n    } while (true);\n}",
        "source_code": "static void\nRestoreBkpBlocks(XLogRecord *record, XLogRecPtr lsn)\n{\n\tRelation\treln;\n\tBuffer\t\tbuffer;\n\tPage\t\tpage;\n\tBkpBlock\tbkpb;\n\tchar\t   *blk;\n\tint\t\t\ti;\n\n\tblk = (char *) XLogRecGetData(record) + record->xl_len;\n\tfor (i = 0; i < XLR_MAX_BKP_BLOCKS; i++)\n\t{\n\t\tif (!(record->xl_info & XLR_SET_BKP_BLOCK(i)))\n\t\t\tcontinue;\n\n\t\tmemcpy((char *) &bkpb, blk, sizeof(BkpBlock));\n\t\tblk += sizeof(BkpBlock);\n\n\t\treln = XLogOpenRelation(true, record->xl_rmid, bkpb.node);\n\n\t\tif (reln)\n\t\t{\n\t\t\tbuffer = XLogReadBuffer(true, reln, bkpb.block);\n\t\t\tif (BufferIsValid(buffer))\n\t\t\t{\n\t\t\t\tpage = (Page) BufferGetPage(buffer);\n\t\t\t\tmemcpy((char *) page, blk, BLCKSZ);\n\t\t\t\tPageSetLSN(page, lsn);\n\t\t\t\tPageSetSUI(page, ThisStartUpID);\n\t\t\t\tUnlockAndWriteBuffer(buffer);\n\t\t\t}\n\t\t}\n\n\t\tblk += BLCKSZ;\n\t}\n}",
        "parsed_output": "void RestoreBkpBlocks(int param_1, undefined4 param_2, undefined4 param_3)\n{\n    int iVar1;\n    int iVar2;\n    undefined4 extraout_ECX;\n    undefined4 *puVar3;\n    undefined4 *puVar4;\n    undefined4 *puVar5;\n    undefined8 uVar6;\n    undefined4 uVar7;\n    int local_48;\n    undefined4 local_3c[4];\n    undefined4 local_2c;\n    \n    puVar3 = (undefined4 *)(*(ushort *)(param_1 + 0x1c) + 0x20 + param_1);\n    local_48 = 0;\n    \n    do {\n        if ((8 >> ((byte)local_48 & 0x1f) & (uint)*(byte *)(param_1 + 0x1e)) != 0) {\n            puVar4 = puVar3;\n            puVar5 = local_3c;\n            \n            for (iVar2 = 5; iVar2 != 0; iVar2--) {\n                *puVar5 = *puVar4;\n                puVar4++;\n                puVar5++;\n            }\n            \n            iVar2 = XLogOpenRelation(1, *(undefined *)(param_1 + 0x1f), local_3c[2], local_3c[3]);\n            \n            if (iVar2 != 0) {\n                uVar6 = XLogReadBuffer(1, iVar2, local_2c, extraout_ECX);\n                iVar2 = (int)((ulonglong)uVar6 >> 0x20);\n                iVar1 = (int)uVar6;\n                \n                if (iVar1 < 0) {\n                    if (SBORROW4(iVar1, -NLocBuffer) == iVar1 + NLocBuffer < 0) {\n                        if (iVar1 < 0) {\n                            puVar4 = *(undefined4 **)(LocalBufferBlockPointers + -4 + iVar1 * -4);\n                            iVar2 = LocalBufferBlockPointers;\n                        }\n                        else {\n                            puVar4 = *(undefined4 **)(BufferBlockPointers + -4 + iVar1 * 4);\n                        }\n                        \n                        uVar7 = 0x2000;\n                        memcpy(puVar4, puVar3 + 5, 0x2000);\n                        puVar4[1] = param_3;\n                        *puVar4 = param_2;\n                        puVar4[2] = ThisStartUpID;\n                        LockBuffer(iVar1, 0, uVar7, iVar2);\n                        WriteBuffer(iVar1);\n                    }\n                }\n                else if ((0 < iVar1) && (iVar1 <= NBuffers)) {\n                    goto LAB_0808f040;\n                }\n            }\n            \n            puVar3 += 0x805;\n        }\n        \n        local_48++;\n        \n        if (local_48 > 2) {\n            return;\n        }\n    } while (true);\n}",
        "baseline_code_stripped": "void RestoreBkpBlocks(int param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  int iVar2;\n  undefined4 extraout_ECX;\n  undefined4 *puVar3;\n  undefined4 *puVar4;\n  undefined4 *puVar5;\n  undefined8 uVar6;\n  undefined4 uVar7;\n  int local_48;\n  undefined4 local_3c [4];\n  undefined4 local_2c;\n  puVar3 = (undefined4 *)(*(ushort *)(param_1 + 0x1c) + 0x20 + param_1);\n  local_48 = 0;\n  do {\n    if ((8 >> ((byte)local_48 & 0x1f) & (uint)*(byte *)(param_1 + 0x1e)) != 0) {\n      puVar4 = puVar3;\n      puVar5 = local_3c;\n      for (iVar2 = 5; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n      }\n      iVar2 = XLogOpenRelation(1,*(undefined *)(param_1 + 0x1f),local_3c[2],local_3c[3]);\n      if (iVar2 != 0) {\n        uVar6 = XLogReadBuffer(1,iVar2,local_2c,extraout_ECX);\n        iVar2 = (int)((ulonglong)uVar6 >> 0x20);\n        iVar1 = (int)uVar6;\n        if (iVar1 < 0) {\n          if (SBORROW4(iVar1,-NLocBuffer) == iVar1 + NLocBuffer < 0) {\nLAB_0808f040:\n            if (iVar1 < 0) {\n              puVar4 = *(undefined4 **)(LocalBufferBlockPointers + -4 + iVar1 * -4);\n              iVar2 = LocalBufferBlockPointers;\n            }\n            else {\n              puVar4 = *(undefined4 **)(BufferBlockPointers + -4 + iVar1 * 4);\n            }\n            uVar7 = 0x2000;\n            memcpy(puVar4,puVar3 + 5,0x2000);\n            puVar4[1] = param_3;\n            *puVar4 = param_2;\n            puVar4[2] = ThisStartUpID;\n            LockBuffer(iVar1,0,uVar7,iVar2);\n            WriteBuffer(iVar1);\n          }\n        }\n        else if ((0 < iVar1) && (iVar1 <= NBuffers)) goto LAB_0808f040;\n      }\n      puVar3 = puVar3 + 0x805;\n    }\n    local_48 = local_48 + 1;\n    if (2 < local_48) {\n      return;\n    }\n  } while( true );\n}",
        "similarity_score_unixcoder": 0.5945148468017578,
        "similarity_score_baseline_stripped": 0.5974754691123962
    },
    {
        "func_name": "tenv::add",
        "normed_func_sha256": "f3316ab41fcff0990e9d596ed2de03eb54144e5bce5a58a53246af7334050345",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4\nFUN_0032b670(undefined8 param_1,uint param_2,undefined4 param_3,long param_4,long param_5,\n            undefined8 param_6)\n{\n  long *plVar1;\n  long lVar2;\n  undefined4 uVar3;\n  long lVar4;\n  undefined8 uVar5;\n  long lVar6;\n  if (*(long *)(param_4 + 0x28) != 0) {\n    lVar2 = *(long *)(param_4 + 0x28);\n    lVar4 = param_4 + 0x20;\n    do {\n      while( true ) {\n        lVar6 = lVar2;\n        plVar1 = (long *)(lVar6 + 0x18);\n        if (param_2 <= *(uint *)(lVar6 + 0x20)) break;\n        lVar2 = *plVar1;\n        lVar6 = lVar4;\n        if (*plVar1 == 0) goto LAB_0032b6c0;\n      }\n      lVar2 = *(long *)(lVar6 + 0x10);\n      lVar4 = lVar6;\n    } while (*(long *)(lVar6 + 0x10) != 0);\nLAB_0032b6c0:\n    if (((param_4 + 0x20 != lVar6) && (*(uint *)(lVar6 + 0x20) <= param_2)) &&\n       (*(long *)(lVar6 + 0x28) != lVar6 + 0x28)) {\n      lVar2 = *(long *)(*(long *)(lVar6 + 0x28) + 0x10);\n      uVar3 = FUN_0039b900(lVar2,param_6);\n      if ((char)uVar3 == '\\0') {\n        return uVar3;\n      }\n      lVar4 = lVar2;\n      if (param_5 != 0) {\n        lVar4 = FUN_001b5be0(0x50);\n        FUN_0032b3d0(lVar4,lVar2,param_5);\n        uVar5 = *(undefined8 *)(lVar2 + 0x48);\n        *(undefined8 *)(lVar4 + 0x40) = *(undefined8 *)(lVar2 + 0x40);\n        uVar5 = FUN_0032b440(param_5,uVar5);\n        *(undefined8 *)(lVar4 + 0x48) = uVar5;\n      }\n      FUN_00243270(param_1,param_3,lVar4);\n      return uVar3;\n    }\n  }\n  return 0;\n}",
        "output": "```c\nundefined4 FUN_0032b670(undefined8 param_1, uint param_2, undefined4 param_3, long param_4, long param_5, undefined8 param_6) {\n    long *plVar1;\n    long lVar2;\n    undefined4 uVar3;\n    long lVar4;\n    undefined8 uVar5;\n    long lVar6;\n    \n    if (*(long *)(param_4 + 0x28) != 0) {\n        lVar2 = *(long *)(param_4 + 0x28);\n        lVar4 = param_4 + 0x20;\n        \n        do {\n            while (true) {\n                lVar6 = lVar2;\n                plVar1 = (long *)(lVar6 + 0x18);\n                \n                if (param_2 <= *(uint *)(lVar6 + 0x20)) \n                    break;\n                \n                lVar2 = *plVar1;\n                lVar6 = lVar4;\n                \n                if (*plVar1 == 0) \n                    goto LAB_0032b6c0;\n            }\n            \n            lVar2 = *(long *)(lVar6 + 0x10);\n            lVar4 = lVar6;\n            \n        } while (*(long *)(lVar6 + 0x10) != 0);\n        \n    LAB_0032b6c0:\n        if (((param_4 + 0x20 != lVar6) && (*(uint *)(lVar6 + 0x20) <= param_2)) && (*(long *)(lVar6 + 0x28) != lVar6 + 0x28)) {\n            lVar2 = *(long *)(*(long *)(lVar6 + 0x28) + 0x10);\n            uVar3 = FUN_0039b900(lVar2, param_6);\n            \n            if ((char)uVar3 == '\\0') {\n                return uVar3;\n            }\n            \n            lVar4 = lVar2;\n            \n            if (param_5 != 0) {\n                lVar4 = FUN_001b5be0(0x50);\n                FUN_0032b3d0(lVar4, lVar2, param_5);\n                uVar5 = *(undefined8 *)(lVar2 + 0x48);\n                *(undefined8 *)(lVar4 + 0x40) = *(undefined8 *)(lVar2 + 0x40);\n                uVar5 = FUN_0032b440(param_5, uVar5);\n                *(undefined8 *)(lVar4 + 0x48) = uVar5;\n            }\n            \n            FUN_00243270(param_1, param_3, lVar4);\n            return uVar3;\n        }\n    }\n    \n    return 0;\n}\n```",
        "source_code": "bool tenv::add(symbol src, symbol dest,\n               tenv& source, varEntry *qualifier, coder &c) {\n  names_t::iterator p = source.names.find(src);\n  if (p != source.names.end())\n    return add(dest, *p, qualifier, c);\n  else\n    return false;\n}",
        "parsed_output": "undefined4 FUN_0032b670(undefined8 param_1, uint param_2, undefined4 param_3, long param_4, long param_5, undefined8 param_6) {\n    long *plVar1;\n    long lVar2;\n    undefined4 uVar3;\n    long lVar4;\n    undefined8 uVar5;\n    long lVar6;\n    \n    if (*(long *)(param_4 + 0x28) != 0) {\n        lVar2 = *(long *)(param_4 + 0x28);\n        lVar4 = param_4 + 0x20;\n        \n        do {\n            while (true) {\n                lVar6 = lVar2;\n                plVar1 = (long *)(lVar6 + 0x18);\n                \n                if (param_2 <= *(uint *)(lVar6 + 0x20)) \n                    break;\n                \n                lVar2 = *plVar1;\n                lVar6 = lVar4;\n                \n                if (*plVar1 == 0) \n                    goto LAB_0032b6c0;\n            }\n            \n            lVar2 = *(long *)(lVar6 + 0x10);\n            lVar4 = lVar6;\n            \n        } while (*(long *)(lVar6 + 0x10) != 0);\n        \n    LAB_0032b6c0:\n        if (((param_4 + 0x20 != lVar6) && (*(uint *)(lVar6 + 0x20) <= param_2)) && (*(long *)(lVar6 + 0x28) != lVar6 + 0x28)) {\n            lVar2 = *(long *)(*(long *)(lVar6 + 0x28) + 0x10);\n            uVar3 = FUN_0039b900(lVar2, param_6);\n            \n            if ((char)uVar3 == '\\0') {\n                return uVar3;\n            }\n            \n            lVar4 = lVar2;\n            \n            if (param_5 != 0) {\n                lVar4 = FUN_001b5be0(0x50);\n                FUN_0032b3d0(lVar4, lVar2, param_5);\n                uVar5 = *(undefined8 *)(lVar2 + 0x48);\n                *(undefined8 *)(lVar4 + 0x40) = *(undefined8 *)(lVar2 + 0x40);\n                uVar5 = FUN_0032b440(param_5, uVar5);\n                *(undefined8 *)(lVar4 + 0x48) = uVar5;\n            }\n            \n            FUN_00243270(param_1, param_3, lVar4);\n            return uVar3;\n        }\n    }\n    \n    return 0;\n}",
        "baseline_code_stripped": "undefined4\nFUN_0032b670(undefined8 param_1,uint param_2,undefined4 param_3,long param_4,long param_5,\n            undefined8 param_6)\n{\n  long *plVar1;\n  long lVar2;\n  undefined4 uVar3;\n  long lVar4;\n  undefined8 uVar5;\n  long lVar6;\n  if (*(long *)(param_4 + 0x28) != 0) {\n    lVar2 = *(long *)(param_4 + 0x28);\n    lVar4 = param_4 + 0x20;\n    do {\n      while( true ) {\n        lVar6 = lVar2;\n        plVar1 = (long *)(lVar6 + 0x18);\n        if (param_2 <= *(uint *)(lVar6 + 0x20)) break;\n        lVar2 = *plVar1;\n        lVar6 = lVar4;\n        if (*plVar1 == 0) goto LAB_0032b6c0;\n      }\n      lVar2 = *(long *)(lVar6 + 0x10);\n      lVar4 = lVar6;\n    } while (*(long *)(lVar6 + 0x10) != 0);\nLAB_0032b6c0:\n    if (((param_4 + 0x20 != lVar6) && (*(uint *)(lVar6 + 0x20) <= param_2)) &&\n       (*(long *)(lVar6 + 0x28) != lVar6 + 0x28)) {\n      lVar2 = *(long *)(*(long *)(lVar6 + 0x28) + 0x10);\n      uVar3 = FUN_0039b900(lVar2,param_6);\n      if ((char)uVar3 == '\\0') {\n        return uVar3;\n      }\n      lVar4 = lVar2;\n      if (param_5 != 0) {\n        lVar4 = FUN_001b5be0(0x50);\n        FUN_0032b3d0(lVar4,lVar2,param_5);\n        uVar5 = *(undefined8 *)(lVar2 + 0x48);\n        *(undefined8 *)(lVar4 + 0x40) = *(undefined8 *)(lVar2 + 0x40);\n        uVar5 = FUN_0032b440(param_5,uVar5);\n        *(undefined8 *)(lVar4 + 0x48) = uVar5;\n      }\n      FUN_00243270(param_1,param_3,lVar4);\n      return uVar3;\n    }\n  }\n  return 0;\n}",
        "similarity_score_unixcoder": 0.44127732515335083,
        "similarity_score_baseline_stripped": 0.4394928514957428
    },
    {
        "func_name": "PitchPreset::write",
        "normed_func_sha256": "a93c4aeae8a726e70df61e9a3cf7185a80af0769cafb0c375a5bf6680280a660",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall PitchPreset::write(PitchPreset *this,PresetType param_1,basic_ptree *param_2)\n{\n  code *pcVar1;\n  long *local_28 [2];\n  long local_18 [2];\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  pcVar1 = *(code **)(*(long *)this + 0x20);\n  local_28[0] = local_18;\n  if (param_1 == 1) {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"output\",0x29a93e);\n    (*pcVar1)(this,param_2,local_28,this + 0x10);\n  }\n  else {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"input\",0x29a945);\n    (*pcVar1)(this,param_2,local_28,this + 8);\n  }\n  if (local_28[0] != local_18) {\n    operator_delete(local_28[0],local_18[0] + 1);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "void PitchPreset::write(PitchPreset *this, PresetType param_1, basic_ptree *param_2)\n{\n    code *function_ptr;\n    char output_str[2];\n    char input_str[2];\n    long stack_guard_value;\n\n    stack_guard_value = ___stack_chk_guard;\n    function_ptr = *(code **)(*(long *)this + 0x20);\n\n    if (param_1 == 1) {\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::assign(output_str, \"output\");\n        (*function_ptr)(this, param_2, output_str, this + 0x10);\n    } else {\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::assign(input_str, \"input\");\n        (*function_ptr)(this, param_2, input_str, this + 8);\n    }\n\n    if (output_str != local_18) {\n        operator_delete(output_str, local_18[0] + 1);\n    }\n\n    if (stack_guard_value == ___stack_chk_guard) {\n        return;\n    }\n\n    __stack_chk_fail();\n}",
        "source_code": "void PitchPreset::write(PresetType preset_type, boost::property_tree::ptree& root) {\n  if (preset_type == PresetType::output) {\n    save(root, \"output\", output_settings);\n  } else {\n    save(root, \"input\", input_settings);\n  }\n}",
        "parsed_output": "void PitchPreset::write(PitchPreset *this, PresetType param_1, basic_ptree *param_2)\n{\n    code *function_ptr;\n    char output_str[2];\n    char input_str[2];\n    long stack_guard_value;\n\n    stack_guard_value = ___stack_chk_guard;\n    function_ptr = *(code **)(*(long *)this + 0x20);\n\n    if (param_1 == 1) {\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::assign(output_str, \"output\");\n        (*function_ptr)(this, param_2, output_str, this + 0x10);\n    } else {\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::assign(input_str, \"input\");\n        (*function_ptr)(this, param_2, input_str, this + 8);\n    }\n\n    if (output_str != local_18) {\n        operator_delete(output_str, local_18[0] + 1);\n    }\n\n    if (stack_guard_value == ___stack_chk_guard) {\n        return;\n    }\n\n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "void __thiscall PitchPreset::write(PitchPreset *this,PresetType param_1,basic_ptree *param_2)\n{\n  code *pcVar1;\n  long *local_28 [2];\n  long local_18 [2];\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  pcVar1 = *(code **)(*(long *)this + 0x20);\n  local_28[0] = local_18;\n  if (param_1 == 1) {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"output\",0x29a93e);\n    (*pcVar1)(this,param_2,local_28,this + 0x10);\n  }\n  else {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"input\",0x29a945);\n    (*pcVar1)(this,param_2,local_28,this + 8);\n  }\n  if (local_28[0] != local_18) {\n    operator_delete(local_28[0],local_18[0] + 1);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.6392897963523865,
        "similarity_score_baseline_stripped": 0.595273494720459
    },
    {
        "func_name": "meth_wxRichTextBuffer_ClearStyleStack",
        "normed_func_sha256": "a840ac8c9b53f94fde4a54c9b47e2c197818531eb2b738acb1f4b3db4ca79508",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined * FUN_001e1f20(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  long local_40 [2];\n  undefined8 local_30;\n  long *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  local_40[0] = param_1;\n  if ((param_1 == 0) ||\n     (iVar1 = (**(code **)(sipAPI__richtext + 0x3a8))(param_1,param_2,0), iVar1 != 0)) {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) goto LAB_001e2014;\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    wxRichTextBuffer::ClearStyleStack();\n  }\n  else {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) {\nLAB_001e2014:\n      (**(code **)(sipAPI__richtext + 0x2a0))(local_30,\"RichTextBuffer\",\"ClearStyleStack\",0);\n      puVar4 = (undefined *)0x0;\n      goto LAB_001e203c;\n    }\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    (**(code **)(*local_28 + 0x458))();\n  }\n  PyEval_RestoreThread(uVar2);\n  lVar3 = PyErr_Occurred();\n  puVar4 = (undefined *)0x0;\n  if (lVar3 == 0) {\n    puVar4 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\nLAB_001e203c:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return puVar4;\n}",
        "output": "```c\nundefined * process_richtext(long param_1, undefined8 param_2)\n{\n    int iVar1;\n    undefined8 uVar2;\n    long lVar3;\n    undefined *result;\n    long local_40[2];\n    undefined8 local_30;\n    long *local_28;\n    long local_20;\n\n    local_20 = *(long *)(in_FS_OFFSET + 0x28);\n    local_30 = 0;\n    local_40[0] = param_1;\n\n    if (param_1 == 0 || (**(code **)(sipAPI__richtext + 0x3a8))(param_1, param_2, 0) != 0) {\n        iVar1 = (**(code **)(sipAPI__richtext + 0x280))(&local_30, param_2, &DAT_002f29ba, local_40, PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550, &local_28);\n        if (iVar1 != 0) {\n            PyErr_Clear();\n            uVar2 = PyEval_SaveThread();\n            wxRichTextBuffer::ClearStyleStack();\n        }\n    } else {\n        iVar1 = (**(code **)(sipAPI__richtext + 0x280))(&local_30, param_2, &DAT_002f29ba, local_40, PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550, &local_28);\n        if (iVar1 == 0) {\n            (**(code **)(sipAPI__richtext + 0x2a0))(local_30, \"RichTextBuffer\", \"ClearStyleStack\", 0);\n            result = (undefined *)0x0;\n            goto LAB_001e203c;\n        }\n        PyErr_Clear();\n        uVar2 = PyEval_SaveThread();\n        (**(code **)(*local_28 + 0x458))();\n    }\n\n    PyEval_RestoreThread(uVar2);\n    lVar3 = PyErr_Occurred();\n    result = (undefined *)0x0;\n\n    if (lVar3 == 0) {\n        result = &_Py_NoneStruct;\n        __Py_NoneStruct = __Py_NoneStruct + 1;\n    }\n\nLAB_001e203c:\n    if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n\n    return result;\n}\n```",
        "source_code": "static PyObject *meth_wxRichTextBuffer_ClearStyleStack(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));\n\n    {\n         ::wxRichTextBuffer *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_wxRichTextBuffer, &sipCpp))\n        {\n            PyErr_Clear();\n\n            Py_BEGIN_ALLOW_THREADS\n            (sipSelfWasArg ? sipCpp-> ::wxRichTextBuffer::ClearStyleStack() : sipCpp->ClearStyleStack());\n            Py_END_ALLOW_THREADS\n\n            if (PyErr_Occurred())\n                return 0;\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    sipNoMethod(sipParseErr, sipName_RichTextBuffer, sipName_ClearStyleStack, SIP_NULLPTR);\n\n    return SIP_NULLPTR;\n}",
        "parsed_output": "undefined * process_richtext(long param_1, undefined8 param_2)\n{\n    int iVar1;\n    undefined8 uVar2;\n    long lVar3;\n    undefined *result;\n    long local_40[2];\n    undefined8 local_30;\n    long *local_28;\n    long local_20;\n\n    local_20 = *(long *)(in_FS_OFFSET + 0x28);\n    local_30 = 0;\n    local_40[0] = param_1;\n\n    if (param_1 == 0 || (**(code **)(sipAPI__richtext + 0x3a8))(param_1, param_2, 0) != 0) {\n        iVar1 = (**(code **)(sipAPI__richtext + 0x280))(&local_30, param_2, &DAT_002f29ba, local_40, PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550, &local_28);\n        if (iVar1 != 0) {\n            PyErr_Clear();\n            uVar2 = PyEval_SaveThread();\n            wxRichTextBuffer::ClearStyleStack();\n        }\n    } else {\n        iVar1 = (**(code **)(sipAPI__richtext + 0x280))(&local_30, param_2, &DAT_002f29ba, local_40, PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550, &local_28);\n        if (iVar1 == 0) {\n            (**(code **)(sipAPI__richtext + 0x2a0))(local_30, \"RichTextBuffer\", \"ClearStyleStack\", 0);\n            result = (undefined *)0x0;\n            goto LAB_001e203c;\n        }\n        PyErr_Clear();\n        uVar2 = PyEval_SaveThread();\n        (**(code **)(*local_28 + 0x458))();\n    }\n\n    PyEval_RestoreThread(uVar2);\n    lVar3 = PyErr_Occurred();\n    result = (undefined *)0x0;\n\n    if (lVar3 == 0) {\n        result = &_Py_NoneStruct;\n        __Py_NoneStruct = __Py_NoneStruct + 1;\n    }\n\nLAB_001e203c:\n    if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n\n    return result;\n}",
        "baseline_code_stripped": "undefined * FUN_001e1f20(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  long local_40 [2];\n  undefined8 local_30;\n  long *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  local_40[0] = param_1;\n  if ((param_1 == 0) ||\n     (iVar1 = (**(code **)(sipAPI__richtext + 0x3a8))(param_1,param_2,0), iVar1 != 0)) {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) goto LAB_001e2014;\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    wxRichTextBuffer::ClearStyleStack();\n  }\n  else {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) {\nLAB_001e2014:\n      (**(code **)(sipAPI__richtext + 0x2a0))(local_30,\"RichTextBuffer\",\"ClearStyleStack\",0);\n      puVar4 = (undefined *)0x0;\n      goto LAB_001e203c;\n    }\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    (**(code **)(*local_28 + 0x458))();\n  }\n  PyEval_RestoreThread(uVar2);\n  lVar3 = PyErr_Occurred();\n  puVar4 = (undefined *)0x0;\n  if (lVar3 == 0) {\n    puVar4 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\nLAB_001e203c:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return puVar4;\n}",
        "similarity_score_unixcoder": 0.6232308149337769,
        "similarity_score_baseline_stripped": 0.6001149415969849
    },
    {
        "func_name": "message_new_empty",
        "normed_func_sha256": "0be0f08bab1e2ad99d5ddfb69ba8a99572936aceb896597fa4c99c45b642a592",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_00172170(long param_1,undefined8 *param_2)\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  undefined8 uVar3;\n  if (param_2 != (undefined8 *)0x0) {\n    puVar2 = (undefined4 *)calloc(1,0x430);\n    if (puVar2 == (undefined4 *)0x0) {\n      uVar3 = 0xfffffff4;\n    }\n    else {\n      uVar1 = *(undefined4 *)(param_1 + 0x18);\n      *(byte *)(puVar2 + 0x109) = *(byte *)(puVar2 + 0x109) & 0xfe;\n      *puVar2 = 1;\n      puVar2[4] = uVar1;\n      *param_2 = puVar2;\n      uVar3 = 0;\n    }\n    return uVar3;\n  }\n  FUN_00148060(0,&DAT_001bfb62,\"../src/libsystemd/sd-netlink/netlink-message.c\",0x1b,\n               \"message_new_empty\");\n  return 0xffffffea;\n}",
        "output": "```c\nundefined8 allocate_and_initialize_buffer(long size, undefined8 *buffer)\n{\n    undefined4 value;\n    undefined4 *allocated_buffer;\n    undefined8 result;\n    \n    if (buffer != (undefined8 *)0x0) {\n        allocated_buffer = (undefined4 *)calloc(1, 0x430);\n        if (allocated_buffer == (undefined4 *)0x0) {\n            result = 0xfffffff4;\n        }\n        else {\n            value = *(undefined4 *)(size + 0x18);\n            *(byte *)(allocated_buffer + 0x109) = *(byte *)(allocated_buffer + 0x109) & 0xfe;\n            *allocated_buffer = 1;\n            allocated_buffer[4] = value;\n            *buffer = allocated_buffer;\n            result = 0;\n        }\n        return result;\n    }\n    \n    FUN_00148060(0, &DAT_001bfb62, \"../src/libsystemd/sd-netlink/netlink-message.c\", 0x1b, \"message_new_empty\");\n    return 0xffffffea;\n}\n```",
        "source_code": "int message_new_empty(sd_netlink *rtnl, sd_netlink_message **ret) {\n        sd_netlink_message *m;\n        assert_return(ret, -EINVAL);\n        m = new0(sd_netlink_message, 1);\n        if (!m)\n                return -ENOMEM;\n        m->n_ref = 1;\n        m->protocol = rtnl->protocol;\n        m->sealed = false;\n        *ret = m;\n        return 0;\n}",
        "parsed_output": "undefined8 allocate_and_initialize_buffer(long size, undefined8 *buffer)\n{\n    undefined4 value;\n    undefined4 *allocated_buffer;\n    undefined8 result;\n    \n    if (buffer != (undefined8 *)0x0) {\n        allocated_buffer = (undefined4 *)calloc(1, 0x430);\n        if (allocated_buffer == (undefined4 *)0x0) {\n            result = 0xfffffff4;\n        }\n        else {\n            value = *(undefined4 *)(size + 0x18);\n            *(byte *)(allocated_buffer + 0x109) = *(byte *)(allocated_buffer + 0x109) & 0xfe;\n            *allocated_buffer = 1;\n            allocated_buffer[4] = value;\n            *buffer = allocated_buffer;\n            result = 0;\n        }\n        return result;\n    }\n    \n    FUN_00148060(0, &DAT_001bfb62, \"../src/libsystemd/sd-netlink/netlink-message.c\", 0x1b, \"message_new_empty\");\n    return 0xffffffea;\n}",
        "baseline_code_stripped": "undefined8 FUN_00172170(long param_1,undefined8 *param_2)\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  undefined8 uVar3;\n  if (param_2 != (undefined8 *)0x0) {\n    puVar2 = (undefined4 *)calloc(1,0x430);\n    if (puVar2 == (undefined4 *)0x0) {\n      uVar3 = 0xfffffff4;\n    }\n    else {\n      uVar1 = *(undefined4 *)(param_1 + 0x18);\n      *(byte *)(puVar2 + 0x109) = *(byte *)(puVar2 + 0x109) & 0xfe;\n      *puVar2 = 1;\n      puVar2[4] = uVar1;\n      *param_2 = puVar2;\n      uVar3 = 0;\n    }\n    return uVar3;\n  }\n  FUN_00148060(0,&DAT_001bfb62,\"../src/libsystemd/sd-netlink/netlink-message.c\",0x1b,\n               \"message_new_empty\");\n  return 0xffffffea;\n}",
        "similarity_score_unixcoder": 0.5568093061447144,
        "similarity_score_baseline_stripped": 0.5321404933929443
    },
    {
        "func_name": "send_CharSet",
        "normed_func_sha256": "f2b2d298b3cf7e51637cf5484e6481f38c14bce7a51afba8d2e58f36203a60e0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00186aab(undefined8 param_1,long param_2)\n{\n  byte bVar1;\n  undefined *local_10;\n  local_10 = (undefined *)0x0;\n  bVar1 = *(byte *)(param_2 + 2) >> 4;\n  if (bVar1 == 3) {\n    local_10 = &DAT_001cffac;\n  }\n  else if (bVar1 < 4) {\n    if (bVar1 == 2) {\n      local_10 = &DAT_001cffa8;\n    }\n    else if (bVar1 < 3) {\n      if (bVar1 == 0) {\n        local_10 = &DAT_001cffa0;\n      }\n      else if (bVar1 == 1) {\n        local_10 = &DAT_001cffa4;\n      }\n    }\n  }\n  if (local_10 != (undefined *)0x0) {\n    FUN_00186fdd(param_1,local_10);\n  }\n  return;\n}",
        "output": "```c\nvoid process_data(undefined8 param_1, long param_2)\n{\n    byte bVar1 = *(byte *)(param_2 + 2) >> 4;\n    undefined *data_ptr = NULL;\n\n    if (bVar1 == 3) {\n        data_ptr = &DAT_001cffac;\n    } else if (bVar1 == 2) {\n        data_ptr = &DAT_001cffa8;\n    } else if (bVar1 == 0) {\n        data_ptr = &DAT_001cffa0;\n    } else if (bVar1 == 1) {\n        data_ptr = &DAT_001cffa4;\n    }\n\n    if (data_ptr != NULL) {\n        process_data(param_1, data_ptr);\n    }\n}\n```",
        "source_code": "static void\nsend_CharSet(XtermWidget xw, LineData *ld)\n{\n#if OPT_DEC_CHRSET\n    const char *msg = 0;\n\n    switch (GetLineDblCS(ld)) {\n    case CSET_SWL:\n\tmsg = \"\\033#5\";\n\tbreak;\n    case CSET_DHL_TOP:\n\tmsg = \"\\033#3\";\n\tbreak;\n    case CSET_DHL_BOT:\n\tmsg = \"\\033#4\";\n\tbreak;\n    case CSET_DWL:\n\tmsg = \"\\033#6\";\n\tbreak;\n    }\n    if (msg != 0)\n\tstringToPrinter(xw, msg);\n#else\n    (void) xw;\n    (void) ld;\n#endif /* OPT_DEC_CHRSET */\n}",
        "parsed_output": "void process_data(undefined8 param_1, long param_2)\n{\n    byte bVar1 = *(byte *)(param_2 + 2) >> 4;\n    undefined *data_ptr = NULL;\n\n    if (bVar1 == 3) {\n        data_ptr = &DAT_001cffac;\n    } else if (bVar1 == 2) {\n        data_ptr = &DAT_001cffa8;\n    } else if (bVar1 == 0) {\n        data_ptr = &DAT_001cffa0;\n    } else if (bVar1 == 1) {\n        data_ptr = &DAT_001cffa4;\n    }\n\n    if (data_ptr != NULL) {\n        process_data(param_1, data_ptr);\n    }\n}",
        "baseline_code_stripped": "void FUN_00186aab(undefined8 param_1,long param_2)\n{\n  byte bVar1;\n  undefined *local_10;\n  local_10 = (undefined *)0x0;\n  bVar1 = *(byte *)(param_2 + 2) >> 4;\n  if (bVar1 == 3) {\n    local_10 = &DAT_001cffac;\n  }\n  else if (bVar1 < 4) {\n    if (bVar1 == 2) {\n      local_10 = &DAT_001cffa8;\n    }\n    else if (bVar1 < 3) {\n      if (bVar1 == 0) {\n        local_10 = &DAT_001cffa0;\n      }\n      else if (bVar1 == 1) {\n        local_10 = &DAT_001cffa4;\n      }\n    }\n  }\n  if (local_10 != (undefined *)0x0) {\n    FUN_00186fdd(param_1,local_10);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.49793583154678345,
        "similarity_score_baseline_stripped": 0.494633287191391
    },
    {
        "func_name": "meth_QQuickItem_grabToImage",
        "normed_func_sha256": "415a100168782cf8af63c903dee54b2c1005845202e4086a5dc13ab1ea1d8c36",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0018aef0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  undefined8 local_38 [2];\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 *local_18;\n  QSize *pQStack_10;\n  long local_8;\n  local_18 = &local_20;\n  local_28 = 0;\n  local_20 = 0xffffffffffffffff;\n  local_8 = ___stack_chk_guard;\n  local_38[0] = param_1;\n  iVar1 = (**(code **)(DAT_00273618 + 0x370))\n                    (&local_28,param_2,param_3,&PTR_s_targetSize_002626c0,0,&DAT_001f6098,local_38,\n                     PTR_DAT_00272258,&pQStack_10,PTR_s_QSize_00272728,&local_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_00273618 + 0x2a0))\n              (local_28,\"QQuickItem\",\"grabToImage\",s_grabToImage_self__targetSize__QS_00261ed8);\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = PyEval_SaveThread();\n    puVar3 = (undefined8 *)operator_new(0x10);\n    QQuickItem::grabToImage(pQStack_10);\n    PyEval_RestoreThread(uVar2);\n    uVar2 = (**(code **)(DAT_00273618 + 0x90))(*puVar3,PTR_DAT_00272290,0);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(uVar2);\n}",
        "output": "void grabImageAndSave(undefined8 param_1, undefined8 param_2, undefined8 param_3)\n{\n    int result;\n    undefined8 threadState;\n    undefined8 *newPtr;\n    undefined8 localVars[2];\n    undefined8 localVar1;\n    undefined8 localVar2;\n    undefined8 *localVarPtr;\n    QSize *qSizePtr;\n    long stackGuard;\n\n    localVarPtr = &localVar2;\n    localVar1 = 0;\n    localVar2 = 0xffffffffffffffff;\n    stackGuard = ___stack_chk_guard;\n    localVars[0] = param_1;\n    result = (**(code **)(DAT_00273618 + 0x370))(&localVar1, param_2, param_3, &PTR_s_targetSize_002626c0, 0, &DAT_001f6098, localVars, PTR_DAT_00272258, &qSizePtr, PTR_s_QSize_00272728, &localVarPtr);\n    \n    if (result == 0) {\n        (**(code **)(DAT_00273618 + 0x2a0))(localVar1, \"QQuickItem\", \"grabToImage\", s_grabToImage_self__targetSize__QS_00261ed8);\n        threadState = 0;\n    } else {\n        threadState = PyEval_SaveThread();\n        newPtr = (undefined8 *)operator_new(0x10);\n        QQuickItem::grabToImage(qSizePtr);\n        PyEval_RestoreThread(threadState);\n        threadState = (**(code **)(DAT_00273618 + 0x90))(*newPtr, PTR_DAT_00272290, 0);\n    }\n    \n    if (stackGuard == ___stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail(threadState);\n}",
        "source_code": "static PyObject *meth_QQuickItem_grabToImage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        const  ::QSize& a0def = QSize();\n        const  ::QSize* a0 = &a0def;\n         ::QQuickItem *sipCpp;\n\n        static const char *sipKwdList[] = {\n            sipName_targetSize,\n        };\n\n        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, \"B|J9\", &sipSelf, sipType_QQuickItem, &sipCpp, sipType_QSize, &a0))\n        {\n             ::QQuickItemGrabResult*sipRes = 0;\n\n#line 282 \"/builddir/build/BUILD/PyQt5_gpl-5.11.3/aarch64-redhat-linux-gnu/sip/QtQuick/qquickitem.sip\"\n        QSharedPointer<QQuickItemGrabResult> *grab;\n        \n        Py_BEGIN_ALLOW_THREADS\n        // This will leak but there seems to be no way to detach the object.\n        grab = new QSharedPointer<QQuickItemGrabResult>(sipCpp->grabToImage(*a0));\n        Py_END_ALLOW_THREADS\n        \n        sipRes = grab->data();\n#line 4464 \"/builddir/build/BUILD/PyQt5_gpl-5.11.3/aarch64-redhat-linux-gnu/QtQuick/sipQtQuickQQuickItem.cpp\"\n\n            return sipConvertFromNewType(sipRes,sipType_QQuickItemGrabResult,NULL);\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QQuickItem, sipName_grabToImage, doc_QQuickItem_grabToImage);\n\n    return NULL;\n}",
        "parsed_output": "void grabImageAndSave(undefined8 param_1, undefined8 param_2, undefined8 param_3)\n{\n    int result;\n    undefined8 threadState;\n    undefined8 *newPtr;\n    undefined8 localVars[2];\n    undefined8 localVar1;\n    undefined8 localVar2;\n    undefined8 *localVarPtr;\n    QSize *qSizePtr;\n    long stackGuard;\n\n    localVarPtr = &localVar2;\n    localVar1 = 0;\n    localVar2 = 0xffffffffffffffff;\n    stackGuard = ___stack_chk_guard;\n    localVars[0] = param_1;\n    result = (**(code **)(DAT_00273618 + 0x370))(&localVar1, param_2, param_3, &PTR_s_targetSize_002626c0, 0, &DAT_001f6098, localVars, PTR_DAT_00272258, &qSizePtr, PTR_s_QSize_00272728, &localVarPtr);\n    \n    if (result == 0) {\n        (**(code **)(DAT_00273618 + 0x2a0))(localVar1, \"QQuickItem\", \"grabToImage\", s_grabToImage_self__targetSize__QS_00261ed8);\n        threadState = 0;\n    } else {\n        threadState = PyEval_SaveThread();\n        newPtr = (undefined8 *)operator_new(0x10);\n        QQuickItem::grabToImage(qSizePtr);\n        PyEval_RestoreThread(threadState);\n        threadState = (**(code **)(DAT_00273618 + 0x90))(*newPtr, PTR_DAT_00272290, 0);\n    }\n    \n    if (stackGuard == ___stack_chk_guard) {\n        return;\n    }\n    \n    __stack_chk_fail(threadState);\n}",
        "baseline_code_stripped": "void FUN_0018aef0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  undefined8 local_38 [2];\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 *local_18;\n  QSize *pQStack_10;\n  long local_8;\n  local_18 = &local_20;\n  local_28 = 0;\n  local_20 = 0xffffffffffffffff;\n  local_8 = ___stack_chk_guard;\n  local_38[0] = param_1;\n  iVar1 = (**(code **)(DAT_00273618 + 0x370))\n                    (&local_28,param_2,param_3,&PTR_s_targetSize_002626c0,0,&DAT_001f6098,local_38,\n                     PTR_DAT_00272258,&pQStack_10,PTR_s_QSize_00272728,&local_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_00273618 + 0x2a0))\n              (local_28,\"QQuickItem\",\"grabToImage\",s_grabToImage_self__targetSize__QS_00261ed8);\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = PyEval_SaveThread();\n    puVar3 = (undefined8 *)operator_new(0x10);\n    QQuickItem::grabToImage(pQStack_10);\n    PyEval_RestoreThread(uVar2);\n    uVar2 = (**(code **)(DAT_00273618 + 0x90))(*puVar3,PTR_DAT_00272290,0);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(uVar2);\n}",
        "similarity_score_unixcoder": 0.679508626461029,
        "similarity_score_baseline_stripped": 0.632226288318634
    },
    {
        "func_name": "game_hub_data_compat_tool_real_run_data_free",
        "normed_func_sha256": "438821cb6448faf6abb4221552c9c43641d71545bf24150f264e7e3ad33332b0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid game_hub_data_compat_tool_real_run_data_free(int param_1)\n{\n  if (*(int *)(param_1 + 0x14) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x14));\n    *(undefined4 *)(param_1 + 0x14) = 0;\n  }\n  if (*(int *)(param_1 + 0x10) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x10));\n    *(undefined4 *)(param_1 + 0x10) = 0;\n  }\n  g_slice_free1(0x18,param_1);\n  return;\n}",
        "output": "void game_hub_data_compat_tool_real_run_data_free(int param_1)\n{\n    if (*(int *)(param_1 + 0x14) != 0) {\n        g_object_unref(*(undefined4 *)(param_1 + 0x14));\n        *(undefined4 *)(param_1 + 0x14) = 0;\n    }\n    \n    if (*(int *)(param_1 + 0x10) != 0) {\n        g_object_unref(*(undefined4 *)(param_1 + 0x10));\n        *(undefined4 *)(param_1 + 0x10) = 0;\n    }\n    \n    g_slice_free1(0x18, param_1);\n}",
        "source_code": "static void\ngame_hub_data_compat_tool_real_run_data_free (gpointer _data)\n{\n\tGameHubDataCompatToolRunData* _data_;\n\t_data_ = _data;\n#line 25 \"../src/data/CompatTool.vala\"\n\t_g_object_unref0 (_data_->game);\n#line 25 \"../src/data/CompatTool.vala\"\n\t_g_object_unref0 (_data_->self);\n#line 25 \"../src/data/CompatTool.vala\"\n\tg_slice_free (GameHubDataCompatToolRunData, _data_);\n#line 1016 \"CompatTool.c\"\n}",
        "parsed_output": "void game_hub_data_compat_tool_real_run_data_free(int param_1)\n{\n    if (*(int *)(param_1 + 0x14) != 0) {\n        g_object_unref(*(undefined4 *)(param_1 + 0x14));\n        *(undefined4 *)(param_1 + 0x14) = 0;\n    }\n    \n    if (*(int *)(param_1 + 0x10) != 0) {\n        g_object_unref(*(undefined4 *)(param_1 + 0x10));\n        *(undefined4 *)(param_1 + 0x10) = 0;\n    }\n    \n    g_slice_free1(0x18, param_1);\n}",
        "baseline_code_stripped": "void game_hub_data_compat_tool_real_run_data_free(int param_1)\n{\n  if (*(int *)(param_1 + 0x14) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x14));\n    *(undefined4 *)(param_1 + 0x14) = 0;\n  }\n  if (*(int *)(param_1 + 0x10) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x10));\n    *(undefined4 *)(param_1 + 0x10) = 0;\n  }\n  g_slice_free1(0x18,param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.7395138144493103,
        "similarity_score_baseline_stripped": 0.7293176651000977
    },
    {
        "func_name": "sipQtCharts_QScatterSeries::connectNotify",
        "normed_func_sha256": "cf635fe8270631b3f5917c72303734da6dc28985b7e711e2912fbcd3abc33de3",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall\nsipQtCharts_QScatterSeries::connectNotify(sipQtCharts_QScatterSeries *this,QMetaMethod *param_1)\n{\n  _object *p_Var1;\n  int in_GS_OFFSET;\n  PyGILState_STATE local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  p_Var1 = (_object *)\n           (**(code **)(DAT_000d2940 + 0x164))\n                     (&local_14,this + 0x16,*(undefined4 *)(this + 0xc),0,\"connectNotify\");\n  if (p_Var1 == (_object *)0x0) {\n    FUN_00035fa0(this,param_1);\n  }\n  else {\n    sipVH_QtChart_0(local_14,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)\n                             PTR_s_PyQt5_000cc22c,*(_sipSimpleWrapper **)(this + 0xc),p_Var1,param_1\n                   );\n  }\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  __stack_chk_fail_local();\n}",
        "output": "```c\nvoid sipQtCharts_QScatterSeries::connectNotify(sipQtCharts_QScatterSeries *this, QMetaMethod *param_1)\n{\n    _object *p_Var1;\n    int local_10;\n    \n    local_10 = *(int *)(in_GS_OFFSET + 0x14);\n    p_Var1 = (_object *)(**(code **)(DAT_000d2940 + 0x164))(&local_14, this + 0x16, *(undefined4 *)(this + 0xc), 0, \"connectNotify\");\n    \n    if (p_Var1 == (_object *)0x0) {\n        FUN_00035fa0(this, param_1);\n    } else {\n        sipVH_QtChart_0(local_14, (_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)PTR_s_PyQt5_000cc22c, *(_sipSimpleWrapper **)(this + 0xc), p_Var1, param_1);\n    }\n    \n    if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n        return;\n    }\n    \n    __stack_chk_fail_local();\n}\n```",
        "source_code": "void sipQtCharts_QScatterSeries::connectNotify(const  ::QMetaMethod& a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_connectNotify);\n\n    if (!sipMeth)\n    {\n         ::QtCharts::QScatterSeries::connectNotify(a0);\n        return;\n    }\n\n    extern void sipVH_QtChart_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);\n\n    sipVH_QtChart_0(sipGILState, sipImportedVirtErrorHandlers_QtChart_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);\n}",
        "parsed_output": "void sipQtCharts_QScatterSeries::connectNotify(sipQtCharts_QScatterSeries *this, QMetaMethod *param_1)\n{\n    _object *p_Var1;\n    int local_10;\n    \n    local_10 = *(int *)(in_GS_OFFSET + 0x14);\n    p_Var1 = (_object *)(**(code **)(DAT_000d2940 + 0x164))(&local_14, this + 0x16, *(undefined4 *)(this + 0xc), 0, \"connectNotify\");\n    \n    if (p_Var1 == (_object *)0x0) {\n        FUN_00035fa0(this, param_1);\n    } else {\n        sipVH_QtChart_0(local_14, (_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)PTR_s_PyQt5_000cc22c, *(_sipSimpleWrapper **)(this + 0xc), p_Var1, param_1);\n    }\n    \n    if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n        return;\n    }\n    \n    __stack_chk_fail_local();\n}",
        "baseline_code_stripped": "void __thiscall\nsipQtCharts_QScatterSeries::connectNotify(sipQtCharts_QScatterSeries *this,QMetaMethod *param_1)\n{\n  _object *p_Var1;\n  int in_GS_OFFSET;\n  PyGILState_STATE local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  p_Var1 = (_object *)\n           (**(code **)(DAT_000d2940 + 0x164))\n                     (&local_14,this + 0x16,*(undefined4 *)(this + 0xc),0,\"connectNotify\");\n  if (p_Var1 == (_object *)0x0) {\n    FUN_00035fa0(this,param_1);\n  }\n  else {\n    sipVH_QtChart_0(local_14,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)\n                             PTR_s_PyQt5_000cc22c,*(_sipSimpleWrapper **)(this + 0xc),p_Var1,param_1\n                   );\n  }\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  __stack_chk_fail_local();\n}",
        "similarity_score_unixcoder": 0.7405977249145508,
        "similarity_score_baseline_stripped": 0.7519751191139221
    },
    {
        "func_name": "RemoveObstacle::apply",
        "normed_func_sha256": "477d534fa11340a99a8fca21f0af40048992ce748121a484385fdc070fa07878",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_005a0ee0(undefined8 param_1,long *param_2,long *param_3,undefined8 param_4)\n{\n  undefined4 uVar1;\n  long *plVar2;\n  JsonNode *pJVar3;\n  CObstacleInstance *this;\n  undefined local_d1;\n  undefined auStack_d0 [8];\n  _Rb_tree_node_base a_Stack_c8 [8];\n  undefined8 local_c0;\n  _Rb_tree_node_base *local_b8;\n  undefined **local_a0;\n  undefined8 uStack_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  JsonNode *local_80;\n  JsonNode *local_78;\n  JsonNode *local_70;\n  long local_68;\n  local_88 = 0xffffffff;\n  local_68 = ___stack_chk_guard;\n  local_a0 = &PTR_FUN_007f7050;\n  uStack_98 = 0;\n  local_90 = 0;\n  local_80 = (JsonNode *)0x0;\n  local_78 = (JsonNode *)0x0;\n  local_70 = (JsonNode *)0x0;\n  if (*(code **)(*param_3 + 0x148) == spells::BaseMechanics::battle) {\n    plVar2 = (long *)param_3[10];\n  }\n  else {\n    plVar2 = (long *)(**(code **)(*param_3 + 0x148))(param_3);\n  }\n  plVar2 = (long *)(**(code **)(*(long *)((long)plVar2 + *(long *)(*plVar2 + -0x98)) + 0x18))\n                             ((long)plVar2 + *(long *)(*plVar2 + -0x98));\n  if (*(code **)(*plVar2 + 0x18) == BattleInfo::getBattleID) {\n    local_88 = *(undefined4 *)(plVar2 + 1);\n  }\n  else {\n    local_88 = (**(code **)(*plVar2 + 0x18))();\n  }\n  FUN_0059c0f4(param_1,param_3,param_4,0);\n  pJVar3 = local_78;\n  while (local_78 = pJVar3, local_b8 != a_Stack_c8) {\n    local_d1 = 3;\n    this = *(CObstacleInstance **)(local_b8 + 0x20);\n    if (pJVar3 == local_70) {\n      FUN_002d3b60(&local_80,pJVar3,this + 0xc,&local_d1);\n      pJVar3 = local_78 + -0x78;\n    }\n    else {\n      uVar1 = *(undefined4 *)(this + 0xc);\n      JsonNode::JsonNode(pJVar3,0);\n      pJVar3[0x70] = (JsonNode)0x3;\n      *(undefined4 *)(pJVar3 + 0x74) = uVar1;\n      pJVar3 = local_78;\n      local_78 = local_78 + 0x78;\n    }\n    CObstacleInstance::toInfo(this,(ObstacleChanges *)pJVar3,3);\n    local_b8 = (_Rb_tree_node_base *)std::_Rb_tree_increment(local_b8);\n    pJVar3 = local_78;\n  }\n  FUN_002b8b20(auStack_d0,local_c0);\n  if (local_80 != local_78) {\n    (**(code **)(*param_2 + 0x58))(param_2,&local_a0);\n  }\n  FUN_002bf270(&local_a0);\n  if (local_68 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_68 - ___stack_chk_guard);\n}",
        "output": "```c\nvoid processObstacleChanges(undefined8 param_1, long *param_2, long *param_3, undefined8 param_4) {\n    undefined4 uVar1;\n    long *plVar2;\n    JsonNode *pJVar3;\n    CObstacleInstance *this;\n    undefined local_d1;\n    undefined auStack_d0[8];\n    _Rb_tree_node_base a_Stack_c8[8];\n    undefined8 local_c0;\n    _Rb_tree_node_base *local_b8;\n    undefined **local_a0;\n    undefined8 uStack_98;\n    undefined8 local_90;\n    undefined4 local_88;\n    JsonNode *local_80;\n    JsonNode *local_78;\n    JsonNode *local_70;\n    long local_68;\n    \n    local_88 = 0xffffffff;\n    local_68 = ___stack_chk_guard;\n    local_a0 = &PTR_FUN_007f7050;\n    uStack_98 = 0;\n    local_90 = 0;\n    local_80 = (JsonNode *)0x0;\n    local_78 = (JsonNode *)0x0;\n    local_70 = (JsonNode *)0x0;\n    \n    if (*(code **)(*param_3 + 0x148) == spells::BaseMechanics::battle) {\n        plVar2 = (long *)param_3[10];\n    } else {\n        plVar2 = (long *)(**(code **)(*param_3 + 0x148))(param_3);\n    }\n    \n    plVar2 = (long *)(**(code **)(*(long *)((long)plVar2 + *(long *)(*plVar2 + -0x98)) + 0x18))((long)plVar2 + *(long *)(*plVar2 + -0x98));\n    \n    if (*(code **)(*plVar2 + 0x18) == BattleInfo::getBattleID) {\n        local_88 = *(undefined4 *)(plVar2 + 1);\n    } else {\n        local_88 = (**(code **)(*plVar2 + 0x18))();\n    }\n    \n    FUN_0059c0f4(param_1, param_3, param_4, 0);\n    pJVar3 = local_78;\n    \n    while (local_78 = pJVar3, local_b8 != a_Stack_c8) {\n        local_d1 = 3;\n        this = *(CObstacleInstance **)(local_b8 + 0x20);\n        \n        if (pJVar3 == local_70) {\n            FUN_002d3b60(&local_80, pJVar3, this + 0xc, &local_d1);\n            pJVar3 = local_78 + -0x78;\n        } else {\n            uVar1 = *(undefined4 *)(this + 0xc);\n            JsonNode::JsonNode(pJVar3, 0);\n            pJVar3[0x70] = (JsonNode)0x3;\n            *(undefined4 *)(pJVar3 + 0x74) = uVar1;\n            pJVar3 = local_78;\n            local_78 = local_78 + 0x78;\n        }\n        \n        CObstacleInstance::toInfo(this, (ObstacleChanges *)pJVar3, 3);\n        local_b8 = (_Rb_tree_node_base *)std::_Rb_tree_increment(local_b8);\n        pJVar3 = local_78;\n    }\n    \n    FUN_002b8b20(auStack_d0, local_c0);\n    \n    if (local_80 != local_78) {\n        (**(code **)(*param_2 + 0x58))(param_2, &local_a0);\n    }\n    \n    FUN_002bf270(&local_a0);\n    \n    if (local_68 - ___stack_chk_guard == 0) {\n        return;\n    }\n    \n    __stack_chk_fail(&__stack_chk_guard, 0, local_68 - ___stack_chk_guard);\n}\n```",
        "source_code": "void RemoveObstacle::apply(ServerCallback * server, const Mechanics * m, const EffectTarget & target) const\n{\n\tBattleObstaclesChanged pack;\n\tpack.battleID = m->battle()->getBattle()->getBattleID();\n\n\tfor(const auto & obstacle : getTargets(m, target, false))\n\t{\n\t\tauto * serializable = const_cast<CObstacleInstance*>(obstacle); //Workaround\n\t\tpack.changes.emplace_back(obstacle->uniqueID, BattleChanges::EOperation::REMOVE);\n\t\tserializable->toInfo(pack.changes.back(), BattleChanges::EOperation::REMOVE);\n\t}\n\n\tif(!pack.changes.empty())\n\t\tserver->apply(&pack);\n}",
        "parsed_output": "void processObstacleChanges(undefined8 param_1, long *param_2, long *param_3, undefined8 param_4) {\n    undefined4 uVar1;\n    long *plVar2;\n    JsonNode *pJVar3;\n    CObstacleInstance *this;\n    undefined local_d1;\n    undefined auStack_d0[8];\n    _Rb_tree_node_base a_Stack_c8[8];\n    undefined8 local_c0;\n    _Rb_tree_node_base *local_b8;\n    undefined **local_a0;\n    undefined8 uStack_98;\n    undefined8 local_90;\n    undefined4 local_88;\n    JsonNode *local_80;\n    JsonNode *local_78;\n    JsonNode *local_70;\n    long local_68;\n    \n    local_88 = 0xffffffff;\n    local_68 = ___stack_chk_guard;\n    local_a0 = &PTR_FUN_007f7050;\n    uStack_98 = 0;\n    local_90 = 0;\n    local_80 = (JsonNode *)0x0;\n    local_78 = (JsonNode *)0x0;\n    local_70 = (JsonNode *)0x0;\n    \n    if (*(code **)(*param_3 + 0x148) == spells::BaseMechanics::battle) {\n        plVar2 = (long *)param_3[10];\n    } else {\n        plVar2 = (long *)(**(code **)(*param_3 + 0x148))(param_3);\n    }\n    \n    plVar2 = (long *)(**(code **)(*(long *)((long)plVar2 + *(long *)(*plVar2 + -0x98)) + 0x18))((long)plVar2 + *(long *)(*plVar2 + -0x98));\n    \n    if (*(code **)(*plVar2 + 0x18) == BattleInfo::getBattleID) {\n        local_88 = *(undefined4 *)(plVar2 + 1);\n    } else {\n        local_88 = (**(code **)(*plVar2 + 0x18))();\n    }\n    \n    FUN_0059c0f4(param_1, param_3, param_4, 0);\n    pJVar3 = local_78;\n    \n    while (local_78 = pJVar3, local_b8 != a_Stack_c8) {\n        local_d1 = 3;\n        this = *(CObstacleInstance **)(local_b8 + 0x20);\n        \n        if (pJVar3 == local_70) {\n            FUN_002d3b60(&local_80, pJVar3, this + 0xc, &local_d1);\n            pJVar3 = local_78 + -0x78;\n        } else {\n            uVar1 = *(undefined4 *)(this + 0xc);\n            JsonNode::JsonNode(pJVar3, 0);\n            pJVar3[0x70] = (JsonNode)0x3;\n            *(undefined4 *)(pJVar3 + 0x74) = uVar1;\n            pJVar3 = local_78;\n            local_78 = local_78 + 0x78;\n        }\n        \n        CObstacleInstance::toInfo(this, (ObstacleChanges *)pJVar3, 3);\n        local_b8 = (_Rb_tree_node_base *)std::_Rb_tree_increment(local_b8);\n        pJVar3 = local_78;\n    }\n    \n    FUN_002b8b20(auStack_d0, local_c0);\n    \n    if (local_80 != local_78) {\n        (**(code **)(*param_2 + 0x58))(param_2, &local_a0);\n    }\n    \n    FUN_002bf270(&local_a0);\n    \n    if (local_68 - ___stack_chk_guard == 0) {\n        return;\n    }\n    \n    __stack_chk_fail(&__stack_chk_guard, 0, local_68 - ___stack_chk_guard);\n}",
        "baseline_code_stripped": "void FUN_005a0ee0(undefined8 param_1,long *param_2,long *param_3,undefined8 param_4)\n{\n  undefined4 uVar1;\n  long *plVar2;\n  JsonNode *pJVar3;\n  CObstacleInstance *this;\n  undefined local_d1;\n  undefined auStack_d0 [8];\n  _Rb_tree_node_base a_Stack_c8 [8];\n  undefined8 local_c0;\n  _Rb_tree_node_base *local_b8;\n  undefined **local_a0;\n  undefined8 uStack_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  JsonNode *local_80;\n  JsonNode *local_78;\n  JsonNode *local_70;\n  long local_68;\n  local_88 = 0xffffffff;\n  local_68 = ___stack_chk_guard;\n  local_a0 = &PTR_FUN_007f7050;\n  uStack_98 = 0;\n  local_90 = 0;\n  local_80 = (JsonNode *)0x0;\n  local_78 = (JsonNode *)0x0;\n  local_70 = (JsonNode *)0x0;\n  if (*(code **)(*param_3 + 0x148) == spells::BaseMechanics::battle) {\n    plVar2 = (long *)param_3[10];\n  }\n  else {\n    plVar2 = (long *)(**(code **)(*param_3 + 0x148))(param_3);\n  }\n  plVar2 = (long *)(**(code **)(*(long *)((long)plVar2 + *(long *)(*plVar2 + -0x98)) + 0x18))\n                             ((long)plVar2 + *(long *)(*plVar2 + -0x98));\n  if (*(code **)(*plVar2 + 0x18) == BattleInfo::getBattleID) {\n    local_88 = *(undefined4 *)(plVar2 + 1);\n  }\n  else {\n    local_88 = (**(code **)(*plVar2 + 0x18))();\n  }\n  FUN_0059c0f4(param_1,param_3,param_4,0);\n  pJVar3 = local_78;\n  while (local_78 = pJVar3, local_b8 != a_Stack_c8) {\n    local_d1 = 3;\n    this = *(CObstacleInstance **)(local_b8 + 0x20);\n    if (pJVar3 == local_70) {\n      FUN_002d3b60(&local_80,pJVar3,this + 0xc,&local_d1);\n      pJVar3 = local_78 + -0x78;\n    }\n    else {\n      uVar1 = *(undefined4 *)(this + 0xc);\n      JsonNode::JsonNode(pJVar3,0);\n      pJVar3[0x70] = (JsonNode)0x3;\n      *(undefined4 *)(pJVar3 + 0x74) = uVar1;\n      pJVar3 = local_78;\n      local_78 = local_78 + 0x78;\n    }\n    CObstacleInstance::toInfo(this,(ObstacleChanges *)pJVar3,3);\n    local_b8 = (_Rb_tree_node_base *)std::_Rb_tree_increment(local_b8);\n    pJVar3 = local_78;\n  }\n  FUN_002b8b20(auStack_d0,local_c0);\n  if (local_80 != local_78) {\n    (**(code **)(*param_2 + 0x58))(param_2,&local_a0);\n  }\n  FUN_002bf270(&local_a0);\n  if (local_68 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_68 - ___stack_chk_guard);\n}",
        "similarity_score_unixcoder": 0.42862939834594727,
        "similarity_score_baseline_stripped": 0.3773499131202698
    },
    {
        "func_name": "sipQTransposeProxyModel::headerData",
        "normed_func_sha256": "558b272a016bf8d4cdce8dcd4e1fee402fbe8b8de5f2dbc1b95f26e7a679853c",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_000aeb40(int param_1,Orientation param_2,int param_3,undefined4 param_4,undefined4 param_5)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  int unaff_EDI;\n  int in_GS_OFFSET;\n  undefined4 uStack_20;\n  undefined auStack_1c [8];\n  undefined local_14 [4];\n  undefined4 local_10;\n  FUN_00089011();\n  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  iVar1 = (**(code **)(*(int *)((int)&fde_0024eb90 + unaff_EDI + 2) + 0x260))\n                    (local_14,param_2 + 0x25,param_2 + 8,0,unaff_EDI + 0x161867);\n  if (iVar1 == 0) {\n    QTransposeProxyModel::headerData(param_1,param_2,param_3);\n    puVar2 = &uStack_20;\n  }\n  else {\n    uStack_20 = param_5;\n    FUN_001d4e90(iVar1,param_3,param_4);\n    puVar2 = (undefined4 *)auStack_1c;\n  }\n  if (*(int *)((int)puVar2 + 0xc) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return param_1;\n  }\n  *(undefined **)((int)puVar2 + -4) = &UNK_000aebea;\n  FUN_001da030();\n}",
        "output": "int process_data(int data, Orientation orientation, int param3, undefined4 param4, undefined4 param5)\n{\n  int result;\n  undefined4 *ptr;\n  int unaff_EDI;\n  int gs_offset;\n  undefined4 uStack_20;\n  undefined stack_values[8];\n  undefined local_data[4];\n  undefined4 local_param;\n  \n  initialize_function();\n  local_param = *(undefined4 *)(gs_offset + 0x14);\n  result = (**(code **)(*(int *)((int)&fde_0024eb90 + unaff_EDI + 2) + 0x260))\n                    (local_data, orientation + 0x25, orientation + 8, 0, unaff_EDI + 0x161867);\n  \n  if (result == 0) {\n    QTransposeProxyModel::headerData(data, orientation, param3);\n    ptr = &uStack_20;\n  } else {\n    uStack_20 = param5;\n    process_data2(result, param3, param4);\n    ptr = (undefined4 *)stack_values;\n  }\n  \n  if (*(int *)((int)ptr + 0xc) == *(int *)(gs_offset + 0x14)) {\n    return data;\n  }\n  \n  *(undefined **)((int)ptr - 4) = &UNK_000aebea;\n  finalize_function();\n}",
        "source_code": "::QVariant sipQTransposeProxyModel::headerData(int a0, ::Qt::Orientation a1,int a2) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n#if SIP_ABI_MAJOR_VERSION >= 12 && SIP_ABI_MINOR_VERSION >= 8\n    sipMeth = sipIsPyMethod_12_8(&sipGILState, const_cast<char *>(&sipPyMethods[25]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_headerData);\n\n#else\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[25]), sipPySelf, SIP_NULLPTR, sipName_headerData);\n#endif\n\n    if (!sipMeth)\n        return  ::QTransposeProxyModel::headerData(a0,a1,a2);\n\n    extern  ::QVariant sipVH_QtCore_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int, ::Qt::Orientation,int);\n\n    return sipVH_QtCore_25(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0, a1, a2);\n}",
        "parsed_output": "int process_data(int data, Orientation orientation, int param3, undefined4 param4, undefined4 param5)\n{\n  int result;\n  undefined4 *ptr;\n  int unaff_EDI;\n  int gs_offset;\n  undefined4 uStack_20;\n  undefined stack_values[8];\n  undefined local_data[4];\n  undefined4 local_param;\n  \n  initialize_function();\n  local_param = *(undefined4 *)(gs_offset + 0x14);\n  result = (**(code **)(*(int *)((int)&fde_0024eb90 + unaff_EDI + 2) + 0x260))\n                    (local_data, orientation + 0x25, orientation + 8, 0, unaff_EDI + 0x161867);\n  \n  if (result == 0) {\n    QTransposeProxyModel::headerData(data, orientation, param3);\n    ptr = &uStack_20;\n  } else {\n    uStack_20 = param5;\n    process_data2(result, param3, param4);\n    ptr = (undefined4 *)stack_values;\n  }\n  \n  if (*(int *)((int)ptr + 0xc) == *(int *)(gs_offset + 0x14)) {\n    return data;\n  }\n  \n  *(undefined **)((int)ptr - 4) = &UNK_000aebea;\n  finalize_function();\n}",
        "baseline_code_stripped": "int FUN_000aeb40(int param_1,Orientation param_2,int param_3,undefined4 param_4,undefined4 param_5)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  int unaff_EDI;\n  int in_GS_OFFSET;\n  undefined4 uStack_20;\n  undefined auStack_1c [8];\n  undefined local_14 [4];\n  undefined4 local_10;\n  FUN_00089011();\n  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  iVar1 = (**(code **)(*(int *)((int)&fde_0024eb90 + unaff_EDI + 2) + 0x260))\n                    (local_14,param_2 + 0x25,param_2 + 8,0,unaff_EDI + 0x161867);\n  if (iVar1 == 0) {\n    QTransposeProxyModel::headerData(param_1,param_2,param_3);\n    puVar2 = &uStack_20;\n  }\n  else {\n    uStack_20 = param_5;\n    FUN_001d4e90(iVar1,param_3,param_4);\n    puVar2 = (undefined4 *)auStack_1c;\n  }\n  if (*(int *)((int)puVar2 + 0xc) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return param_1;\n  }\n  *(undefined **)((int)puVar2 + -4) = &UNK_000aebea;\n  FUN_001da030();\n}",
        "similarity_score_unixcoder": 0.6081013679504395,
        "similarity_score_baseline_stripped": 0.6006065607070923
    },
    {
        "func_name": "ServicePage::onCurrentServerChanged",
        "normed_func_sha256": "7a286658067c6031477184439dab50eec06e0f427fdf391692752e761748097e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall ServicePage::onCurrentServerChanged(ServicePage *this)\n{\n  QString *pQVar1;\n  code *pcVar2;\n  char cVar3;\n  int iVar4;\n  long *plVar5;\n  long in_FS_OFFSET;\n  QString local_68 [8];\n  QString local_60 [8];\n  Jid local_58 [8];\n  undefined8 local_50;\n  undefined8 *local_48;\n  long local_40;\n  local_50 = *(undefined8 *)(this + 0x70);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  *(undefined8 **)(this + 0x70) = &QListData::shared_null;\n  local_48 = &QListData::shared_null;\n  QList<Jid>::_QList((QList_Jid_ *)&local_50);\n  QList<Jid>::_QList((QList_Jid_ *)&local_48);\n  QComboBox::clear();\n  local_48 = &QArrayData::shared_null;\n  QLabel::setText(*(QString **)(this + 0x30));\n  QString::_QString((QString *)&local_48);\n  iVar4 = QComboBox::count();\n  if (0 < iVar4) {\n    iVar4 = QComboBox::count();\n    if (0 < iVar4) {\n      plVar5 = (long *)PluginHelper::pluginInstance_IServiceDiscovery_();\n      if (plVar5 != (long *)0x0) {\n        pcVar2 = *(code **)(*plVar5 + 0xd0);\n        local_48 = &QArrayData::shared_null;\n        serverJid();\n        Jid::Jid((Jid *)&local_50,local_60);\n        streamJid();\n        Jid::Jid(local_58,local_68);\n        cVar3 = (*pcVar2)(plVar5,local_58,&local_50,&local_48);\n        Jid::_Jid(local_58);\n        QString::_QString(local_68);\n        Jid::_Jid((Jid *)&local_50);\n        QString::_QString(local_60);\n        QString::_QString((QString *)&local_48);\n        if (cVar3 != '\\0') {\n          this[0x68] = (ServicePage)0x1;\n          pQVar1 = *(QString **)(this + 0x30);\n          QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae20);\n          QLabel::setText(pQVar1);\n          goto LAB_001d5fc8;\n        }\n      }\n      pQVar1 = *(QString **)(this + 0x30);\n      QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae48);\n      QLabel::setText(pQVar1);\n      goto LAB_001d5fc8;\n    }\n  }\n  pQVar1 = *(QString **)(this + 0x30);\n  QMetaObject::tr((char *)&local_48,staticMetaObject,0x20adf8);\n  QLabel::setText(pQVar1);\nLAB_001d5fc8:\n  QString::_QString((QString *)&local_48);\n  QWizardPage::completeChanged();\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "void __thiscall ServicePage::onCurrentServerChanged(ServicePage *this)\n{\n    QString *currentText;\n    code *pluginFunction;\n    char successFlag;\n    int count;\n    long *pluginInstance;\n    long stackGuard;\n    \n    long sharedNull = *(long *)(this + 0x70);\n    stackGuard = *(long *)(in_FS_OFFSET + 0x28);\n    \n    *(long *)(this + 0x70) = &QListData::shared_null;\n    QList<Jid>::_QList((QList_Jid_ *)&sharedNull);\n    \n    QList<Jid>::_QList((QList_Jid_ *)&sharedNull);\n    QComboBox::clear();\n    \n    QLabel::setText(*(QString **)(this + 0x30));\n    QString::_QString((QString *)&sharedNull);\n    \n    count = QComboBox::count();\n    \n    if (count > 0) {\n        pluginInstance = (long *)PluginHelper::pluginInstance_IServiceDiscovery_();\n        \n        if (pluginInstance != (long *)0x0) {\n            pluginFunction = *(code **)(*pluginInstance + 0xd0);\n            sharedNull = &QArrayData::shared_null;\n            \n            serverJid();\n            Jid::Jid((Jid *)&sharedNull, local_60);\n            streamJid();\n            Jid::Jid(local_58, local_68);\n            \n            successFlag = (*pluginFunction)(pluginInstance, local_58, &sharedNull, &sharedNull);\n            \n            Jid::_Jid(local_58);\n            QString::_QString(local_68);\n            Jid::_Jid((Jid *)&sharedNull);\n            QString::_QString(local_60);\n            QString::_QString((QString *)&sharedNull);\n            \n            if (successFlag != '\\0') {\n                this[0x68] = (ServicePage)0x1;\n                currentText = *(QString **)(this + 0x30);\n                QMetaObject::tr((char *)&sharedNull, staticMetaObject, 0x20ae20);\n                QLabel::setText(currentText);\n                goto LAB_001d5fc8;\n            }\n        }\n        \n        currentText = *(QString **)(this + 0x30);\n        QMetaObject::tr((char *)&sharedNull, staticMetaObject, 0x20ae48);\n        QLabel::setText(currentText);\n        goto LAB_001d5fc8;\n    }\n    \n    currentText = *(QString **)(this + 0x30);\n    QMetaObject::tr((char *)&sharedNull, staticMetaObject, 0x20adf8);\n    QLabel::setText(currentText);\n    \nLAB_001d5fc8:\n    QString::_QString((QString *)&sharedNull);\n    QWizardPage::completeChanged();\n    \n    if (stackGuard == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}",
        "source_code": "void ServicePage::onCurrentServerChanged()\r\n{\r\n\tFWaitInfo.clear();\r\n\tcmbService->clear();\r\n\tlblInfo->setText(QString::null);\r\n\r\n\tif (cmbAccount->count()>0 && cmbServer->count()>0)\r\n\t{\r\n\t\tIServiceDiscovery *discovery = PluginHelper::pluginInstance<IServiceDiscovery>();\r\n\t\tif (discovery && discovery->requestDiscoItems(streamJid(),serverJid()))\r\n\t\t{\r\n\t\t\tFWaitItems = true;\r\n\t\t\tlblInfo->setText(tr(\"Loading list of available services...\"));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlblInfo->setText(tr(\"Failed to load list of services\"));\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlblInfo->setText(tr(\"Account or server is not selected\"));\r\n\t}\r\n\r\n\temit completeChanged();\r\n}",
        "parsed_output": "void __thiscall ServicePage::onCurrentServerChanged(ServicePage *this)\n{\n    QString *currentText;\n    code *pluginFunction;\n    char successFlag;\n    int count;\n    long *pluginInstance;\n    long stackGuard;\n    \n    long sharedNull = *(long *)(this + 0x70);\n    stackGuard = *(long *)(in_FS_OFFSET + 0x28);\n    \n    *(long *)(this + 0x70) = &QListData::shared_null;\n    QList<Jid>::_QList((QList_Jid_ *)&sharedNull);\n    \n    QList<Jid>::_QList((QList_Jid_ *)&sharedNull);\n    QComboBox::clear();\n    \n    QLabel::setText(*(QString **)(this + 0x30));\n    QString::_QString((QString *)&sharedNull);\n    \n    count = QComboBox::count();\n    \n    if (count > 0) {\n        pluginInstance = (long *)PluginHelper::pluginInstance_IServiceDiscovery_();\n        \n        if (pluginInstance != (long *)0x0) {\n            pluginFunction = *(code **)(*pluginInstance + 0xd0);\n            sharedNull = &QArrayData::shared_null;\n            \n            serverJid();\n            Jid::Jid((Jid *)&sharedNull, local_60);\n            streamJid();\n            Jid::Jid(local_58, local_68);\n            \n            successFlag = (*pluginFunction)(pluginInstance, local_58, &sharedNull, &sharedNull);\n            \n            Jid::_Jid(local_58);\n            QString::_QString(local_68);\n            Jid::_Jid((Jid *)&sharedNull);\n            QString::_QString(local_60);\n            QString::_QString((QString *)&sharedNull);\n            \n            if (successFlag != '\\0') {\n                this[0x68] = (ServicePage)0x1;\n                currentText = *(QString **)(this + 0x30);\n                QMetaObject::tr((char *)&sharedNull, staticMetaObject, 0x20ae20);\n                QLabel::setText(currentText);\n                goto LAB_001d5fc8;\n            }\n        }\n        \n        currentText = *(QString **)(this + 0x30);\n        QMetaObject::tr((char *)&sharedNull, staticMetaObject, 0x20ae48);\n        QLabel::setText(currentText);\n        goto LAB_001d5fc8;\n    }\n    \n    currentText = *(QString **)(this + 0x30);\n    QMetaObject::tr((char *)&sharedNull, staticMetaObject, 0x20adf8);\n    QLabel::setText(currentText);\n    \nLAB_001d5fc8:\n    QString::_QString((QString *)&sharedNull);\n    QWizardPage::completeChanged();\n    \n    if (stackGuard == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n    }\n    \n    __stack_chk_fail();\n}",
        "baseline_code_stripped": "void __thiscall ServicePage::onCurrentServerChanged(ServicePage *this)\n{\n  QString *pQVar1;\n  code *pcVar2;\n  char cVar3;\n  int iVar4;\n  long *plVar5;\n  long in_FS_OFFSET;\n  QString local_68 [8];\n  QString local_60 [8];\n  Jid local_58 [8];\n  undefined8 local_50;\n  undefined8 *local_48;\n  long local_40;\n  local_50 = *(undefined8 *)(this + 0x70);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  *(undefined8 **)(this + 0x70) = &QListData::shared_null;\n  local_48 = &QListData::shared_null;\n  QList<Jid>::_QList((QList_Jid_ *)&local_50);\n  QList<Jid>::_QList((QList_Jid_ *)&local_48);\n  QComboBox::clear();\n  local_48 = &QArrayData::shared_null;\n  QLabel::setText(*(QString **)(this + 0x30));\n  QString::_QString((QString *)&local_48);\n  iVar4 = QComboBox::count();\n  if (0 < iVar4) {\n    iVar4 = QComboBox::count();\n    if (0 < iVar4) {\n      plVar5 = (long *)PluginHelper::pluginInstance_IServiceDiscovery_();\n      if (plVar5 != (long *)0x0) {\n        pcVar2 = *(code **)(*plVar5 + 0xd0);\n        local_48 = &QArrayData::shared_null;\n        serverJid();\n        Jid::Jid((Jid *)&local_50,local_60);\n        streamJid();\n        Jid::Jid(local_58,local_68);\n        cVar3 = (*pcVar2)(plVar5,local_58,&local_50,&local_48);\n        Jid::_Jid(local_58);\n        QString::_QString(local_68);\n        Jid::_Jid((Jid *)&local_50);\n        QString::_QString(local_60);\n        QString::_QString((QString *)&local_48);\n        if (cVar3 != '\\0') {\n          this[0x68] = (ServicePage)0x1;\n          pQVar1 = *(QString **)(this + 0x30);\n          QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae20);\n          QLabel::setText(pQVar1);\n          goto LAB_001d5fc8;\n        }\n      }\n      pQVar1 = *(QString **)(this + 0x30);\n      QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae48);\n      QLabel::setText(pQVar1);\n      goto LAB_001d5fc8;\n    }\n  }\n  pQVar1 = *(QString **)(this + 0x30);\n  QMetaObject::tr((char *)&local_48,staticMetaObject,0x20adf8);\n  QLabel::setText(pQVar1);\nLAB_001d5fc8:\n  QString::_QString((QString *)&local_48);\n  QWizardPage::completeChanged();\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.6427496671676636,
        "similarity_score_baseline_stripped": 0.6262897849082947
    },
    {
        "func_name": "botlink_resolve_success",
        "normed_func_sha256": "515d28efdd2e4c7a363a30b26e9ac714b550cba85844ae7e085d90156e2bc1ad",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_10011df0(int param_1)\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined4 uVar5;\n  char *__src;\n  iVar1 = param_1 * 0x188;\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc + 0x184);\n  uVar5 = *(undefined4 *)(iVar3 + 0x18);\n  *(undefined4 *)(iVar1 + _DAT_10077ffc + 4) = *(undefined4 *)(iVar3 + 0x14);\n  __src = *(char **)(iVar3 + 0x10);\n  FUN_10027460(param_1,&PTR_s_FORK_BOT_10075e48,0x9c);\n  iVar3 = iVar1 + _DAT_10077ffc;\n  *(undefined4 *)(iVar3 + 0x17c) = _DAT_100780c4;\n  strcpy((char *)(*(int *)(iVar3 + 0x184) + 0x79),__src);\n  iVar3 = _DAT_10077ffc;\n  iVar2 = iVar1 + _DAT_10077ffc;\n  puVar4 = *(undefined4 **)(iVar2 + 0x184);\n  puVar4[2] = 0x76652062;\n  puVar4[3] = 0x6f742900;\n  puVar4[1] = 0x6d697469;\n  *puVar4 = 0x28707269;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x90) = uVar5;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x94) = *(undefined4 *)(iVar2 + 8);\n  uVar5 = FUN_10039320(0x20);\n  *(undefined4 *)(iVar1 + iVar3) = uVar5;\n  FUN_100319f0(__src,\"botnet.c\",0x42b);\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc);\n  if (-1 < iVar3) {\n    uVar5 = FUN_10038c20(*(undefined4 *)(iVar1 + _DAT_10077ffc + 4));\n    iVar1 = FUN_1003a5d0(iVar3,uVar5,*(undefined4 *)(iVar1 + _DAT_10077ffc + 8));\n    if (-1 < iVar1) {\n      return;\n    }\n  }\n  FUN_10024db0(param_1);\n  return;\n}",
        "output": "```c\nvoid process_data(int param_1)\n{\n    int offset = param_1 * 0x188;\n    int data_offset = *(int *)(offset + _DAT_10077ffc + 0x184);\n    undefined4 uVar5 = *(undefined4 *)(data_offset + 0x18);\n    \n    *(undefined4 *)(offset + _DAT_10077ffc + 4) = *(undefined4 *)(data_offset + 0x14);\n    \n    char *source = *(char **)(data_offset + 0x10);\n    \n    process_function(param_1, &PTR_s_FORK_BOT_10075e48, 0x9c);\n    \n    *(undefined4 *)(offset + 0x17c + _DAT_10077ffc) = _DAT_100780c4;\n    \n    strcpy((char *)(*(int *)(offset + 0x184 + _DAT_10077ffc) + 0x79), source);\n    \n    int data_address = offset + _DAT_10077ffc;\n    undefined4 *data_ptr = *(undefined4 **)(data_address + 0x184);\n    \n    data_ptr[2] = 0x76652062;\n    data_ptr[3] = 0x6f742900;\n    data_ptr[1] = 0x6d697469;\n    *data_ptr = 0x28707269;\n    \n    *(undefined4 *)(*(int *)(data_address + 0x184) + 0x90) = uVar5;\n    *(undefined4 *)(*(int *)(data_address + 0x184) + 0x94) = *(undefined4 *)(data_address + 8);\n    \n    uVar5 = process_data_function(0x20);\n    \n    *(undefined4 *)(offset + _DAT_10077ffc) = uVar5;\n    \n    process_function(source, \"botnet.c\", 0x42b);\n    \n    int data_value = *(int *)(offset + _DAT_10077ffc);\n    \n    if (data_value >= 0) {\n        uVar5 = process_data_function(*(undefined4 *)(offset + _DAT_10077ffc + 4));\n        int result = process_final_data(data_value, uVar5, *(undefined4 *)(offset + _DAT_10077ffc + 8));\n        \n        if (result >= 0) {\n            return;\n        }\n    }\n    \n    process_final_function(param_1);\n    return;\n}\n```",
        "source_code": "static void botlink_resolve_success(int i)\n{\n  int idx = dcc[i].u.dns->ibuf;\n  char *linker = dcc[i].u.dns->cptr;\n\n  dcc[i].addr = dcc[i].u.dns->ip;\n  changeover_dcc(i, &DCC_FORK_BOT, sizeof(struct bot_info));\n  dcc[i].timeval = now;\n  strcpy(dcc[i].u.bot->linker, linker);\n  strcpy(dcc[i].u.bot->version, \"(primitive bot)\");\n  dcc[i].u.bot->numver = idx;\n  dcc[i].u.bot->port = dcc[i].port;     /* Remember where i started */\n  dcc[i].sock = getsock(SOCK_STRONGCONN);\n  nfree(linker);\n  if (dcc[i].sock < 0 ||\n      open_telnet_raw(dcc[i].sock, iptostr(htonl(dcc[i].addr)),\n                      dcc[i].port) < 0)\n    failed_link(i);\n}",
        "parsed_output": "void process_data(int param_1)\n{\n    int offset = param_1 * 0x188;\n    int data_offset = *(int *)(offset + _DAT_10077ffc + 0x184);\n    undefined4 uVar5 = *(undefined4 *)(data_offset + 0x18);\n    \n    *(undefined4 *)(offset + _DAT_10077ffc + 4) = *(undefined4 *)(data_offset + 0x14);\n    \n    char *source = *(char **)(data_offset + 0x10);\n    \n    process_function(param_1, &PTR_s_FORK_BOT_10075e48, 0x9c);\n    \n    *(undefined4 *)(offset + 0x17c + _DAT_10077ffc) = _DAT_100780c4;\n    \n    strcpy((char *)(*(int *)(offset + 0x184 + _DAT_10077ffc) + 0x79), source);\n    \n    int data_address = offset + _DAT_10077ffc;\n    undefined4 *data_ptr = *(undefined4 **)(data_address + 0x184);\n    \n    data_ptr[2] = 0x76652062;\n    data_ptr[3] = 0x6f742900;\n    data_ptr[1] = 0x6d697469;\n    *data_ptr = 0x28707269;\n    \n    *(undefined4 *)(*(int *)(data_address + 0x184) + 0x90) = uVar5;\n    *(undefined4 *)(*(int *)(data_address + 0x184) + 0x94) = *(undefined4 *)(data_address + 8);\n    \n    uVar5 = process_data_function(0x20);\n    \n    *(undefined4 *)(offset + _DAT_10077ffc) = uVar5;\n    \n    process_function(source, \"botnet.c\", 0x42b);\n    \n    int data_value = *(int *)(offset + _DAT_10077ffc);\n    \n    if (data_value >= 0) {\n        uVar5 = process_data_function(*(undefined4 *)(offset + _DAT_10077ffc + 4));\n        int result = process_final_data(data_value, uVar5, *(undefined4 *)(offset + _DAT_10077ffc + 8));\n        \n        if (result >= 0) {\n            return;\n        }\n    }\n    \n    process_final_function(param_1);\n    return;\n}",
        "baseline_code_stripped": "void FUN_10011df0(int param_1)\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined4 uVar5;\n  char *__src;\n  iVar1 = param_1 * 0x188;\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc + 0x184);\n  uVar5 = *(undefined4 *)(iVar3 + 0x18);\n  *(undefined4 *)(iVar1 + _DAT_10077ffc + 4) = *(undefined4 *)(iVar3 + 0x14);\n  __src = *(char **)(iVar3 + 0x10);\n  FUN_10027460(param_1,&PTR_s_FORK_BOT_10075e48,0x9c);\n  iVar3 = iVar1 + _DAT_10077ffc;\n  *(undefined4 *)(iVar3 + 0x17c) = _DAT_100780c4;\n  strcpy((char *)(*(int *)(iVar3 + 0x184) + 0x79),__src);\n  iVar3 = _DAT_10077ffc;\n  iVar2 = iVar1 + _DAT_10077ffc;\n  puVar4 = *(undefined4 **)(iVar2 + 0x184);\n  puVar4[2] = 0x76652062;\n  puVar4[3] = 0x6f742900;\n  puVar4[1] = 0x6d697469;\n  *puVar4 = 0x28707269;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x90) = uVar5;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x94) = *(undefined4 *)(iVar2 + 8);\n  uVar5 = FUN_10039320(0x20);\n  *(undefined4 *)(iVar1 + iVar3) = uVar5;\n  FUN_100319f0(__src,\"botnet.c\",0x42b);\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc);\n  if (-1 < iVar3) {\n    uVar5 = FUN_10038c20(*(undefined4 *)(iVar1 + _DAT_10077ffc + 4));\n    iVar1 = FUN_1003a5d0(iVar3,uVar5,*(undefined4 *)(iVar1 + _DAT_10077ffc + 8));\n    if (-1 < iVar1) {\n      return;\n    }\n  }\n  FUN_10024db0(param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.45700603723526,
        "similarity_score_baseline_stripped": 0.4765426218509674
    },
    {
        "func_name": "truncate64",
        "normed_func_sha256": "ef59824173e1837ee91fe70d42957dccc71cf4f253c65ae334e63dda8115f708",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint truncate64(char *__file,__off64_t __length)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  uVar1 = (**(code **)(in_GS_OFFSET + 0x10))();\n  if (0xfffff000 < uVar1) {\n    *(uint *)((undefined *)0x8 + in_GS_OFFSET) = -uVar1;\n    uVar1 = 0xffffffff;\n  }\n  return uVar1;\n}",
        "output": "```c\nint truncate64(char *__file, __off64_t __length)\n{\n    uint uVar1;\n    int in_GS_OFFSET;\n\n    uVar1 = (**(code **)(in_GS_OFFSET + 0x10))();\n\n    if (uVar1 > 0xfffff000) {\n        *(uint *)((undefined *)0x8 + in_GS_OFFSET) = -uVar1;\n        uVar1 = 0xffffffff;\n    }\n\n    return uVar1;\n}\n```",
        "source_code": "int\ntruncate64 (const char *path, off64_t length)\n{\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n  if (! __have_no_truncate64)\n#endif\n    {\n      unsigned int low = length & 0xffffffff;\n      unsigned int high = length >> 32;\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n      int saved_errno = errno;\n#endif\n      int result = INLINE_SYSCALL (truncate64, 3, CHECK_STRING (path),\n\t\t\t\t   __LONG_LONG_PAIR (high, low));\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n      if (result != -1 || errno != ENOSYS)\n#endif\n\treturn result;\n\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n      __set_errno (saved_errno);\n      __have_no_truncate64 = 1;\n#endif\n    }\n\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n  if ((off_t) length != length)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  return __truncate (path, (off_t) length);\n#endif\n}",
        "parsed_output": "int truncate64(char *__file, __off64_t __length)\n{\n    uint uVar1;\n    int in_GS_OFFSET;\n\n    uVar1 = (**(code **)(in_GS_OFFSET + 0x10))();\n\n    if (uVar1 > 0xfffff000) {\n        *(uint *)((undefined *)0x8 + in_GS_OFFSET) = -uVar1;\n        uVar1 = 0xffffffff;\n    }\n\n    return uVar1;\n}",
        "baseline_code_stripped": "int truncate64(char *__file,__off64_t __length)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  uVar1 = (**(code **)(in_GS_OFFSET + 0x10))();\n  if (0xfffff000 < uVar1) {\n    *(uint *)((undefined *)0x8 + in_GS_OFFSET) = -uVar1;\n    uVar1 = 0xffffffff;\n  }\n  return uVar1;\n}",
        "similarity_score_unixcoder": 0.6573612093925476,
        "similarity_score_baseline_stripped": 0.6443058848381042
    },
    {
        "func_name": "ByteString_CreateFromInt32",
        "normed_func_sha256": "7d289aa6ea103094a0f31a150ef7fafefe5fa908bfa7516227bace0055418cd4",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nbinfilter * __thiscall\nbinfilter::ByteString_CreateFromInt32(binfilter *this,long param_1,short param_2)\n{\n  ushort uVar1;\n  int in_GS_OFFSET;\n  char local_31 [33];\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar1 = rtl_str_valueOfInt32(local_31,param_1,(int)param_2);\n  ByteString::ByteString((ByteString *)this,local_31,uVar1);\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return this;\n  }\n  FUN_0019b1f0();\n}",
        "output": "```c\nbinfilter * __thiscall\nbinfilter::ByteString_CreateFromInt32(binfilter *this, long param_1, short param_2)\n{\n    ushort uVar1;\n    int in_GS_OFFSET;\n    char local_31[33];\n    int local_10;\n\n    local_10 = *(int *)(in_GS_OFFSET + 0x14);\n    uVar1 = rtl_str_valueOfInt32(local_31, param_1, (int)param_2);\n    ByteString::ByteString((ByteString *)this, local_31, uVar1);\n\n    if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n        return this;\n    }\n    \n    FUN_0019b1f0();\n}\n```",
        "source_code": "ByteString ByteString_CreateFromInt32(sal_Int32 n, sal_Int16 nRadix)\n    {\n        sal_Char aBuf[RTL_STR_MAX_VALUEOFINT32];\n        BOOST_STATIC_ASSERT(RTL_STR_MAX_VALUEOFINT32 <= STRING_MAXLEN);\n        return ByteString(\n            aBuf,\n            static_cast< xub_StrLen >(rtl_str_valueOfInt32( aBuf, n, nRadix )) );\n    }",
        "parsed_output": "binfilter * __thiscall\nbinfilter::ByteString_CreateFromInt32(binfilter *this, long param_1, short param_2)\n{\n    ushort uVar1;\n    int in_GS_OFFSET;\n    char local_31[33];\n    int local_10;\n\n    local_10 = *(int *)(in_GS_OFFSET + 0x14);\n    uVar1 = rtl_str_valueOfInt32(local_31, param_1, (int)param_2);\n    ByteString::ByteString((ByteString *)this, local_31, uVar1);\n\n    if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n        return this;\n    }\n    \n    FUN_0019b1f0();\n}",
        "baseline_code_stripped": "binfilter * __thiscall\nbinfilter::ByteString_CreateFromInt32(binfilter *this,long param_1,short param_2)\n{\n  ushort uVar1;\n  int in_GS_OFFSET;\n  char local_31 [33];\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar1 = rtl_str_valueOfInt32(local_31,param_1,(int)param_2);\n  ByteString::ByteString((ByteString *)this,local_31,uVar1);\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return this;\n  }\n  FUN_0019b1f0();\n}",
        "similarity_score_unixcoder": 0.583957314491272,
        "similarity_score_baseline_stripped": 0.5975655913352966
    },
    {
        "func_name": "save_as_application_proceed",
        "normed_func_sha256": "f14a16a1ca5b344a98cdf047dc65aaa0e72eec918d30dd77d74214e31d86ccfc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_001b07d8(longlong param_1)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 in_r8;\n  longlong in_r13;\n  longlong local_88;\n  longlong local_40;\n  longlong local_38;\n  local_38 = *(longlong *)(in_r13 + -0x7010);\n  local_40 = 0;\n  iVar1 = FUN_00148400(*(undefined8 *)(param_1 + 0x30),*(undefined8 *)(param_1 + 0x10),\n                       *(undefined8 *)(param_1 + 0x38),*(undefined4 *)(param_1 + 0x68),&local_40,\n                       in_r8,0,0);\n  if (iVar1 == 0) {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d48,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(local_40 + 8));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n  }\n  else {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d78,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n    uVar4 = FUN_00152220(0,local_88 + -0x47d10,5);\n    FUN_00143f80(uVar3,uVar4,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30)\n                );\n    FUN_001452c0(uVar3,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30));\n    uVar4 = FUN_00149ec0(*(undefined8 *)(param_1 + 0x30));\n    FUN_0014d740(2,0,local_88 + -0xa76b0,uVar4);\n    FUN_00144ac0(0);\n  }\n  FUN_001459a0(uVar3,1);\n  uVar4 = FUN_001479c0();\n  FUN_001508a0(uVar4,*(undefined8 *)(param_1 + 0x28),uVar3);\n  FUN_001b06a8(param_1);\n  if (local_40 != 0) {\n    FUN_00151b40();\n  }\n  FUN_00144ac0(uVar2);\n  if (local_38 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  FUN_0014f3a0();\n}",
        "output": "void process_data(longlong param_1)\n{\n    longlong local_38 = *(longlong *)(in_r13 + -0x7010);\n    longlong local_40 = 0;\n    \n    int result = process_data_helper(*(undefined8 *)(param_1 + 0x30), *(undefined8 *)(param_1 + 0x10),\n                                     *(undefined8 *)(param_1 + 0x38), *(undefined4 *)(param_1 + 0x68), &local_40,\n                                     in_r8, 0, 0);\n    \n    if (result == 0) {\n        undefined8 uVar2 = FUN_00152220(0, local_88 + -0x47d48, 5);\n        uVar2 = FUN_001536e0(uVar2, *(undefined8 *)(param_1 + 0x28), *(undefined8 *)(local_40 + 8));\n        undefined8 uVar3 = FUN_0014b9a0();\n        \n        if (*(longlong *)(param_1 + 0x58) != 0) {\n            FUN_0014d380();\n        }\n    } else {\n        undefined8 uVar2 = FUN_00152220(0, local_88 + -0x47d78, 5);\n        uVar2 = FUN_001536e0(uVar2, *(undefined8 *)(param_1 + 0x28));\n        undefined8 uVar3 = FUN_0014b9a0();\n        \n        if (*(longlong *)(param_1 + 0x58) != 0) {\n            FUN_0014d380();\n        }\n        \n        undefined8 uVar4 = FUN_00152220(0, local_88 + -0x47d10, 5);\n        FUN_00143f80(uVar3, uVar4, local_88 + -0x47d08, local_88 + -0x4bd08, *(undefined8 *)(param_1 + 0x30));\n        FUN_001452c0(uVar3, local_88 + -0x47d08, local_88 + -0x4bd08, *(undefined8 *)(param_1 + 0x30));\n        uVar4 = FUN_00149ec0(*(undefined8 *)(param_1 + 0x30));\n        FUN_0014d740(2, 0, local_88 + -0xa76b0, uVar4);\n        FUN_00144ac0(0);\n    }\n    \n    FUN_001459a0(uVar3, 1);\n    undefined8 uVar4 = FUN_001479c0();\n    FUN_001508a0(uVar4, *(undefined8 *)(param_1 + 0x28), uVar3);\n    FUN_001b06a8(param_1);\n    \n    if (local_40 != 0) {\n        FUN_00151b40();\n    }\n    \n    FUN_00144ac0(uVar2);\n    \n    if (local_38 == *(longlong *)(in_r13 + -0x7010)) {\n        return;\n    }\n    \n    FUN_0014f3a0();\n}",
        "source_code": "static void\nsave_as_application_proceed (EphyApplicationDialogData *data)\n{\n  g_autofree char *message = NULL;\n  GNotification *notification;\n  gboolean success;\n  g_autoptr (GError) error = NULL;\n\n  /* Create Web Application, including a new profile and .desktop file. */\n  success = ephy_web_application_create (data->app_id,\n                                         data->url,\n                                         data->token,\n                                         data->webapp_options,\n                                         &error);\n\n  if (success)\n    message = g_strdup_printf (_(\"The application \u201c%s\u201d is ready to be used\"),\n                               data->chosen_name);\n  else\n    message = g_strdup_printf (_(\"The application \u201c%s\u201d could not be created: %s\"),\n                               data->chosen_name, error->message);\n\n  notification = g_notification_new (message);\n\n  if (data->framed_pixbuf)\n    g_notification_set_icon (notification, G_ICON (data->framed_pixbuf));\n\n  if (success) {\n    /* Translators: Desktop notification when a new web app is created. */\n    g_notification_add_button_with_target (notification, _(\"Launch\"), \"app.launch-app\", \"s\", data->app_id);\n    g_notification_set_default_action_and_target (notification, \"app.launch-app\", \"s\", data->app_id);\n\n    ephy_focus_desktop_app (data->app_id);\n  }\n\n  g_notification_set_priority (notification, G_NOTIFICATION_PRIORITY_LOW);\n\n  g_application_send_notification (G_APPLICATION (g_application_get_default ()), data->chosen_name, notification);\n\n  ephy_application_dialog_data_free (data);\n}",
        "parsed_output": "void process_data(longlong param_1)\n{\n    longlong local_38 = *(longlong *)(in_r13 + -0x7010);\n    longlong local_40 = 0;\n    \n    int result = process_data_helper(*(undefined8 *)(param_1 + 0x30), *(undefined8 *)(param_1 + 0x10),\n                                     *(undefined8 *)(param_1 + 0x38), *(undefined4 *)(param_1 + 0x68), &local_40,\n                                     in_r8, 0, 0);\n    \n    if (result == 0) {\n        undefined8 uVar2 = FUN_00152220(0, local_88 + -0x47d48, 5);\n        uVar2 = FUN_001536e0(uVar2, *(undefined8 *)(param_1 + 0x28), *(undefined8 *)(local_40 + 8));\n        undefined8 uVar3 = FUN_0014b9a0();\n        \n        if (*(longlong *)(param_1 + 0x58) != 0) {\n            FUN_0014d380();\n        }\n    } else {\n        undefined8 uVar2 = FUN_00152220(0, local_88 + -0x47d78, 5);\n        uVar2 = FUN_001536e0(uVar2, *(undefined8 *)(param_1 + 0x28));\n        undefined8 uVar3 = FUN_0014b9a0();\n        \n        if (*(longlong *)(param_1 + 0x58) != 0) {\n            FUN_0014d380();\n        }\n        \n        undefined8 uVar4 = FUN_00152220(0, local_88 + -0x47d10, 5);\n        FUN_00143f80(uVar3, uVar4, local_88 + -0x47d08, local_88 + -0x4bd08, *(undefined8 *)(param_1 + 0x30));\n        FUN_001452c0(uVar3, local_88 + -0x47d08, local_88 + -0x4bd08, *(undefined8 *)(param_1 + 0x30));\n        uVar4 = FUN_00149ec0(*(undefined8 *)(param_1 + 0x30));\n        FUN_0014d740(2, 0, local_88 + -0xa76b0, uVar4);\n        FUN_00144ac0(0);\n    }\n    \n    FUN_001459a0(uVar3, 1);\n    undefined8 uVar4 = FUN_001479c0();\n    FUN_001508a0(uVar4, *(undefined8 *)(param_1 + 0x28), uVar3);\n    FUN_001b06a8(param_1);\n    \n    if (local_40 != 0) {\n        FUN_00151b40();\n    }\n    \n    FUN_00144ac0(uVar2);\n    \n    if (local_38 == *(longlong *)(in_r13 + -0x7010)) {\n        return;\n    }\n    \n    FUN_0014f3a0();\n}",
        "baseline_code_stripped": "void FUN_001b07d8(longlong param_1)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 in_r8;\n  longlong in_r13;\n  longlong local_88;\n  longlong local_40;\n  longlong local_38;\n  local_38 = *(longlong *)(in_r13 + -0x7010);\n  local_40 = 0;\n  iVar1 = FUN_00148400(*(undefined8 *)(param_1 + 0x30),*(undefined8 *)(param_1 + 0x10),\n                       *(undefined8 *)(param_1 + 0x38),*(undefined4 *)(param_1 + 0x68),&local_40,\n                       in_r8,0,0);\n  if (iVar1 == 0) {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d48,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(local_40 + 8));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n  }\n  else {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d78,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n    uVar4 = FUN_00152220(0,local_88 + -0x47d10,5);\n    FUN_00143f80(uVar3,uVar4,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30)\n                );\n    FUN_001452c0(uVar3,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30));\n    uVar4 = FUN_00149ec0(*(undefined8 *)(param_1 + 0x30));\n    FUN_0014d740(2,0,local_88 + -0xa76b0,uVar4);\n    FUN_00144ac0(0);\n  }\n  FUN_001459a0(uVar3,1);\n  uVar4 = FUN_001479c0();\n  FUN_001508a0(uVar4,*(undefined8 *)(param_1 + 0x28),uVar3);\n  FUN_001b06a8(param_1);\n  if (local_40 != 0) {\n    FUN_00151b40();\n  }\n  FUN_00144ac0(uVar2);\n  if (local_38 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  FUN_0014f3a0();\n}",
        "similarity_score_unixcoder": 0.41323742270469666,
        "similarity_score_baseline_stripped": 0.40226635336875916
    },
    {
        "func_name": "_wrap_meep_grid_volume_icenter",
        "normed_func_sha256": "5f2c1e968960a76781eb3f969cc9f4071c3bb34c2b8642b6058203432a8b905b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00058de0(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined local_48 [4];\n  undefined4 local_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  undefined4 uStack_38;\n  undefined4 local_34;\n  undefined4 uStack_30;\n  undefined4 local_2c;\n  undefined4 uStack_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 local_1c;\n  undefined4 uStack_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  iVar1 = FUN_0002aef4(param_1,local_48,DAT_000e6ce8,0);\n  if (iVar1 < 0) {\n    scm_wrong_type_arg(\"meep-grid-volume-icenter\",1,param_1);\n  }\n  meep::grid_volume::icenter();\n  local_44 = local_2c;\n  uStack_40 = uStack_28;\n  uStack_3c = uStack_24;\n  uStack_38 = uStack_20;\n  local_34 = local_1c;\n  uStack_30 = uStack_18;\n  puVar2 = (undefined4 *)operator_new(0x18);\n  local_44 = local_2c;\n  *puVar2 = local_2c;\n  puVar2[1] = uStack_40;\n  puVar2[2] = uStack_3c;\n  puVar2[3] = uStack_38;\n  puVar2[4] = local_34;\n  puVar2[5] = uStack_30;\n  FUN_0002b164(puVar2,DAT_000e6d00,1);\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "void FUN_00058de0(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined local_48 [4];\n  undefined4 local_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  undefined4 uStack_38;\n  undefined4 local_34;\n  undefined4 uStack_30;\n  undefined4 local_2c;\n  undefined4 uStack_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 local_1c;\n  undefined4 uStack_18;\n  int local_14;\n  \n  local_14 = __stack_chk_guard;\n  iVar1 = FUN_0002aef4(param_1, local_48, DAT_000e6ce8, 0);\n  \n  if (iVar1 < 0) {\n    scm_wrong_type_arg(\"meep-grid-volume-icenter\", 1, param_1);\n  }\n  \n  meep::grid_volume::icenter();\n  \n  local_44 = local_2c;\n  uStack_40 = uStack_28;\n  uStack_3c = uStack_24;\n  uStack_38 = uStack_20;\n  local_34 = local_1c;\n  uStack_30 = uStack_18;\n  \n  puVar2 = (undefined4 *)operator_new(0x18);\n  \n  local_44 = local_2c;\n  *puVar2 = local_2c;\n  puVar2[1] = uStack_40;\n  puVar2[2] = uStack_3c;\n  puVar2[3] = uStack_38;\n  puVar2[4] = local_34;\n  puVar2[5] = uStack_30;\n  \n  FUN_0002b164(puVar2, DAT_000e6d00, 1);\n  \n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  \n  __stack_chk_fail();\n}",
        "source_code": "static SCM\n_wrap_meep_grid_volume_icenter (SCM s_0)\n{\n#define FUNC_NAME \"meep-grid-volume-icenter\"\n  meep::grid_volume *arg1 = (meep::grid_volume *) 0 ;\n  SCM gswig_result;\n  SWIGUNUSED int gswig_list_p = 0;\n  meep::ivec result;\n  \n  {\n    arg1 = (meep::grid_volume *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_meep__grid_volume, 1, 0);\n  }\n  result = ((meep::grid_volume const *)arg1)->icenter();\n  {\n    meep::ivec * resultptr;\n    resultptr = new meep::ivec((const meep::ivec &) result);\n    gswig_result =  SWIG_NewPointerObj (resultptr, SWIGTYPE_p_meep__ivec, 1);\n  }\n  \n  \n  return gswig_result;\n#undef FUNC_NAME\n}",
        "parsed_output": "void FUN_00058de0(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined local_48 [4];\n  undefined4 local_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  undefined4 uStack_38;\n  undefined4 local_34;\n  undefined4 uStack_30;\n  undefined4 local_2c;\n  undefined4 uStack_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 local_1c;\n  undefined4 uStack_18;\n  int local_14;\n  \n  local_14 = __stack_chk_guard;\n  iVar1 = FUN_0002aef4(param_1, local_48, DAT_000e6ce8, 0);\n  \n  if (iVar1 < 0) {\n    scm_wrong_type_arg(\"meep-grid-volume-icenter\", 1, param_1);\n  }\n  \n  meep::grid_volume::icenter();\n  \n  local_44 = local_2c;\n  uStack_40 = uStack_28;\n  uStack_3c = uStack_24;\n  uStack_38 = uStack_20;\n  local_34 = local_1c;\n  uStack_30 = uStack_18;\n  \n  puVar2 = (undefined4 *)operator_new(0x18);\n  \n  local_44 = local_2c;\n  *puVar2 = local_2c;\n  puVar2[1] = uStack_40;\n  puVar2[2] = uStack_3c;\n  puVar2[3] = uStack_38;\n  puVar2[4] = local_34;\n  puVar2[5] = uStack_30;\n  \n  FUN_0002b164(puVar2, DAT_000e6d00, 1);\n  \n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  \n  __stack_chk_fail();\n}",
        "baseline_code_stripped": "void FUN_00058de0(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined local_48 [4];\n  undefined4 local_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  undefined4 uStack_38;\n  undefined4 local_34;\n  undefined4 uStack_30;\n  undefined4 local_2c;\n  undefined4 uStack_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 local_1c;\n  undefined4 uStack_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  iVar1 = FUN_0002aef4(param_1,local_48,DAT_000e6ce8,0);\n  if (iVar1 < 0) {\n    scm_wrong_type_arg(\"meep-grid-volume-icenter\",1,param_1);\n  }\n  meep::grid_volume::icenter();\n  local_44 = local_2c;\n  uStack_40 = uStack_28;\n  uStack_3c = uStack_24;\n  uStack_38 = uStack_20;\n  local_34 = local_1c;\n  uStack_30 = uStack_18;\n  puVar2 = (undefined4 *)operator_new(0x18);\n  local_44 = local_2c;\n  *puVar2 = local_2c;\n  puVar2[1] = uStack_40;\n  puVar2[2] = uStack_3c;\n  puVar2[3] = uStack_38;\n  puVar2[4] = local_34;\n  puVar2[5] = uStack_30;\n  FUN_0002b164(puVar2,DAT_000e6d00,1);\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.649197518825531,
        "similarity_score_baseline_stripped": 0.6443890929222107
    },
    {
        "func_name": "remoteDomainGetGuestInfo",
        "normed_func_sha256": "11ac12fba50d67b18e05e56afecdba6c7683af36674a47348feb748fc8fbad20",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4\nFUN_003f3652(long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,\n            undefined4 param_5)\n{\n  undefined8 uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  undefined4 local_54;\n  undefined4 local_48 [2];\n  undefined8 local_40;\n  undefined local_38 [32];\n  undefined4 local_18;\n  undefined4 local_14;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_54 = 0xffffffff;\n  uVar1 = *(undefined8 *)(*(long *)(param_1 + 0x18) + 0x88);\n  FUN_003ca6fa(uVar1);\n  FUN_003f3f4c(local_38,param_1);\n  local_18 = param_2;\n  local_14 = param_5;\n  memset(local_48,0,0x10);\n  iVar2 = FUN_003efead(*(undefined8 *)(param_1 + 0x18),uVar1,0,0x1a2,\n                       xdr_remote_domain_get_guest_info_args,local_38,\n                       xdr_remote_domain_get_guest_info_ret,local_48,param_4,param_3,param_5);\n  if (iVar2 != -1) {\n    iVar2 = virTypedParamsDeserialize(local_40,local_48[0],0x800,param_3,param_4);\n    if (-1 < iVar2) {\n      local_54 = 0;\n    }\n    xdr_free(xdr_remote_domain_get_guest_info_ret,(char *)local_48);\n  }\n  FUN_003ca71a(uVar1);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return local_54;\n}",
        "output": "```c\nint get_guest_info(long param_1, int param_2, long param_3, long param_4, int param_5) {\n    int result = -1;\n    long local_10;\n    local_10 = *(long *)(param_1 + 0x18);\n    int local_54 = -1;\n    long uVar1 = *(long *)(local_10 + 0x88);\n    FUN_003ca6fa(uVar1);\n    char local_38[32];\n    FUN_003f3f4c(local_38, param_1);\n    int local_18 = param_2;\n    int local_14 = param_5;\n    int local_48[2];\n    memset(local_48, 0, 0x10);\n    int iVar2 = FUN_003efead(local_10, uVar1, 0, 0x1a2, xdr_remote_domain_get_guest_info_args, local_38, xdr_remote_domain_get_guest_info_ret, local_48, param_4, param_3, param_5);\n    if (iVar2 != -1) {\n        iVar2 = virTypedParamsDeserialize(local_40, local_48[0], 0x800, param_3, param_4);\n        if (iVar2 >= 0) {\n            local_54 = 0;\n        }\n        xdr_free(xdr_remote_domain_get_guest_info_ret, (char *)local_48);\n    }\n    FUN_003ca71a(uVar1);\n    if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n    return local_54;\n}\n```",
        "source_code": "static int\nremoteDomainGetGuestInfo(virDomainPtr dom,\n                         unsigned int types,\n                         virTypedParameterPtr *params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    int rv = -1;\n    struct private_data *priv = dom->conn->privateData;\n    remote_domain_get_guest_info_args args;\n    remote_domain_get_guest_info_ret ret;\n\n    remoteDriverLock(priv);\n\n    make_nonnull_domain(&args.dom, dom);\n\n    args.types = types;\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n\n    if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_GET_GUEST_INFO,\n             (xdrproc_t)xdr_remote_domain_get_guest_info_args, (char *)&args,\n             (xdrproc_t)xdr_remote_domain_get_guest_info_ret, (char *)&ret) == -1)\n        goto done;\n\n    if (virTypedParamsDeserialize((struct _virTypedParameterRemote *) ret.params.params_val,\n                                  ret.params.params_len,\n                                  REMOTE_DOMAIN_GUEST_INFO_PARAMS_MAX,\n                                  params,\n                                  nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_remote_domain_get_guest_info_ret,\n             (char *) &ret);\n\n done:\n    remoteDriverUnlock(priv);\n    return rv;\n}",
        "parsed_output": "int get_guest_info(long param_1, int param_2, long param_3, long param_4, int param_5) {\n    int result = -1;\n    long local_10;\n    local_10 = *(long *)(param_1 + 0x18);\n    int local_54 = -1;\n    long uVar1 = *(long *)(local_10 + 0x88);\n    FUN_003ca6fa(uVar1);\n    char local_38[32];\n    FUN_003f3f4c(local_38, param_1);\n    int local_18 = param_2;\n    int local_14 = param_5;\n    int local_48[2];\n    memset(local_48, 0, 0x10);\n    int iVar2 = FUN_003efead(local_10, uVar1, 0, 0x1a2, xdr_remote_domain_get_guest_info_args, local_38, xdr_remote_domain_get_guest_info_ret, local_48, param_4, param_3, param_5);\n    if (iVar2 != -1) {\n        iVar2 = virTypedParamsDeserialize(local_40, local_48[0], 0x800, param_3, param_4);\n        if (iVar2 >= 0) {\n            local_54 = 0;\n        }\n        xdr_free(xdr_remote_domain_get_guest_info_ret, (char *)local_48);\n    }\n    FUN_003ca71a(uVar1);\n    if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n    }\n    return local_54;\n}",
        "baseline_code_stripped": "undefined4\nFUN_003f3652(long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,\n            undefined4 param_5)\n{\n  undefined8 uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  undefined4 local_54;\n  undefined4 local_48 [2];\n  undefined8 local_40;\n  undefined local_38 [32];\n  undefined4 local_18;\n  undefined4 local_14;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_54 = 0xffffffff;\n  uVar1 = *(undefined8 *)(*(long *)(param_1 + 0x18) + 0x88);\n  FUN_003ca6fa(uVar1);\n  FUN_003f3f4c(local_38,param_1);\n  local_18 = param_2;\n  local_14 = param_5;\n  memset(local_48,0,0x10);\n  iVar2 = FUN_003efead(*(undefined8 *)(param_1 + 0x18),uVar1,0,0x1a2,\n                       xdr_remote_domain_get_guest_info_args,local_38,\n                       xdr_remote_domain_get_guest_info_ret,local_48,param_4,param_3,param_5);\n  if (iVar2 != -1) {\n    iVar2 = virTypedParamsDeserialize(local_40,local_48[0],0x800,param_3,param_4);\n    if (-1 < iVar2) {\n      local_54 = 0;\n    }\n    xdr_free(xdr_remote_domain_get_guest_info_ret,(char *)local_48);\n  }\n  FUN_003ca71a(uVar1);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return local_54;\n}",
        "similarity_score_unixcoder": 0.7185488939285278,
        "similarity_score_baseline_stripped": 0.6256576776504517
    },
    {
        "func_name": "dino_entities_message_get_real_jid",
        "normed_func_sha256": "c6b9c1e0af59c12795773ec2273afdbaacf73d0a8b10047eab11045269403fc3",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 dino_entities_message_get_real_jid(int param_1)\n{\n  if (param_1 != 0) {\n    return *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x14);\n  }\n  g_return_if_fail_warning(\"libdino\",\"dino_entities_message_get_real_jid\",\"self != NULL\");\n  return 0;\n}",
        "output": "```c\nundefined4 dino_entities_message_get_real_jid(int param_1)\n{\n    if (param_1 != 0) {\n        return *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x14);\n    }\n    else {\n        g_return_if_fail_warning(\"libdino\", \"dino_entities_message_get_real_jid\", \"self != NULL\");\n        return 0;\n    }\n}\n```",
        "source_code": "XmppJid*\ndino_entities_message_get_real_jid (DinoEntitiesMessage* self)\n{\n\tXmppJid* result;\n\tXmppJid* _tmp0_;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\tg_return_val_if_fail (self != NULL, NULL);\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\t_tmp0_ = self->priv->_real_jid;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\tresult = _tmp0_;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\treturn result;\n#line 2816 \"message.c\"\n}",
        "parsed_output": "undefined4 dino_entities_message_get_real_jid(int param_1)\n{\n    if (param_1 != 0) {\n        return *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x14);\n    }\n    else {\n        g_return_if_fail_warning(\"libdino\", \"dino_entities_message_get_real_jid\", \"self != NULL\");\n        return 0;\n    }\n}",
        "baseline_code_stripped": "undefined4 dino_entities_message_get_real_jid(int param_1)\n{\n  if (param_1 != 0) {\n    return *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x14);\n  }\n  g_return_if_fail_warning(\"libdino\",\"dino_entities_message_get_real_jid\",\"self != NULL\");\n  return 0;\n}",
        "similarity_score_unixcoder": 0.684382438659668,
        "similarity_score_baseline_stripped": 0.7007763981819153
    },
    {
        "func_name": "sipQgsLayoutView::showEvent",
        "normed_func_sha256": "1a6bc7810dbed627cc7cf033d7c2b28cc099ff9edde8c0816daeccba084dfb7b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_004dc6c4(int *param_1)\n{\n  undefined4 uVar1;\n  uVar1 = PyEval_SaveThread();\n  if (param_1 != (int *)0x0) {\n    (**(code **)(*param_1 + 4))(param_1);\n  }\n  PyEval_RestoreThread(uVar1);\n  return;\n}",
        "output": "```c\nvoid execute_function(int *function_pointer)\n{\n    undefined4 thread_state;\n    thread_state = PyEval_SaveThread();\n    \n    if (function_pointer != (int *)0x0) {\n        (**(code **)(*function_pointer + 4))(function_pointer);\n    }\n    \n    PyEval_RestoreThread(thread_state);\n    return;\n}\n```",
        "source_code": "void sipQgsLayoutView::showEvent( ::QShowEvent*a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[13],sipPySelf,NULL,sipName_showEvent);\n\n    if (!sipMeth)\n    {\n         ::QgsLayoutView::showEvent(a0);\n        return;\n    }\n\n    extern void sipVH__gui_30(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QShowEvent*);\n\n    sipVH__gui_30(sipGILState, sipImportedVirtErrorHandlers__gui_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);\n}",
        "parsed_output": "void execute_function(int *function_pointer)\n{\n    undefined4 thread_state;\n    thread_state = PyEval_SaveThread();\n    \n    if (function_pointer != (int *)0x0) {\n        (**(code **)(*function_pointer + 4))(function_pointer);\n    }\n    \n    PyEval_RestoreThread(thread_state);\n    return;\n}",
        "baseline_code_stripped": "void FUN_004dc6c4(int *param_1)\n{\n  undefined4 uVar1;\n  uVar1 = PyEval_SaveThread();\n  if (param_1 != (int *)0x0) {\n    (**(code **)(*param_1 + 4))(param_1);\n  }\n  PyEval_RestoreThread(uVar1);\n  return;\n}",
        "similarity_score_unixcoder": 0.4651567041873932,
        "similarity_score_baseline_stripped": 0.4899625778198242
    },
    {
        "func_name": "_wrap_ephy_password_manager_add_password",
        "normed_func_sha256": "21440c1d75f502c6675c600c42168ee588884369e11133af9cf9f1a84c0e0961",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined1 * FUN_004ca070(long param_1,undefined8 param_2,undefined8 param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined1 *puVar6;\n  long local_18;\n  iVar3 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"O:EphyPasswordManager.add_password\",&PTR_s_info_00620a90,\n                     &local_18);\n  puVar6 = (undefined1 *)0x0;\n  if (iVar3 != 0) {\n    if (((*(long *)(local_18 + 8) == *(long *)(_PyGObject_API + 0x80)) ||\n        (iVar3 = PyType_IsSubtype(), iVar3 != 0)) &&\n       (lVar1 = *(long *)(local_18 + 0x18), lVar4 = ephy_password_info_get_type(), lVar1 == lVar4))\n    {\n      uVar2 = *(undefined8 *)(local_18 + 0x10);\n      uVar5 = ephy_password_manager_get_type();\n      uVar5 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 0x10),uVar5);\n      ephy_password_manager_add_password(uVar5,uVar2);\n      _Py_NoneStruct._0_4_ = _Py_NoneStruct._0_4_ + 1;\n      puVar6 = _Py_NoneStruct;\n    }\n    else {\n      PyErr_SetString(PyExc_TypeError,\"info should be a EphyPasswordInfo\");\n      puVar6 = (undefined1 *)0x0;\n    }\n  }\n  return puVar6;\n}",
        "output": "```c\nundefined1 *add_password_to_manager(long param_1, undefined8 param_2, undefined8 param_3)\n{\n    long lVar1;\n    undefined8 uVar2;\n    int iVar3;\n    long lVar4;\n    undefined8 uVar5;\n    undefined1 *puVar6;\n    long local_18;\n    \n    iVar3 = PyArg_ParseTupleAndKeywords(param_2, param_3, \"O:EphyPasswordManager.add_password\", &PTR_s_info_00620a90, &local_18);\n    puVar6 = (undefined1 *)0x0;\n    \n    if (iVar3 != 0) {\n        if (((*(long *)(local_18 + 8) == *(long *)(_PyGObject_API + 0x80)) || (iVar3 = PyType_IsSubtype(), iVar3 != 0) &&\n            (lVar1 = *(long *)(local_18 + 0x18), lVar4 = ephy_password_info_get_type(), lVar1 == lVar4)) {\n            uVar2 = *(undefined8 *)(local_18 + 0x10);\n            uVar5 = ephy_password_manager_get_type();\n            uVar5 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 0x10), uVar5);\n            ephy_password_manager_add_password(uVar5, uVar2);\n            _Py_NoneStruct._0_4_ = _Py_NoneStruct._0_4_ + 1;\n            puVar6 = _Py_NoneStruct;\n        } else {\n            PyErr_SetString(PyExc_TypeError, \"info should be a EphyPasswordInfo\");\n            puVar6 = (undefined1 *)0x0;\n        }\n    }\n    \n    return puVar6;\n}\n```",
        "source_code": "static PyObject *\n_wrap_ephy_password_manager_add_password(PyGObject *self, PyObject *args, PyObject *kwargs)\n{\n    static char *kwlist[] = { \"info\", NULL };\n    PyObject *py_info;\n    EphyPasswordInfo *info = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs, \"O:EphyPasswordManager.add_password\", kwlist, &py_info))\n        return NULL;\n    if (pyg_boxed_check(py_info, EPHY_TYPE_PASSWORD_INFO))\n        info = pyg_boxed_get(py_info, EphyPasswordInfo);\n    else {\n        PyErr_SetString(PyExc_TypeError, \"info should be a EphyPasswordInfo\");\n        return NULL;\n    }\n    ephy_password_manager_add_password(EPHY_PASSWORD_MANAGER(self->obj), info);\n    Py_INCREF(Py_None);\n    return Py_None;\n}",
        "parsed_output": "undefined1 *add_password_to_manager(long param_1, undefined8 param_2, undefined8 param_3)\n{\n    long lVar1;\n    undefined8 uVar2;\n    int iVar3;\n    long lVar4;\n    undefined8 uVar5;\n    undefined1 *puVar6;\n    long local_18;\n    \n    iVar3 = PyArg_ParseTupleAndKeywords(param_2, param_3, \"O:EphyPasswordManager.add_password\", &PTR_s_info_00620a90, &local_18);\n    puVar6 = (undefined1 *)0x0;\n    \n    if (iVar3 != 0) {\n        if (((*(long *)(local_18 + 8) == *(long *)(_PyGObject_API + 0x80)) || (iVar3 = PyType_IsSubtype(), iVar3 != 0) &&\n            (lVar1 = *(long *)(local_18 + 0x18), lVar4 = ephy_password_info_get_type(), lVar1 == lVar4)) {\n            uVar2 = *(undefined8 *)(local_18 + 0x10);\n            uVar5 = ephy_password_manager_get_type();\n            uVar5 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 0x10), uVar5);\n            ephy_password_manager_add_password(uVar5, uVar2);\n            _Py_NoneStruct._0_4_ = _Py_NoneStruct._0_4_ + 1;\n            puVar6 = _Py_NoneStruct;\n        } else {\n            PyErr_SetString(PyExc_TypeError, \"info should be a EphyPasswordInfo\");\n            puVar6 = (undefined1 *)0x0;\n        }\n    }\n    \n    return puVar6;\n}",
        "baseline_code_stripped": "undefined1 * FUN_004ca070(long param_1,undefined8 param_2,undefined8 param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined1 *puVar6;\n  long local_18;\n  iVar3 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"O:EphyPasswordManager.add_password\",&PTR_s_info_00620a90,\n                     &local_18);\n  puVar6 = (undefined1 *)0x0;\n  if (iVar3 != 0) {\n    if (((*(long *)(local_18 + 8) == *(long *)(_PyGObject_API + 0x80)) ||\n        (iVar3 = PyType_IsSubtype(), iVar3 != 0)) &&\n       (lVar1 = *(long *)(local_18 + 0x18), lVar4 = ephy_password_info_get_type(), lVar1 == lVar4))\n    {\n      uVar2 = *(undefined8 *)(local_18 + 0x10);\n      uVar5 = ephy_password_manager_get_type();\n      uVar5 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 0x10),uVar5);\n      ephy_password_manager_add_password(uVar5,uVar2);\n      _Py_NoneStruct._0_4_ = _Py_NoneStruct._0_4_ + 1;\n      puVar6 = _Py_NoneStruct;\n    }\n    else {\n      PyErr_SetString(PyExc_TypeError,\"info should be a EphyPasswordInfo\");\n      puVar6 = (undefined1 *)0x0;\n    }\n  }\n  return puVar6;\n}",
        "similarity_score_unixcoder": 0.7594155669212341,
        "similarity_score_baseline_stripped": 0.7029593586921692
    },
    {
        "func_name": "getGuard",
        "normed_func_sha256": "fa9da67e45a6fef8f712a6823fd4cf79fee510cdf38aecc82547cbe7e235f190",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar * getGuard(int param_1)\n{\n  undefined8 uVar1;\n  undefined4 in_ESI;\n  undefined4 in_register_0000003c;\n  char *pcVar2;\n  cString acStack_28 [24];\n  pcVar2 = (char *)CONCAT44(in_register_0000003c,param_1);\n  switch(in_ESI) {\n  case 0:\n    cString::sprintf(pcVar2,&DAT_0012d554);\n    break;\n  case 1:\n    cString::sprintf(pcVar2,&DAT_0012d559);\n    break;\n  case 2:\n    cString::sprintf(pcVar2,&DAT_0012d55e);\n    break;\n  case 3:\n    cString::sprintf(pcVar2,&DAT_0012d562);\n    break;\n  case 4:\n    uVar1 = I18nTranslate(\"Auto\",\"femon\");\n    cString::sprintf((char *)acStack_28,\"%s\",uVar1);\n    cString::_cString(acStack_28);\n  default:\n    cString::sprintf(pcVar2,&DAT_00128586);\n  }\n  return pcVar2;\n}",
        "output": "char * getGuard(int param_1)\n{\n    char *result;\n    char buffer[24];\n\n    switch(param_1) {\n        case 0:\n            sprintf(buffer, \"Guard Type 1\");\n            break;\n        case 1:\n            sprintf(buffer, \"Guard Type 2\");\n            break;\n        case 2:\n            sprintf(buffer, \"Guard Type 3\");\n            break;\n        case 3:\n            sprintf(buffer, \"Guard Type 4\");\n            break;\n        case 4:\n            result = I18nTranslate(\"Auto\", \"femon\");\n            sprintf(buffer, \"%s\", result);\n            _cString(buffer);\n            break;\n        default:\n            sprintf(buffer, \"Default Guard Type\");\n    }\n    \n    result = buffer;\n    return result;\n}",
        "source_code": "cString getGuard(int value)\n{\n  switch (value) {\n    case GUARD_INTERVAL_1_32: return cString::sprintf(\"1/32\");\n    case GUARD_INTERVAL_1_16: return cString::sprintf(\"1/16\");\n    case GUARD_INTERVAL_1_8:  return cString::sprintf(\"1/8\");\n    case GUARD_INTERVAL_1_4:  return cString::sprintf(\"1/4\");\n    case GUARD_INTERVAL_AUTO: cString::sprintf(\"%s\", tr(\"Auto\"));\n    }\n  return cString::sprintf(\"---\");\n}",
        "parsed_output": "char * getGuard(int param_1)\n{\n    char *result;\n    char buffer[24];\n\n    switch(param_1) {\n        case 0:\n            sprintf(buffer, \"Guard Type 1\");\n            break;\n        case 1:\n            sprintf(buffer, \"Guard Type 2\");\n            break;\n        case 2:\n            sprintf(buffer, \"Guard Type 3\");\n            break;\n        case 3:\n            sprintf(buffer, \"Guard Type 4\");\n            break;\n        case 4:\n            result = I18nTranslate(\"Auto\", \"femon\");\n            sprintf(buffer, \"%s\", result);\n            _cString(buffer);\n            break;\n        default:\n            sprintf(buffer, \"Default Guard Type\");\n    }\n    \n    result = buffer;\n    return result;\n}",
        "baseline_code_stripped": "char * getGuard(int param_1)\n{\n  undefined8 uVar1;\n  undefined4 in_ESI;\n  undefined4 in_register_0000003c;\n  char *pcVar2;\n  cString acStack_28 [24];\n  pcVar2 = (char *)CONCAT44(in_register_0000003c,param_1);\n  switch(in_ESI) {\n  case 0:\n    cString::sprintf(pcVar2,&DAT_0012d554);\n    break;\n  case 1:\n    cString::sprintf(pcVar2,&DAT_0012d559);\n    break;\n  case 2:\n    cString::sprintf(pcVar2,&DAT_0012d55e);\n    break;\n  case 3:\n    cString::sprintf(pcVar2,&DAT_0012d562);\n    break;\n  case 4:\n    uVar1 = I18nTranslate(\"Auto\",\"femon\");\n    cString::sprintf((char *)acStack_28,\"%s\",uVar1);\n    cString::_cString(acStack_28);\n  default:\n    cString::sprintf(pcVar2,&DAT_00128586);\n  }\n  return pcVar2;\n}",
        "similarity_score_unixcoder": 0.7335938215255737,
        "similarity_score_baseline_stripped": 0.5830280184745789
    },
    {
        "func_name": "_wrap_ColorShift_SetJsonValue",
        "normed_func_sha256": "cee1148d3ea61c3c3baf1ef9ea29a39f11cac582360540b57e55f906871652fd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_00058cd0(int param_1,undefined4 *param_2,undefined4 param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 extraout_ECX;\n  int in_GS_OFFSET;\n  undefined8 uVar5;\n  Value *local_54;\n  Value local_50 [24];\n  Value local_38 [24];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x58cdb;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar2 = Json::Value::Value(local_50,0);\n  if (param_1 != 1) {\n    rb_raise(_rb_eArgError,\"wrong # of arguments(%d for 1)\",param_1,uVar2);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(1,param_3,param_2,param_2);\n    if (iVar3 == -1) {\n      iVar3 = -5;\n    }\n    uVar4 = FUN_0003948e();\n    rb_raise(uVar4,&DAT_0013fdc3,uVar2,iVar3);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(2,*param_2,extraout_ECX,extraout_ECX);\n    uVar5 = FUN_0003948e();\n    rb_raise((int)uVar5,&DAT_0013fdc3,uVar2,(int)((ulonglong)uVar5 >> 0x20));\n  }\n  if (local_54 != (Value *)0x0) {\n    Json::Value::Value(local_38,local_54);\n    Json::Value::operator_(local_50,SUB41(local_38,0));\n    Json::Value::_Value(local_38);\n    pcVar1 = *(code **)(iRam00000000 + 0x24);\n    Json::Value::Value(local_38,local_50);\n    (*pcVar1)(0,local_38);\n    Json::Value::_Value(local_38);\n    Json::Value::_Value(local_50);\n    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n      return 4;\n    }\n    FUN_0013fce0();\n  }\n  uVar2 = FUN_000392b0(2,*param_2,0,0);\n  rb_raise(_rb_eArgError,&DAT_0013fdc3,uVar2);\n}",
        "output": "```c\nundefined4 FUN_00058cd0(int param_1, undefined4 *param_2, undefined4 param_3)\n{\n    code *pcVar1;\n    undefined4 uVar2;\n    int iVar3;\n    undefined4 uVar4;\n    undefined4 extraout_ECX;\n    int in_GS_OFFSET;\n    undefined8 uVar5;\n    Value *local_54;\n    Value local_50[24];\n    Value local_38[24];\n    int local_20;\n    undefined4 uStack_14;\n    \n    uStack_14 = 0x58cdb;\n    local_20 = *(int *)(in_GS_OFFSET + 0x14);\n    uVar2 = Json::Value::Value(local_50, 0);\n    \n    if (param_1 != 1) {\n        rb_raise(_rb_eArgError, \"wrong # of arguments(%d for 1)\", param_1, uVar2);\n    }\n    \n    iVar3 = FUN_0003e770(0, 0);\n    \n    if (iVar3 < 0) {\n        uVar2 = FUN_000392b0(1, param_3, param_2, param_2);\n        \n        if (iVar3 == -1) {\n            iVar3 = -5;\n        }\n        \n        uVar4 = FUN_0003948e();\n        rb_raise(uVar4, &DAT_0013fdc3, uVar2, iVar3);\n    }\n    \n    iVar3 = FUN_0003e770(0, 0);\n    \n    if (iVar3 < 0) {\n        uVar2 = FUN_000392b0(2, *param_2, extraout_ECX, extraout_ECX);\n        uVar5 = FUN_0003948e();\n        rb_raise((int)uVar5, &DAT_0013fdc3, uVar2, (int)((ulonglong)uVar5 >> 0x20));\n    }\n    \n    if (local_54 != (Value *)0x0) {\n        Json::Value::Value(local_38, local_54);\n        Json::Value::operator_(local_50, SUB41(local_38, 0));\n        Json::Value::_Value(local_38);\n        pcVar1 = *(code **)(iRam00000000 + 0x24);\n        Json::Value::Value(local_38, local_50);\n        (*pcVar1)(0, local_38);\n        Json::Value::_Value(local_38);\n        Json::Value::_Value(local_50);\n        \n        if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n            return 4;\n        }\n        \n        FUN_0013fce0();\n    }\n    \n    uVar2 = FUN_000392b0(2, *param_2, 0, 0);\n    rb_raise(_rb_eArgError, &DAT_0013fdc3, uVar2);\n}\n```",
        "source_code": "SWIGINTERN VALUE\n_wrap_ColorShift_SetJsonValue(int argc, VALUE *argv, VALUE self) {\n  openshot::ColorShift *arg1 = (openshot::ColorShift *) 0 ;\n  Json::Value arg2 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  void *argp2 ;\n  int res2 = 0 ;\n  \n  if ((argc < 1) || (argc > 1)) {\n    rb_raise(rb_eArgError, \"wrong # of arguments(%d for 1)\",argc); SWIG_fail;\n  }\n  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_openshot__ColorShift, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( \"\", \"openshot::ColorShift *\",\"SetJsonValue\", 1, self )); \n  }\n  arg1 = reinterpret_cast< openshot::ColorShift * >(argp1);\n  {\n    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_Json__Value,  0 );\n    if (!SWIG_IsOK(res2)) {\n      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( \"\", \"Json::Value const\",\"SetJsonValue\", 2, argv[0] )); \n    }  \n    if (!argp2) {\n      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError(\"invalid null reference \", \"Json::Value const\",\"SetJsonValue\", 2, argv[0]));\n    } else {\n      arg2 = *(reinterpret_cast< Json::Value * >(argp2));\n    }\n  }\n  (arg1)->SetJsonValue(arg2);\n  return Qnil;\nfail:\n  return Qnil;\n}",
        "parsed_output": "undefined4 FUN_00058cd0(int param_1, undefined4 *param_2, undefined4 param_3)\n{\n    code *pcVar1;\n    undefined4 uVar2;\n    int iVar3;\n    undefined4 uVar4;\n    undefined4 extraout_ECX;\n    int in_GS_OFFSET;\n    undefined8 uVar5;\n    Value *local_54;\n    Value local_50[24];\n    Value local_38[24];\n    int local_20;\n    undefined4 uStack_14;\n    \n    uStack_14 = 0x58cdb;\n    local_20 = *(int *)(in_GS_OFFSET + 0x14);\n    uVar2 = Json::Value::Value(local_50, 0);\n    \n    if (param_1 != 1) {\n        rb_raise(_rb_eArgError, \"wrong # of arguments(%d for 1)\", param_1, uVar2);\n    }\n    \n    iVar3 = FUN_0003e770(0, 0);\n    \n    if (iVar3 < 0) {\n        uVar2 = FUN_000392b0(1, param_3, param_2, param_2);\n        \n        if (iVar3 == -1) {\n            iVar3 = -5;\n        }\n        \n        uVar4 = FUN_0003948e();\n        rb_raise(uVar4, &DAT_0013fdc3, uVar2, iVar3);\n    }\n    \n    iVar3 = FUN_0003e770(0, 0);\n    \n    if (iVar3 < 0) {\n        uVar2 = FUN_000392b0(2, *param_2, extraout_ECX, extraout_ECX);\n        uVar5 = FUN_0003948e();\n        rb_raise((int)uVar5, &DAT_0013fdc3, uVar2, (int)((ulonglong)uVar5 >> 0x20));\n    }\n    \n    if (local_54 != (Value *)0x0) {\n        Json::Value::Value(local_38, local_54);\n        Json::Value::operator_(local_50, SUB41(local_38, 0));\n        Json::Value::_Value(local_38);\n        pcVar1 = *(code **)(iRam00000000 + 0x24);\n        Json::Value::Value(local_38, local_50);\n        (*pcVar1)(0, local_38);\n        Json::Value::_Value(local_38);\n        Json::Value::_Value(local_50);\n        \n        if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n            return 4;\n        }\n        \n        FUN_0013fce0();\n    }\n    \n    uVar2 = FUN_000392b0(2, *param_2, 0, 0);\n    rb_raise(_rb_eArgError, &DAT_0013fdc3, uVar2);\n}",
        "baseline_code_stripped": "undefined4 FUN_00058cd0(int param_1,undefined4 *param_2,undefined4 param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 extraout_ECX;\n  int in_GS_OFFSET;\n  undefined8 uVar5;\n  Value *local_54;\n  Value local_50 [24];\n  Value local_38 [24];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x58cdb;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar2 = Json::Value::Value(local_50,0);\n  if (param_1 != 1) {\n    rb_raise(_rb_eArgError,\"wrong # of arguments(%d for 1)\",param_1,uVar2);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(1,param_3,param_2,param_2);\n    if (iVar3 == -1) {\n      iVar3 = -5;\n    }\n    uVar4 = FUN_0003948e();\n    rb_raise(uVar4,&DAT_0013fdc3,uVar2,iVar3);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(2,*param_2,extraout_ECX,extraout_ECX);\n    uVar5 = FUN_0003948e();\n    rb_raise((int)uVar5,&DAT_0013fdc3,uVar2,(int)((ulonglong)uVar5 >> 0x20));\n  }\n  if (local_54 != (Value *)0x0) {\n    Json::Value::Value(local_38,local_54);\n    Json::Value::operator_(local_50,SUB41(local_38,0));\n    Json::Value::_Value(local_38);\n    pcVar1 = *(code **)(iRam00000000 + 0x24);\n    Json::Value::Value(local_38,local_50);\n    (*pcVar1)(0,local_38);\n    Json::Value::_Value(local_38);\n    Json::Value::_Value(local_50);\n    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n      return 4;\n    }\n    FUN_0013fce0();\n  }\n  uVar2 = FUN_000392b0(2,*param_2,0,0);\n  rb_raise(_rb_eArgError,&DAT_0013fdc3,uVar2);\n}",
        "similarity_score_unixcoder": 0.5849495530128479,
        "similarity_score_baseline_stripped": 0.5859087109565735
    },
    {
        "func_name": "lu_shadow_uses_elevated_privileges",
        "normed_func_sha256": "52320d3b6a1ca684d2aefa145f40839fcc9dfb973bc0a2677aec0765513bb45d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nbool FUN_00013089(int param_1)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  char *pcVar3;\n  int iVar4;\n  int iVar5;\n  uVar1 = g_strconcat(*(undefined4 *)(param_1 + 0xc),\"/directory\",0);\n  uVar2 = lu_cfg_read_single(*(undefined4 *)(param_1 + 0x10),uVar1,&DAT_00018a38);\n  g_free(uVar1);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/shadow\",0);\n  iVar4 = access(pcVar3,6);\n  g_free(pcVar3);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/gshadow\",0);\n  iVar5 = access(pcVar3,6);\n  g_free(pcVar3);\n  return iVar5 != 0 || iVar4 != 0;\n}",
        "output": "```c\nbool check_access(int param_1)\n{\n    char *directory_path = g_strconcat(*(char **)(param_1 + 0xC), \"/directory\", 0);\n    char *uVar2 = lu_cfg_read_single(*(char **)(param_1 + 0x10), directory_path, &DAT_00018a38);\n    g_free(directory_path);\n    \n    char *shadow_path = g_strconcat(\"%s/%s\", uVar2, \"/shadow\", 0);\n    int shadow_access = access(shadow_path, 6);\n    g_free(shadow_path);\n    \n    char *gshadow_path = g_strconcat(\"%s/%s\", uVar2, \"/gshadow\", 0);\n    int gshadow_access = access(gshadow_path, 6);\n    g_free(gshadow_path);\n    \n    return gshadow_access != 0 || shadow_access != 0;\n}\n```",
        "source_code": "static gboolean\nlu_shadow_uses_elevated_privileges(struct lu_module *module)\n{\n\tconst char *directory;\n\tchar *path, *key;\n\tgboolean ret = FALSE;\n\t/* Get the directory the files are in. */\n\tkey = g_strconcat(module->name, \"/directory\", NULL);\n\tdirectory = lu_cfg_read_single(module->lu_context, key, SYSCONFDIR);\n\tg_free(key);\n\t/* If we can't access the shadow file as a normal user, then the\n\t * answer is \"yes\". */\n\tpath = g_strconcat(\"%s/%s\", directory, \"/shadow\", NULL);\n\tif (access(path, R_OK | W_OK) != 0) {\n\t\tret = TRUE;\n\t}\n\tg_free(path);\n\t/* If we can't access the gshadow file as a normal user, then the\n\t * answer is \"yes\". */\n\tpath = g_strconcat(\"%s/%s\", directory, \"/gshadow\", NULL);\n\tif (access(path, R_OK | W_OK) != 0) {\n\t\tret = TRUE;\n\t}\n\tg_free(path);\n\treturn ret;\n}",
        "parsed_output": "bool check_access(int param_1)\n{\n    char *directory_path = g_strconcat(*(char **)(param_1 + 0xC), \"/directory\", 0);\n    char *uVar2 = lu_cfg_read_single(*(char **)(param_1 + 0x10), directory_path, &DAT_00018a38);\n    g_free(directory_path);\n    \n    char *shadow_path = g_strconcat(\"%s/%s\", uVar2, \"/shadow\", 0);\n    int shadow_access = access(shadow_path, 6);\n    g_free(shadow_path);\n    \n    char *gshadow_path = g_strconcat(\"%s/%s\", uVar2, \"/gshadow\", 0);\n    int gshadow_access = access(gshadow_path, 6);\n    g_free(gshadow_path);\n    \n    return gshadow_access != 0 || shadow_access != 0;\n}",
        "baseline_code_stripped": "bool FUN_00013089(int param_1)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  char *pcVar3;\n  int iVar4;\n  int iVar5;\n  uVar1 = g_strconcat(*(undefined4 *)(param_1 + 0xc),\"/directory\",0);\n  uVar2 = lu_cfg_read_single(*(undefined4 *)(param_1 + 0x10),uVar1,&DAT_00018a38);\n  g_free(uVar1);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/shadow\",0);\n  iVar4 = access(pcVar3,6);\n  g_free(pcVar3);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/gshadow\",0);\n  iVar5 = access(pcVar3,6);\n  g_free(pcVar3);\n  return iVar5 != 0 || iVar4 != 0;\n}",
        "similarity_score_unixcoder": 0.6819860339164734,
        "similarity_score_baseline_stripped": 0.5106364488601685
    },
    {
        "func_name": "sequeler_widgets_connection_dialog_class_init",
        "normed_func_sha256": "ddc6034aff01cf7ce7461601663446e999c5617d85f93f43f9ca537883a8840b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sequeler_widgets_connection_dialog_class_init(undefined8 param_1)\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  DAT_00160530 = g_type_class_peek_parent();\n  g_type_class_adjust_private_offset(param_1,&DAT_00160528);\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x20) = _vala_sequeler_widgets_connection_dialog_get_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x18) = _vala_sequeler_widgets_connection_dialog_set_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x10) = sequeler_widgets_connection_dialog_constructor;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x30) = sequeler_widgets_connection_dialog_finalize;\n  uVar2 = g_type_check_class_cast(param_1,0x50);\n  uVar3 = sequeler_window_get_type();\n  DAT_00160540 = g_param_spec_object(\"window\",\"window\",\"window\",uVar3,0xeb);\n  g_object_class_install_property(uVar2,1);\n  return;\n}",
        "output": "void sequeler_widgets_connection_dialog_class_init(undefined8 param_1)\n{\n  long class_type;\n  undefined8 parent_class;\n  undefined8 connection_dialog_class;\n  \n  parent_class = g_type_class_peek_parent();\n  g_type_class_adjust_private_offset(param_1, &DAT_00160528);\n  \n  class_type = g_type_check_class_cast(param_1, 0x50);\n  *(code **)(class_type + 0x20) = _vala_sequeler_widgets_connection_dialog_get_property;\n  \n  class_type = g_type_check_class_cast(param_1, 0x50);\n  *(code **)(class_type + 0x18) = _vala_sequeler_widgets_connection_dialog_set_property;\n  \n  class_type = g_type_check_class_cast(param_1, 0x50);\n  *(code **)(class_type + 0x10) = sequeler_widgets_connection_dialog_constructor;\n  \n  class_type = g_type_check_class_cast(param_1, 0x50);\n  *(code **)(class_type + 0x30) = sequeler_widgets_connection_dialog_finalize;\n  \n  connection_dialog_class = g_type_check_class_cast(param_1, 0x50);\n  DAT_00160540 = g_param_spec_object(\"window\", \"window\", \"window\", sequeler_window_get_type(), 0xeb);\n  \n  g_object_class_install_property(connection_dialog_class, 1);\n  \n  return;\n}",
        "source_code": "static void\nsequeler_widgets_connection_dialog_class_init (SequelerWidgetsConnectionDialogClass * klass,\n                                               gpointer klass_data)\n{\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tsequeler_widgets_connection_dialog_parent_class = g_type_class_peek_parent (klass);\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tg_type_class_adjust_private_offset (klass, &SequelerWidgetsConnectionDialog_private_offset);\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->get_property = _vala_sequeler_widgets_connection_dialog_get_property;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->set_property = _vala_sequeler_widgets_connection_dialog_set_property;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->constructor = sequeler_widgets_connection_dialog_constructor;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->finalize = sequeler_widgets_connection_dialog_finalize;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tg_object_class_install_property (G_OBJECT_CLASS (klass), SEQUELER_WIDGETS_CONNECTION_DIALOG_WINDOW_PROPERTY, sequeler_widgets_connection_dialog_properties[SEQUELER_WIDGETS_CONNECTION_DIALOG_WINDOW_PROPERTY] = g_param_spec_object (\"window\", \"window\", \"window\", SEQUELER_TYPE_WINDOW, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));\n#line 5302 \"ConnectionDialog.c\"\n}",
        "parsed_output": "void sequeler_widgets_connection_dialog_class_init(undefined8 param_1)\n{\n  long class_type;\n  undefined8 parent_class;\n  undefined8 connection_dialog_class;\n  \n  parent_class = g_type_class_peek_parent();\n  g_type_class_adjust_private_offset(param_1, &DAT_00160528);\n  \n  class_type = g_type_check_class_cast(param_1, 0x50);\n  *(code **)(class_type + 0x20) = _vala_sequeler_widgets_connection_dialog_get_property;\n  \n  class_type = g_type_check_class_cast(param_1, 0x50);\n  *(code **)(class_type + 0x18) = _vala_sequeler_widgets_connection_dialog_set_property;\n  \n  class_type = g_type_check_class_cast(param_1, 0x50);\n  *(code **)(class_type + 0x10) = sequeler_widgets_connection_dialog_constructor;\n  \n  class_type = g_type_check_class_cast(param_1, 0x50);\n  *(code **)(class_type + 0x30) = sequeler_widgets_connection_dialog_finalize;\n  \n  connection_dialog_class = g_type_check_class_cast(param_1, 0x50);\n  DAT_00160540 = g_param_spec_object(\"window\", \"window\", \"window\", sequeler_window_get_type(), 0xeb);\n  \n  g_object_class_install_property(connection_dialog_class, 1);\n  \n  return;\n}",
        "baseline_code_stripped": "void sequeler_widgets_connection_dialog_class_init(undefined8 param_1)\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  DAT_00160530 = g_type_class_peek_parent();\n  g_type_class_adjust_private_offset(param_1,&DAT_00160528);\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x20) = _vala_sequeler_widgets_connection_dialog_get_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x18) = _vala_sequeler_widgets_connection_dialog_set_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x10) = sequeler_widgets_connection_dialog_constructor;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x30) = sequeler_widgets_connection_dialog_finalize;\n  uVar2 = g_type_check_class_cast(param_1,0x50);\n  uVar3 = sequeler_window_get_type();\n  DAT_00160540 = g_param_spec_object(\"window\",\"window\",\"window\",uVar3,0xeb);\n  g_object_class_install_property(uVar2,1);\n  return;\n}",
        "similarity_score_unixcoder": 0.8334956765174866,
        "similarity_score_baseline_stripped": 0.8177669644355774
    },
    {
        "func_name": "imap_cmd_parser_copy",
        "normed_func_sha256": "b8ca09fcc5483d042f325f768af4c47af19446f5bcb0ce7f74e4cca0f0f16856",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00119230(int param_1,longlong param_2,longlong param_3,undefined8 param_4,\n                 undefined8 param_5)\n{\n  size_t sVar1;\n  uint uVar2;\n  longlong lVar3;\n  longlong lVar4;\n  longlong in_r13;\n  undefined8 uVar5;\n  char *__s;\n  longlong lStack_305c8;\n  undefined auStack_3053c [12];\n  undefined8 uStack_30530;\n  undefined8 uStack_30528;\n  void *pvStack_30518;\n  undefined8 uStack_30510;\n  undefined8 uStack_30508;\n  undefined8 uStack_304e8;\n  undefined8 uStack_304e0;\n  undefined8 uStack_304d8;\n  undefined8 *puStack_304d0;\n  undefined8 uStack_304c8;\n  undefined8 uStack_304c0;\n  undefined8 uStack_304b8;\n  undefined4 uStack_304b0;\n  undefined8 uStack_304a8;\n  undefined8 uStack_304a0;\n  undefined auStack_30498 [197640];\n  uVar5 = 0x70d;\n  lVar4 = *(longlong *)(in_r13 + -0x7010);\n  uStack_30530 = 0;\n  uStack_30528 = 0;\n  pvStack_30518 = (void *)0x0;\n  uStack_30510 = 0;\n  uStack_30508 = 0;\n  if ((*(int *)(param_3 + 0xd8) != 5) || (uVar5 = 0x708, param_1 < 4)) goto LAB_001192dc;\n  lVar3 = FUN_00118778(param_3,*(undefined8 *)(param_2 + 0x10),&pvStack_30518,param_4,param_5,0);\n  if ((lVar3 == 0) && (__s = *(char **)(param_2 + 0x18), *__s != '\\0')) {\n    sVar1 = strlen(__s);\n    if (0x3ff < sVar1) goto LAB_00119480;\n    lVar3 = FUN_00113948(param_3 + 0x208ad,__s,auStack_30498);\n    if (lVar3 == 0) goto LAB_00119480;\n    uStack_304b0 = *(undefined4 *)(lStack_305c8 + -0x2d30c);\n    puStack_304d0 = &uStack_304a0;\n    uStack_304e8 = 0;\n    uStack_304e0 = 0;\n    uStack_304d8 = 0;\n    uStack_304c0 = 0;\n    uStack_304b8 = 0;\n    uStack_304a8 = 0;\n    uStack_304a0 = 0;\n    uStack_304c8 = 1;\n    uVar2 = (**(code **)(lStack_305c8 + -0x6a70))\n                      (param_3 + 0x207ad,param_3 + 0x108,&pvStack_30518,&uStack_304e8,auStack_3053c)\n    ;\n    if (uVar2 < 6) {\n      (*(code *)((longlong)*(int *)(lStack_305c8 + -0x4ea98) +\n                (longlong)(int *)(lStack_305c8 + -0x4ea98)))((ulonglong)uVar2 << 2);\n      return;\n    }\n    uVar5 = 0x77f;\n    FUN_00128d48(&puStack_304d0);\n    FUN_00128c98(&uStack_304e8);\n  }\n  else {\nLAB_00119480:\n    uVar5 = 0x708;\n  }\n  if (pvStack_30518 != (void *)0x0) {\n    operator_delete(pvStack_30518);\n  }\nLAB_001192dc:\n  if (lVar4 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  __stack_chk_fail(uVar5);\n}",
        "output": "```c\nvoid process_data(int param_1, longlong param_2, longlong param_3, undefined8 param_4, undefined8 param_5) {\n    size_t sVar1;\n    uint uVar2;\n    longlong lVar3;\n    longlong lVar4;\n    longlong in_r13;\n    undefined8 uVar5;\n    char *__s;\n    longlong lStack_305c8;\n    undefined auStack_3053c[12];\n    undefined8 uStack_30530;\n    undefined8 uStack_30528;\n    void *pvStack_30518;\n    undefined8 uStack_30510;\n    undefined8 uStack_30508;\n    undefined8 uStack_304e8;\n    undefined8 uStack_304e0;\n    undefined8 uStack_304d8;\n    undefined8 *puStack_304d0;\n    undefined8 uStack_304c8;\n    undefined8 uStack_304c0;\n    undefined8 uStack_304b8;\n    undefined4 uStack_304b0;\n    undefined8 uStack_304a8;\n    undefined8 uStack_304a0;\n    undefined auStack_30498[197640];\n    \n    uVar5 = 0x70d;\n    lVar4 = *(longlong *)(in_r13 + -0x7010);\n    uStack_30530 = 0;\n    uStack_30528 = 0;\n    pvStack_30518 = (void *)0x0;\n    uStack_30510 = 0;\n    uStack_30508 = 0;\n    \n    if ((*(int *)(param_3 + 0xd8) != 5) || (uVar5 = 0x708, param_1 < 4)) {\n        goto LAB_001192dc;\n    }\n    \n    lVar3 = FUN_00118778(param_3, *(undefined8 *)(param_2 + 0x10), &pvStack_30518, param_4, param_5, 0);\n    \n    if ((lVar3 == 0) && (__s = *(char **)(param_2 + 0x18), *__s != '\\0')) {\n        sVar1 = strlen(__s);\n        \n        if (0x3ff < sVar1) {\n            goto LAB_00119480;\n        }\n        \n        lVar3 = FUN_00113948(param_3 + 0x208ad, __s, auStack_30498);\n        \n        if (lVar3 == 0) {\n            goto LAB_00119480;\n        }\n        \n        uStack_304b0 = *(undefined4 *)(lStack_305c8 + -0x2d30c);\n        puStack_304d0 = &uStack_304a0;\n        uStack_304e8 = 0;\n        uStack_304e0 = 0;\n        uStack_304d8 = 0;\n        uStack_304c0 = 0;\n        uStack_304b8 = 0;\n        uStack_304a8 = 0;\n        uStack_304a0 = 0;\n        uStack_304c8 = 1;\n        \n        uVar2 = (**(code **)(lStack_305c8 + -0x6a70))(param_3 + 0x207ad, param_3 + 0x108, &pvStack_30518, &uStack_304e8, auStack_3053c);\n        \n        if (uVar2 < 6) {\n            (*(code *)((longlong)*(int *)(lStack_305c8 + -0x4ea98) + (longlong)(int *)(lStack_305c8 + -0x4ea98)))((ulonglong)uVar2 << 2);\n            return;\n        }\n        \n        uVar5 = 0x77f;\n        FUN_00128d48(&puStack_304d0);\n        FUN_00128c98(&uStack_304e8);\n    } else {\n        LAB_00119480:\n        uVar5 = 0x708;\n    }\n    \n    if (pvStack_30518 != (void *)0x0) {\n        operator_delete(pvStack_30518);\n    }\n    \n    LAB_001192dc:\n    \n    if (lVar4 == *(longlong *)(in_r13 + -0x7010)) {\n        return;\n    }\n    \n    __stack_chk_fail(uVar5);\n}\n```",
        "source_code": "int imap_cmd_parser_copy(int argc, char **argv, IMAP_CONTEXT *pcontext) try\n{\n\tunsigned int uid;\n\tint errnum;\n\tBOOL b_first;\n\tBOOL b_copied;\n\tint i, j;\n\tunsigned long uidvalidity;\n\tsize_t string_length = 0, string_length1 = 0;\n\tchar buff[64*1024];\n\tchar temp_name[1024];\n\timap_seq_list list_uid;\n\tchar uid_string[64*1024];\n\tchar uid_string1[64*1024];\n    \n\tif (pcontext->proto_stat != iproto_stat::select)\n\t\treturn 1805;\n\tif (argc < 4 || parse_imap_seqx(*pcontext, argv[2], list_uid) != 0 ||\n\t    strlen(argv[3]) == 0 || strlen(argv[3]) >= 1024 ||\n\t    !imap_cmd_parser_imapfolder_to_sysfolder(pcontext->lang, argv[3], temp_name))\n\t\treturn 1800;\n\tXARRAY xarray;\n\tauto ssr = system_services_fetch_simple_uid(pcontext->maildir,\n\t           pcontext->selected_folder, list_uid, &xarray, &errnum);\n\tauto result = m2icode(ssr, errnum);\n\tif (result != 0)\n\t\treturn result;\n\tif (system_services_summary_folder(pcontext->maildir,\n\t    temp_name, nullptr, nullptr, nullptr, &uidvalidity, nullptr,\n\t    nullptr, &errnum) != MIDB_RESULT_OK)\n\t\tuidvalidity = 0;\n\tb_copied = TRUE;\n\tb_first = FALSE;\n\tstring_length = 0;\n\tstring_length1 = 0;\n\tint num = xarray.get_capacity();\n\tfor (i=0; i<num; i++) {\n\t\tauto pitem = xarray.get_item(i);\n\t\tpitem = pcontext->contents.get_itemx(pitem->uid);\n\t\tif (pitem == nullptr)\n\t\t\tcontinue;\n\t\tif (system_services_copy_mail(pcontext->maildir,\n\t\t    pcontext->selected_folder, pitem->mid, temp_name,\n\t\t    pitem->mid, &errnum) != MIDB_RESULT_OK) {\n\t\t\tb_copied = FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tif (uidvalidity == 0)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\tif (system_services_get_uid(pcontext->maildir,\n\t\t\t    temp_name, pitem->mid, &uid) != MIDB_RESULT_OK) {\n\t\t\t\tusleep(500000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b_first) {\n\t\t\t\tuid_string[string_length++] = ',';\n\t\t\t\tuid_string1[string_length1++] = ',';\n\t\t\t} else {\n\t\t\t\tb_first =  TRUE;\n\t\t\t}\n\t\t\tstring_length += gx_snprintf(uid_string + string_length,\n\t\t\t\t\t std::size(uid_string) - string_length, \"%d\", pitem->uid);\n\t\t\tstring_length1 += gx_snprintf(uid_string1 + string_length1,\n\t\t\t\t\t  std::size(uid_string1) - string_length1, \"%d\", uid);\n\t\t\tbreak;\n\t\t}\n\t\tif (j == 10)\n\t\t\tuidvalidity = 0;\n\t}\n\tif (!b_copied) {\n\t\tstd::vector<MITEM *> exp_list;\n\t\tfor (;i>0; i--) {\n\t\t\tauto pitem = xarray.get_item(i - 1);\n\t\t\tif (pitem->uid == 0)\n\t\t\t\tcontinue;\n\t\t\texp_list.push_back(pitem);\n\t\t}\n\t\tsystem_services_remove_mail(pcontext->maildir,\n\t\t\ttemp_name, exp_list, &errnum);\n\t}\n\tpcontext->stream.clear();\n\tif (b_copied) {\n\t\timap_parser_echo_modify(pcontext, &pcontext->stream);\n\t\t/* IMAP_CODE_2170022: OK <COPYUID> COPY completed */\n\t\tauto imap_reply_str = resource_get_imap_code(1722, 1, &string_length);\n\t\tauto imap_reply_str1 = resource_get_imap_code(1722, 2, &string_length1);\n\t\tif (uidvalidity != 0)\n\t\t\tstring_length = gx_snprintf(buff, std::size(buff),\n\t\t\t\t\"%s %s [COPYUID %llu %s %s] %s\", argv[0],\n\t\t\t\timap_reply_str, LLU{uidvalidity},\n\t\t\t\tuid_string, uid_string1, imap_reply_str1);\n\t\telse\n\t\t\tstring_length = gx_snprintf(buff, std::size(buff),\n\t\t\t\t\"%s %s %s\", argv[0], imap_reply_str, imap_reply_str1);\n\t} else {\n\t\t/* IMAP_CODE_2190016: NO COPY failed */\n\t\tauto imap_reply_str = resource_get_imap_code(1916, 1, &string_length);\n\t\tstring_length = gx_snprintf(buff, std::size(buff),\n\t\t\t\"%s %s\", argv[0], imap_reply_str);\n\t}\n\tif (pcontext->stream.write(buff, string_length) != STREAM_WRITE_OK)\n\t\treturn 1922;\n\tpcontext->write_offset = 0;\n\tpcontext->sched_stat = isched_stat::wrlst;\n\treturn DISPATCH_BREAK;\n} catch (const std::bad_alloc &) {\n\tmlog(LV_ERR, \"E-1245: ENOMEM\");\n\treturn 1918;\n}",
        "parsed_output": "void process_data(int param_1, longlong param_2, longlong param_3, undefined8 param_4, undefined8 param_5) {\n    size_t sVar1;\n    uint uVar2;\n    longlong lVar3;\n    longlong lVar4;\n    longlong in_r13;\n    undefined8 uVar5;\n    char *__s;\n    longlong lStack_305c8;\n    undefined auStack_3053c[12];\n    undefined8 uStack_30530;\n    undefined8 uStack_30528;\n    void *pvStack_30518;\n    undefined8 uStack_30510;\n    undefined8 uStack_30508;\n    undefined8 uStack_304e8;\n    undefined8 uStack_304e0;\n    undefined8 uStack_304d8;\n    undefined8 *puStack_304d0;\n    undefined8 uStack_304c8;\n    undefined8 uStack_304c0;\n    undefined8 uStack_304b8;\n    undefined4 uStack_304b0;\n    undefined8 uStack_304a8;\n    undefined8 uStack_304a0;\n    undefined auStack_30498[197640];\n    \n    uVar5 = 0x70d;\n    lVar4 = *(longlong *)(in_r13 + -0x7010);\n    uStack_30530 = 0;\n    uStack_30528 = 0;\n    pvStack_30518 = (void *)0x0;\n    uStack_30510 = 0;\n    uStack_30508 = 0;\n    \n    if ((*(int *)(param_3 + 0xd8) != 5) || (uVar5 = 0x708, param_1 < 4)) {\n        goto LAB_001192dc;\n    }\n    \n    lVar3 = FUN_00118778(param_3, *(undefined8 *)(param_2 + 0x10), &pvStack_30518, param_4, param_5, 0);\n    \n    if ((lVar3 == 0) && (__s = *(char **)(param_2 + 0x18), *__s != '\\0')) {\n        sVar1 = strlen(__s);\n        \n        if (0x3ff < sVar1) {\n            goto LAB_00119480;\n        }\n        \n        lVar3 = FUN_00113948(param_3 + 0x208ad, __s, auStack_30498);\n        \n        if (lVar3 == 0) {\n            goto LAB_00119480;\n        }\n        \n        uStack_304b0 = *(undefined4 *)(lStack_305c8 + -0x2d30c);\n        puStack_304d0 = &uStack_304a0;\n        uStack_304e8 = 0;\n        uStack_304e0 = 0;\n        uStack_304d8 = 0;\n        uStack_304c0 = 0;\n        uStack_304b8 = 0;\n        uStack_304a8 = 0;\n        uStack_304a0 = 0;\n        uStack_304c8 = 1;\n        \n        uVar2 = (**(code **)(lStack_305c8 + -0x6a70))(param_3 + 0x207ad, param_3 + 0x108, &pvStack_30518, &uStack_304e8, auStack_3053c);\n        \n        if (uVar2 < 6) {\n            (*(code *)((longlong)*(int *)(lStack_305c8 + -0x4ea98) + (longlong)(int *)(lStack_305c8 + -0x4ea98)))((ulonglong)uVar2 << 2);\n            return;\n        }\n        \n        uVar5 = 0x77f;\n        FUN_00128d48(&puStack_304d0);\n        FUN_00128c98(&uStack_304e8);\n    } else {\n        LAB_00119480:\n        uVar5 = 0x708;\n    }\n    \n    if (pvStack_30518 != (void *)0x0) {\n        operator_delete(pvStack_30518);\n    }\n    \n    LAB_001192dc:\n    \n    if (lVar4 == *(longlong *)(in_r13 + -0x7010)) {\n        return;\n    }\n    \n    __stack_chk_fail(uVar5);\n}",
        "baseline_code_stripped": "void FUN_00119230(int param_1,longlong param_2,longlong param_3,undefined8 param_4,\n                 undefined8 param_5)\n{\n  size_t sVar1;\n  uint uVar2;\n  longlong lVar3;\n  longlong lVar4;\n  longlong in_r13;\n  undefined8 uVar5;\n  char *__s;\n  longlong lStack_305c8;\n  undefined auStack_3053c [12];\n  undefined8 uStack_30530;\n  undefined8 uStack_30528;\n  void *pvStack_30518;\n  undefined8 uStack_30510;\n  undefined8 uStack_30508;\n  undefined8 uStack_304e8;\n  undefined8 uStack_304e0;\n  undefined8 uStack_304d8;\n  undefined8 *puStack_304d0;\n  undefined8 uStack_304c8;\n  undefined8 uStack_304c0;\n  undefined8 uStack_304b8;\n  undefined4 uStack_304b0;\n  undefined8 uStack_304a8;\n  undefined8 uStack_304a0;\n  undefined auStack_30498 [197640];\n  uVar5 = 0x70d;\n  lVar4 = *(longlong *)(in_r13 + -0x7010);\n  uStack_30530 = 0;\n  uStack_30528 = 0;\n  pvStack_30518 = (void *)0x0;\n  uStack_30510 = 0;\n  uStack_30508 = 0;\n  if ((*(int *)(param_3 + 0xd8) != 5) || (uVar5 = 0x708, param_1 < 4)) goto LAB_001192dc;\n  lVar3 = FUN_00118778(param_3,*(undefined8 *)(param_2 + 0x10),&pvStack_30518,param_4,param_5,0);\n  if ((lVar3 == 0) && (__s = *(char **)(param_2 + 0x18), *__s != '\\0')) {\n    sVar1 = strlen(__s);\n    if (0x3ff < sVar1) goto LAB_00119480;\n    lVar3 = FUN_00113948(param_3 + 0x208ad,__s,auStack_30498);\n    if (lVar3 == 0) goto LAB_00119480;\n    uStack_304b0 = *(undefined4 *)(lStack_305c8 + -0x2d30c);\n    puStack_304d0 = &uStack_304a0;\n    uStack_304e8 = 0;\n    uStack_304e0 = 0;\n    uStack_304d8 = 0;\n    uStack_304c0 = 0;\n    uStack_304b8 = 0;\n    uStack_304a8 = 0;\n    uStack_304a0 = 0;\n    uStack_304c8 = 1;\n    uVar2 = (**(code **)(lStack_305c8 + -0x6a70))\n                      (param_3 + 0x207ad,param_3 + 0x108,&pvStack_30518,&uStack_304e8,auStack_3053c)\n    ;\n    if (uVar2 < 6) {\n      (*(code *)((longlong)*(int *)(lStack_305c8 + -0x4ea98) +\n                (longlong)(int *)(lStack_305c8 + -0x4ea98)))((ulonglong)uVar2 << 2);\n      return;\n    }\n    uVar5 = 0x77f;\n    FUN_00128d48(&puStack_304d0);\n    FUN_00128c98(&uStack_304e8);\n  }\n  else {\nLAB_00119480:\n    uVar5 = 0x708;\n  }\n  if (pvStack_30518 != (void *)0x0) {\n    operator_delete(pvStack_30518);\n  }\nLAB_001192dc:\n  if (lVar4 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  __stack_chk_fail(uVar5);\n}",
        "similarity_score_unixcoder": 0.528451144695282,
        "similarity_score_baseline_stripped": 0.5057766437530518
    },
    {
        "func_name": "BotTree::serialize",
        "normed_func_sha256": "76fe8713c2d7998c190a0e815fd24283ab97f4c85ccb45333e160b7124920fb9",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 __fastcall FUN_10002610(int param_1)\n{\n  undefined4 unaff_retaddr;\n  FUN_1004a620(param_1 + 0x21d8,64000,0);\n  if ((_DAT_10840e5c & 1) == 0) {\n    _DAT_10840e5c = _DAT_10840e5c | 1;\n    DAT_10840e58 = FUN_1004a640(1);\n  }\n  FUN_1004a7b0(DAT_10840e58);\n  (**(code **)(**(int **)(param_1 + 0x21d4) + 0x10))(DAT_10840e58);\n  FUN_1004a730(DAT_10840e58,param_1 + 0x1b0c,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 4,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 5,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 6,1,0);\n  DAT_10840e54 = FUN_1004a7c0(DAT_10840e58);\n  FUN_1004a7b0(DAT_10840e58);\n  FUN_1004a6b0(DAT_10840e58,unaff_retaddr,DAT_10840e54,0);\n  return 1;\n}",
        "output": "```c\nundefined4 __fastcall FUN_10002610(int param_1)\n{\n    undefined4 unaff_retaddr;\n    \n    FUN_1004a620(param_1 + 0x21d8, 64000, 0);\n    \n    if ((_DAT_10840e5c & 1) == 0) {\n        _DAT_10840e5c |= 1;\n        DAT_10840e58 = FUN_1004a640(1);\n    }\n    \n    FUN_1004a7b0(DAT_10840e58);\n    \n    (*(code **)(*(int *)(param_1 + 0x21d4) + 0x10))(DAT_10840e58);\n    \n    FUN_1004a730(DAT_10840e58, param_1 + 0x1b0c, 1, 0);\n    FUN_1004a730(DAT_10840e58, param_1 + 4, 1, 0);\n    FUN_1004a730(DAT_10840e58, param_1 + 5, 1, 0);\n    FUN_1004a730(DAT_10840e58, param_1 + 6, 1, 0);\n    \n    DAT_10840e54 = FUN_1004a7c0(DAT_10840e58);\n    FUN_1004a7b0(DAT_10840e58);\n    FUN_1004a6b0(DAT_10840e58, unaff_retaddr, DAT_10840e54, 0);\n    \n    return 1;\n}\n```",
        "source_code": "bool BotTree::serialize(void *data_)\n{\n   memstream_set_buffer(buffer, MEM_STREAM_BUFFER_SIZE);\n   static memstream_t *stream = memstream_open(1);\n   assert(stream != NULL);\n   memstream_rewind(stream);\n   assert(tree != NULL);\n   tree->serialize(stream);                                                                            // write to the stream\n   memstream_write(stream, &calculatedBestCellToPickUpBonus, sizeof(calculatedBestCellToPickUpBonus)); // write to the stream\n   memstream_write(stream, &_direction1FrameAgo, sizeof(_direction1FrameAgo));                         // write to the stream\n   memstream_write(stream, &_direction2FramesAgo, sizeof(_direction2FramesAgo));                       // write to the stream\n   memstream_write(stream, &_shiveringCounter, sizeof(_shiveringCounter));                             // write to the stream\n   serializeSize = memstream_pos(stream);\n   memstream_rewind(stream);\n   memstream_read(stream, data_, serializeSize);     // read from the stream\n   return(true);\n}",
        "parsed_output": "undefined4 __fastcall FUN_10002610(int param_1)\n{\n    undefined4 unaff_retaddr;\n    \n    FUN_1004a620(param_1 + 0x21d8, 64000, 0);\n    \n    if ((_DAT_10840e5c & 1) == 0) {\n        _DAT_10840e5c |= 1;\n        DAT_10840e58 = FUN_1004a640(1);\n    }\n    \n    FUN_1004a7b0(DAT_10840e58);\n    \n    (*(code **)(*(int *)(param_1 + 0x21d4) + 0x10))(DAT_10840e58);\n    \n    FUN_1004a730(DAT_10840e58, param_1 + 0x1b0c, 1, 0);\n    FUN_1004a730(DAT_10840e58, param_1 + 4, 1, 0);\n    FUN_1004a730(DAT_10840e58, param_1 + 5, 1, 0);\n    FUN_1004a730(DAT_10840e58, param_1 + 6, 1, 0);\n    \n    DAT_10840e54 = FUN_1004a7c0(DAT_10840e58);\n    FUN_1004a7b0(DAT_10840e58);\n    FUN_1004a6b0(DAT_10840e58, unaff_retaddr, DAT_10840e54, 0);\n    \n    return 1;\n}",
        "baseline_code_stripped": "undefined4 __fastcall FUN_10002610(int param_1)\n{\n  undefined4 unaff_retaddr;\n  FUN_1004a620(param_1 + 0x21d8,64000,0);\n  if ((_DAT_10840e5c & 1) == 0) {\n    _DAT_10840e5c = _DAT_10840e5c | 1;\n    DAT_10840e58 = FUN_1004a640(1);\n  }\n  FUN_1004a7b0(DAT_10840e58);\n  (**(code **)(**(int **)(param_1 + 0x21d4) + 0x10))(DAT_10840e58);\n  FUN_1004a730(DAT_10840e58,param_1 + 0x1b0c,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 4,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 5,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 6,1,0);\n  DAT_10840e54 = FUN_1004a7c0(DAT_10840e58);\n  FUN_1004a7b0(DAT_10840e58);\n  FUN_1004a6b0(DAT_10840e58,unaff_retaddr,DAT_10840e54,0);\n  return 1;\n}",
        "similarity_score_unixcoder": 0.4439275562763214,
        "similarity_score_baseline_stripped": 0.45023924112319946
    },
    {
        "func_name": "fp_Line::findNextTabStop",
        "normed_func_sha256": "fecba40e7ff4a373a5ef76f55418342d9ff5122d0f973287b53889c52c6f7357",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nbool __thiscall\nfp_Line::findNextTabStop\n          (fp_Line *this,int param_1,int *param_2,eTabType *param_3,eTabLeader *param_4)\n{\n  fl_BlockLayout *this_00;\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int in_GS_OFFSET;\n  undefined4 local_2c;\n  undefined4 local_28;\n  int local_24;\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x25e569;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  this_00 = *(fl_BlockLayout **)(this + 0x94);\n  local_24 = 0;\n  local_28 = 0;\n  local_2c = 0;\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar3 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar3 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  iVar1 = getMaxWidth(this);\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar2 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar2 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  fl_BlockLayout::findNextTabStop\n            (this_00,iVar2 + param_1,iVar3 + iVar1,&local_24,(eTabType *)&local_28,\n             (eTabLeader *)&local_2c);\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar3 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar3 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  iVar3 = local_24 - iVar3;\n  local_24 = iVar3;\n  iVar1 = getMaxWidth(this);\n  if (iVar3 <= iVar1) {\n    *param_2 = iVar3;\n    *(undefined4 *)param_3 = local_28;\n    *(undefined4 *)param_4 = local_2c;\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return iVar3 <= iVar1;\n  }\n  FUN_00549f50();\n}",
        "output": "```c\nbool __thiscall fp_Line::findNextTabStop(fp_Line *this, int param_1, int *param_2, eTabType *param_3, eTabLeader *param_4)\n{\n    fl_BlockLayout *blockLayout;\n    int width1;\n    int width2;\n    int tabStop;\n    int local_24;\n    int local_20;\n    eTabLeader tabLeader;\n    eTabType tabType;\n    \n    local_20 = *(int *)(in_GS_OFFSET + 0x14);\n    blockLayout = *(fl_BlockLayout **)(this + 0x94);\n    local_24 = 0;\n    \n    if (*(code **)(*(int *)this + 0x20) == getX) {\n        width2 = *(int *)(this + 0xbc);\n    } else {\n        width2 = (**(code **)(*(int *)this + 0x20))(this);\n    }\n    \n    width1 = getMaxWidth(this);\n    \n    if (*(code **)(*(int *)this + 0x20) == getX) {\n        tabStop = *(int *)(this + 0xbc);\n    } else {\n        tabStop = (**(code **)(*(int *)this + 0x20))(this);\n    }\n    \n    fl_BlockLayout::findNextTabStop(blockLayout, tabStop + param_1, width2 + width1, &local_24, &tabType, &tabLeader);\n    \n    tabStop = local_24 - tabStop;\n    local_24 = tabStop;\n    \n    if (tabStop <= width1) {\n        *param_2 = tabStop;\n        *(eTabType *)param_3 = tabType;\n        *(eTabLeader *)param_4 = tabLeader;\n    }\n    \n    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n        return tabStop <= width1;\n    }\n    \n    FUN_00549f50();\n}\n```",
        "source_code": "bool\tfp_Line::findNextTabStop(UT_sint32 iStartX, UT_sint32& iPosition, eTabType & iType, eTabLeader & iLeader )\n{\n\tUT_sint32\tiTabStopPosition = 0;\n\teTabType\tiTabStopType = FL_TAB_NONE;\n\teTabLeader\tiTabStopLeader = FL_LEADER_NONE;\n\n\tUT_DebugOnly<bool> bRes = m_pBlock->findNextTabStop(iStartX + getX(), \n\t\t\t\t\t\t\t    getX() + getMaxWidth(), \n\t\t\t\t\t\t\t    iTabStopPosition, iTabStopType, \n\t\t\t\t\t\t\t    iTabStopLeader);\n\tUT_ASSERT(bRes);\n\n\tiTabStopPosition -= getX();\n\n\t//has to be <=\n\tif (iTabStopPosition <= getMaxWidth())\n\t{\n\t\tiPosition = iTabStopPosition;\n\t\tiType = iTabStopType;\n\t\tiLeader = iTabStopLeader;\n\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tUT_DEBUGMSG((\"fp_Line::findNextTabStop: iStartX %d, getMaxWidth %d\\n\"\n\t\t\t\t\t \"\t\t\tiPosition %d, iTabStopPosition %d, iType %d, iLeader %d\\n\",\n\t\t\t     iStartX, getMaxWidth(),iPosition, iTabStopPosition,static_cast<UT_sint32>(iType), static_cast<UT_sint32>(iLeader)));\n\t\treturn false;\n\t}\n}",
        "parsed_output": "bool __thiscall fp_Line::findNextTabStop(fp_Line *this, int param_1, int *param_2, eTabType *param_3, eTabLeader *param_4)\n{\n    fl_BlockLayout *blockLayout;\n    int width1;\n    int width2;\n    int tabStop;\n    int local_24;\n    int local_20;\n    eTabLeader tabLeader;\n    eTabType tabType;\n    \n    local_20 = *(int *)(in_GS_OFFSET + 0x14);\n    blockLayout = *(fl_BlockLayout **)(this + 0x94);\n    local_24 = 0;\n    \n    if (*(code **)(*(int *)this + 0x20) == getX) {\n        width2 = *(int *)(this + 0xbc);\n    } else {\n        width2 = (**(code **)(*(int *)this + 0x20))(this);\n    }\n    \n    width1 = getMaxWidth(this);\n    \n    if (*(code **)(*(int *)this + 0x20) == getX) {\n        tabStop = *(int *)(this + 0xbc);\n    } else {\n        tabStop = (**(code **)(*(int *)this + 0x20))(this);\n    }\n    \n    fl_BlockLayout::findNextTabStop(blockLayout, tabStop + param_1, width2 + width1, &local_24, &tabType, &tabLeader);\n    \n    tabStop = local_24 - tabStop;\n    local_24 = tabStop;\n    \n    if (tabStop <= width1) {\n        *param_2 = tabStop;\n        *(eTabType *)param_3 = tabType;\n        *(eTabLeader *)param_4 = tabLeader;\n    }\n    \n    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n        return tabStop <= width1;\n    }\n    \n    FUN_00549f50();\n}",
        "baseline_code_stripped": "bool __thiscall\nfp_Line::findNextTabStop\n          (fp_Line *this,int param_1,int *param_2,eTabType *param_3,eTabLeader *param_4)\n{\n  fl_BlockLayout *this_00;\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int in_GS_OFFSET;\n  undefined4 local_2c;\n  undefined4 local_28;\n  int local_24;\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x25e569;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  this_00 = *(fl_BlockLayout **)(this + 0x94);\n  local_24 = 0;\n  local_28 = 0;\n  local_2c = 0;\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar3 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar3 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  iVar1 = getMaxWidth(this);\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar2 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar2 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  fl_BlockLayout::findNextTabStop\n            (this_00,iVar2 + param_1,iVar3 + iVar1,&local_24,(eTabType *)&local_28,\n             (eTabLeader *)&local_2c);\n  if (*(code **)(*(int *)this + 0x20) == getX) {\n    iVar3 = *(int *)(this + 0xbc);\n  }\n  else {\n    iVar3 = (**(code **)(*(int *)this + 0x20))(this);\n  }\n  iVar3 = local_24 - iVar3;\n  local_24 = iVar3;\n  iVar1 = getMaxWidth(this);\n  if (iVar3 <= iVar1) {\n    *param_2 = iVar3;\n    *(undefined4 *)param_3 = local_28;\n    *(undefined4 *)param_4 = local_2c;\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return iVar3 <= iVar1;\n  }\n  FUN_00549f50();\n}",
        "similarity_score_unixcoder": 0.7809802293777466,
        "similarity_score_baseline_stripped": 0.7001904845237732
    },
    {
        "func_name": "TypeName",
        "normed_func_sha256": "d5684d4d62f54b30d28882da40876d002cb7ef0f485aedf958a63d17b5fbb2a5",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar * FUN_080917f0(undefined4 param_1)\n{\n  undefined4 uVar1;\n  char *pcVar2;\n  undefined local_20 [19];\n  undefined local_d;\n  switch(param_1) {\n  default:\n    FUN_080992e0(local_20,3,\"../../src/google/protobuf/compiler/java/java_extension.cc\",0x48);\n    uVar1 = FUN_080998e0(local_20,\"Can\\'t get here.\");\n    FUN_08099bc0(&local_d,uVar1);\n    FUN_08099a40(local_20);\n    pcVar2 = (char *)0x0;\n    break;\n  case 1:\n    pcVar2 = \"DOUBLE\";\n    break;\n  case 2:\n    pcVar2 = \"FLOAT\";\n    break;\n  case 3:\n    pcVar2 = \"INT64\";\n    break;\n  case 4:\n    pcVar2 = \"UINT64\";\n    break;\n  case 5:\n    pcVar2 = \"INT32\";\n    break;\n  case 6:\n    pcVar2 = \"FIXED64\";\n    break;\n  case 7:\n    pcVar2 = \"FIXED32\";\n    break;\n  case 8:\n    pcVar2 = \"BOOL\";\n    break;\n  case 9:\n    pcVar2 = \"STRING\";\n    break;\n  case 10:\n    pcVar2 = \"GROUP\";\n    break;\n  case 0xb:\n    pcVar2 = \"MESSAGE\";\n    break;\n  case 0xc:\n    pcVar2 = \"BYTES\";\n    break;\n  case 0xd:\n    pcVar2 = \"UINT32\";\n    break;\n  case 0xe:\n    pcVar2 = \"ENUM\";\n    break;\n  case 0xf:\n    pcVar2 = \"SFIXED32\";\n    break;\n  case 0x10:\n    pcVar2 = \"SFIXED64\";\n    break;\n  case 0x11:\n    pcVar2 = \"SINT32\";\n    break;\n  case 0x12:\n    pcVar2 = \"SINT64\";\n  }\n  return pcVar2;\n}",
        "output": "char * get_data_type_name(int data_type)\n{\n    switch(data_type) {\n        case 1:\n            return \"DOUBLE\";\n        case 2:\n            return \"FLOAT\";\n        case 3:\n            return \"INT64\";\n        case 4:\n            return \"UINT64\";\n        case 5:\n            return \"INT32\";\n        case 6:\n            return \"FIXED64\";\n        case 7:\n            return \"FIXED32\";\n        case 8:\n            return \"BOOL\";\n        case 9:\n            return \"STRING\";\n        case 10:\n            return \"GROUP\";\n        case 11:\n            return \"MESSAGE\";\n        case 12:\n            return \"BYTES\";\n        case 13:\n            return \"UINT32\";\n        case 14:\n            return \"ENUM\";\n        case 15:\n            return \"SFIXED32\";\n        case 16:\n            return \"SFIXED64\";\n        case 17:\n            return \"SINT32\";\n        case 18:\n            return \"SINT64\";\n        default:\n            char error_message[19];\n            sprintf(error_message, \"Can't get here.\");\n            log_error(error_message);\n            return NULL;\n    }\n}",
        "source_code": "const char* TypeName(FieldDescriptor::Type field_type) {\n  switch (field_type) {\n    case FieldDescriptor::TYPE_INT32   : return \"INT32\";\n    case FieldDescriptor::TYPE_UINT32  : return \"UINT32\";\n    case FieldDescriptor::TYPE_SINT32  : return \"SINT32\";\n    case FieldDescriptor::TYPE_FIXED32 : return \"FIXED32\";\n    case FieldDescriptor::TYPE_SFIXED32: return \"SFIXED32\";\n    case FieldDescriptor::TYPE_INT64   : return \"INT64\";\n    case FieldDescriptor::TYPE_UINT64  : return \"UINT64\";\n    case FieldDescriptor::TYPE_SINT64  : return \"SINT64\";\n    case FieldDescriptor::TYPE_FIXED64 : return \"FIXED64\";\n    case FieldDescriptor::TYPE_SFIXED64: return \"SFIXED64\";\n    case FieldDescriptor::TYPE_FLOAT   : return \"FLOAT\";\n    case FieldDescriptor::TYPE_DOUBLE  : return \"DOUBLE\";\n    case FieldDescriptor::TYPE_BOOL    : return \"BOOL\";\n    case FieldDescriptor::TYPE_STRING  : return \"STRING\";\n    case FieldDescriptor::TYPE_BYTES   : return \"BYTES\";\n    case FieldDescriptor::TYPE_ENUM    : return \"ENUM\";\n    case FieldDescriptor::TYPE_GROUP   : return \"GROUP\";\n    case FieldDescriptor::TYPE_MESSAGE : return \"MESSAGE\";\n  }\n  GOOGLE_LOG(FATAL) << \"Can't get here.\";\n  return NULL;\n}",
        "parsed_output": "char * get_data_type_name(int data_type)\n{\n    switch(data_type) {\n        case 1:\n            return \"DOUBLE\";\n        case 2:\n            return \"FLOAT\";\n        case 3:\n            return \"INT64\";\n        case 4:\n            return \"UINT64\";\n        case 5:\n            return \"INT32\";\n        case 6:\n            return \"FIXED64\";\n        case 7:\n            return \"FIXED32\";\n        case 8:\n            return \"BOOL\";\n        case 9:\n            return \"STRING\";\n        case 10:\n            return \"GROUP\";\n        case 11:\n            return \"MESSAGE\";\n        case 12:\n            return \"BYTES\";\n        case 13:\n            return \"UINT32\";\n        case 14:\n            return \"ENUM\";\n        case 15:\n            return \"SFIXED32\";\n        case 16:\n            return \"SFIXED64\";\n        case 17:\n            return \"SINT32\";\n        case 18:\n            return \"SINT64\";\n        default:\n            char error_message[19];\n            sprintf(error_message, \"Can't get here.\");\n            log_error(error_message);\n            return NULL;\n    }\n}",
        "baseline_code_stripped": "char * FUN_080917f0(undefined4 param_1)\n{\n  undefined4 uVar1;\n  char *pcVar2;\n  undefined local_20 [19];\n  undefined local_d;\n  switch(param_1) {\n  default:\n    FUN_080992e0(local_20,3,\"../../src/google/protobuf/compiler/java/java_extension.cc\",0x48);\n    uVar1 = FUN_080998e0(local_20,\"Can\\'t get here.\");\n    FUN_08099bc0(&local_d,uVar1);\n    FUN_08099a40(local_20);\n    pcVar2 = (char *)0x0;\n    break;\n  case 1:\n    pcVar2 = \"DOUBLE\";\n    break;\n  case 2:\n    pcVar2 = \"FLOAT\";\n    break;\n  case 3:\n    pcVar2 = \"INT64\";\n    break;\n  case 4:\n    pcVar2 = \"UINT64\";\n    break;\n  case 5:\n    pcVar2 = \"INT32\";\n    break;\n  case 6:\n    pcVar2 = \"FIXED64\";\n    break;\n  case 7:\n    pcVar2 = \"FIXED32\";\n    break;\n  case 8:\n    pcVar2 = \"BOOL\";\n    break;\n  case 9:\n    pcVar2 = \"STRING\";\n    break;\n  case 10:\n    pcVar2 = \"GROUP\";\n    break;\n  case 0xb:\n    pcVar2 = \"MESSAGE\";\n    break;\n  case 0xc:\n    pcVar2 = \"BYTES\";\n    break;\n  case 0xd:\n    pcVar2 = \"UINT32\";\n    break;\n  case 0xe:\n    pcVar2 = \"ENUM\";\n    break;\n  case 0xf:\n    pcVar2 = \"SFIXED32\";\n    break;\n  case 0x10:\n    pcVar2 = \"SFIXED64\";\n    break;\n  case 0x11:\n    pcVar2 = \"SINT32\";\n    break;\n  case 0x12:\n    pcVar2 = \"SINT64\";\n  }\n  return pcVar2;\n}",
        "similarity_score_unixcoder": 0.8061752915382385,
        "similarity_score_baseline_stripped": 0.593778669834137
    },
    {
        "func_name": "log_Z3_algebraic_eval",
        "normed_func_sha256": "2b3e7f22436b94f80bd68b8460b22a2dc95cb730cfbf85d7aa1c78caa227c9db",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_012f3f90(undefined8 param_1,undefined8 param_2,int param_3,undefined8 *param_4)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  FUN_012ea5d0();\n  FUN_012ea740(param_1);\n  FUN_012ea740(param_2);\n  FUN_012ea6f0(param_3);\n  puVar1 = param_4 + (ulong)(param_3 - 1) + 1;\n  if (param_3 != 0) {\n    do {\n      uVar2 = *param_4;\n      param_4 = param_4 + 1;\n      FUN_012ea740(uVar2);\n    } while (param_4 != puVar1);\n  }\n  FUN_012ea830(param_3);\n  FUN_012ea6a0(0x207);\n  return;\n}",
        "output": "void process_data(undefined8 param_1, undefined8 param_2, int param_3, undefined8 *param_4)\n{\n    undefined8 *current_ptr;\n    undefined8 data_value;\n    \n    initialize_data_processing();\n    \n    process_data_entry(param_1);\n    process_data_entry(param_2);\n    process_data_entry(param_3);\n    \n    current_ptr = param_4 + (ulong)(param_3 - 1) + 1;\n    \n    if (param_3 != 0) {\n        do {\n            data_value = *param_4;\n            param_4 = param_4 + 1;\n            process_data_entry(data_value);\n        } while (param_4 != current_ptr);\n    }\n    \n    finalize_data_processing(param_3);\n    additional_processing(0x207);\n    \n    return;\n}",
        "source_code": "void log_Z3_algebraic_eval(Z3_context a0, Z3_ast a1, unsigned a2, Z3_ast const * a3) {\n  R();\n  P(a0);\n  P(a1);\n  U(a2);\n  for (unsigned i = 0; i < a2; i++) { P(a3[i]); }\n  Ap(a2);\n  C(519);\n}",
        "parsed_output": "void process_data(undefined8 param_1, undefined8 param_2, int param_3, undefined8 *param_4)\n{\n    undefined8 *current_ptr;\n    undefined8 data_value;\n    \n    initialize_data_processing();\n    \n    process_data_entry(param_1);\n    process_data_entry(param_2);\n    process_data_entry(param_3);\n    \n    current_ptr = param_4 + (ulong)(param_3 - 1) + 1;\n    \n    if (param_3 != 0) {\n        do {\n            data_value = *param_4;\n            param_4 = param_4 + 1;\n            process_data_entry(data_value);\n        } while (param_4 != current_ptr);\n    }\n    \n    finalize_data_processing(param_3);\n    additional_processing(0x207);\n    \n    return;\n}",
        "baseline_code_stripped": "void FUN_012f3f90(undefined8 param_1,undefined8 param_2,int param_3,undefined8 *param_4)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  FUN_012ea5d0();\n  FUN_012ea740(param_1);\n  FUN_012ea740(param_2);\n  FUN_012ea6f0(param_3);\n  puVar1 = param_4 + (ulong)(param_3 - 1) + 1;\n  if (param_3 != 0) {\n    do {\n      uVar2 = *param_4;\n      param_4 = param_4 + 1;\n      FUN_012ea740(uVar2);\n    } while (param_4 != puVar1);\n  }\n  FUN_012ea830(param_3);\n  FUN_012ea6a0(0x207);\n  return;\n}",
        "similarity_score_unixcoder": 0.46816277503967285,
        "similarity_score_baseline_stripped": 0.49670955538749695
    },
    {
        "func_name": "CAAEquinoxesAndSolstices::LengthOfSummer",
        "normed_func_sha256": "de710b8ff868c8b978ae374914daad4f0d5ac6873216a44ff1afcd9f6b0ed833",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\ndouble FUN_18002d650(long param_1,char param_2,bool param_3)\n{\n  double dVar1;\n  double dVar2;\n  if (param_2 == '\\0') {\n    dVar1 = CAAEquinoxesAndSolstices::NorthwardEquinox(param_1 + 1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::SouthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  else {\n    dVar1 = CAAEquinoxesAndSolstices::SouthwardEquinox(param_1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::NorthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  return dVar1;\n}",
        "output": "```c\ndouble calculateSeasonalDifference(long param_1, char param_2, bool param_3)\n{\n    double result;\n    double equinox;\n    double solstice;\n    \n    if (param_2 == '\\0') {\n        equinox = CAAEquinoxesAndSolstices::NorthwardEquinox(param_1 + 1, param_3);\n        solstice = CAAEquinoxesAndSolstices::SouthernSolstice(param_1, param_3);\n        result = equinox - solstice;\n    } else {\n        equinox = CAAEquinoxesAndSolstices::SouthwardEquinox(param_1, param_3);\n        solstice = CAAEquinoxesAndSolstices::NorthernSolstice(param_1, param_3);\n        result = equinox - solstice;\n    }\n    \n    return result;\n}\n```",
        "source_code": "double CAAEquinoxesAndSolstices::LengthOfSummer(long Year, bool bNorthernHemisphere, bool bHighPrecision) noexcept\r\n{\r\n  if (bNorthernHemisphere)\r\n    return SouthwardEquinox(Year, bHighPrecision) - NorthernSolstice(Year, bHighPrecision);\r\n  else\r\n  {\r\n    //The Summer season wraps around into the following year for the southern hemisphere\r\n    return NorthwardEquinox(Year + 1, bHighPrecision) - SouthernSolstice(Year, bHighPrecision);\r\n  }\r\n}",
        "parsed_output": "double calculateSeasonalDifference(long param_1, char param_2, bool param_3)\n{\n    double result;\n    double equinox;\n    double solstice;\n    \n    if (param_2 == '\\0') {\n        equinox = CAAEquinoxesAndSolstices::NorthwardEquinox(param_1 + 1, param_3);\n        solstice = CAAEquinoxesAndSolstices::SouthernSolstice(param_1, param_3);\n        result = equinox - solstice;\n    } else {\n        equinox = CAAEquinoxesAndSolstices::SouthwardEquinox(param_1, param_3);\n        solstice = CAAEquinoxesAndSolstices::NorthernSolstice(param_1, param_3);\n        result = equinox - solstice;\n    }\n    \n    return result;\n}",
        "baseline_code_stripped": "double FUN_18002d650(long param_1,char param_2,bool param_3)\n{\n  double dVar1;\n  double dVar2;\n  if (param_2 == '\\0') {\n    dVar1 = CAAEquinoxesAndSolstices::NorthwardEquinox(param_1 + 1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::SouthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  else {\n    dVar1 = CAAEquinoxesAndSolstices::SouthwardEquinox(param_1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::NorthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  return dVar1;\n}",
        "similarity_score_unixcoder": 0.7017641663551331,
        "similarity_score_baseline_stripped": 0.5614171624183655
    },
    {
        "func_name": "Scm_S32VectorSet",
        "normed_func_sha256": "747814e3360de27d88c17c45d311f75c97043d5c39faf4a77b6b7c2eea7dd68a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint Scm_S32VectorSet(int param_1,int param_2,undefined4 param_3,undefined4 param_4)\n{\n  undefined4 uVar1;\n  if ((param_2 < 0) || (*(int *)(param_1 + 4) >> 1 <= param_2)) {\n    Scm_Error(\"index out of range: %d\",param_2);\n  }\n  if ((*(byte *)(param_1 + 4) & 1) != 0) {\n    Scm_Error(\"uniform vector is immutable: %S\",param_1);\n  }\n  uVar1 = Scm_GetInteger32Clamp(param_3,param_4,0);\n  *(undefined4 *)(*(int *)(param_1 + 0xc) + param_2 * 4) = uVar1;\n  return param_1;\n}",
        "output": "int Scm_S32VectorSet(int vector, int index, undefined4 value1, undefined4 value2)\n{\n    undefined4 clampedValue = Scm_GetInteger32Clamp(value1, value2, 0);\n    \n    if (index < 0 || (*(int *)(vector + 4) >> 1 <= index)) {\n        Scm_Error(\"index out of range: %d\", index);\n    }\n    \n    if ((*(byte *)(vector + 4) & 1) != 0) {\n        Scm_Error(\"uniform vector is immutable: %S\", vector);\n    }\n    \n    *(undefined4 *)(*(int *)(vector + 0xc) + index * 4) = clampedValue;\n    \n    return vector;\n}",
        "source_code": "ScmObj Scm_S32VectorSet(ScmS32Vector *vec, int index, ScmObj val, int clamp)\n{\n    ScmInt32 elt;\n    if (index < 0 || index >= SCM_S32VECTOR_SIZE(vec))\n        Scm_Error(\"index out of range: %d\", index);\n    SCM_UVECTOR_CHECK_MUTABLE(vec);\n    elt = (ScmInt32)Scm_GetInteger32Clamp(val, clamp, NULL);\n    SCM_S32VECTOR_ELEMENTS(vec)[index] = elt;\n    return SCM_OBJ(vec);\n}",
        "parsed_output": "int Scm_S32VectorSet(int vector, int index, undefined4 value1, undefined4 value2)\n{\n    undefined4 clampedValue = Scm_GetInteger32Clamp(value1, value2, 0);\n    \n    if (index < 0 || (*(int *)(vector + 4) >> 1 <= index)) {\n        Scm_Error(\"index out of range: %d\", index);\n    }\n    \n    if ((*(byte *)(vector + 4) & 1) != 0) {\n        Scm_Error(\"uniform vector is immutable: %S\", vector);\n    }\n    \n    *(undefined4 *)(*(int *)(vector + 0xc) + index * 4) = clampedValue;\n    \n    return vector;\n}",
        "baseline_code_stripped": "int Scm_S32VectorSet(int param_1,int param_2,undefined4 param_3,undefined4 param_4)\n{\n  undefined4 uVar1;\n  if ((param_2 < 0) || (*(int *)(param_1 + 4) >> 1 <= param_2)) {\n    Scm_Error(\"index out of range: %d\",param_2);\n  }\n  if ((*(byte *)(param_1 + 4) & 1) != 0) {\n    Scm_Error(\"uniform vector is immutable: %S\",param_1);\n  }\n  uVar1 = Scm_GetInteger32Clamp(param_3,param_4,0);\n  *(undefined4 *)(*(int *)(param_1 + 0xc) + param_2 * 4) = uVar1;\n  return param_1;\n}",
        "similarity_score_unixcoder": 0.7787382006645203,
        "similarity_score_baseline_stripped": 0.7355295419692993
    },
    {
        "func_name": "rtw89_ops_add_interface",
        "normed_func_sha256": "e412389363a5bbe12a8c36cbbf208b0c9c41f543489e2645bf58beb28294b68b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint rtw89_ops_add_interface(long param_1,long param_2)\n{\n  long lVar1;\n  char cVar2;\n  int iVar3;\n  long lVar4;\n  long lVar5;\n  long *plVar6;\n  lVar1 = param_2 + 0x408;\n  lVar5 = *(long *)(param_1 + 0x50);\n  mutex_lock(lVar5 + 0x298);\n  *(long *)(param_2 + 0x418) = lVar5;\n  plVar6 = *(long **)(lVar5 + 0x2c0);\n  cVar2 = __list_add_valid(lVar1,plVar6,lVar5 + 0x2b8);\n  if (cVar2 != '\\0') {\n    *(long *)(lVar5 + 0x2c0) = lVar1;\n    *(long *)(param_2 + 0x408) = lVar5 + 0x2b8;\n    *(long **)(param_2 + 0x410) = plVar6;\n    *plVar6 = lVar1;\n  }\n  *(undefined8 *)(param_2 + 0x440) = 0xfffffffe0;\n  *(long *)(param_2 + 0x448) = param_2 + 0x448;\n  *(long *)(param_2 + 0x450) = param_2 + 0x448;\n  *(code **)(param_2 + 0x458) = rtw89_core_update_beacon_work;\n  rtw89_leave_ps_mode(lVar5);\n  rtw89_traffic_stats_init(lVar5,param_2 + 0x500);\n  rtw89_vif_type_mapping(param_2,0);\n  cVar2 = rtw89_core_acquire_bit_map(lVar5 + 0x5c0,5);\n  *(char *)(param_2 + 0x421) = cVar2;\n  if (cVar2 == '\\x05') {\n    iVar3 = -0x1c;\n  }\n  else {\n    *(undefined2 *)(param_2 + 0x42e) = 0;\n    *(undefined2 *)(param_2 + 0x434) = 0;\n    *(undefined4 *)(param_2 + 0x422) = *(undefined4 *)(param_2 + 0x3dc);\n    *(undefined2 *)(param_2 + 0x426) = *(undefined2 *)(param_2 + 0x3e0);\n    iVar3 = rtw89_mac_add_vif(lVar5,lVar1);\n    if (iVar3 == 0) {\n      lVar4 = *(long *)(param_2 + 1000);\n      if (lVar4 != 0) {\n        *(long *)(lVar4 + 0x18) = lVar4 + 0x18;\n        *(long *)(lVar4 + 0x20) = lVar4 + 0x18;\n      }\n      rtw89_btc_ntfy_role_info(lVar5,lVar1,0,0);\n      rtw89_recalc_lps(lVar5);\n    }\n    else {\n      rtw89_core_release_bit_map(lVar5 + 0x5c0,*(undefined *)(param_2 + 0x421));\n    }\n  }\n  mutex_unlock(lVar5 + 0x298);\n  return iVar3;\n}",
        "output": "```c\nint rtw89_ops_add_interface(long param_1, long param_2)\n{\n    long lVar1;\n    char cVar2;\n    int iVar3;\n    long lVar4;\n    long lVar5;\n    long *plVar6;\n    \n    lVar1 = param_2 + 0x408;\n    lVar5 = *(long *)(param_1 + 0x50);\n    mutex_lock(lVar5 + 0x298);\n    \n    *(long *)(param_2 + 0x418) = lVar5;\n    plVar6 = *(long **)(lVar5 + 0x2c0);\n    cVar2 = __list_add_valid(lVar1, plVar6, lVar5 + 0x2b8);\n    \n    if (cVar2 != '\\0') {\n        *(long *)(lVar5 + 0x2c0) = lVar1;\n        *(long *)(param_2 + 0x408) = lVar5 + 0x2b8;\n        *(long **)(param_2 + 0x410) = plVar6;\n        *plVar6 = lVar1;\n    }\n    \n    *(undefined8 *)(param_2 + 0x440) = 0xfffffffe0;\n    *(long *)(param_2 + 0x448) = param_2 + 0x448;\n    *(long *)(param_2 + 0x450) = param_2 + 0x448;\n    *(code **)(param_2 + 0x458) = rtw89_core_update_beacon_work;\n    \n    rtw89_leave_ps_mode(lVar5);\n    rtw89_traffic_stats_init(lVar5, param_2 + 0x500);\n    rtw89_vif_type_mapping(param_2, 0);\n    \n    cVar2 = rtw89_core_acquire_bit_map(lVar5 + 0x5c0, 5);\n    *(char *)(param_2 + 0x421) = cVar2;\n    \n    if (cVar2 == '\\x05') {\n        iVar3 = -0x1c;\n    }\n    else {\n        *(undefined2 *)(param_2 + 0x42e) = 0;\n        *(undefined2 *)(param_2 + 0x434) = 0;\n        *(undefined4 *)(param_2 + 0x422) = *(undefined4 *)(param_2 + 0x3dc);\n        *(undefined2 *)(param_2 + 0x426) = *(undefined2 *)(param_2 + 0x3e0);\n        \n        iVar3 = rtw89_mac_add_vif(lVar5, lVar1);\n        \n        if (iVar3 == 0) {\n            lVar4 = *(long *)(param_2 + 1000);\n            \n            if (lVar4 != 0) {\n                *(long *)(lVar4 + 0x18) = lVar4 + 0x18;\n                *(long *)(lVar4 + 0x20) = lVar4 + 0x18;\n            }\n            \n            rtw89_btc_ntfy_role_info(lVar5, lVar1, 0, 0);\n            rtw89_recalc_lps(lVar5);\n        }\n        else {\n            rtw89_core_release_bit_map(lVar5 + 0x5c0, *(undefined *)(param_2 + 0x421));\n        }\n    }\n    \n    mutex_unlock(lVar5 + 0x298);\n    return iVar3;\n}\n```",
        "source_code": "static int rtw89_ops_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tint ret = 0;\n\n\trtw89_debug(rtwdev, RTW89_DBG_STATE, \"add vif %pM type %d, p2p %d\\n\",\n\t\t    vif->addr, vif->type, vif->p2p);\n\n\tmutex_lock(&rtwdev->mutex);\n\trtwvif->rtwdev = rtwdev;\n\tlist_add_tail(&rtwvif->list, &rtwdev->rtwvifs_list);\n\tINIT_WORK(&rtwvif->update_beacon_work, rtw89_core_update_beacon_work);\n\trtw89_leave_ps_mode(rtwdev);\n\n\trtw89_traffic_stats_init(rtwdev, &rtwvif->stats);\n\trtw89_vif_type_mapping(vif, false);\n\trtwvif->port = rtw89_core_acquire_bit_map(rtwdev->hw_port,\n\t\t\t\t\t\t  RTW89_PORT_NUM);\n\tif (rtwvif->port == RTW89_PORT_NUM) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\trtwvif->bcn_hit_cond = 0;\n\trtwvif->mac_idx = RTW89_MAC_0;\n\trtwvif->phy_idx = RTW89_PHY_0;\n\trtwvif->hit_rule = 0;\n\tether_addr_copy(rtwvif->mac_addr, vif->addr);\n\n\tret = rtw89_mac_add_vif(rtwdev, rtwvif);\n\tif (ret) {\n\t\trtw89_core_release_bit_map(rtwdev->hw_port, rtwvif->port);\n\t\tgoto out;\n\t}\n\n\trtw89_core_txq_init(rtwdev, vif->txq);\n\n\trtw89_btc_ntfy_role_info(rtwdev, rtwvif, NULL, BTC_ROLE_START);\n\n\trtw89_recalc_lps(rtwdev);\nout:\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}",
        "parsed_output": "int rtw89_ops_add_interface(long param_1, long param_2)\n{\n    long lVar1;\n    char cVar2;\n    int iVar3;\n    long lVar4;\n    long lVar5;\n    long *plVar6;\n    \n    lVar1 = param_2 + 0x408;\n    lVar5 = *(long *)(param_1 + 0x50);\n    mutex_lock(lVar5 + 0x298);\n    \n    *(long *)(param_2 + 0x418) = lVar5;\n    plVar6 = *(long **)(lVar5 + 0x2c0);\n    cVar2 = __list_add_valid(lVar1, plVar6, lVar5 + 0x2b8);\n    \n    if (cVar2 != '\\0') {\n        *(long *)(lVar5 + 0x2c0) = lVar1;\n        *(long *)(param_2 + 0x408) = lVar5 + 0x2b8;\n        *(long **)(param_2 + 0x410) = plVar6;\n        *plVar6 = lVar1;\n    }\n    \n    *(undefined8 *)(param_2 + 0x440) = 0xfffffffe0;\n    *(long *)(param_2 + 0x448) = param_2 + 0x448;\n    *(long *)(param_2 + 0x450) = param_2 + 0x448;\n    *(code **)(param_2 + 0x458) = rtw89_core_update_beacon_work;\n    \n    rtw89_leave_ps_mode(lVar5);\n    rtw89_traffic_stats_init(lVar5, param_2 + 0x500);\n    rtw89_vif_type_mapping(param_2, 0);\n    \n    cVar2 = rtw89_core_acquire_bit_map(lVar5 + 0x5c0, 5);\n    *(char *)(param_2 + 0x421) = cVar2;\n    \n    if (cVar2 == '\\x05') {\n        iVar3 = -0x1c;\n    }\n    else {\n        *(undefined2 *)(param_2 + 0x42e) = 0;\n        *(undefined2 *)(param_2 + 0x434) = 0;\n        *(undefined4 *)(param_2 + 0x422) = *(undefined4 *)(param_2 + 0x3dc);\n        *(undefined2 *)(param_2 + 0x426) = *(undefined2 *)(param_2 + 0x3e0);\n        \n        iVar3 = rtw89_mac_add_vif(lVar5, lVar1);\n        \n        if (iVar3 == 0) {\n            lVar4 = *(long *)(param_2 + 1000);\n            \n            if (lVar4 != 0) {\n                *(long *)(lVar4 + 0x18) = lVar4 + 0x18;\n                *(long *)(lVar4 + 0x20) = lVar4 + 0x18;\n            }\n            \n            rtw89_btc_ntfy_role_info(lVar5, lVar1, 0, 0);\n            rtw89_recalc_lps(lVar5);\n        }\n        else {\n            rtw89_core_release_bit_map(lVar5 + 0x5c0, *(undefined *)(param_2 + 0x421));\n        }\n    }\n    \n    mutex_unlock(lVar5 + 0x298);\n    return iVar3;\n}",
        "baseline_code_stripped": "int rtw89_ops_add_interface(long param_1,long param_2)\n{\n  long lVar1;\n  char cVar2;\n  int iVar3;\n  long lVar4;\n  long lVar5;\n  long *plVar6;\n  lVar1 = param_2 + 0x408;\n  lVar5 = *(long *)(param_1 + 0x50);\n  mutex_lock(lVar5 + 0x298);\n  *(long *)(param_2 + 0x418) = lVar5;\n  plVar6 = *(long **)(lVar5 + 0x2c0);\n  cVar2 = __list_add_valid(lVar1,plVar6,lVar5 + 0x2b8);\n  if (cVar2 != '\\0') {\n    *(long *)(lVar5 + 0x2c0) = lVar1;\n    *(long *)(param_2 + 0x408) = lVar5 + 0x2b8;\n    *(long **)(param_2 + 0x410) = plVar6;\n    *plVar6 = lVar1;\n  }\n  *(undefined8 *)(param_2 + 0x440) = 0xfffffffe0;\n  *(long *)(param_2 + 0x448) = param_2 + 0x448;\n  *(long *)(param_2 + 0x450) = param_2 + 0x448;\n  *(code **)(param_2 + 0x458) = rtw89_core_update_beacon_work;\n  rtw89_leave_ps_mode(lVar5);\n  rtw89_traffic_stats_init(lVar5,param_2 + 0x500);\n  rtw89_vif_type_mapping(param_2,0);\n  cVar2 = rtw89_core_acquire_bit_map(lVar5 + 0x5c0,5);\n  *(char *)(param_2 + 0x421) = cVar2;\n  if (cVar2 == '\\x05') {\n    iVar3 = -0x1c;\n  }\n  else {\n    *(undefined2 *)(param_2 + 0x42e) = 0;\n    *(undefined2 *)(param_2 + 0x434) = 0;\n    *(undefined4 *)(param_2 + 0x422) = *(undefined4 *)(param_2 + 0x3dc);\n    *(undefined2 *)(param_2 + 0x426) = *(undefined2 *)(param_2 + 0x3e0);\n    iVar3 = rtw89_mac_add_vif(lVar5,lVar1);\n    if (iVar3 == 0) {\n      lVar4 = *(long *)(param_2 + 1000);\n      if (lVar4 != 0) {\n        *(long *)(lVar4 + 0x18) = lVar4 + 0x18;\n        *(long *)(lVar4 + 0x20) = lVar4 + 0x18;\n      }\n      rtw89_btc_ntfy_role_info(lVar5,lVar1,0,0);\n      rtw89_recalc_lps(lVar5);\n    }\n    else {\n      rtw89_core_release_bit_map(lVar5 + 0x5c0,*(undefined *)(param_2 + 0x421));\n    }\n  }\n  mutex_unlock(lVar5 + 0x298);\n  return iVar3;\n}",
        "similarity_score_unixcoder": 0.702107310295105,
        "similarity_score_baseline_stripped": 0.6887228488922119
    },
    {
        "func_name": "imap_appenduid",
        "normed_func_sha256": "5e356651556c06d457242e6b3cfe55e6221a6c8cf7f642fb73c9e7899908ca3c",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 __regparm3\nFUN_08060340(void *param_1_00,undefined4 param_2_00,undefined4 param_3_00,int param_1,\n            undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,\n            undefined4 param_6)\n{\n  int iVar1;\n  char **ppcVar2;\n  byte bVar3;\n  char *local_20d8;\n  undefined4 local_20d4;\n  int local_20cc;\n  int local_20c8;\n  undefined4 local_20c4;\n  undefined4 local_20c0;\n  undefined4 local_20bc;\n  undefined4 local_20b8;\n  undefined4 local_20b4;\n  ulong local_2090;\n  char *local_2080;\n  undefined4 local_207c;\n  undefined4 local_2078;\n  ulong local_205c;\n  undefined4 local_2054;\n  undefined4 local_2050;\n  bVar3 = 0;\n  iVar1 = FUN_08088df0(DAT_08098edc,\"[APPENDUID \");\n  if (iVar1 != 0) {\n    local_205c = strtoul((char *)(iVar1 + 0xb),&local_20d8,10);\n    local_2090 = strtoul(local_20d8,&local_2080,10);\n    if ((((local_205c != 0) && (local_2090 != 0)) && ((char *)(iVar1 + 0xb) < local_20d8)) &&\n       (((*local_20d8 == ' ' && (local_20d8 < local_2080)) && (*local_2080 == ']')))) {\n      memcpy(&local_2080,param_1_00,0x2064);\n      local_2050 = 0;\n      local_2054 = FUN_080880d0(param_6);\n      local_207c = param_2_00;\n      local_2078 = param_2_00;\n      FUN_080697d0(&local_2080);\n      ppcVar2 = &local_20d8;\n      for (iVar1 = 0x16; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *ppcVar2 = (char *)0x0;\n        ppcVar2 = ppcVar2 + (uint)bVar3 * -2 + 1;\n      }\n      local_20d8 = (char *)CONCAT31((uint3)((uint)param_5 >> 8) & 1,0x80);\n      local_20d4 = 3;\n      local_20cc = param_1 + 0xfff;\n      if (-1 < param_1) {\n        local_20cc = param_1;\n      }\n      local_20cc = local_20cc >> 0xc;\n      local_20c8 = param_1 % 0x1000;\n      local_20c4 = param_3;\n      local_20c0 = param_2;\n      local_20b8 = param_4;\n      local_20bc = param_4;\n      local_20b4 = param_3_00;\n      FUN_08069260(&local_2080,&local_20d8);\n      return 1;\n    }\n  }\n  return 0;\n}",
        "output": "```c\nint append_uid(void *data, int data_length, int param1, int param2, int param3, int param4, int param5, int param6) {\n    int result = 0;\n    int index = find_string(data, \"[APPENDUID \");\n    \n    if (index != 0) {\n        ulong uid1 = strtoul((char *)(index + 0xb), &data, 10);\n        ulong uid2 = strtoul(data, &data, 10);\n        \n        if (uid1 != 0 && uid2 != 0 && (char *)(index + 0xb) < data && *data == ' ' && data < &data && *data == ']') {\n            memcpy(&data, data, 0x2064);\n            int temp = 0;\n            int temp2 = get_value(param6);\n            int temp3 = data_length;\n            int temp4 = data_length;\n            process_data(&data);\n            \n            for (int i = 0x16; i != 0; i--) {\n                data = NULL;\n            }\n            \n            data = (char *)0x80;\n            int temp5 = 3;\n            int temp6 = param1 + 0xfff;\n            \n            if (param1 >= -1) {\n                temp6 = param1;\n            }\n            \n            temp6 = temp6 >> 0xc;\n            int temp7 = param1 % 0x1000;\n            int temp8 = param3;\n            int temp9 = param2;\n            int temp10 = param4;\n            int temp11 = param4;\n            int temp12 = data_length;\n            \n            process_data(&data, &data);\n            result = 1;\n        }\n    }\n    \n    return result;\n}\n```",
        "source_code": "static enum okay\nimap_appenduid(struct mailbox *mp, FILE *fp, time_t t, long off1,\n\t\tlong xsize, long size, long lines, int flag, const char *name)\n{\n\tconst char\t*cp;\n\tunsigned long\tuidvalidity, uid;\n\tstruct mailbox\txmb;\n\tstruct message\txm;\n\tif ((cp = asccasestr(responded_text, \"[APPENDUID \")) == NULL ||\n\t\t\timap_appenduid_parse(&cp[11], &uidvalidity,\n\t\t\t\t&uid) == STOP)\n\t\treturn STOP;\n\txmb = *mp;\n\txmb.mb_cache_directory = NULL;\n\txmb.mb_imap_mailbox = savestr(name);\n\txmb.mb_uidvalidity = uidvalidity;\n\txmb.mb_otf = xmb.mb_itf = fp;\n\tinitcache(&xmb);\n\tmemset(&xm, 0, sizeof xm);\n\txm.m_flag = (flag & MREAD) | MNEW;\n\txm.m_time = t;\n\txm.m_block = mailx_blockof(off1);\n\txm.m_offset = mailx_offsetof(off1);\n\txm.m_size = size;\n\txm.m_xsize = xsize;\n\txm.m_lines = xm.m_xlines = lines;\n\txm.m_uid = uid;\n\txm.m_have = HAVE_HEADER|HAVE_BODY;\n\tputcache(&xmb, &xm);\n\treturn OKAY;\n}",
        "parsed_output": "int append_uid(void *data, int data_length, int param1, int param2, int param3, int param4, int param5, int param6) {\n    int result = 0;\n    int index = find_string(data, \"[APPENDUID \");\n    \n    if (index != 0) {\n        ulong uid1 = strtoul((char *)(index + 0xb), &data, 10);\n        ulong uid2 = strtoul(data, &data, 10);\n        \n        if (uid1 != 0 && uid2 != 0 && (char *)(index + 0xb) < data && *data == ' ' && data < &data && *data == ']') {\n            memcpy(&data, data, 0x2064);\n            int temp = 0;\n            int temp2 = get_value(param6);\n            int temp3 = data_length;\n            int temp4 = data_length;\n            process_data(&data);\n            \n            for (int i = 0x16; i != 0; i--) {\n                data = NULL;\n            }\n            \n            data = (char *)0x80;\n            int temp5 = 3;\n            int temp6 = param1 + 0xfff;\n            \n            if (param1 >= -1) {\n                temp6 = param1;\n            }\n            \n            temp6 = temp6 >> 0xc;\n            int temp7 = param1 % 0x1000;\n            int temp8 = param3;\n            int temp9 = param2;\n            int temp10 = param4;\n            int temp11 = param4;\n            int temp12 = data_length;\n            \n            process_data(&data, &data);\n            result = 1;\n        }\n    }\n    \n    return result;\n}",
        "baseline_code_stripped": "undefined4 __regparm3\nFUN_08060340(void *param_1_00,undefined4 param_2_00,undefined4 param_3_00,int param_1,\n            undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,\n            undefined4 param_6)\n{\n  int iVar1;\n  char **ppcVar2;\n  byte bVar3;\n  char *local_20d8;\n  undefined4 local_20d4;\n  int local_20cc;\n  int local_20c8;\n  undefined4 local_20c4;\n  undefined4 local_20c0;\n  undefined4 local_20bc;\n  undefined4 local_20b8;\n  undefined4 local_20b4;\n  ulong local_2090;\n  char *local_2080;\n  undefined4 local_207c;\n  undefined4 local_2078;\n  ulong local_205c;\n  undefined4 local_2054;\n  undefined4 local_2050;\n  bVar3 = 0;\n  iVar1 = FUN_08088df0(DAT_08098edc,\"[APPENDUID \");\n  if (iVar1 != 0) {\n    local_205c = strtoul((char *)(iVar1 + 0xb),&local_20d8,10);\n    local_2090 = strtoul(local_20d8,&local_2080,10);\n    if ((((local_205c != 0) && (local_2090 != 0)) && ((char *)(iVar1 + 0xb) < local_20d8)) &&\n       (((*local_20d8 == ' ' && (local_20d8 < local_2080)) && (*local_2080 == ']')))) {\n      memcpy(&local_2080,param_1_00,0x2064);\n      local_2050 = 0;\n      local_2054 = FUN_080880d0(param_6);\n      local_207c = param_2_00;\n      local_2078 = param_2_00;\n      FUN_080697d0(&local_2080);\n      ppcVar2 = &local_20d8;\n      for (iVar1 = 0x16; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *ppcVar2 = (char *)0x0;\n        ppcVar2 = ppcVar2 + (uint)bVar3 * -2 + 1;\n      }\n      local_20d8 = (char *)CONCAT31((uint3)((uint)param_5 >> 8) & 1,0x80);\n      local_20d4 = 3;\n      local_20cc = param_1 + 0xfff;\n      if (-1 < param_1) {\n        local_20cc = param_1;\n      }\n      local_20cc = local_20cc >> 0xc;\n      local_20c8 = param_1 % 0x1000;\n      local_20c4 = param_3;\n      local_20c0 = param_2;\n      local_20b8 = param_4;\n      local_20bc = param_4;\n      local_20b4 = param_3_00;\n      FUN_08069260(&local_2080,&local_20d8);\n      return 1;\n    }\n  }\n  return 0;\n}",
        "similarity_score_unixcoder": 0.5949592590332031,
        "similarity_score_baseline_stripped": 0.4950212240219116
    },
    {
        "func_name": "nmethod::nmethod",
        "normed_func_sha256": "33f94793a5dc5183748e51c1dda09a5fb6c2f4d17ce64b9274e01d73a39b4d93",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0037a4e8(undefined8 *param_1,undefined8 param_2,undefined param_3,undefined4 param_4,\n                 undefined4 param_5,long param_6,long param_7,undefined8 param_8,undefined4 param_9,\n                 undefined4 param_10,undefined4 param_11,undefined4 param_12_00,undefined8 param_12)\n{\n  short sVar1;\n  undefined8 uVar2;\n  undefined auStack_8 [8];\n  FUN_0023abf8(param_1,\"native nmethod\",1,param_7,param_4,0xd8,*(undefined2 *)(param_6 + 8),param_8,\n               param_12,0);\n  param_1[7] = 0;\n  *param_1 = &PTR_LAB_004fa598;\n  uVar2 = FUN_002400ec();\n  param_1[8] = uVar2;\n  param_1[9] = param_2;\n  *(undefined4 *)(param_1 + 10) = param_9;\n  *(undefined4 *)((long)param_1 + 0x54) = param_11;\n  FUN_00375c50(param_1,param_7,param_6);\n  *(undefined *)((long)param_1 + 0xcc) = 0;\n  *(undefined4 *)((long)param_1 + 0x94) = 0xffffffff;\n  *(undefined *)((long)param_1 + 0xcd) = param_3;\n  param_1[0xc] = 0;\n  param_1[0x11] = 0;\n  *(undefined4 *)((long)param_1 + 0xc4) = 0;\n  *(undefined4 *)(param_1 + 0x19) = param_5;\n  *(undefined2 *)((long)param_1 + 0xb2) = *(undefined2 *)(*(long *)(param_1[9] + 8) + 0x30);\n  if (*(int *)(param_6 + 0x10) == -1) {\n    *(undefined4 *)((long)param_1 + 0xa4) = 0;\n  }\n  else {\n    *(int *)((long)param_1 + 0xa4) = *(int *)((long)param_1 + 0x24) + *(int *)(param_6 + 0x10);\n  }\n  *(undefined2 *)(param_1 + 0x16) = 0;\n  param_1[0x15] = 0;\n  if (*(long *)(param_7 + 0x130) == 0) {\n    sVar1 = 0;\n  }\n  else {\n    sVar1 = FUN_003857f0(*(long *)(param_7 + 0x130) + 8);\n  }\n  *(ushort *)((long)param_1 + 0xb4) = sVar1 + 7U & 0xfff8;\n  FUN_0037ad4c(param_7);\n  *(undefined4 *)(param_1 + 0x13) = 0;\n  *(undefined4 *)((long)param_1 + 0xb6) = 0;\n  *(undefined8 *)((long)param_1 + 0xbc) = 0;\n  param_1[0xb] = (long)param_1 + (long)*(int *)(param_1 + 3);\n  FUN_0023e344(param_7,param_1);\n  FUN_0023e9f0(param_7,param_1);\n  FUN_0037ad64(param_7,param_1);\n  FUN_00378f30(param_1);\n  if (DAT_0051549e != '\\0') {\n    FUN_002492c8(auStack_8);\n    if (DAT_0054cc40 != 0) {\n      FUN_0046a004(DAT_0054cc40,\"print_native_nmethod\");\n      FUN_0046a5ec(DAT_0054cc40,param_1[9]);\n      FUN_0046a2f0(DAT_0054cc40);\n      FUN_0046a188(DAT_0054cc40,\" address=\\'0x%016lx\\'\",param_1);\n    }\n    if (DAT_0051549e == '\\0') {\n      FUN_00377f6c(param_1);\n    }\n    else {\n      FUN_0039e450(PTR_DAT_00507218,\n                   \"-------------------------- Assembly (native nmethod) ---------------------------\"\n                  );\n      FUN_0037a488(param_1);\n      FUN_0039e450(PTR_DAT_00507218,\n                   \"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \"\n                  );\n    }\n    if (DAT_0054cc40 != 0) {\n      FUN_0046a214(DAT_0054cc40,\"print_native_nmethod\");\n    }\n    FUN_002492ec(auStack_8);\n  }\n  return;\n}",
        "output": "void createNativeNMethod(undefined8 *param_1, undefined8 param_2, undefined param_3, undefined4 param_4,\n                           undefined4 param_5, long param_6, long param_7, undefined8 param_8, undefined4 param_9,\n                           undefined4 param_10, undefined4 param_11, undefined4 param_12_00, undefined8 param_12)\n{\n    short sVar1;\n    undefined8 uVar2;\n    undefined auStack_8[8];\n    \n    initializeNMethod(param_1, \"native nmethod\", 1, param_7, param_4, 0xd8, *(short *)(param_6 + 8), param_8, param_12, 0);\n    \n    param_1[7] = 0;\n    *param_1 = &PTR_LAB_004fa598;\n    \n    uVar2 = getNMethodAddress();\n    param_1[8] = uVar2;\n    param_1[9] = param_2;\n    *(undefined4 *)(param_1 + 10) = param_9;\n    *(undefined4 *)((long)param_1 + 0x54) = param_11;\n    \n    processNMethod(param_1, param_7, param_6);\n    \n    *(undefined *)((long)param_1 + 0xcc) = 0;\n    *(undefined4 *)((long)param_1 + 0x94) = 0xffffffff;\n    *(undefined *)((long)param_1 + 0xcd) = param_3;\n    param_1[0xc] = 0;\n    param_1[0x11] = 0;\n    *(undefined4 *)((long)param_1 + 0xc4) = 0;\n    *(undefined4 *)(param_1 + 0x19) = param_5;\n    *(short *)((long)param_1 + 0xb2) = *(short *)(*(long *)(param_1[9] + 8) + 0x30);\n    \n    if (*(int *)(param_6 + 0x10) == -1) {\n        *(undefined4 *)((long)param_1 + 0xa4) = 0;\n    }\n    else {\n        *(int *)((long)param_1 + 0xa4) = *(int *)((long)param_1 + 0x24) + *(int *)(param_6 + 0x10);\n    }\n    \n    *(short *)(param_1 + 0x16) = 0;\n    param_1[0x15] = 0;\n    \n    if (*(long *)(param_7 + 0x130) == 0) {\n        sVar1 = 0;\n    }\n    else {\n        sVar1 = getNMethodInfo(*(long *)(param_7 + 0x130) + 8);\n    }\n    \n    *(ushort *)((long)param_1 + 0xb4) = sVar1 + 7U & 0xfff8;\n    \n    cleanupNMethod(param_7);\n    \n    *(undefined4 *)(param_1 + 0x13) = 0;\n    *(undefined4 *)((long)param_1 + 0xb6) = 0;\n    *(undefined8 *)((long)param_1 + 0xbc) = 0;\n    param_1[0xb] = (long)param_1 + (long)*(int *)(param_1 + 3);\n    \n    processNMethodInfo(param_7, param_1);\n    processNMethodInfo(param_7, param_1);\n    processNMethodInfo(param_7, param_1);\n    processNMethodInfo(param_1);\n    \n    if (DAT_0051549e != '\\0') {\n        printNMethodInfo(auStack_8);\n        \n        if (DAT_0054cc40 != 0) {\n            printNMethod(DAT_0054cc40, \"print_native_nmethod\");\n            printNMethod(DAT_0054cc40, param_1[9]);\n            printNMethod(DAT_0054cc40);\n            printNMethod(DAT_0054cc40, \" address=\\'0x%016lx\\'\", param_1);\n        }\n        \n        if (DAT_0051549e == '\\0') {\n            cleanupNMethod(param_1);\n        }\n        else {\n            printSeparator(PTR_DAT_00507218, \"-------------------------- Assembly (native nmethod) ---------------------------\");\n            printNMethodInfo(param_1);\n            printSeparator(PTR_DAT_00507218, \"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \");\n        }\n        \n        if (DAT_0054cc40 != 0) {\n            printNMethod(DAT_0054cc40, \"print_native_nmethod\");\n        }\n        \n        cleanupNMethod(auStack_8);\n    }\n    \n    return;\n}",
        "source_code": "nmethod::nmethod(\n  methodOop method,\n  int nmethod_size,\n  int compile_id,\n  CodeOffsets* offsets,\n  CodeBuffer* code_buffer,\n  int frame_size,\n  ByteSize basic_lock_owner_sp_offset,\n  ByteSize basic_lock_sp_offset,\n  OopMapSet* oop_maps )\n  : CodeBlob(\"native nmethod\", code_buffer, sizeof(nmethod),\n             nmethod_size, offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps),\n  _native_receiver_sp_offset(basic_lock_owner_sp_offset),\n  _native_basic_lock_sp_offset(basic_lock_sp_offset)\n{\n  {\n    debug_only(No_Safepoint_Verifier nsv;)\n    assert_locked_or_safepoint(CodeCache_lock);\n\n    init_defaults();\n    _method                  = method;\n    _entry_bci               = InvocationEntryBci;\n    // We have no exception handler or deopt handler make the\n    // values something that will never match a pc like the nmethod vtable entry\n    _exception_offset        = 0;\n    _deoptimize_offset       = 0;\n    _deoptimize_mh_offset    = 0;\n    _orig_pc_offset          = 0;\n\n    _consts_offset           = data_offset();\n    _stub_offset             = data_offset();\n    _oops_offset             = data_offset();\n    _scopes_data_offset      = _oops_offset          + round_to(code_buffer->total_oop_size(), oopSize);\n    _scopes_pcs_offset       = _scopes_data_offset;\n    _dependencies_offset     = _scopes_pcs_offset;\n    _handler_table_offset    = _dependencies_offset;\n    _nul_chk_table_offset    = _handler_table_offset;\n    _nmethod_end_offset      = _nul_chk_table_offset;\n    _compile_id              = compile_id;\n    _comp_level              = CompLevel_none;\n    _entry_point             = code_begin()          + offsets->value(CodeOffsets::Entry);\n    _verified_entry_point    = code_begin()          + offsets->value(CodeOffsets::Verified_Entry);\n    _osr_entry_point         = NULL;\n    _exception_cache         = NULL;\n    _pc_desc_cache.reset_to(NULL);\n\n    code_buffer->copy_oops_to(this);\n    if (ScavengeRootsInCode && detect_scavenge_root_oops()) {\n      CodeCache::add_scavenge_root_nmethod(this);\n    }\n    debug_only(verify_scavenge_root_oops());\n    CodeCache::commit(this);\n  }\n\n  if (PrintNativeNMethods || PrintDebugInfo || PrintRelocations || PrintDependencies) {\n    ttyLocker ttyl;  // keep the following output all in one block\n    // This output goes directly to the tty, not the compiler log.\n    // To enable tools to match it up with the compilation activity,\n    // be sure to tag this tty output with the compile ID.\n    if (xtty != NULL) {\n      xtty->begin_head(\"print_native_nmethod\");\n      xtty->method(_method);\n      xtty->stamp();\n      xtty->end_head(\" address='\" INTPTR_FORMAT \"'\", (intptr_t) this);\n    }\n    // print the header part first\n    print();\n    // then print the requested information\n    if (PrintNativeNMethods) {\n      print_code();\n      oop_maps->print();\n    }\n    if (PrintRelocations) {\n      print_relocations();\n    }\n    if (xtty != NULL) {\n      xtty->tail(\"print_native_nmethod\");\n    }\n  }\n  Events::log(\"Create nmethod \" INTPTR_FORMAT, this);\n}",
        "parsed_output": "void createNativeNMethod(undefined8 *param_1, undefined8 param_2, undefined param_3, undefined4 param_4,\n                           undefined4 param_5, long param_6, long param_7, undefined8 param_8, undefined4 param_9,\n                           undefined4 param_10, undefined4 param_11, undefined4 param_12_00, undefined8 param_12)\n{\n    short sVar1;\n    undefined8 uVar2;\n    undefined auStack_8[8];\n    \n    initializeNMethod(param_1, \"native nmethod\", 1, param_7, param_4, 0xd8, *(short *)(param_6 + 8), param_8, param_12, 0);\n    \n    param_1[7] = 0;\n    *param_1 = &PTR_LAB_004fa598;\n    \n    uVar2 = getNMethodAddress();\n    param_1[8] = uVar2;\n    param_1[9] = param_2;\n    *(undefined4 *)(param_1 + 10) = param_9;\n    *(undefined4 *)((long)param_1 + 0x54) = param_11;\n    \n    processNMethod(param_1, param_7, param_6);\n    \n    *(undefined *)((long)param_1 + 0xcc) = 0;\n    *(undefined4 *)((long)param_1 + 0x94) = 0xffffffff;\n    *(undefined *)((long)param_1 + 0xcd) = param_3;\n    param_1[0xc] = 0;\n    param_1[0x11] = 0;\n    *(undefined4 *)((long)param_1 + 0xc4) = 0;\n    *(undefined4 *)(param_1 + 0x19) = param_5;\n    *(short *)((long)param_1 + 0xb2) = *(short *)(*(long *)(param_1[9] + 8) + 0x30);\n    \n    if (*(int *)(param_6 + 0x10) == -1) {\n        *(undefined4 *)((long)param_1 + 0xa4) = 0;\n    }\n    else {\n        *(int *)((long)param_1 + 0xa4) = *(int *)((long)param_1 + 0x24) + *(int *)(param_6 + 0x10);\n    }\n    \n    *(short *)(param_1 + 0x16) = 0;\n    param_1[0x15] = 0;\n    \n    if (*(long *)(param_7 + 0x130) == 0) {\n        sVar1 = 0;\n    }\n    else {\n        sVar1 = getNMethodInfo(*(long *)(param_7 + 0x130) + 8);\n    }\n    \n    *(ushort *)((long)param_1 + 0xb4) = sVar1 + 7U & 0xfff8;\n    \n    cleanupNMethod(param_7);\n    \n    *(undefined4 *)(param_1 + 0x13) = 0;\n    *(undefined4 *)((long)param_1 + 0xb6) = 0;\n    *(undefined8 *)((long)param_1 + 0xbc) = 0;\n    param_1[0xb] = (long)param_1 + (long)*(int *)(param_1 + 3);\n    \n    processNMethodInfo(param_7, param_1);\n    processNMethodInfo(param_7, param_1);\n    processNMethodInfo(param_7, param_1);\n    processNMethodInfo(param_1);\n    \n    if (DAT_0051549e != '\\0') {\n        printNMethodInfo(auStack_8);\n        \n        if (DAT_0054cc40 != 0) {\n            printNMethod(DAT_0054cc40, \"print_native_nmethod\");\n            printNMethod(DAT_0054cc40, param_1[9]);\n            printNMethod(DAT_0054cc40);\n            printNMethod(DAT_0054cc40, \" address=\\'0x%016lx\\'\", param_1);\n        }\n        \n        if (DAT_0051549e == '\\0') {\n            cleanupNMethod(param_1);\n        }\n        else {\n            printSeparator(PTR_DAT_00507218, \"-------------------------- Assembly (native nmethod) ---------------------------\");\n            printNMethodInfo(param_1);\n            printSeparator(PTR_DAT_00507218, \"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \");\n        }\n        \n        if (DAT_0054cc40 != 0) {\n            printNMethod(DAT_0054cc40, \"print_native_nmethod\");\n        }\n        \n        cleanupNMethod(auStack_8);\n    }\n    \n    return;\n}",
        "baseline_code_stripped": "void FUN_0037a4e8(undefined8 *param_1,undefined8 param_2,undefined param_3,undefined4 param_4,\n                 undefined4 param_5,long param_6,long param_7,undefined8 param_8,undefined4 param_9,\n                 undefined4 param_10,undefined4 param_11,undefined4 param_12_00,undefined8 param_12)\n{\n  short sVar1;\n  undefined8 uVar2;\n  undefined auStack_8 [8];\n  FUN_0023abf8(param_1,\"native nmethod\",1,param_7,param_4,0xd8,*(undefined2 *)(param_6 + 8),param_8,\n               param_12,0);\n  param_1[7] = 0;\n  *param_1 = &PTR_LAB_004fa598;\n  uVar2 = FUN_002400ec();\n  param_1[8] = uVar2;\n  param_1[9] = param_2;\n  *(undefined4 *)(param_1 + 10) = param_9;\n  *(undefined4 *)((long)param_1 + 0x54) = param_11;\n  FUN_00375c50(param_1,param_7,param_6);\n  *(undefined *)((long)param_1 + 0xcc) = 0;\n  *(undefined4 *)((long)param_1 + 0x94) = 0xffffffff;\n  *(undefined *)((long)param_1 + 0xcd) = param_3;\n  param_1[0xc] = 0;\n  param_1[0x11] = 0;\n  *(undefined4 *)((long)param_1 + 0xc4) = 0;\n  *(undefined4 *)(param_1 + 0x19) = param_5;\n  *(undefined2 *)((long)param_1 + 0xb2) = *(undefined2 *)(*(long *)(param_1[9] + 8) + 0x30);\n  if (*(int *)(param_6 + 0x10) == -1) {\n    *(undefined4 *)((long)param_1 + 0xa4) = 0;\n  }\n  else {\n    *(int *)((long)param_1 + 0xa4) = *(int *)((long)param_1 + 0x24) + *(int *)(param_6 + 0x10);\n  }\n  *(undefined2 *)(param_1 + 0x16) = 0;\n  param_1[0x15] = 0;\n  if (*(long *)(param_7 + 0x130) == 0) {\n    sVar1 = 0;\n  }\n  else {\n    sVar1 = FUN_003857f0(*(long *)(param_7 + 0x130) + 8);\n  }\n  *(ushort *)((long)param_1 + 0xb4) = sVar1 + 7U & 0xfff8;\n  FUN_0037ad4c(param_7);\n  *(undefined4 *)(param_1 + 0x13) = 0;\n  *(undefined4 *)((long)param_1 + 0xb6) = 0;\n  *(undefined8 *)((long)param_1 + 0xbc) = 0;\n  param_1[0xb] = (long)param_1 + (long)*(int *)(param_1 + 3);\n  FUN_0023e344(param_7,param_1);\n  FUN_0023e9f0(param_7,param_1);\n  FUN_0037ad64(param_7,param_1);\n  FUN_00378f30(param_1);\n  if (DAT_0051549e != '\\0') {\n    FUN_002492c8(auStack_8);\n    if (DAT_0054cc40 != 0) {\n      FUN_0046a004(DAT_0054cc40,\"print_native_nmethod\");\n      FUN_0046a5ec(DAT_0054cc40,param_1[9]);\n      FUN_0046a2f0(DAT_0054cc40);\n      FUN_0046a188(DAT_0054cc40,\" address=\\'0x%016lx\\'\",param_1);\n    }\n    if (DAT_0051549e == '\\0') {\n      FUN_00377f6c(param_1);\n    }\n    else {\n      FUN_0039e450(PTR_DAT_00507218,\n                   \"-------------------------- Assembly (native nmethod) ---------------------------\"\n                  );\n      FUN_0037a488(param_1);\n      FUN_0039e450(PTR_DAT_00507218,\n                   \"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \"\n                  );\n    }\n    if (DAT_0054cc40 != 0) {\n      FUN_0046a214(DAT_0054cc40,\"print_native_nmethod\");\n    }\n    FUN_002492ec(auStack_8);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.5222694277763367,
        "similarity_score_baseline_stripped": 0.4730994999408722
    },
    {
        "func_name": "geary_app_local_load_operation_real_execute_async_co",
        "normed_func_sha256": "588dfdb7ad76474622e3a5a6ace14cf7983b04d33782202ab9dc62edfbb0cf31",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 geary_app_local_load_operation_real_execute_async_co(int *param_1)\n{\n  undefined8 uVar1;\n  long lVar2;\n  if (*param_1 == 0) {\n    *(undefined8 *)(param_1 + 10) = 0;\n    uVar1 = geary_app_conversation_operation_get_type();\n    lVar2 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 8),uVar1);\n    uVar1 = *(undefined8 *)(lVar2 + 0x28);\n    *param_1 = 1;\n    *(undefined8 *)(param_1 + 10) = uVar1;\n    geary_app_conversation_monitor_local_load_async\n              (uVar1,geary_app_local_load_operation_execute_async_ready,param_1);\n    return 0;\n  }\n  if (*param_1 == 1) {\n    geary_app_conversation_monitor_local_load_finish\n              (*(undefined8 *)(param_1 + 10),*(undefined8 *)(param_1 + 4));\n    if (*param_1 == 0) {\n      g_simple_async_result_complete_in_idle(*(undefined8 *)(param_1 + 6));\n    }\n    else {\n      g_simple_async_result_complete();\n    }\n    g_object_unref(*(undefined8 *)(param_1 + 6));\n    return 0;\n  }\n  g_assertion_message_expr\n            (0,\n             \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n             ,0xc,\"geary_app_local_load_operation_real_execute_async_co\",0);\n}",
        "output": "```c\nundefined8 geary_app_local_load_operation_real_execute_async_co(int *param_1)\n{\n    undefined8 uVar1;\n    long lVar2;\n    \n    if (*param_1 == 0) {\n        *(undefined8 *)(param_1 + 10) = 0;\n        uVar1 = geary_app_conversation_operation_get_type();\n        lVar2 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 8), uVar1);\n        uVar1 = *(undefined8 *)(lVar2 + 0x28);\n        *param_1 = 1;\n        *(undefined8 *)(param_1 + 10) = uVar1;\n        geary_app_conversation_monitor_local_load_async(uVar1, geary_app_local_load_operation_execute_async_ready, param_1);\n        return 0;\n    }\n    \n    if (*param_1 == 1) {\n        geary_app_conversation_monitor_local_load_finish(*(undefined8 *)(param_1 + 10), *(undefined8 *)(param_1 + 4));\n        \n        if (*param_1 == 0) {\n            g_simple_async_result_complete_in_idle(*(undefined8 *)(param_1 + 6));\n        } else {\n            g_simple_async_result_complete();\n        }\n        \n        g_object_unref(*(undefined8 *)(param_1 + 6));\n        return 0;\n    }\n    \n    g_assertion_message_expr(0, \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\", 0xc, \"geary_app_local_load_operation_real_execute_async_co\", 0);\n}\n```",
        "source_code": "static gboolean geary_app_local_load_operation_real_execute_async_co (GearyAppLocalLoadOperationExecuteAsyncData* _data_) {\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\tswitch (_data_->_state_) {\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t\tcase 0:\n#line 210 \"app-local-load-operation.c\"\n\t\tgoto _state_0;\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t\tcase 1:\n#line 214 \"app-local-load-operation.c\"\n\t\tgoto _state_1;\n\t\tdefault:\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t\tg_assert_not_reached ();\n#line 219 \"app-local-load-operation.c\"\n\t}\n\t_state_0:\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t_data_->_tmp0_ = NULL;\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t_data_->_tmp0_ = G_TYPE_CHECK_INSTANCE_CAST (_data_->self, GEARY_APP_TYPE_CONVERSATION_OPERATION, GearyAppConversationOperation)->monitor;\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t_data_->_state_ = 1;\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\tgeary_app_conversation_monitor_local_load_async (_data_->_tmp0_, geary_app_local_load_operation_execute_async_ready, _data_);\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\treturn FALSE;\n#line 232 \"app-local-load-operation.c\"\n\t_state_1:\n#line 13 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\tgeary_app_conversation_monitor_local_load_finish (_data_->_tmp0_, _data_->_res_);\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\tif (_data_->_state_ == 0) {\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t\tg_simple_async_result_complete_in_idle (_data_->_async_result);\n#line 240 \"app-local-load-operation.c\"\n\t} else {\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\t\tg_simple_async_result_complete (_data_->_async_result);\n#line 244 \"app-local-load-operation.c\"\n\t}\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\tg_object_unref (_data_->_async_result);\n#line 12 \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n\treturn FALSE;\n#line 250 \"app-local-load-operation.c\"\n}",
        "parsed_output": "undefined8 geary_app_local_load_operation_real_execute_async_co(int *param_1)\n{\n    undefined8 uVar1;\n    long lVar2;\n    \n    if (*param_1 == 0) {\n        *(undefined8 *)(param_1 + 10) = 0;\n        uVar1 = geary_app_conversation_operation_get_type();\n        lVar2 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 8), uVar1);\n        uVar1 = *(undefined8 *)(lVar2 + 0x28);\n        *param_1 = 1;\n        *(undefined8 *)(param_1 + 10) = uVar1;\n        geary_app_conversation_monitor_local_load_async(uVar1, geary_app_local_load_operation_execute_async_ready, param_1);\n        return 0;\n    }\n    \n    if (*param_1 == 1) {\n        geary_app_conversation_monitor_local_load_finish(*(undefined8 *)(param_1 + 10), *(undefined8 *)(param_1 + 4));\n        \n        if (*param_1 == 0) {\n            g_simple_async_result_complete_in_idle(*(undefined8 *)(param_1 + 6));\n        } else {\n            g_simple_async_result_complete();\n        }\n        \n        g_object_unref(*(undefined8 *)(param_1 + 6));\n        return 0;\n    }\n    \n    g_assertion_message_expr(0, \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\", 0xc, \"geary_app_local_load_operation_real_execute_async_co\", 0);\n}",
        "baseline_code_stripped": "undefined8 geary_app_local_load_operation_real_execute_async_co(int *param_1)\n{\n  undefined8 uVar1;\n  long lVar2;\n  if (*param_1 == 0) {\n    *(undefined8 *)(param_1 + 10) = 0;\n    uVar1 = geary_app_conversation_operation_get_type();\n    lVar2 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 8),uVar1);\n    uVar1 = *(undefined8 *)(lVar2 + 0x28);\n    *param_1 = 1;\n    *(undefined8 *)(param_1 + 10) = uVar1;\n    geary_app_conversation_monitor_local_load_async\n              (uVar1,geary_app_local_load_operation_execute_async_ready,param_1);\n    return 0;\n  }\n  if (*param_1 == 1) {\n    geary_app_conversation_monitor_local_load_finish\n              (*(undefined8 *)(param_1 + 10),*(undefined8 *)(param_1 + 4));\n    if (*param_1 == 0) {\n      g_simple_async_result_complete_in_idle(*(undefined8 *)(param_1 + 6));\n    }\n    else {\n      g_simple_async_result_complete();\n    }\n    g_object_unref(*(undefined8 *)(param_1 + 6));\n    return 0;\n  }\n  g_assertion_message_expr\n            (0,\n             \"/builddir/build/BUILD/geary-0.8.1/src/engine/app/conversation-monitor/app-local-load-operation.vala\"\n             ,0xc,\"geary_app_local_load_operation_real_execute_async_co\",0);\n}",
        "similarity_score_unixcoder": 0.7301182746887207,
        "similarity_score_baseline_stripped": 0.7635511159896851
    },
    {
        "func_name": "_wrap_SpinButton_SetValue",
        "normed_func_sha256": "4372c039ca3a0465f8cbb97b3b7a556824a043afd1618b9316bbe9bc9896b79b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined * FUN_00078f64(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int *local_138;\n  undefined4 local_134;\n  undefined4 local_130;\n  undefined4 local_12c;\n  undefined *local_128;\n  undefined *local_124;\n  undefined4 local_120;\n  undefined auStack_11c [268];\n  local_130 = 0;\n  local_138 = (int *)0x0;\n  local_134 = 0;\n  local_120 = _DAT_00104c40;\n  local_128 = PTR_DAT_00104c38;\n  local_124 = PTR_DAT_00104c3c;\n  iVar1 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"OO:SpinButton_SetValue\",&local_128,&local_134,&local_130);\n  if (iVar1 != 0) {\n    FUN_00041f74(local_134,&local_138,_DAT_00113c10,1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",1);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    uVar2 = local_130;\n    iVar1 = PyNumber_Check(local_130);\n    if (iVar1 == 0) {\n      FUN_00041db4(\"number\",uVar2);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = PyInt_AsLong(uVar2);\n    }\n    local_12c = uVar2;\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",2);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    uVar3 = (**(code **)(_DAT_001124f8 + 0x10))();\n    (**(code **)(*local_138 + 700))(local_138,uVar2);\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    (**(code **)(_DAT_001124f8 + 0x14))(uVar3);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      __Py_NoneStruct = __Py_NoneStruct + 1;\n      return &_Py_NoneStruct;\n    }\n  }\n  return (undefined *)0x0;\n}",
        "output": "```c\nvoid* SpinButton_SetValue(int param1, int param2, int param3) {\n    int result;\n    int* local_138;\n    int local_134;\n    int local_130;\n    int local_12c;\n    void* local_128;\n    void* local_124;\n    int local_120;\n    char local_11c[268];\n    \n    local_130 = 0;\n    local_138 = (int*)0x0;\n    local_134 = 0;\n    local_120 = _DAT_00104c40;\n    local_128 = PTR_DAT_00104c38;\n    local_124 = PTR_DAT_00104c3c;\n    \n    result = PyArg_ParseTupleAndKeywords(param2, param3, \"OO:SpinButton_SetValue\", &local_128, &local_134, &local_130);\n    \n    if (result != 0) {\n        FUN_00041f74(local_134, &local_138, _DAT_00113c10, 1);\n        result = PyErr_Occurred();\n        \n        if (result != 0) {\n            PyOS_snprintf(local_11c, 0x100, \"argument number %d:\", 1);\n            result = FUN_0003da74(local_11c, 1);\n            \n            if (result != 0) {\n                return (void*)0x0;\n            }\n        }\n        \n        local_12c = PyNumber_Check(local_130);\n        \n        if (local_12c == 0) {\n            FUN_00041db4(\"number\", local_130);\n            local_12c = 0;\n        } else {\n            local_12c = PyInt_AsLong(local_130);\n        }\n        \n        result = PyErr_Occurred();\n        \n        if (result != 0) {\n            PyOS_snprintf(local_11c, 0x100, \"argument number %d:\", 2);\n            result = FUN_0003da74(local_11c, 1);\n            \n            if (result != 0) {\n                return (void*)0x0;\n            }\n        }\n        \n        if (_DAT_001124f8 == 0) {\n            _DAT_001124f8 = PyCObject_Import(\"wx._core_\", \"_wxPyCoreAPI\");\n        }\n        \n        result = (**(code**)(_DAT_001124f8 + 0x10))();\n        (**(code**)(*local_138 + 700))(local_138, local_12c);\n        \n        if (_DAT_001124f8 == 0) {\n            _DAT_001124f8 = PyCObject_Import(\"wx._core_\", \"_wxPyCoreAPI\");\n        }\n        \n        (**(code**)(_DAT_001124f8 + 0x14))(result);\n        result = PyErr_Occurred();\n        \n        if (result == 0) {\n            __Py_NoneStruct = __Py_NoneStruct + 1;\n            return &_Py_NoneStruct;\n        }\n    }\n    \n    return (void*)0x0;\n}\n```",
        "source_code": "static PyObject *_wrap_SpinButton_SetValue(PyObject *, PyObject *args, PyObject *kwargs) {\n    PyObject *resultobj = NULL;\n    wxSpinButton *arg1 = (wxSpinButton *) 0 ;\n    int arg2 ;\n    PyObject * obj0 = 0 ;\n    PyObject * obj1 = 0 ;\n    char *kwnames[] = {\n        (char *) \"self\",(char *) \"val\", NULL \n    };\n    \n    if(!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"OO:SpinButton_SetValue\",kwnames,&obj0,&obj1)) goto fail;\n    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_wxSpinButton, SWIG_POINTER_EXCEPTION | 0);\n    if (SWIG_arg_fail(1)) SWIG_fail;\n    {\n        arg2 = static_cast<int >(SWIG_As_int(obj1)); \n        if (SWIG_arg_fail(2)) SWIG_fail;\n    }\n    {\n        PyThreadState* __tstate = wxPyBeginAllowThreads();\n        (arg1)->SetValue(arg2);\n        \n        wxPyEndAllowThreads(__tstate);\n        if (PyErr_Occurred()) SWIG_fail;\n    }\n    Py_INCREF(Py_None); resultobj = Py_None;\n    return resultobj;\n    fail:\n    return NULL;\n}",
        "parsed_output": "void* SpinButton_SetValue(int param1, int param2, int param3) {\n    int result;\n    int* local_138;\n    int local_134;\n    int local_130;\n    int local_12c;\n    void* local_128;\n    void* local_124;\n    int local_120;\n    char local_11c[268];\n    \n    local_130 = 0;\n    local_138 = (int*)0x0;\n    local_134 = 0;\n    local_120 = _DAT_00104c40;\n    local_128 = PTR_DAT_00104c38;\n    local_124 = PTR_DAT_00104c3c;\n    \n    result = PyArg_ParseTupleAndKeywords(param2, param3, \"OO:SpinButton_SetValue\", &local_128, &local_134, &local_130);\n    \n    if (result != 0) {\n        FUN_00041f74(local_134, &local_138, _DAT_00113c10, 1);\n        result = PyErr_Occurred();\n        \n        if (result != 0) {\n            PyOS_snprintf(local_11c, 0x100, \"argument number %d:\", 1);\n            result = FUN_0003da74(local_11c, 1);\n            \n            if (result != 0) {\n                return (void*)0x0;\n            }\n        }\n        \n        local_12c = PyNumber_Check(local_130);\n        \n        if (local_12c == 0) {\n            FUN_00041db4(\"number\", local_130);\n            local_12c = 0;\n        } else {\n            local_12c = PyInt_AsLong(local_130);\n        }\n        \n        result = PyErr_Occurred();\n        \n        if (result != 0) {\n            PyOS_snprintf(local_11c, 0x100, \"argument number %d:\", 2);\n            result = FUN_0003da74(local_11c, 1);\n            \n            if (result != 0) {\n                return (void*)0x0;\n            }\n        }\n        \n        if (_DAT_001124f8 == 0) {\n            _DAT_001124f8 = PyCObject_Import(\"wx._core_\", \"_wxPyCoreAPI\");\n        }\n        \n        result = (**(code**)(_DAT_001124f8 + 0x10))();\n        (**(code**)(*local_138 + 700))(local_138, local_12c);\n        \n        if (_DAT_001124f8 == 0) {\n            _DAT_001124f8 = PyCObject_Import(\"wx._core_\", \"_wxPyCoreAPI\");\n        }\n        \n        (**(code**)(_DAT_001124f8 + 0x14))(result);\n        result = PyErr_Occurred();\n        \n        if (result == 0) {\n            __Py_NoneStruct = __Py_NoneStruct + 1;\n            return &_Py_NoneStruct;\n        }\n    }\n    \n    return (void*)0x0;\n}",
        "baseline_code_stripped": "undefined * FUN_00078f64(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int *local_138;\n  undefined4 local_134;\n  undefined4 local_130;\n  undefined4 local_12c;\n  undefined *local_128;\n  undefined *local_124;\n  undefined4 local_120;\n  undefined auStack_11c [268];\n  local_130 = 0;\n  local_138 = (int *)0x0;\n  local_134 = 0;\n  local_120 = _DAT_00104c40;\n  local_128 = PTR_DAT_00104c38;\n  local_124 = PTR_DAT_00104c3c;\n  iVar1 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"OO:SpinButton_SetValue\",&local_128,&local_134,&local_130);\n  if (iVar1 != 0) {\n    FUN_00041f74(local_134,&local_138,_DAT_00113c10,1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",1);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    uVar2 = local_130;\n    iVar1 = PyNumber_Check(local_130);\n    if (iVar1 == 0) {\n      FUN_00041db4(\"number\",uVar2);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = PyInt_AsLong(uVar2);\n    }\n    local_12c = uVar2;\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",2);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    uVar3 = (**(code **)(_DAT_001124f8 + 0x10))();\n    (**(code **)(*local_138 + 700))(local_138,uVar2);\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    (**(code **)(_DAT_001124f8 + 0x14))(uVar3);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      __Py_NoneStruct = __Py_NoneStruct + 1;\n      return &_Py_NoneStruct;\n    }\n  }\n  return (undefined *)0x0;\n}",
        "similarity_score_unixcoder": 0.6754022836685181,
        "similarity_score_baseline_stripped": 0.6331114172935486
    },
    {
        "func_name": "gen_aarch64_fcmla0v8hf",
        "normed_func_sha256": "9993a206e0c3c63f19e507a837715d8e0b7a32cb6924ca53e7f90e67cb5e1013",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_10dda440(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 uVar1;\n  longlong lVar2;\n  longlong lVar3;\n  uVar1 = FUN_102c5b28(2,param_3,param_4);\n  lVar2 = FUN_106a7fd8(0x14);\n  *(undefined4 *)(lVar2 + 0x10) = 0x175;\n  *(undefined8 *)(lVar2 + 8) = uVar1;\n  *(undefined *)(lVar2 + 2) = 0x67;\n  lVar3 = FUN_106a7fd8(0x36);\n  *(undefined *)(lVar3 + 2) = 0x67;\n  *(undefined8 *)(lVar3 + 8) = param_2;\n  *(longlong *)(lVar3 + 0x10) = lVar2;\n  lVar2 = FUN_106a7fd8(0x19);\n  *(undefined *)(lVar2 + 2) = 0;\n  *(undefined8 *)(lVar2 + 8) = param_1;\n  *(longlong *)(lVar2 + 0x10) = lVar3;\n  return;\n}",
        "output": "void createDataStructureAndLinkNodes(undefined8 param_1, undefined8 param_2, undefined8 param_3, undefined8 param_4)\n{\n    undefined8 uVar1 = fetchData(2, param_3, param_4);\n    longlong node1 = createNode(0x14);\n    *(undefined4 *)(node1 + 0x10) = 0x175;\n    *(undefined8 *)(node1 + 8) = uVar1;\n    *(undefined *)(node1 + 2) = 0x67;\n    \n    longlong node2 = createNode(0x36);\n    *(undefined *)(node2 + 2) = 0x67;\n    *(undefined8 *)(node2 + 8) = param_2;\n    *(longlong *)(node2 + 0x10) = node1;\n    \n    longlong node3 = createNode(0x19);\n    *(undefined *)(node3 + 2) = 0;\n    *(undefined8 *)(node3 + 8) = param_1;\n    *(longlong *)(node3 + 0x10) = node2;\n}",
        "source_code": "rtx\ngen_aarch64_fcmla0v8hf (rtx operand0 ATTRIBUTE_UNUSED,\n\trtx operand1 ATTRIBUTE_UNUSED,\n\trtx operand2 ATTRIBUTE_UNUSED,\n\trtx operand3 ATTRIBUTE_UNUSED)\n{\n  return gen_rtx_SET (operand0,\n\tgen_rtx_PLUS (V8HFmode,\n\toperand1,\n\tgen_rtx_UNSPEC (V8HFmode,\n\tgen_rtvec (2,\n\t\toperand2,\n\t\toperand3),\n\t373)));\n}",
        "parsed_output": "void createDataStructureAndLinkNodes(undefined8 param_1, undefined8 param_2, undefined8 param_3, undefined8 param_4)\n{\n    undefined8 uVar1 = fetchData(2, param_3, param_4);\n    longlong node1 = createNode(0x14);\n    *(undefined4 *)(node1 + 0x10) = 0x175;\n    *(undefined8 *)(node1 + 8) = uVar1;\n    *(undefined *)(node1 + 2) = 0x67;\n    \n    longlong node2 = createNode(0x36);\n    *(undefined *)(node2 + 2) = 0x67;\n    *(undefined8 *)(node2 + 8) = param_2;\n    *(longlong *)(node2 + 0x10) = node1;\n    \n    longlong node3 = createNode(0x19);\n    *(undefined *)(node3 + 2) = 0;\n    *(undefined8 *)(node3 + 8) = param_1;\n    *(longlong *)(node3 + 0x10) = node2;\n}",
        "baseline_code_stripped": "void FUN_10dda440(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 uVar1;\n  longlong lVar2;\n  longlong lVar3;\n  uVar1 = FUN_102c5b28(2,param_3,param_4);\n  lVar2 = FUN_106a7fd8(0x14);\n  *(undefined4 *)(lVar2 + 0x10) = 0x175;\n  *(undefined8 *)(lVar2 + 8) = uVar1;\n  *(undefined *)(lVar2 + 2) = 0x67;\n  lVar3 = FUN_106a7fd8(0x36);\n  *(undefined *)(lVar3 + 2) = 0x67;\n  *(undefined8 *)(lVar3 + 8) = param_2;\n  *(longlong *)(lVar3 + 0x10) = lVar2;\n  lVar2 = FUN_106a7fd8(0x19);\n  *(undefined *)(lVar2 + 2) = 0;\n  *(undefined8 *)(lVar2 + 8) = param_1;\n  *(longlong *)(lVar2 + 0x10) = lVar3;\n  return;\n}",
        "similarity_score_unixcoder": 0.44541335105895996,
        "similarity_score_baseline_stripped": 0.4848305284976959
    },
    {
        "func_name": "netdfs_dissect_struct_dfs_Info7",
        "normed_func_sha256": "a48f04ed5282635da9004526d138dcf00b3d91031e468b552e50939e57c80577",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_0137dda0(undefined4 param_1,uint param_2,int param_3,int param_4,undefined4 param_5,\n                undefined4 param_6)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  if ((*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0) && ((param_2 & 3) != 0)) {\n    param_2 = (param_2 & 0xfffffffc) + 4;\n  }\n  uVar1 = 0;\n  uVar3 = 0;\n  if (param_4 != 0) {\n    uVar3 = proto_tree_add_item(param_4,param_6,param_1,param_2,0xffffffff,1);\n    uVar1 = proto_item_add_subtree(uVar3,DAT_0274f2c4);\n  }\n  iVar2 = dissect_ndr_uuid_t(param_1,param_2,param_3,uVar1,param_5,DAT_0274f3c8,0);\n  proto_item_set_len(uVar3,iVar2 - param_2);\n  return iVar2;\n}",
        "output": "int process_data(undefined4 param_1, uint param_2, int param_3, int param_4, undefined4 param_5, undefined4 param_6)\n{\n    undefined4 uVar1;\n    int iVar2;\n    undefined4 uVar3;\n    \n    if ((*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0) && ((param_2 & 3) != 0)) {\n        param_2 = (param_2 & 0xfffffffc) + 4;\n    }\n    \n    uVar1 = 0;\n    uVar3 = 0;\n    \n    if (param_4 != 0) {\n        uVar3 = proto_tree_add_item(param_4, param_6, param_1, param_2, 0xffffffff, 1);\n        uVar1 = proto_item_add_subtree(uVar3, DAT_0274f2c4);\n    }\n    \n    iVar2 = dissect_ndr_uuid_t(param_1, param_2, param_3, uVar1, param_5, DAT_0274f3c8, 0);\n    proto_item_set_len(uVar3, iVar2 - param_2);\n    \n    return iVar2;\n}",
        "source_code": "int\nnetdfs_dissect_struct_dfs_Info7(tvbuff_t *tvb _U_, int offset _U_, packet_info *pinfo _U_, proto_tree *parent_tree _U_, guint8 *drep _U_, int hf_index _U_, guint32 param _U_)\n{\n\tproto_item *item = NULL;\n\tproto_tree *tree = NULL;\n\tint old_offset;\n\n\tALIGN_TO_4_BYTES;\n\n\told_offset = offset;\n\n\tif (parent_tree) {\n\t\titem = proto_tree_add_item(parent_tree, hf_index, tvb, offset, -1, TRUE);\n\t\ttree = proto_item_add_subtree(item, ett_netdfs_dfs_Info7);\n\t}\n\t\n\toffset = netdfs_dissect_element_dfs_Info7_generation_guid(tvb, offset, pinfo, tree, drep);\n\n\n\tproto_item_set_len(item, offset-old_offset);\n\n\treturn offset;\n}",
        "parsed_output": "int process_data(undefined4 param_1, uint param_2, int param_3, int param_4, undefined4 param_5, undefined4 param_6)\n{\n    undefined4 uVar1;\n    int iVar2;\n    undefined4 uVar3;\n    \n    if ((*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0) && ((param_2 & 3) != 0)) {\n        param_2 = (param_2 & 0xfffffffc) + 4;\n    }\n    \n    uVar1 = 0;\n    uVar3 = 0;\n    \n    if (param_4 != 0) {\n        uVar3 = proto_tree_add_item(param_4, param_6, param_1, param_2, 0xffffffff, 1);\n        uVar1 = proto_item_add_subtree(uVar3, DAT_0274f2c4);\n    }\n    \n    iVar2 = dissect_ndr_uuid_t(param_1, param_2, param_3, uVar1, param_5, DAT_0274f3c8, 0);\n    proto_item_set_len(uVar3, iVar2 - param_2);\n    \n    return iVar2;\n}",
        "baseline_code_stripped": "int FUN_0137dda0(undefined4 param_1,uint param_2,int param_3,int param_4,undefined4 param_5,\n                undefined4 param_6)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  if ((*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0) && ((param_2 & 3) != 0)) {\n    param_2 = (param_2 & 0xfffffffc) + 4;\n  }\n  uVar1 = 0;\n  uVar3 = 0;\n  if (param_4 != 0) {\n    uVar3 = proto_tree_add_item(param_4,param_6,param_1,param_2,0xffffffff,1);\n    uVar1 = proto_item_add_subtree(uVar3,DAT_0274f2c4);\n  }\n  iVar2 = dissect_ndr_uuid_t(param_1,param_2,param_3,uVar1,param_5,DAT_0274f3c8,0);\n  proto_item_set_len(uVar3,iVar2 - param_2);\n  return iVar2;\n}",
        "similarity_score_unixcoder": 0.7208852171897888,
        "similarity_score_baseline_stripped": 0.709363579750061
    },
    {
        "func_name": "YUVProgramContext::updateUProjection",
        "normed_func_sha256": "54cc64237870bf521c109ddb31036fe18f5055766efe64a8abe1744dd89c4844",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall YUVProgramContext::updateUProjection(YUVProgramContext *this)\n{\n  *(undefined4 *)(this + 0x78) = 0x40000000;\n  *(undefined4 *)(this + 0x7c) = 0;\n  *(undefined4 *)(this + 0x80) = 0;\n  *(undefined4 *)(this + 0x84) = 0;\n  *(undefined4 *)(this + 0x88) = 0;\n  *(undefined4 *)(this + 0x8c) = 0x40000000;\n  __aeabi_memclr8(this + 0x90,0x18);\n  *(undefined4 *)(this + 0xa8) = 0xbf800000;\n  *(undefined4 *)(this + 0xac) = 0xbf800000;\n  *(undefined4 *)(this + 0xb0) = 0;\n  *(undefined4 *)(this + 0xb4) = 0x3f800000;\n  if ((*(int *)(this + 0x104) != 0) && (*(int *)(this + 0x100) != 0)) {\n    *(float *)(this + 0x78) = 2.0 / (float)(longlong)*(int *)(this + 0x100);\n    *(float *)(this + 0x8c) = 2.0 / (float)(longlong)*(int *)(this + 0x104);\n  }\n  return;\n}",
        "output": "void __thiscall YUVProgramContext::updateUProjection(YUVProgramContext *this)\n{\n  this->uProjectionMatrix[0] = 1.0f;\n  this->uProjectionMatrix[1] = 0.0f;\n  this->uProjectionMatrix[2] = 0.0f;\n  this->uProjectionMatrix[3] = 0.0f;\n  this->uProjectionMatrix[4] = 0.0f;\n  this->uProjectionMatrix[5] = 1.0f;\n  \n  memset(this->uProjectionMatrix + 6, 0, 24);\n  \n  this->uProjectionMatrix[20] = -1.0f;\n  this->uProjectionMatrix[21] = -1.0f;\n  this->uProjectionMatrix[22] = 0.0f;\n  this->uProjectionMatrix[23] = 1.0f;\n  \n  if (this->someValue != 0 && this->anotherValue != 0) {\n    this->uProjectionMatrix[0] = 2.0f / static_cast<float>(this->anotherValue);\n    this->uProjectionMatrix[5] = 2.0f / static_cast<float>(this->someValue);\n  }\n}",
        "source_code": "void YUVProgramContext::updateUProjection() {\n    mUProjection[0][0] = 2.0f;\n    mUProjection[0][1] = 0.0f;\n    mUProjection[0][2] = 0.0f;\n    mUProjection[0][3] = 0.0f;\n    mUProjection[1][0] = 0.0f;\n    mUProjection[1][1] = 2.0f;\n    mUProjection[1][2] = 0.0f;\n    mUProjection[1][3] = 0.0f;\n    mUProjection[2][0] = 0.0f;\n    mUProjection[2][1] = 0.0f;\n    mUProjection[2][2] = 0.0f;\n    mUProjection[2][3] = 0.0f;\n    mUProjection[3][0] = -1.0f;\n    mUProjection[3][1] = -1.0f;\n    mUProjection[3][2] = 0.0f;\n    mUProjection[3][3] = 1.0f;\n\n    if (mWindowHeight != 0 && mWindowWidth != 0) {\n        mUProjection[0][0] = 2.0f / mWindowWidth;\n        mUProjection[1][1] = 2.0f / mWindowHeight;\n    }\n}",
        "parsed_output": "void __thiscall YUVProgramContext::updateUProjection(YUVProgramContext *this)\n{\n  this->uProjectionMatrix[0] = 1.0f;\n  this->uProjectionMatrix[1] = 0.0f;\n  this->uProjectionMatrix[2] = 0.0f;\n  this->uProjectionMatrix[3] = 0.0f;\n  this->uProjectionMatrix[4] = 0.0f;\n  this->uProjectionMatrix[5] = 1.0f;\n  \n  memset(this->uProjectionMatrix + 6, 0, 24);\n  \n  this->uProjectionMatrix[20] = -1.0f;\n  this->uProjectionMatrix[21] = -1.0f;\n  this->uProjectionMatrix[22] = 0.0f;\n  this->uProjectionMatrix[23] = 1.0f;\n  \n  if (this->someValue != 0 && this->anotherValue != 0) {\n    this->uProjectionMatrix[0] = 2.0f / static_cast<float>(this->anotherValue);\n    this->uProjectionMatrix[5] = 2.0f / static_cast<float>(this->someValue);\n  }\n}",
        "baseline_code_stripped": "void __thiscall YUVProgramContext::updateUProjection(YUVProgramContext *this)\n{\n  *(undefined4 *)(this + 0x78) = 0x40000000;\n  *(undefined4 *)(this + 0x7c) = 0;\n  *(undefined4 *)(this + 0x80) = 0;\n  *(undefined4 *)(this + 0x84) = 0;\n  *(undefined4 *)(this + 0x88) = 0;\n  *(undefined4 *)(this + 0x8c) = 0x40000000;\n  __aeabi_memclr8(this + 0x90,0x18);\n  *(undefined4 *)(this + 0xa8) = 0xbf800000;\n  *(undefined4 *)(this + 0xac) = 0xbf800000;\n  *(undefined4 *)(this + 0xb0) = 0;\n  *(undefined4 *)(this + 0xb4) = 0x3f800000;\n  if ((*(int *)(this + 0x104) != 0) && (*(int *)(this + 0x100) != 0)) {\n    *(float *)(this + 0x78) = 2.0 / (float)(longlong)*(int *)(this + 0x100);\n    *(float *)(this + 0x8c) = 2.0 / (float)(longlong)*(int *)(this + 0x104);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.8461596369743347,
        "similarity_score_baseline_stripped": 0.6691746115684509
    },
    {
        "func_name": "decode_sib_address",
        "normed_func_sha256": "74b135bce90d50efa45fe04a912714fb565c7b76973ffef47e435c514a8773aa",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_0010fb20(uint param_1,int param_2)\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  switch(param_1 & 7) {\n  case 0:\n    iVar2 = _DAT_00323378;\n    break;\n  case 1:\n    iVar2 = _DAT_00323380;\n    break;\n  case 2:\n    iVar2 = DAT_00323384;\n    break;\n  case 3:\n    iVar2 = DAT_0032337c;\n    break;\n  case 5:\n    if (param_2 == 0) {\n      iVar2 = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n      DAT_00323398 = DAT_00323398 + 4;\n      break;\n    }\n  case 4:\n    DAT_003233ac = DAT_003233ac | 1;\n    iVar2 = _DAT_00323388;\n    break;\n  case 6:\n    iVar2 = DAT_00323390;\n    break;\n  case 7:\n    iVar2 = DAT_00323394;\n  }\n  bVar1 = (byte)((int)param_1 >> 6);\n  switch((int)param_1 >> 3 & 7) {\n  case 0:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323378;\n  case 1:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323380;\n  case 2:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323384;\n  case 3:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032337c;\n  case 4:\n    iVar3 = 0;\n    break;\n  case 5:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032338c;\n  case 6:\n    iVar3 = (1 << (bVar1 & 3)) * DAT_00323390;\n    break;\n  case 7:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323394;\n  }\n  return iVar2 + iVar3;\n}",
        "output": "```c\nint FUN_0010fb20(uint param_1, int param_2)\n{\n    byte bVar1 = (byte)((int)param_1 >> 6);\n    int iVar2 = 0;\n    int iVar3 = 0;\n\n    switch(param_1 & 7) {\n        case 0:\n            iVar2 = _DAT_00323378;\n            break;\n        case 1:\n            iVar2 = _DAT_00323380;\n            break;\n        case 2:\n            iVar2 = DAT_00323384;\n            break;\n        case 3:\n            iVar2 = DAT_0032337c;\n            break;\n        case 5:\n            if (param_2 == 0) {\n                iVar2 = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n                DAT_00323398 = DAT_00323398 + 4;\n                break;\n            }\n        case 4:\n            DAT_003233ac = DAT_003233ac | 1;\n            iVar2 = _DAT_00323388;\n            break;\n        case 6:\n            iVar2 = DAT_00323390;\n            break;\n        case 7:\n            iVar2 = DAT_00323394;\n    }\n\n    switch((int)param_1 >> 3 & 7) {\n        case 0:\n            return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323378;\n        case 1:\n            return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323380;\n        case 2:\n            return iVar2 + (1 << (bVar1 & 3)) * DAT_00323384;\n        case 3:\n            return iVar2 + (1 << (bVar1 & 3)) * DAT_0032337c;\n        case 4:\n            iVar3 = 0;\n            break;\n        case 5:\n            return iVar2 + (1 << (bVar1 & 3)) * DAT_0032338c;\n        case 6:\n            iVar3 = (1 << (bVar1 & 3)) * DAT_00323390;\n            break;\n        case 7:\n            return iVar2 + (1 << (bVar1 & 3)) * DAT_00323394;\n    }\n\n    return iVar2 + iVar3;\n}\n```",
        "source_code": "u32\ndecode_sib_address(int sib, int mod)\n{\n    u32 base = 0, i = 0, scale = 1;\n\n    switch (sib & 0x07) {\n    case 0:\n        DECODE_PRINTF(\"[EAX]\");\n        base = M.x86.R_EAX;\n        break;\n    case 1:\n        DECODE_PRINTF(\"[ECX]\");\n        base = M.x86.R_ECX;\n        break;\n    case 2:\n        DECODE_PRINTF(\"[EDX]\");\n        base = M.x86.R_EDX;\n        break;\n    case 3:\n        DECODE_PRINTF(\"[EBX]\");\n        base = M.x86.R_EBX;\n        break;\n    case 4:\n        DECODE_PRINTF(\"[ESP]\");\n        base = M.x86.R_ESP;\n        M.x86.mode |= SYSMODE_SEG_DS_SS;\n        break;\n    case 5:\n        if (mod == 0) {\n            base = fetch_long_imm();\n            DECODE_PRINTF2(\"%08x\", base);\n        }\n        else {\n            DECODE_PRINTF(\"[EBP]\");\n            base = M.x86.R_ESP;\n            M.x86.mode |= SYSMODE_SEG_DS_SS;\n        }\n        break;\n    case 6:\n        DECODE_PRINTF(\"[ESI]\");\n        base = M.x86.R_ESI;\n        break;\n    case 7:\n        DECODE_PRINTF(\"[EDI]\");\n        base = M.x86.R_EDI;\n        break;\n    }\n    switch ((sib >> 3) & 0x07) {\n    case 0:\n        DECODE_PRINTF(\"[EAX\");\n        i = M.x86.R_EAX;\n        break;\n    case 1:\n        DECODE_PRINTF(\"[ECX\");\n        i = M.x86.R_ECX;\n        break;\n    case 2:\n        DECODE_PRINTF(\"[EDX\");\n        i = M.x86.R_EDX;\n        break;\n    case 3:\n        DECODE_PRINTF(\"[EBX\");\n        i = M.x86.R_EBX;\n        break;\n    case 4:\n        i = 0;\n        break;\n    case 5:\n        DECODE_PRINTF(\"[EBP\");\n        i = M.x86.R_EBP;\n        break;\n    case 6:\n        DECODE_PRINTF(\"[ESI\");\n        i = M.x86.R_ESI;\n        break;\n    case 7:\n        DECODE_PRINTF(\"[EDI\");\n        i = M.x86.R_EDI;\n        break;\n    }\n    scale = 1 << ((sib >> 6) & 0x03);\n    if (((sib >> 3) & 0x07) != 4) {\n        if (scale == 1) {\n            DECODE_PRINTF(\"]\");\n        }\n        else {\n            DECODE_PRINTF2(\"*%d]\", scale);\n        }\n    }\n    return base + (i * scale);\n}",
        "parsed_output": "int FUN_0010fb20(uint param_1, int param_2)\n{\n    byte bVar1 = (byte)((int)param_1 >> 6);\n    int iVar2 = 0;\n    int iVar3 = 0;\n\n    switch(param_1 & 7) {\n        case 0:\n            iVar2 = _DAT_00323378;\n            break;\n        case 1:\n            iVar2 = _DAT_00323380;\n            break;\n        case 2:\n            iVar2 = DAT_00323384;\n            break;\n        case 3:\n            iVar2 = DAT_0032337c;\n            break;\n        case 5:\n            if (param_2 == 0) {\n                iVar2 = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n                DAT_00323398 = DAT_00323398 + 4;\n                break;\n            }\n        case 4:\n            DAT_003233ac = DAT_003233ac | 1;\n            iVar2 = _DAT_00323388;\n            break;\n        case 6:\n            iVar2 = DAT_00323390;\n            break;\n        case 7:\n            iVar2 = DAT_00323394;\n    }\n\n    switch((int)param_1 >> 3 & 7) {\n        case 0:\n            return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323378;\n        case 1:\n            return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323380;\n        case 2:\n            return iVar2 + (1 << (bVar1 & 3)) * DAT_00323384;\n        case 3:\n            return iVar2 + (1 << (bVar1 & 3)) * DAT_0032337c;\n        case 4:\n            iVar3 = 0;\n            break;\n        case 5:\n            return iVar2 + (1 << (bVar1 & 3)) * DAT_0032338c;\n        case 6:\n            iVar3 = (1 << (bVar1 & 3)) * DAT_00323390;\n            break;\n        case 7:\n            return iVar2 + (1 << (bVar1 & 3)) * DAT_00323394;\n    }\n\n    return iVar2 + iVar3;\n}",
        "baseline_code_stripped": "int FUN_0010fb20(uint param_1,int param_2)\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  switch(param_1 & 7) {\n  case 0:\n    iVar2 = _DAT_00323378;\n    break;\n  case 1:\n    iVar2 = _DAT_00323380;\n    break;\n  case 2:\n    iVar2 = DAT_00323384;\n    break;\n  case 3:\n    iVar2 = DAT_0032337c;\n    break;\n  case 5:\n    if (param_2 == 0) {\n      iVar2 = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n      DAT_00323398 = DAT_00323398 + 4;\n      break;\n    }\n  case 4:\n    DAT_003233ac = DAT_003233ac | 1;\n    iVar2 = _DAT_00323388;\n    break;\n  case 6:\n    iVar2 = DAT_00323390;\n    break;\n  case 7:\n    iVar2 = DAT_00323394;\n  }\n  bVar1 = (byte)((int)param_1 >> 6);\n  switch((int)param_1 >> 3 & 7) {\n  case 0:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323378;\n  case 1:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323380;\n  case 2:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323384;\n  case 3:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032337c;\n  case 4:\n    iVar3 = 0;\n    break;\n  case 5:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032338c;\n  case 6:\n    iVar3 = (1 << (bVar1 & 3)) * DAT_00323390;\n    break;\n  case 7:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323394;\n  }\n  return iVar2 + iVar3;\n}",
        "similarity_score_unixcoder": 0.589012861251831,
        "similarity_score_baseline_stripped": 0.5846819281578064
    },
    {
        "func_name": "m68k_op_move_16_tos_al",
        "normed_func_sha256": "bad3fcf49b58e1f1f5a12d5855427450193d1155115a7d1fe59121577ee083ca",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00e28907(void)\n{\n  undefined4 uVar1;\n  if (DAT_03e4ce14 == 0) {\n    FUN_00de4420();\n  }\n  else {\n    uVar1 = FUN_00de3aef();\n    FUN_00de40bf(uVar1);\n  }\n  return;\n}",
        "output": "void process_data()\n{\n    if (data_flag == 0) {\n        initialize_data();\n    }\n    else {\n        int processed_data = process_data_function();\n        finalize_data(processed_data);\n    }\n    return;\n}",
        "source_code": "static void m68k_op_move_16_tos_al(void)\n{\n\tif(FLAG_S)\n\t{\n\t\tuint new_sr = OPER_AL_16();\n\t\tm68ki_trace_t0();\t\t\t   /* auto-disable (see m68kcpu.h) */\n\t\tm68ki_set_sr(new_sr);\n\t\treturn;\n\t}\n\tm68ki_exception_privilege_violation();\n}",
        "parsed_output": "void process_data()\n{\n    if (data_flag == 0) {\n        initialize_data();\n    }\n    else {\n        int processed_data = process_data_function();\n        finalize_data(processed_data);\n    }\n    return;\n}",
        "baseline_code_stripped": "void FUN_00e28907(void)\n{\n  undefined4 uVar1;\n  if (DAT_03e4ce14 == 0) {\n    FUN_00de4420();\n  }\n  else {\n    uVar1 = FUN_00de3aef();\n    FUN_00de40bf(uVar1);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.3979746699333191,
        "similarity_score_baseline_stripped": 0.4923078119754791
    },
    {
        "func_name": "ImageDataParameter::release_source",
        "normed_func_sha256": "737cbad3d711833c3121204f21422ae18966e99fe00aef7adee8545670e25d4a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall FUN_100e7930(MessageLite *param_1)\n{\n  uint *puVar1;\n  Arena *pAVar2;\n  puVar1 = (uint *)thunk_FUN_1008f9a0(0);\n  *puVar1 = *puVar1 | 1;\n  google::protobuf::MessageLite::GetArenaForAllocation(param_1);\n  pAVar2 = (Arena *)__RTC_CheckEsp();\n  google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(param_1 + 0x10),pAVar2);\n  __RTC_CheckEsp();\n  __RTC_CheckEsp();\n  return;\n}",
        "output": "void processMessage(MessageLite *message)\n{\n    uint *flag = (uint *)getFlagPointer(0);\n    *flag = *flag | 1;\n    \n    Arena *arena = google::protobuf::MessageLite::GetArenaForAllocation(message);\n    google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(message + 0x10), arena);\n}",
        "source_code": "inline std::string* ImageDataParameter::release_source() {\n  // @@protoc_insertion_point(field_release:opencv_caffe.ImageDataParameter.source)\n  if (!_internal_has_source()) {\n    return nullptr;\n  }\n  _has_bits_[0] &= ~0x00000001u;\n  auto* p = source_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());\n#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING\n  if (source_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {\n    source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), \"\", GetArenaForAllocation());\n  }\n#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING\n  return p;\n}",
        "parsed_output": "void processMessage(MessageLite *message)\n{\n    uint *flag = (uint *)getFlagPointer(0);\n    *flag = *flag | 1;\n    \n    Arena *arena = google::protobuf::MessageLite::GetArenaForAllocation(message);\n    google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(message + 0x10), arena);\n}",
        "baseline_code_stripped": "void __fastcall FUN_100e7930(MessageLite *param_1)\n{\n  uint *puVar1;\n  Arena *pAVar2;\n  puVar1 = (uint *)thunk_FUN_1008f9a0(0);\n  *puVar1 = *puVar1 | 1;\n  google::protobuf::MessageLite::GetArenaForAllocation(param_1);\n  pAVar2 = (Arena *)__RTC_CheckEsp();\n  google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(param_1 + 0x10),pAVar2);\n  __RTC_CheckEsp();\n  __RTC_CheckEsp();\n  return;\n}",
        "similarity_score_unixcoder": 0.5478149652481079,
        "similarity_score_baseline_stripped": 0.48968306183815
    },
    {
        "func_name": "OpmlParser::defaultEnd",
        "normed_func_sha256": "cf621c8237672c026956ee9cf7554f3fc184a1b1f28e29888c6096f512283f9b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid OpmlParser::defaultEnd(QSharedPointer *param_1,Thread *param_2)\n{\n  void *pvVar1;\n  int iVar2;\n  ulong uVar3;\n  QSharedPointer QVar4;\n  undefined8 local_20;\n  void *pvStack_18;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  ThreadWeaver::Job::defaultEnd(param_1 + 4,param_2);\n  uVar3 = (**(code **)(**(long **)param_2 + 0x48))();\n  QVar4 = (QSharedPointer)&local_20;\n  if ((uVar3 & 1) == 0) {\n    pvStack_18 = *(void **)(param_2 + 8);\n    local_20 = *(undefined8 *)param_2;\n    if (pvStack_18 != (void *)0x0) {\n      FUN_0032a300(&local_20);\n    }\n    failed((OpmlParser *)param_1,QVar4);\n    if (pvStack_18 != (void *)0x0) {\n      FUN_003441a0();\n    }\n  }\n  pvStack_18 = *(void **)(param_2 + 8);\n  local_20 = *(undefined8 *)param_2;\n  if (pvStack_18 != (void *)0x0) {\n    FUN_006e2be0(1);\n    FUN_006e2be0(1,(long)pvStack_18 + 4);\n  }\n  done((OpmlParser *)param_1,QVar4);\n  pvVar1 = pvStack_18;\n  if (pvStack_18 != (void *)0x0) {\n    iVar2 = FUN_006e2be0(0xffffffff,(long)pvStack_18 + 4);\n    if (iVar2 == 1) {\n      (**(code **)((long)pvVar1 + 8))(pvVar1);\n    }\n    iVar2 = FUN_006e2be0(0xffffffff,pvVar1);\n    if (iVar2 == 1) {\n      operator_delete(pvVar1);\n    }\n  }\n  if (local_8 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);\n}",
        "output": "void OpmlParser::defaultEnd(QSharedPointer *param_1, Thread *param_2)\n{\n    void *pvVar1;\n    int iVar2;\n    ulong uVar3;\n    QSharedPointer QVar4;\n    undefined8 local_20;\n    void *pvStack_18;\n    long local_8;\n\n    local_8 = ___stack_chk_guard;\n    ThreadWeaver::Job::defaultEnd(param_1 + 4, param_2);\n    \n    uVar3 = (**(code **)(**(long **)param_2 + 0x48))();\n    QVar4 = (QSharedPointer)&local_20;\n    \n    if ((uVar3 & 1) == 0) {\n        pvStack_18 = *(void **)(param_2 + 8);\n        local_20 = *(undefined8 *)param_2;\n        \n        if (pvStack_18 != (void *)0x0) {\n            FUN_0032a300(&local_20);\n        }\n        \n        failed((OpmlParser *)param_1, QVar4);\n        \n        if (pvStack_18 != (void *)0x0) {\n            FUN_003441a0();\n        }\n    }\n    \n    pvStack_18 = *(void **)(param_2 + 8);\n    local_20 = *(undefined8 *)param_2;\n    \n    if (pvStack_18 != (void *)0x0) {\n        FUN_006e2be0(1);\n        FUN_006e2be0(1, (long)pvStack_18 + 4);\n    }\n    \n    done((OpmlParser *)param_1, QVar4);\n    pvVar1 = pvStack_18;\n    \n    if (pvStack_18 != (void *)0x0) {\n        iVar2 = FUN_006e2be0(0xffffffff, (long)pvStack_18 + 4);\n        \n        if (iVar2 == 1) {\n            (**(code **)((long)pvVar1 + 8))(pvVar1);\n        }\n        \n        iVar2 = FUN_006e2be0(0xffffffff, pvVar1);\n        \n        if (iVar2 == 1) {\n            operator_delete(pvVar1);\n        }\n    }\n    \n    if (local_8 - ___stack_chk_guard == 0) {\n        return;\n    }\n    \n    __stack_chk_fail(&__stack_chk_guard, 0, local_8 - ___stack_chk_guard);\n}",
        "source_code": "void\nOpmlParser::defaultEnd(const ThreadWeaver::JobPointer& self, ThreadWeaver::Thread *thread)\n{\n    ThreadWeaver::Job::defaultEnd(self, thread);\n    if (!self->success()) {\n        Q_EMIT failed(self);\n    }\n    Q_EMIT done(self);\n}",
        "parsed_output": "void OpmlParser::defaultEnd(QSharedPointer *param_1, Thread *param_2)\n{\n    void *pvVar1;\n    int iVar2;\n    ulong uVar3;\n    QSharedPointer QVar4;\n    undefined8 local_20;\n    void *pvStack_18;\n    long local_8;\n\n    local_8 = ___stack_chk_guard;\n    ThreadWeaver::Job::defaultEnd(param_1 + 4, param_2);\n    \n    uVar3 = (**(code **)(**(long **)param_2 + 0x48))();\n    QVar4 = (QSharedPointer)&local_20;\n    \n    if ((uVar3 & 1) == 0) {\n        pvStack_18 = *(void **)(param_2 + 8);\n        local_20 = *(undefined8 *)param_2;\n        \n        if (pvStack_18 != (void *)0x0) {\n            FUN_0032a300(&local_20);\n        }\n        \n        failed((OpmlParser *)param_1, QVar4);\n        \n        if (pvStack_18 != (void *)0x0) {\n            FUN_003441a0();\n        }\n    }\n    \n    pvStack_18 = *(void **)(param_2 + 8);\n    local_20 = *(undefined8 *)param_2;\n    \n    if (pvStack_18 != (void *)0x0) {\n        FUN_006e2be0(1);\n        FUN_006e2be0(1, (long)pvStack_18 + 4);\n    }\n    \n    done((OpmlParser *)param_1, QVar4);\n    pvVar1 = pvStack_18;\n    \n    if (pvStack_18 != (void *)0x0) {\n        iVar2 = FUN_006e2be0(0xffffffff, (long)pvStack_18 + 4);\n        \n        if (iVar2 == 1) {\n            (**(code **)((long)pvVar1 + 8))(pvVar1);\n        }\n        \n        iVar2 = FUN_006e2be0(0xffffffff, pvVar1);\n        \n        if (iVar2 == 1) {\n            operator_delete(pvVar1);\n        }\n    }\n    \n    if (local_8 - ___stack_chk_guard == 0) {\n        return;\n    }\n    \n    __stack_chk_fail(&__stack_chk_guard, 0, local_8 - ___stack_chk_guard);\n}",
        "baseline_code_stripped": "void OpmlParser::defaultEnd(QSharedPointer *param_1,Thread *param_2)\n{\n  void *pvVar1;\n  int iVar2;\n  ulong uVar3;\n  QSharedPointer QVar4;\n  undefined8 local_20;\n  void *pvStack_18;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  ThreadWeaver::Job::defaultEnd(param_1 + 4,param_2);\n  uVar3 = (**(code **)(**(long **)param_2 + 0x48))();\n  QVar4 = (QSharedPointer)&local_20;\n  if ((uVar3 & 1) == 0) {\n    pvStack_18 = *(void **)(param_2 + 8);\n    local_20 = *(undefined8 *)param_2;\n    if (pvStack_18 != (void *)0x0) {\n      FUN_0032a300(&local_20);\n    }\n    failed((OpmlParser *)param_1,QVar4);\n    if (pvStack_18 != (void *)0x0) {\n      FUN_003441a0();\n    }\n  }\n  pvStack_18 = *(void **)(param_2 + 8);\n  local_20 = *(undefined8 *)param_2;\n  if (pvStack_18 != (void *)0x0) {\n    FUN_006e2be0(1);\n    FUN_006e2be0(1,(long)pvStack_18 + 4);\n  }\n  done((OpmlParser *)param_1,QVar4);\n  pvVar1 = pvStack_18;\n  if (pvStack_18 != (void *)0x0) {\n    iVar2 = FUN_006e2be0(0xffffffff,(long)pvStack_18 + 4);\n    if (iVar2 == 1) {\n      (**(code **)((long)pvVar1 + 8))(pvVar1);\n    }\n    iVar2 = FUN_006e2be0(0xffffffff,pvVar1);\n    if (iVar2 == 1) {\n      operator_delete(pvVar1);\n    }\n  }\n  if (local_8 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);\n}",
        "similarity_score_unixcoder": 0.6080970168113708,
        "similarity_score_baseline_stripped": 0.5953972935676575
    },
    {
        "func_name": "sipQgsMapLayer::sipProtectVirt_decodedSource",
        "normed_func_sha256": "4c76efd72899d90139badcb6bbc0e4297c58126a1f2a435049d3f2114dd040ba",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nQString * sipQgsMapLayer::sipProtectVirt_decodedSource\n                    (bool param_1,QString *param_2,QString *param_3,QgsReadWriteContext *param_4)\n{\n  long lVar1;\n  undefined7 in_register_00000039;\n  QString *pQVar2;\n  long in_FS_OFFSET;\n  pQVar2 = (QString *)CONCAT71(in_register_00000039,param_1);\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((char)param_3 == '\\0') {\n    (**(code **)(*(long *)param_2 + 0x260))(pQVar2);\n  }\n  else {\n    QgsMapLayer::decodedSource(pQVar2,param_2,param_4);\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pQVar2;\n  }\n  __stack_chk_fail();\n}",
        "output": "QString * sipQgsMapLayer::sipProtectVirt_decodedSource(bool param_1, QString *param_2, QString *param_3, QgsReadWriteContext *param_4)\n{\n    QString *result;\n    \n    result = (QString *)param_1;\n    \n    if ((char)param_3 == '\\0') {\n        (**(code **)(*(long *)param_2 + 0x260))(result);\n    } else {\n        QgsMapLayer::decodedSource(result, param_2, param_4);\n    }\n    \n    return result;\n}",
        "source_code": "::QString sipQgsMapLayer::sipProtectVirt_decodedSource(bool sipSelfWasArg, const ::QString& a0, const ::QString& a1, const ::QgsReadWriteContext& a2) const\n{\n    return (sipSelfWasArg ? ::QgsMapLayer::decodedSource(a0, a1, a2) : decodedSource(a0, a1, a2));\n}",
        "parsed_output": "QString * sipQgsMapLayer::sipProtectVirt_decodedSource(bool param_1, QString *param_2, QString *param_3, QgsReadWriteContext *param_4)\n{\n    QString *result;\n    \n    result = (QString *)param_1;\n    \n    if ((char)param_3 == '\\0') {\n        (**(code **)(*(long *)param_2 + 0x260))(result);\n    } else {\n        QgsMapLayer::decodedSource(result, param_2, param_4);\n    }\n    \n    return result;\n}",
        "baseline_code_stripped": "QString * sipQgsMapLayer::sipProtectVirt_decodedSource\n                    (bool param_1,QString *param_2,QString *param_3,QgsReadWriteContext *param_4)\n{\n  long lVar1;\n  undefined7 in_register_00000039;\n  QString *pQVar2;\n  long in_FS_OFFSET;\n  pQVar2 = (QString *)CONCAT71(in_register_00000039,param_1);\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((char)param_3 == '\\0') {\n    (**(code **)(*(long *)param_2 + 0x260))(pQVar2);\n  }\n  else {\n    QgsMapLayer::decodedSource(pQVar2,param_2,param_4);\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pQVar2;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.8098395466804504,
        "similarity_score_baseline_stripped": 0.6999660134315491
    },
    {
        "func_name": "acquire_daemonlock",
        "normed_func_sha256": "c3da76d1bdc1bc0cda3854b90611fd5bba1e2e96b17a9f29f352d9a865adc815",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00018ca0(int param_1)\n{\n  int unaff_r2;\n  __pid_t _Var1;\n  size_t __n;\n  size_t sVar2;\n  int *piVar3;\n  char *pcVar4;\n  int iVar5;\n  ssize_t sVar6;\n  int iVar7;\n  char *local_3028;\n  char acStack_3024 [12288];\n  int local_24;\n  local_24 = *(int *)(unaff_r2 + -0x7008);\n  if (param_1 == 0) {\n    if (_DAT_0006dea8 == -1) {\n      _DAT_0006dea8 = open(\"/var/run/crond.pid\",0x42,0x180);\n      if (_DAT_0006dea8 == -1) {\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t open or create %s: %s\",\"/var/run/crond.pid\",\n                      pcVar4);\n        __fprintf_chk(stderr,1,\"%s: %s\\n\",ProgramName,acStack_3024);\n        _Var1 = getpid();\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"DEATH\",acStack_3024);\n        exit(1);\n      }\n      iVar5 = flock(_DAT_0006dea8,6);\n      if (iVar5 < 0) {\n        piVar3 = __errno_location();\n        iVar5 = *piVar3;\n        memset(acStack_3024,0,0x3000);\n        sVar6 = read(_DAT_0006dea8,acStack_3024,0x2fff);\n        if (sVar6 < 1) {\n          iVar7 = -1;\n        }\n        else {\n          iVar7 = __strtol_internal(acStack_3024,&local_3028,10,0);\n          if ((((0 < iVar7) && (acStack_3024 != local_3028)) && (*local_3028 == '\\n')) &&\n             (iVar7 != 0x7fffffff)) {\n            pcVar4 = strerror(iVar5);\n            __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid may be %ld: %s\",\n                          \"/var/run/crond.pid\",iVar7,pcVar4);\n            goto LAB_00018f18;\n          }\n        }\n        pcVar4 = strerror(iVar5);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid unknown: %s\",\n                      \"/var/run/crond.pid\",pcVar4);\nLAB_00018f18:\n        pcVar4 = strerror(iVar5);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid may be %ld: %s\",\n                      \"/var/run/crond.pid\",iVar7,pcVar4);\n        __fprintf_chk(stderr,1,\"%s: %s\\n\",ProgramName,acStack_3024);\n        _Var1 = getpid();\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"DEATH\",acStack_3024);\n        exit(1);\n      }\n      fchmod(_DAT_0006dea8,0x1a4);\n      fcntl(_DAT_0006dea8,2,1);\n    }\n    _Var1 = getpid();\n    __sprintf_chk(acStack_3024,1,0x3000,\"%ld\\n\",_Var1);\n    lseek(_DAT_0006dea8,0,0);\n    __n = strlen(acStack_3024);\n    sVar2 = write(_DAT_0006dea8,acStack_3024,__n);\n    if (__n == sVar2) {\n      iVar5 = ftruncate(_DAT_0006dea8,__n);\n      if (iVar5 == -1) {\n        _Var1 = getpid();\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"ftruncate() failed:\",pcVar4);\n      }\n    }\n    else {\n      _Var1 = getpid();\n      piVar3 = __errno_location();\n      pcVar4 = strerror(*piVar3);\n      FUN_00018530(&DAT_0001bbd8,_Var1,\"write() failed:\",pcVar4);\n    }\n  }\n  else if (_DAT_0006dea8 != -1) {\n    close(_DAT_0006dea8);\n    _DAT_0006dea8 = -1;\n  }\n  if (local_24 == *(int *)(unaff_r2 + -0x7008)) {\n    return;\n  }\n  FUN_0001aef0();\n}",
        "output": "```c\nvoid save_pid_to_file(int param_1)\n{\n    int unaff_r2;\n    __pid_t pid;\n    size_t len;\n    size_t bytes_written;\n    int *errno_ptr;\n    char *error_msg;\n    int result;\n    ssize_t bytes_read;\n    int other_pid;\n    char *temp_ptr;\n    char error_msg_buffer[12288];\n    int original_pid;\n    \n    original_pid = *(int *)(unaff_r2 + -0x7008);\n    \n    if (param_1 == 0) {\n        if (_DAT_0006dea8 == -1) {\n            _DAT_0006dea8 = open(\"/var/run/crond.pid\", O_RDWR | O_CREAT, 0640);\n            if (_DAT_0006dea8 == -1) {\n                errno_ptr = __errno_location();\n                error_msg = strerror(*errno_ptr);\n                sprintf(error_msg_buffer, \"can't open or create %s: %s\", \"/var/run/crond.pid\", error_msg);\n                fprintf(stderr, \"%s: %s\\n\", ProgramName, error_msg_buffer);\n                pid = getpid();\n                log_message(&DAT_0001bbd8, pid, \"DEATH\", error_msg_buffer);\n                exit(1);\n            }\n            result = flock(_DAT_0006dea8, LOCK_EX);\n            if (result < 0) {\n                errno_ptr = __errno_location();\n                result = *errno_ptr;\n                memset(error_msg_buffer, 0, 12288);\n                bytes_read = read(_DAT_0006dea8, error_msg_buffer, 12287);\n                if (bytes_read < 1) {\n                    result = -1;\n                }\n                else {\n                    other_pid = strtol(error_msg_buffer, &temp_ptr, 10);\n                    if (other_pid > 0 && error_msg_buffer != temp_ptr && *temp_ptr == '\\n' && other_pid != 0x7fffffff) {\n                        error_msg = strerror(result);\n                        sprintf(error_msg_buffer, \"can't lock %s, otherpid may be %ld: %s\", \"/var/run/crond.pid\", other_pid, error_msg);\n                        goto LABEL_00018f18;\n                    }\n                }\n                error_msg = strerror(result);\n                sprintf(error_msg_buffer, \"can't lock %s, otherpid unknown: %s\", \"/var/run/crond.pid\", error_msg);\n            LABEL_00018f18:\n                error_msg = strerror(result);\n                sprintf(error_msg_buffer, \"can't lock %s, otherpid may be %ld: %s\", \"/var/run/crond.pid\", other_pid, error_msg);\n                fprintf(stderr, \"%s: %s\\n\", ProgramName, error_msg_buffer);\n                pid = getpid();\n                log_message(&DAT_0001bbd8, pid, \"DEATH\", error_msg_buffer);\n                exit(1);\n            }\n            fchmod(_DAT_0006dea8, 420);\n            fcntl(_DAT_0006dea8, F_SETFD, 1);\n        }\n        pid = getpid();\n        sprintf(error_msg_buffer, \"%ld\\n\", pid);\n        lseek(_DAT_0006dea8, 0, 0);\n        len = strlen(error_msg_buffer);\n        bytes_written = write(_DAT_0006dea8, error_msg_buffer, len);\n        if (len == bytes_written) {\n            result = ftruncate(_DAT_0006dea8, len);\n            if (result == -1) {\n                pid = getpid();\n                errno_ptr = __errno_location();\n                error_msg = strerror(*errno_ptr);\n                log_message(&DAT_0001bbd8, pid, \"ftruncate() failed:\", error_msg);\n            }\n        }\n        else {\n            pid = getpid();\n            errno_ptr = __errno_location();\n            error_msg = strerror(*errno_ptr);\n            log_message(&DAT_0001bbd8, pid, \"write() failed:\", error_msg);\n        }\n    }\n    else if (_DAT_0006dea8 != -1) {\n        close(_DAT_0006dea8);\n        _DAT_0006dea8 = -1;\n    }\n    if (original_pid == *(int *)(unaff_r2 + -0x7008)) {\n        return;\n    }\n    cleanup();\n}\n```",
        "source_code": "void\nacquire_daemonlock(int closeflag) {\n\tstatic int fd = -1;\n\tchar buf[3*MAX_FNAME];\n\tconst char *pidfile;\n\tchar *ep;\n\tlong otherpid=-1;\n\tssize_t num, len;\n\n\tif (closeflag) {\n\t\t/* close stashed fd for child so we don't leak it. */\n\t\tif (fd != -1) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (fd == -1) {\n\t\tpidfile = _PATH_CRON_PID;\n\t\t/* Initial mode is 0600 to prevent flock() race/DoS. */\n\t\tif ((fd = open(pidfile, O_RDWR|O_CREAT, 0600)) == -1) {\n\t\t\tsprintf(buf, \"can't open or create %s: %s\",\n\t\t\t\tpidfile, strerror(errno));\n\t\t\tfprintf(stderr, \"%s: %s\\n\", ProgramName, buf);\n\t\t\tlog_it(\"CRON\", getpid(), \"DEATH\", buf);\n\t\t\texit(ERROR_EXIT);\n\t\t}\n\n\t\tif (flock(fd, LOCK_EX|LOCK_NB) < OK) {\n\t\t\tint save_errno = errno;\n\n\t\t\tbzero(buf, sizeof(buf));\n\t\t\tif ((num = read(fd, buf, sizeof(buf) - 1)) > 0 &&\n\t\t\t    (otherpid = strtol(buf, &ep, 10)) > 0 &&\n\t\t\t    ep != buf && *ep == '\\n' && otherpid != LONG_MAX) {\n\t\t\t\tsprintf(buf,\n\t\t\t\t    \"can't lock %s, otherpid may be %ld: %s\",\n\t\t\t\t    pidfile, otherpid, strerror(save_errno));\n\t\t\t} else {\n\t\t\t\tsprintf(buf,\n\t\t\t\t    \"can't lock %s, otherpid unknown: %s\",\n\t\t\t\t    pidfile, strerror(save_errno));\n\t\t\t}\n\t\t\tsprintf(buf, \"can't lock %s, otherpid may be %ld: %s\",\n\t\t\t\tpidfile, otherpid, strerror(save_errno));\n\t\t\tfprintf(stderr, \"%s: %s\\n\", ProgramName, buf);\n\t\t\tlog_it(\"CRON\", getpid(), \"DEATH\", buf);\n\t\t\texit(ERROR_EXIT);\n\t\t}\n\t\t(void) fchmod(fd, 0644);\n\t\t(void) fcntl(fd, F_SETFD, 1);\n\t}\n\n\tsprintf(buf, \"%ld\\n\", (long)getpid());\n\t(void) lseek(fd, (off_t)0, SEEK_SET);\n\tlen =  strlen(buf);\n\tif( (num = write(fd, buf, len)) != len )\n\t    log_it(\"CRON\", getpid(), \"write() failed:\", strerror(errno));\n\telse\n\t{\t    \n\t    if( ftruncate(fd, num) == -1 )\n\t\tlog_it(\"CRON\", getpid(), \"ftruncate() failed:\", strerror(errno));\n\t}\n\n\t/* abandon fd even though the file is open. we need to keep\n\t * it open and locked, but we don't need the handles elsewhere.\n\t */\n}",
        "parsed_output": "void save_pid_to_file(int param_1)\n{\n    int unaff_r2;\n    __pid_t pid;\n    size_t len;\n    size_t bytes_written;\n    int *errno_ptr;\n    char *error_msg;\n    int result;\n    ssize_t bytes_read;\n    int other_pid;\n    char *temp_ptr;\n    char error_msg_buffer[12288];\n    int original_pid;\n    \n    original_pid = *(int *)(unaff_r2 + -0x7008);\n    \n    if (param_1 == 0) {\n        if (_DAT_0006dea8 == -1) {\n            _DAT_0006dea8 = open(\"/var/run/crond.pid\", O_RDWR | O_CREAT, 0640);\n            if (_DAT_0006dea8 == -1) {\n                errno_ptr = __errno_location();\n                error_msg = strerror(*errno_ptr);\n                sprintf(error_msg_buffer, \"can't open or create %s: %s\", \"/var/run/crond.pid\", error_msg);\n                fprintf(stderr, \"%s: %s\\n\", ProgramName, error_msg_buffer);\n                pid = getpid();\n                log_message(&DAT_0001bbd8, pid, \"DEATH\", error_msg_buffer);\n                exit(1);\n            }\n            result = flock(_DAT_0006dea8, LOCK_EX);\n            if (result < 0) {\n                errno_ptr = __errno_location();\n                result = *errno_ptr;\n                memset(error_msg_buffer, 0, 12288);\n                bytes_read = read(_DAT_0006dea8, error_msg_buffer, 12287);\n                if (bytes_read < 1) {\n                    result = -1;\n                }\n                else {\n                    other_pid = strtol(error_msg_buffer, &temp_ptr, 10);\n                    if (other_pid > 0 && error_msg_buffer != temp_ptr && *temp_ptr == '\\n' && other_pid != 0x7fffffff) {\n                        error_msg = strerror(result);\n                        sprintf(error_msg_buffer, \"can't lock %s, otherpid may be %ld: %s\", \"/var/run/crond.pid\", other_pid, error_msg);\n                        goto LABEL_00018f18;\n                    }\n                }\n                error_msg = strerror(result);\n                sprintf(error_msg_buffer, \"can't lock %s, otherpid unknown: %s\", \"/var/run/crond.pid\", error_msg);\n            LABEL_00018f18:\n                error_msg = strerror(result);\n                sprintf(error_msg_buffer, \"can't lock %s, otherpid may be %ld: %s\", \"/var/run/crond.pid\", other_pid, error_msg);\n                fprintf(stderr, \"%s: %s\\n\", ProgramName, error_msg_buffer);\n                pid = getpid();\n                log_message(&DAT_0001bbd8, pid, \"DEATH\", error_msg_buffer);\n                exit(1);\n            }\n            fchmod(_DAT_0006dea8, 420);\n            fcntl(_DAT_0006dea8, F_SETFD, 1);\n        }\n        pid = getpid();\n        sprintf(error_msg_buffer, \"%ld\\n\", pid);\n        lseek(_DAT_0006dea8, 0, 0);\n        len = strlen(error_msg_buffer);\n        bytes_written = write(_DAT_0006dea8, error_msg_buffer, len);\n        if (len == bytes_written) {\n            result = ftruncate(_DAT_0006dea8, len);\n            if (result == -1) {\n                pid = getpid();\n                errno_ptr = __errno_location();\n                error_msg = strerror(*errno_ptr);\n                log_message(&DAT_0001bbd8, pid, \"ftruncate() failed:\", error_msg);\n            }\n        }\n        else {\n            pid = getpid();\n            errno_ptr = __errno_location();\n            error_msg = strerror(*errno_ptr);\n            log_message(&DAT_0001bbd8, pid, \"write() failed:\", error_msg);\n        }\n    }\n    else if (_DAT_0006dea8 != -1) {\n        close(_DAT_0006dea8);\n        _DAT_0006dea8 = -1;\n    }\n    if (original_pid == *(int *)(unaff_r2 + -0x7008)) {\n        return;\n    }\n    cleanup();\n}",
        "baseline_code_stripped": "void FUN_00018ca0(int param_1)\n{\n  int unaff_r2;\n  __pid_t _Var1;\n  size_t __n;\n  size_t sVar2;\n  int *piVar3;\n  char *pcVar4;\n  int iVar5;\n  ssize_t sVar6;\n  int iVar7;\n  char *local_3028;\n  char acStack_3024 [12288];\n  int local_24;\n  local_24 = *(int *)(unaff_r2 + -0x7008);\n  if (param_1 == 0) {\n    if (_DAT_0006dea8 == -1) {\n      _DAT_0006dea8 = open(\"/var/run/crond.pid\",0x42,0x180);\n      if (_DAT_0006dea8 == -1) {\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t open or create %s: %s\",\"/var/run/crond.pid\",\n                      pcVar4);\n        __fprintf_chk(stderr,1,\"%s: %s\\n\",ProgramName,acStack_3024);\n        _Var1 = getpid();\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"DEATH\",acStack_3024);\n        exit(1);\n      }\n      iVar5 = flock(_DAT_0006dea8,6);\n      if (iVar5 < 0) {\n        piVar3 = __errno_location();\n        iVar5 = *piVar3;\n        memset(acStack_3024,0,0x3000);\n        sVar6 = read(_DAT_0006dea8,acStack_3024,0x2fff);\n        if (sVar6 < 1) {\n          iVar7 = -1;\n        }\n        else {\n          iVar7 = __strtol_internal(acStack_3024,&local_3028,10,0);\n          if ((((0 < iVar7) && (acStack_3024 != local_3028)) && (*local_3028 == '\\n')) &&\n             (iVar7 != 0x7fffffff)) {\n            pcVar4 = strerror(iVar5);\n            __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid may be %ld: %s\",\n                          \"/var/run/crond.pid\",iVar7,pcVar4);\n            goto LAB_00018f18;\n          }\n        }\n        pcVar4 = strerror(iVar5);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid unknown: %s\",\n                      \"/var/run/crond.pid\",pcVar4);\nLAB_00018f18:\n        pcVar4 = strerror(iVar5);\n        __sprintf_chk(acStack_3024,1,0x3000,\"can\\'t lock %s, otherpid may be %ld: %s\",\n                      \"/var/run/crond.pid\",iVar7,pcVar4);\n        __fprintf_chk(stderr,1,\"%s: %s\\n\",ProgramName,acStack_3024);\n        _Var1 = getpid();\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"DEATH\",acStack_3024);\n        exit(1);\n      }\n      fchmod(_DAT_0006dea8,0x1a4);\n      fcntl(_DAT_0006dea8,2,1);\n    }\n    _Var1 = getpid();\n    __sprintf_chk(acStack_3024,1,0x3000,\"%ld\\n\",_Var1);\n    lseek(_DAT_0006dea8,0,0);\n    __n = strlen(acStack_3024);\n    sVar2 = write(_DAT_0006dea8,acStack_3024,__n);\n    if (__n == sVar2) {\n      iVar5 = ftruncate(_DAT_0006dea8,__n);\n      if (iVar5 == -1) {\n        _Var1 = getpid();\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        FUN_00018530(&DAT_0001bbd8,_Var1,\"ftruncate() failed:\",pcVar4);\n      }\n    }\n    else {\n      _Var1 = getpid();\n      piVar3 = __errno_location();\n      pcVar4 = strerror(*piVar3);\n      FUN_00018530(&DAT_0001bbd8,_Var1,\"write() failed:\",pcVar4);\n    }\n  }\n  else if (_DAT_0006dea8 != -1) {\n    close(_DAT_0006dea8);\n    _DAT_0006dea8 = -1;\n  }\n  if (local_24 == *(int *)(unaff_r2 + -0x7008)) {\n    return;\n  }\n  FUN_0001aef0();\n}",
        "similarity_score_unixcoder": 0.8088853359222412,
        "similarity_score_baseline_stripped": 0.7211880683898926
    },
    {
        "func_name": "internal_create_group",
        "normed_func_sha256": "39c901c2821d92209b8a3feade424fc15546c62547061722998ec1192813d077",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __regparm3 internal_create_group(undefined4 *param_1,int param_2,int *param_3)\n{\n  code *pcVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int *piVar5;\n  int local_18;\n  int *local_14;\n  if (param_1 != (undefined4 *)0x0) {\n    if (param_2 == 0) {\n      if (param_1[6] == 0) goto LAB_810c21d9;\n    }\n    else if (param_1[6] == 0) {\n      return -0x16;\n    }\n    if (param_3[2] == 0) {\n      pcVar1 = (code *)0x0;\n      if (*param_3 != 0) {\n        pcVar1 = FUN_8133905c;\n      }\n      warn_slowpath_fmt(\"/home/build/workspace/bst/contrib/kitkat/kernel/fs/sysfs/group.c\",0x48,\n                        \"sysfs: attrs not set by subsystem for group: %s/%s\\n\",*param_1,pcVar1);\n      return -0x16;\n    }\n    if (*param_3 == 0) {\n      local_14 = (int *)param_1[6];\n    }\n    else {\n      iVar2 = sysfs_create_subdir();\n      if (iVar2 != 0) {\n        return iVar2;\n      }\n    }\n    if (local_14 != (int *)0x0) {\n      if (*local_14 == 0) {\n        warn_slowpath_null();\n      }\n      *local_14 = *local_14 + 1;\n    }\n    local_18 = 0;\n    iVar2 = param_3[2];\n    piVar5 = local_14;\n    do {\n      if (*(int *)(iVar2 + local_18 * 4) == 0) {\n        iVar4 = 0;\nLAB_810c22ed:\n        if (local_14 == (int *)0x0) {\n          return iVar4;\n        }\n        *local_14 = *local_14 + -1;\n        if (*local_14 == 0) {\n          release_sysfs_dirent();\n          return iVar4;\n        }\n        return iVar4;\n      }\n      if (param_2 != 0) {\n        sysfs_hash_and_remove(param_2,iVar2,piVar5);\n      }\n      if ((code *)param_3[1] == (code *)0x0) {\n        uVar3 = 0;\nLAB_810c22b3:\n        iVar4 = sysfs_add_file_mode((uVar3 | *(uint *)(*(int *)(iVar2 + local_18 * 4) + 4)) & 0xffff\n                                   );\n        if (iVar4 != 0) {\n          for (piVar5 = (int *)param_3[2]; *piVar5 != 0; piVar5 = piVar5 + 1) {\n            sysfs_hash_and_remove();\n          }\n          if (*param_3 != 0) {\n            sysfs_remove_subdir();\n          }\n          goto LAB_810c22ed;\n        }\n      }\n      else {\n        uVar3 = (*(code *)param_3[1])();\n        if ((short)uVar3 != 0) goto LAB_810c22b3;\n      }\n      local_18 = local_18 + 1;\n    } while( true );\n  }\nLAB_810c21d9:\n  hd_UnplugBug();\n}",
        "output": "```c\nint __regparm3 internal_create_group(undefined4 *param_1, int param_2, int *param_3)\n{\n    code *pcVar1;\n    int iVar2;\n    uint uVar3;\n    int iVar4;\n    int *piVar5;\n    int local_18;\n    int *local_14;\n\n    if (param_1 == (undefined4 *)0x0) {\n        hd_UnplugBug();\n    }\n\n    if (param_2 == 0 && param_1[6] == 0) {\n        hd_UnplugBug();\n    }\n\n    if (param_1[6] == 0) {\n        return -0x16;\n    }\n\n    if (param_3[2] == 0) {\n        pcVar1 = (code *)0x0;\n        if (*param_3 != 0) {\n            pcVar1 = FUN_8133905c;\n        }\n        warn_slowpath_fmt(\"/home/build/workspace/bst/contrib/kitkat/kernel/fs/sysfs/group.c\", 0x48, \"sysfs: attrs not set by subsystem for group: %s/%s\\n\", *param_1, pcVar1);\n        return -0x16;\n    }\n\n    if (*param_3 == 0) {\n        local_14 = (int *)param_1[6];\n    } else {\n        iVar2 = sysfs_create_subdir();\n        if (iVar2 != 0) {\n            return iVar2;\n        }\n    }\n\n    if (local_14 != (int *)0x0) {\n        if (*local_14 == 0) {\n            warn_slowpath_null();\n        }\n        *local_14 = *local_14 + 1;\n    }\n\n    local_18 = 0;\n    iVar2 = param_3[2];\n    piVar5 = local_14;\n\n    do {\n        if (*(int *)(iVar2 + local_18 * 4) == 0) {\n            iVar4 = 0;\n            if (local_14 == (int *)0x0) {\n                return iVar4;\n            }\n            *local_14 = *local_14 + -1;\n            if (*local_14 == 0) {\n                release_sysfs_dirent();\n                return iVar4;\n            }\n            return iVar4;\n        }\n\n        if (param_2 != 0) {\n            sysfs_hash_and_remove(param_2, iVar2, piVar5);\n        }\n\n        if ((code *)param_3[1] == (code *)0x0) {\n            uVar3 = 0;\n        LAB_810c22b3:\n            iVar4 = sysfs_add_file_mode((uVar3 | *(uint *)(*(int *)(iVar2 + local_18 * 4) + 4)) & 0xffff);\n\n            if (iVar4 != 0) {\n                for (piVar5 = (int *)param_3[2]; *piVar5 != 0; piVar5 = piVar5 + 1) {\n                    sysfs_hash_and_remove();\n                }\n                if (*param_3 != 0) {\n                    sysfs_remove_subdir();\n                }\n                return iVar4;\n            }\n        } else {\n            uVar3 = (*(code *)param_3[1])();\n\n            if ((short)uVar3 != 0) {\n                goto LAB_810c22b3;\n            }\n        }\n\n        local_18 = local_18 + 1;\n    } while (true);\n}\n```",
        "source_code": "static int internal_create_group(struct kobject *kobj, int update,\n\t\t\t\t const struct attribute_group *grp)\n{\n\tstruct sysfs_dirent *sd;\n\tint error;\n\n\tBUG_ON(!kobj || (!update && !kobj->sd));\n\n\t/* Updates may happen before the object has been instantiated */\n\tif (unlikely(update && !kobj->sd))\n\t\treturn -EINVAL;\n\tif (!grp->attrs) {\n\t\tWARN(1, \"sysfs: attrs not set by subsystem for group: %s/%s\\n\",\n\t\t\tkobj->name, grp->name ? \"\" : grp->name);\n\t\treturn -EINVAL;\n\t}\n\tif (grp->name) {\n\t\terror = sysfs_create_subdir(kobj, grp->name, &sd);\n\t\tif (error)\n\t\t\treturn error;\n\t} else\n\t\tsd = kobj->sd;\n\tsysfs_get(sd);\n\terror = create_files(sd, kobj, grp, update);\n\tif (error) {\n\t\tif (grp->name)\n\t\t\tsysfs_remove_subdir(sd);\n\t}\n\tsysfs_put(sd);\n\treturn error;\n}",
        "parsed_output": "int __regparm3 internal_create_group(undefined4 *param_1, int param_2, int *param_3)\n{\n    code *pcVar1;\n    int iVar2;\n    uint uVar3;\n    int iVar4;\n    int *piVar5;\n    int local_18;\n    int *local_14;\n\n    if (param_1 == (undefined4 *)0x0) {\n        hd_UnplugBug();\n    }\n\n    if (param_2 == 0 && param_1[6] == 0) {\n        hd_UnplugBug();\n    }\n\n    if (param_1[6] == 0) {\n        return -0x16;\n    }\n\n    if (param_3[2] == 0) {\n        pcVar1 = (code *)0x0;\n        if (*param_3 != 0) {\n            pcVar1 = FUN_8133905c;\n        }\n        warn_slowpath_fmt(\"/home/build/workspace/bst/contrib/kitkat/kernel/fs/sysfs/group.c\", 0x48, \"sysfs: attrs not set by subsystem for group: %s/%s\\n\", *param_1, pcVar1);\n        return -0x16;\n    }\n\n    if (*param_3 == 0) {\n        local_14 = (int *)param_1[6];\n    } else {\n        iVar2 = sysfs_create_subdir();\n        if (iVar2 != 0) {\n            return iVar2;\n        }\n    }\n\n    if (local_14 != (int *)0x0) {\n        if (*local_14 == 0) {\n            warn_slowpath_null();\n        }\n        *local_14 = *local_14 + 1;\n    }\n\n    local_18 = 0;\n    iVar2 = param_3[2];\n    piVar5 = local_14;\n\n    do {\n        if (*(int *)(iVar2 + local_18 * 4) == 0) {\n            iVar4 = 0;\n            if (local_14 == (int *)0x0) {\n                return iVar4;\n            }\n            *local_14 = *local_14 + -1;\n            if (*local_14 == 0) {\n                release_sysfs_dirent();\n                return iVar4;\n            }\n            return iVar4;\n        }\n\n        if (param_2 != 0) {\n            sysfs_hash_and_remove(param_2, iVar2, piVar5);\n        }\n\n        if ((code *)param_3[1] == (code *)0x0) {\n            uVar3 = 0;\n        LAB_810c22b3:\n            iVar4 = sysfs_add_file_mode((uVar3 | *(uint *)(*(int *)(iVar2 + local_18 * 4) + 4)) & 0xffff);\n\n            if (iVar4 != 0) {\n                for (piVar5 = (int *)param_3[2]; *piVar5 != 0; piVar5 = piVar5 + 1) {\n                    sysfs_hash_and_remove();\n                }\n                if (*param_3 != 0) {\n                    sysfs_remove_subdir();\n                }\n                return iVar4;\n            }\n        } else {\n            uVar3 = (*(code *)param_3[1])();\n\n            if ((short)uVar3 != 0) {\n                goto LAB_810c22b3;\n            }\n        }\n\n        local_18 = local_18 + 1;\n    } while (true);\n}",
        "baseline_code_stripped": "int __regparm3 internal_create_group(undefined4 *param_1,int param_2,int *param_3)\n{\n  code *pcVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int *piVar5;\n  int local_18;\n  int *local_14;\n  if (param_1 != (undefined4 *)0x0) {\n    if (param_2 == 0) {\n      if (param_1[6] == 0) goto LAB_810c21d9;\n    }\n    else if (param_1[6] == 0) {\n      return -0x16;\n    }\n    if (param_3[2] == 0) {\n      pcVar1 = (code *)0x0;\n      if (*param_3 != 0) {\n        pcVar1 = FUN_8133905c;\n      }\n      warn_slowpath_fmt(\"/home/build/workspace/bst/contrib/kitkat/kernel/fs/sysfs/group.c\",0x48,\n                        \"sysfs: attrs not set by subsystem for group: %s/%s\\n\",*param_1,pcVar1);\n      return -0x16;\n    }\n    if (*param_3 == 0) {\n      local_14 = (int *)param_1[6];\n    }\n    else {\n      iVar2 = sysfs_create_subdir();\n      if (iVar2 != 0) {\n        return iVar2;\n      }\n    }\n    if (local_14 != (int *)0x0) {\n      if (*local_14 == 0) {\n        warn_slowpath_null();\n      }\n      *local_14 = *local_14 + 1;\n    }\n    local_18 = 0;\n    iVar2 = param_3[2];\n    piVar5 = local_14;\n    do {\n      if (*(int *)(iVar2 + local_18 * 4) == 0) {\n        iVar4 = 0;\nLAB_810c22ed:\n        if (local_14 == (int *)0x0) {\n          return iVar4;\n        }\n        *local_14 = *local_14 + -1;\n        if (*local_14 == 0) {\n          release_sysfs_dirent();\n          return iVar4;\n        }\n        return iVar4;\n      }\n      if (param_2 != 0) {\n        sysfs_hash_and_remove(param_2,iVar2,piVar5);\n      }\n      if ((code *)param_3[1] == (code *)0x0) {\n        uVar3 = 0;\nLAB_810c22b3:\n        iVar4 = sysfs_add_file_mode((uVar3 | *(uint *)(*(int *)(iVar2 + local_18 * 4) + 4)) & 0xffff\n                                   );\n        if (iVar4 != 0) {\n          for (piVar5 = (int *)param_3[2]; *piVar5 != 0; piVar5 = piVar5 + 1) {\n            sysfs_hash_and_remove();\n          }\n          if (*param_3 != 0) {\n            sysfs_remove_subdir();\n          }\n          goto LAB_810c22ed;\n        }\n      }\n      else {\n        uVar3 = (*(code *)param_3[1])();\n        if ((short)uVar3 != 0) goto LAB_810c22b3;\n      }\n      local_18 = local_18 + 1;\n    } while( true );\n  }\nLAB_810c21d9:\n  hd_UnplugBug();\n}",
        "similarity_score_unixcoder": 0.6108883023262024,
        "similarity_score_baseline_stripped": 0.596930742263794
    },
    {
        "func_name": "s_forward",
        "normed_func_sha256": "ee40c9a65acefd1731e6e43be0d81616867d5c1c4935994809e8e5b6e1c25fee",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nXY s_forward(LP lp,PJ_conflict56 *P)\n{\n  undefined8 extraout_RAX;\n  undefined8 uVar1;\n  undefined8 extraout_RAX_00;\n  undefined8 extraout_RDX;\n  undefined8 uVar2;\n  undefined8 extraout_RDX_00;\n  int iVar3;\n  double dVar4;\n  double p;\n  double dVar5;\n  double dVar6;\n  double dVar7;\n  double in_XMM1_Qa;\n  double dVar8;\n  double V;\n  double dVar9;\n  double r;\n  XY XVar10;\n  iVar3 = 10;\n  dVar4 = sin(in_XMM1_Qa);\n  dVar7 = P->B;\n  dVar8 = in_XMM1_Qa * 1.10265779;\n  while( true ) {\n    dVar5 = dVar8 * dVar8 + 1.0;\n    dVar9 = SQRT(dVar5);\n    if (dVar5 < 0.0) {\n      sqrt(dVar5);\n    }\n    dVar5 = P->A;\n    dVar6 = log(dVar9 + dVar8);\n    dVar5 = (((dVar5 - dVar9) * dVar8 - dVar6) - dVar4 * dVar7) / (P->A - (dVar9 + dVar9));\n    dVar8 = dVar8 - dVar5;\n    uVar1 = extraout_RAX;\n    uVar2 = extraout_RDX;\n    if ((double)((ulong)dVar5 & 0x7fffffffffffffff) < 1e-10) break;\n    iVar3 = iVar3 + -1;\n    if (iVar3 == 0) {\nLAB_0042e78a:\n      XVar10.y = (double)uVar2;\n      XVar10.x = (double)uVar1;\n      return XVar10;\n    }\n  }\n  dVar7 = dVar8 * dVar8 + 1.0;\n  if (dVar7 < 0.0) {\n    sqrt(dVar7);\n    uVar1 = extraout_RAX_00;\n    uVar2 = extraout_RDX_00;\n  }\n  goto LAB_0042e78a;\n}",
        "output": "```c\nXY s_forward(LP lp, PJ_conflict56 *P)\n{\n    int iterations = 10;\n    double sin_val, B_val, A_val, log_val, sqrt_val, r_val;\n    double XMM1_Qa_val = lp->XMM1_Qa;\n    double V_val;\n    XY result;\n\n    sin_val = sin(XMM1_Qa_val);\n    B_val = P->B;\n    r_val = XMM1_Qa_val * 1.10265779;\n\n    while (true) {\n        double temp = r_val * r_val + 1.0;\n        sqrt_val = sqrt(temp);\n\n        if (temp < 0.0) {\n            sqrt(temp);\n        }\n\n        A_val = P->A;\n        log_val = log(sqrt_val + r_val);\n        double temp2 = (((A_val - sqrt_val) * r_val - log_val) - sin_val * B_val) / (P->A - (sqrt_val + sqrt_val));\n        r_val = r_val - temp2;\n\n        if (fabs(temp2) < 1e-10) {\n            result.y = (double)uVar2;\n            result.x = (double)uVar1;\n            return result;\n        }\n\n        iterations--;\n\n        if (iterations == 0) {\n            result.y = (double)uVar2;\n            result.x = (double)uVar1;\n            return result;\n        }\n    }\n\n    double temp3 = r_val * r_val + 1.0;\n\n    if (temp3 < 0.0) {\n        sqrt(temp3);\n    }\n\n    result.y = (double)uVar2;\n    result.x = (double)uVar1;\n    return result;\n}\n```",
        "source_code": "static PJ_XY s_forward (PJ_LP lp, PJ *P) {           /* Spheroidal, forward */\n    PJ_XY xy = {0.0,0.0};\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(P->opaque);\n    double p, r, V;\n    int i;\n\n    p = Q->B * sin(lp.phi);\n    lp.phi *=  1.10265779;\n    for (i = NITER; i ; --i) {\n        r = sqrt(1. + lp.phi * lp.phi);\n        lp.phi -= V = ( (Q->A - r) * lp.phi - log(lp.phi + r) - p ) /\n            (Q->A - 2. * r);\n        if (fabs(V) < EPS)\n            break;\n    }\n    if (!i)\n        lp.phi = p < 0. ? -CON_POLE : CON_POLE;\n    xy.x = Q->C_x * lp.lam * (Q->D - sqrt(1. + lp.phi * lp.phi));\n    xy.y = Q->C_y * lp.phi;\n\n    return xy;\n}",
        "parsed_output": "XY s_forward(LP lp, PJ_conflict56 *P)\n{\n    int iterations = 10;\n    double sin_val, B_val, A_val, log_val, sqrt_val, r_val;\n    double XMM1_Qa_val = lp->XMM1_Qa;\n    double V_val;\n    XY result;\n\n    sin_val = sin(XMM1_Qa_val);\n    B_val = P->B;\n    r_val = XMM1_Qa_val * 1.10265779;\n\n    while (true) {\n        double temp = r_val * r_val + 1.0;\n        sqrt_val = sqrt(temp);\n\n        if (temp < 0.0) {\n            sqrt(temp);\n        }\n\n        A_val = P->A;\n        log_val = log(sqrt_val + r_val);\n        double temp2 = (((A_val - sqrt_val) * r_val - log_val) - sin_val * B_val) / (P->A - (sqrt_val + sqrt_val));\n        r_val = r_val - temp2;\n\n        if (fabs(temp2) < 1e-10) {\n            result.y = (double)uVar2;\n            result.x = (double)uVar1;\n            return result;\n        }\n\n        iterations--;\n\n        if (iterations == 0) {\n            result.y = (double)uVar2;\n            result.x = (double)uVar1;\n            return result;\n        }\n    }\n\n    double temp3 = r_val * r_val + 1.0;\n\n    if (temp3 < 0.0) {\n        sqrt(temp3);\n    }\n\n    result.y = (double)uVar2;\n    result.x = (double)uVar1;\n    return result;\n}",
        "baseline_code_stripped": "XY s_forward(LP lp,PJ_conflict56 *P)\n{\n  undefined8 extraout_RAX;\n  undefined8 uVar1;\n  undefined8 extraout_RAX_00;\n  undefined8 extraout_RDX;\n  undefined8 uVar2;\n  undefined8 extraout_RDX_00;\n  int iVar3;\n  double dVar4;\n  double p;\n  double dVar5;\n  double dVar6;\n  double dVar7;\n  double in_XMM1_Qa;\n  double dVar8;\n  double V;\n  double dVar9;\n  double r;\n  XY XVar10;\n  iVar3 = 10;\n  dVar4 = sin(in_XMM1_Qa);\n  dVar7 = P->B;\n  dVar8 = in_XMM1_Qa * 1.10265779;\n  while( true ) {\n    dVar5 = dVar8 * dVar8 + 1.0;\n    dVar9 = SQRT(dVar5);\n    if (dVar5 < 0.0) {\n      sqrt(dVar5);\n    }\n    dVar5 = P->A;\n    dVar6 = log(dVar9 + dVar8);\n    dVar5 = (((dVar5 - dVar9) * dVar8 - dVar6) - dVar4 * dVar7) / (P->A - (dVar9 + dVar9));\n    dVar8 = dVar8 - dVar5;\n    uVar1 = extraout_RAX;\n    uVar2 = extraout_RDX;\n    if ((double)((ulong)dVar5 & 0x7fffffffffffffff) < 1e-10) break;\n    iVar3 = iVar3 + -1;\n    if (iVar3 == 0) {\nLAB_0042e78a:\n      XVar10.y = (double)uVar2;\n      XVar10.x = (double)uVar1;\n      return XVar10;\n    }\n  }\n  dVar7 = dVar8 * dVar8 + 1.0;\n  if (dVar7 < 0.0) {\n    sqrt(dVar7);\n    uVar1 = extraout_RAX_00;\n    uVar2 = extraout_RDX_00;\n  }\n  goto LAB_0042e78a;\n}",
        "similarity_score_unixcoder": 0.7016437649726868,
        "similarity_score_baseline_stripped": 0.5989173650741577
    },
    {
        "func_name": "height",
        "normed_func_sha256": "5d1f9df4664c91cd46d2740d85bdb4ef00d7987182ef1c16a6786e34bc2c586d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nulong WebCore::jsImageData_height(JSGlobalObject *param_1,long param_2,PropertyName param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(long *)(param_2 + 0x18) + 8);\n  if (-1 < (int)uVar1) {\n    return (long)(int)uVar1 | 0xfffe000000000000;\n  }\n  return (long)(double)(ulong)uVar1 + 0x2000000000000;\n}",
        "output": "ulong WebCore::jsImageData_height(JSGlobalObject *param_1, long param_2, PropertyName param_3)\n{\n    uint imageHeight = *(uint *)(*(long *)(param_2 + 0x18) + 8);\n    \n    if (imageHeight >= 0) {\n        return (long)(int)imageHeight | 0xfffe000000000000;\n    } else {\n        return (long)(double)(ulong)imageHeight + 0x2000000000000;\n    }\n}",
        "source_code": "constexpr int height() const { return m_height; }",
        "parsed_output": "ulong WebCore::jsImageData_height(JSGlobalObject *param_1, long param_2, PropertyName param_3)\n{\n    uint imageHeight = *(uint *)(*(long *)(param_2 + 0x18) + 8);\n    \n    if (imageHeight >= 0) {\n        return (long)(int)imageHeight | 0xfffe000000000000;\n    } else {\n        return (long)(double)(ulong)imageHeight + 0x2000000000000;\n    }\n}",
        "baseline_code_stripped": "ulong WebCore::jsImageData_height(JSGlobalObject *param_1,long param_2,PropertyName param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(long *)(param_2 + 0x18) + 8);\n  if (-1 < (int)uVar1) {\n    return (long)(int)uVar1 | 0xfffe000000000000;\n  }\n  return (long)(double)(ulong)uVar1 + 0x2000000000000;\n}",
        "similarity_score_unixcoder": 0.550814151763916,
        "similarity_score_baseline_stripped": 0.5196183323860168
    },
    {
        "func_name": "Sbk_QImageCaptureFunc_captureSession",
        "normed_func_sha256": "3a8a92028ce3d53e3ec4fb73e267768b0a429ed5dd2ebb4956cf541cd1f1b84c",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint * FUN_00043be8(_object *param_1)\n{\n  int iVar1;\n  void *pvVar2;\n  int *piVar3;\n  iVar1 = Shiboken::Object::isValid(param_1);\n  if (iVar1 != 0) {\n    Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_000a4c00 + 0x74),(SbkObject *)param_1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      pvVar2 = (void *)QImageCapture::captureSession();\n      piVar3 = (int *)Shiboken::Conversions::pointerToPython\n                                (*(_typeobject **)(DAT_000a4c00 + 0x84),pvVar2);\n      Shiboken::Object::setParent(param_1,(_object *)piVar3);\n      iVar1 = PyErr_Occurred();\n      if (iVar1 == 0) {\n        return piVar3;\n      }\n      if ((piVar3 != (int *)0x0) && (iVar1 = *piVar3, *piVar3 = iVar1 + -1, iVar1 + -1 == 0)) {\n        _Py_Dealloc(piVar3);\n      }\n    }\n    else {\n      PyErr_Occurred();\n    }\n  }\n  return (int *)0x0;\n}",
        "output": "int * capture_image(_object *image_object)\n{\n  int isValid = Shiboken::Object::isValid(image_object);\n  \n  if (isValid != 0) {\n    Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_000a4c00 + 0x74), (SbkObject *)image_object);\n    int errorOccurred = PyErr_Occurred();\n    \n    if (errorOccurred == 0) {\n      void *capture_session = (void *)QImageCapture::captureSession();\n      int *python_pointer = (int *)Shiboken::Conversions::pointerToPython(*(_typeobject **)(DAT_000a4c00 + 0x84), capture_session);\n      Shiboken::Object::setParent(image_object, (_object *)python_pointer);\n      errorOccurred = PyErr_Occurred();\n      \n      if (errorOccurred == 0) {\n        return python_pointer;\n      }\n      \n      if ((python_pointer != (int *)0x0) && (errorOccurred = *python_pointer, *python_pointer = errorOccurred - 1, errorOccurred - 1 == 0)) {\n        _Py_Dealloc(python_pointer);\n      }\n    }\n    else {\n      PyErr_Occurred();\n    }\n  }\n  \n  return (int *)0x0;\n}",
        "source_code": "static PyObject *Sbk_QImageCaptureFunc_captureSession(PyObject *self)\n{\n    if (!Shiboken::Object::isValid(self))\n        return {};\n    auto *cppSelf = reinterpret_cast< ::QImageCapture *>(Shiboken::Conversions::cppPointer(SbkPySide6_QtMultimediaTypes[SBK_QIMAGECAPTURE_IDX], reinterpret_cast<SbkObject *>(self)));\n    SBK_UNUSED(cppSelf)\n    PyObject *pyResult{};\n\n    // Call function/method\n    {\n\n        if (!PyErr_Occurred()) {\n            // captureSession()const\n            QMediaCaptureSession * cppResult = const_cast<const ::QImageCapture *>(cppSelf)->captureSession();\n            pyResult = Shiboken::Conversions::pointerToPython(SbkPySide6_QtMultimediaTypes[SBK_QMEDIACAPTURESESSION_IDX], cppResult);\n            // Ownership transferences (return value heuristics).\n            Shiboken::Object::setParent(self, pyResult);\n        }\n    }\n\n    if (PyErr_Occurred() || !pyResult) {\n        Py_XDECREF(pyResult);\n        return {};\n    }\n    return pyResult;\n}",
        "parsed_output": "int * capture_image(_object *image_object)\n{\n  int isValid = Shiboken::Object::isValid(image_object);\n  \n  if (isValid != 0) {\n    Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_000a4c00 + 0x74), (SbkObject *)image_object);\n    int errorOccurred = PyErr_Occurred();\n    \n    if (errorOccurred == 0) {\n      void *capture_session = (void *)QImageCapture::captureSession();\n      int *python_pointer = (int *)Shiboken::Conversions::pointerToPython(*(_typeobject **)(DAT_000a4c00 + 0x84), capture_session);\n      Shiboken::Object::setParent(image_object, (_object *)python_pointer);\n      errorOccurred = PyErr_Occurred();\n      \n      if (errorOccurred == 0) {\n        return python_pointer;\n      }\n      \n      if ((python_pointer != (int *)0x0) && (errorOccurred = *python_pointer, *python_pointer = errorOccurred - 1, errorOccurred - 1 == 0)) {\n        _Py_Dealloc(python_pointer);\n      }\n    }\n    else {\n      PyErr_Occurred();\n    }\n  }\n  \n  return (int *)0x0;\n}",
        "baseline_code_stripped": "int * FUN_00043be8(_object *param_1)\n{\n  int iVar1;\n  void *pvVar2;\n  int *piVar3;\n  iVar1 = Shiboken::Object::isValid(param_1);\n  if (iVar1 != 0) {\n    Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_000a4c00 + 0x74),(SbkObject *)param_1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      pvVar2 = (void *)QImageCapture::captureSession();\n      piVar3 = (int *)Shiboken::Conversions::pointerToPython\n                                (*(_typeobject **)(DAT_000a4c00 + 0x84),pvVar2);\n      Shiboken::Object::setParent(param_1,(_object *)piVar3);\n      iVar1 = PyErr_Occurred();\n      if (iVar1 == 0) {\n        return piVar3;\n      }\n      if ((piVar3 != (int *)0x0) && (iVar1 = *piVar3, *piVar3 = iVar1 + -1, iVar1 + -1 == 0)) {\n        _Py_Dealloc(piVar3);\n      }\n    }\n    else {\n      PyErr_Occurred();\n    }\n  }\n  return (int *)0x0;\n}",
        "similarity_score_unixcoder": 0.7718857526779175,
        "similarity_score_baseline_stripped": 0.6691700220108032
    },
    {
        "func_name": "WLog_JournaldAppender_Open",
        "normed_func_sha256": "1dd3e8d936cbafc5f6816d19b94ec94c1cf2886c2b6ac4bc194ccf21c23464fc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_0016bd00(long param_1,long param_2)\n{\n  undefined8 uVar1;\n  if ((param_1 != 0) && (param_2 != 0)) {\n    if (*(long *)(param_2 + 0xa8) != 0) {\n      return 1;\n    }\n    uVar1 = FUN_0016bc90(param_2);\n    return uVar1;\n  }\n  return 0;\n}",
        "output": "```c\nundefined8 check_params(long param_1, long param_2)\n{\n    undefined8 result;\n    \n    if (param_1 != 0 && param_2 != 0) {\n        if (*(long *)(param_2 + 0xa8) != 0) {\n            return 1;\n        }\n        result = FUN_0016bc90(param_2);\n        return result;\n    }\n    \n    return 0;\n}\n```",
        "source_code": "static BOOL WLog_JournaldAppender_Open(wLog* log, wLogAppender* appender)\n{\n\tint fd;\n\twLogJournaldAppender *journaldAppender;\n\n\tif (!log || !appender)\n\t\treturn FALSE;\n\n\tjournaldAppender = (wLogJournaldAppender*)appender;\n\tif (journaldAppender->stream)\n\t\treturn TRUE;\n\n\tfd = sd_journal_stream_fd(journaldAppender->identifier, LOG_INFO, 1);\n\tif (fd < 0)\n\t\treturn FALSE;\n\n\tjournaldAppender->stream = fdopen(fd, \"w\");\n\tif (!journaldAppender->stream)\n\t{\n\t\tclose(fd);\n\t\treturn FALSE;\n\t}\n\n\tsetbuffer(journaldAppender->stream, NULL, 0);\n\treturn TRUE;\n}",
        "parsed_output": "undefined8 check_params(long param_1, long param_2)\n{\n    undefined8 result;\n    \n    if (param_1 != 0 && param_2 != 0) {\n        if (*(long *)(param_2 + 0xa8) != 0) {\n            return 1;\n        }\n        result = FUN_0016bc90(param_2);\n        return result;\n    }\n    \n    return 0;\n}",
        "baseline_code_stripped": "undefined8 FUN_0016bd00(long param_1,long param_2)\n{\n  undefined8 uVar1;\n  if ((param_1 != 0) && (param_2 != 0)) {\n    if (*(long *)(param_2 + 0xa8) != 0) {\n      return 1;\n    }\n    uVar1 = FUN_0016bc90(param_2);\n    return uVar1;\n  }\n  return 0;\n}",
        "similarity_score_unixcoder": 0.3535066545009613,
        "similarity_score_baseline_stripped": 0.39779341220855713
    },
    {
        "func_name": "getOwnerMapEntry",
        "normed_func_sha256": "3c8d100d28598420d1b1dc27264508985fadea02aec7b74919849025848d959e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_1025e6a0(char *param_1)\n{\n  int iVar1;\n  undefined4 *local_c;\n  local_c = &DAT_10410960;\n  while ((local_c != (undefined4 *)\"XML-1.00\" &&\n         (iVar1 = strcmp(param_1,(char *)local_c[1]), iVar1 != 0))) {\n    local_c = local_c + 2;\n  }\n  __RTC_CheckEsp();\n  return;\n}",
        "output": "```c\nvoid find_XML_version(char *version)\n{\n    int result;\n    undefined4 *versions = &DAT_10410960;\n    \n    while (versions != (undefined4 *)\"XML-1.00\" && (result = strcmp(version, (char *)versions[1]), result != 0)) {\n        versions = versions + 2;\n    }\n    \n    __RTC_CheckEsp();\n}\n```",
        "source_code": "static inline const OwnerMapEntry *getOwnerMapEntry(const char *name)\n{\n    for (const OwnerMapEntry &entry : ownerMap) {\n        if (strcmp(name, entry.name) == 0) {\n            return &entry;\n        }\n    }\n    return nullptr;\n}",
        "parsed_output": "void find_XML_version(char *version)\n{\n    int result;\n    undefined4 *versions = &DAT_10410960;\n    \n    while (versions != (undefined4 *)\"XML-1.00\" && (result = strcmp(version, (char *)versions[1]), result != 0)) {\n        versions = versions + 2;\n    }\n    \n    __RTC_CheckEsp();\n}",
        "baseline_code_stripped": "void FUN_1025e6a0(char *param_1)\n{\n  int iVar1;\n  undefined4 *local_c;\n  local_c = &DAT_10410960;\n  while ((local_c != (undefined4 *)\"XML-1.00\" &&\n         (iVar1 = strcmp(param_1,(char *)local_c[1]), iVar1 != 0))) {\n    local_c = local_c + 2;\n  }\n  __RTC_CheckEsp();\n  return;\n}",
        "similarity_score_unixcoder": 0.4500303864479065,
        "similarity_score_baseline_stripped": 0.3582296073436737
    },
    {
        "func_name": "gettime",
        "normed_func_sha256": "412011dd2933e049b60bbbb16f239d8d0e688a37ee59997a2060d613ff13fdec",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_0001bd34(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 uVar3;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  uStack_10 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  iVar1 = FUN_00029940(1,&uStack_10);\n  if (iVar1 < 0) {\n    puVar2 = (undefined4 *)FUN_000283d6(iVar1);\n    uVar3 = FUN_0002831c(*puVar2);\n    FUN_00017ef8(3,\"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\",uVar3);\n    uStack_10 = 0;\n  }\n  return uStack_10;\n}",
        "output": "```c\nundefined4 FUN_0001bd34(undefined4 param_1, undefined4 param_2, undefined4 param_3)\n{\n    int result;\n    undefined4 *ptr;\n    undefined4 error_msg;\n    undefined4 arg1 = param_1;\n    undefined4 arg2 = param_2;\n    undefined4 arg3 = param_3;\n    \n    result = FUN_00029940(1, &arg1);\n    \n    if (result < 0) {\n        ptr = (undefined4 *)FUN_000283d6(result);\n        error_msg = FUN_0002831c(*ptr);\n        FUN_00017ef8(3, \"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\", error_msg);\n        arg1 = 0;\n    }\n    \n    return arg1;\n}\n```",
        "source_code": "static time_t gettime(void)\n{\n    struct timespec ts;\n    int ret;\n\n    ret = clock_gettime(CLOCK_MONOTONIC, &ts);\n    if (ret < 0) {\n        ERROR(\"clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\", strerror(errno));\n        return 0;\n    }\n\n    return ts.tv_sec;\n}",
        "parsed_output": "undefined4 FUN_0001bd34(undefined4 param_1, undefined4 param_2, undefined4 param_3)\n{\n    int result;\n    undefined4 *ptr;\n    undefined4 error_msg;\n    undefined4 arg1 = param_1;\n    undefined4 arg2 = param_2;\n    undefined4 arg3 = param_3;\n    \n    result = FUN_00029940(1, &arg1);\n    \n    if (result < 0) {\n        ptr = (undefined4 *)FUN_000283d6(result);\n        error_msg = FUN_0002831c(*ptr);\n        FUN_00017ef8(3, \"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\", error_msg);\n        arg1 = 0;\n    }\n    \n    return arg1;\n}",
        "baseline_code_stripped": "undefined4 FUN_0001bd34(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 uVar3;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  uStack_10 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  iVar1 = FUN_00029940(1,&uStack_10);\n  if (iVar1 < 0) {\n    puVar2 = (undefined4 *)FUN_000283d6(iVar1);\n    uVar3 = FUN_0002831c(*puVar2);\n    FUN_00017ef8(3,\"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\",uVar3);\n    uStack_10 = 0;\n  }\n  return uStack_10;\n}",
        "similarity_score_unixcoder": 0.5433233976364136,
        "similarity_score_baseline_stripped": 0.43212634325027466
    },
    {
        "func_name": "get_origcol_name",
        "normed_func_sha256": "d8241c3295ea1b4e9eb02519639dbfe48eda6c6a7a10d246126bbda521ff0ede",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined * FUN_180025924(longlong param_1,int param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 *puVar1;\n  uint uVar2;\n  undefined *puVar3;\n  undefined *puVar4;\n  uVar2 = abs(param_2);\n  if ((((*(char *)(param_1 + 0x7c8) == '\\0') || (*(char *)(param_1 + 0x7ca) == '\\0')) ||\n      (puVar1 = *(undefined8 **)(*(longlong *)(param_1 + 0x8e0) + (longlong)(int)uVar2 * 8),\n      puVar1 == (undefined8 *)0x0)) || (puVar4 = (undefined *)*puVar1, puVar4 == (undefined *)0x0))\n  {\n    puVar3 = &DAT_18007904c;\n    if (-1 < param_2) {\n      puVar3 = &DAT_180079050;\n    }\n    puVar4 = &DAT_18009f6f8;\n    thunk_FUN_180007388(&DAT_18009f6f8,puVar3,(ulonglong)uVar2,param_4);\n  }\n  return puVar4;\n}",
        "output": "```c\nundefined *get_data(longlong param_1, int param_2, undefined8 param_3, undefined8 param_4)\n{\n    undefined8 *data_ptr;\n    uint abs_param_2 = abs(param_2);\n    \n    if (((*(char *)(param_1 + 0x7c8) == '\\0') || (*(char *)(param_1 + 0x7ca) == '\\0')) ||\n        ((data_ptr = *(undefined8 **)(*(longlong *)(param_1 + 0x8e0) + (longlong)(int)abs_param_2 * 8), data_ptr == (undefined8 *)0x0) ||\n        ((undefined *)*data_ptr == (undefined *)0x0))\n    {\n        undefined *default_data = &DAT_18007904c;\n        if (param_2 >= -1) {\n            default_data = &DAT_180079050;\n        }\n        data_ptr = &DAT_18009f6f8;\n        thunk_FUN_180007388(&DAT_18009f6f8, default_data, (ulonglong)abs_param_2, param_4);\n    }\n    \n    return data_ptr;\n}\n```",
        "source_code": "char * __WINAPI get_origcol_name(lprec *lp, int colnr)\n{\n  MYBOOL newcol;\n  char   *ptr;\n\n  newcol = (MYBOOL) (colnr < 0);\n  colnr = abs(colnr);\n#ifdef Paranoia\n  if(((lp->presolve_undo->var_to_orig == NULL) && newcol) ||\n     (colnr > MAX(lp->columns, lp->presolve_undo->orig_columns))) {\n    report(lp, IMPORTANT, \"get_origcol_name: Column %d out of range\", colnr);\n    return(NULL);\n  }\n#endif\n\n  if(lp->names_used && lp->use_col_names && (lp->col_name[colnr] != NULL) && (lp->col_name[colnr]->name != NULL)) {\n#ifdef Paranoia\n    if(lp->col_name[colnr]->index != colnr)\n      report(lp, SEVERE, \"get_origcol_name: Inconsistent column ordinal %d vs %d\\n\",\n                         colnr, lp->col_name[colnr]->index);\n#endif\n    ptr = lp->col_name[colnr]->name;\n  }\n  else {\n    if(lp->rowcol_name == NULL)\n      if (!allocCHAR(lp, &lp->rowcol_name, 20, FALSE))\n        return(NULL);\n    ptr = lp->rowcol_name;\n    if(newcol)\n      sprintf(ptr, COLNAMEMASK2, colnr);\n    else\n      sprintf(ptr, COLNAMEMASK, colnr);\n  }\n  return(ptr);\n}",
        "parsed_output": "undefined *get_data(longlong param_1, int param_2, undefined8 param_3, undefined8 param_4)\n{\n    undefined8 *data_ptr;\n    uint abs_param_2 = abs(param_2);\n    \n    if (((*(char *)(param_1 + 0x7c8) == '\\0') || (*(char *)(param_1 + 0x7ca) == '\\0')) ||\n        ((data_ptr = *(undefined8 **)(*(longlong *)(param_1 + 0x8e0) + (longlong)(int)abs_param_2 * 8), data_ptr == (undefined8 *)0x0) ||\n        ((undefined *)*data_ptr == (undefined *)0x0))\n    {\n        undefined *default_data = &DAT_18007904c;\n        if (param_2 >= -1) {\n            default_data = &DAT_180079050;\n        }\n        data_ptr = &DAT_18009f6f8;\n        thunk_FUN_180007388(&DAT_18009f6f8, default_data, (ulonglong)abs_param_2, param_4);\n    }\n    \n    return data_ptr;\n}",
        "baseline_code_stripped": "undefined * FUN_180025924(longlong param_1,int param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 *puVar1;\n  uint uVar2;\n  undefined *puVar3;\n  undefined *puVar4;\n  uVar2 = abs(param_2);\n  if ((((*(char *)(param_1 + 0x7c8) == '\\0') || (*(char *)(param_1 + 0x7ca) == '\\0')) ||\n      (puVar1 = *(undefined8 **)(*(longlong *)(param_1 + 0x8e0) + (longlong)(int)uVar2 * 8),\n      puVar1 == (undefined8 *)0x0)) || (puVar4 = (undefined *)*puVar1, puVar4 == (undefined *)0x0))\n  {\n    puVar3 = &DAT_18007904c;\n    if (-1 < param_2) {\n      puVar3 = &DAT_180079050;\n    }\n    puVar4 = &DAT_18009f6f8;\n    thunk_FUN_180007388(&DAT_18009f6f8,puVar3,(ulonglong)uVar2,param_4);\n  }\n  return puVar4;\n}",
        "similarity_score_unixcoder": 0.4854794144630432,
        "similarity_score_baseline_stripped": 0.5044341087341309
    },
    {
        "func_name": "__pyx_f_11statsmodels_3tsa_10statespace_20_simulation_smoother_19zSimulationSmoother_generate_state",
        "normed_func_sha256": "c257f11ac8baf8d3db7ca911c3e8afd859d616c8686c764a4d7bcd46c6dce70d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8\nFUN_00112ce0(long param_1,int param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5)\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  int local_6c;\n  undefined4 local_64;\n  undefined4 local_60;\n  undefined4 local_5c;\n  undefined8 local_58;\n  undefined8 local_50;\n  long local_40;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = *(long *)(param_1 + 0x18);\n  local_64 = 1;\n  local_50 = 0;\n  local_60 = *(undefined4 *)(lVar1 + 0x20);\n  local_58 = 0x3ff0000000000000;\n  local_5c = *(undefined4 *)(lVar1 + 0x24);\n  if (*(int *)(lVar1 + 0xb8c) == 0) {\n    if (*(long *)(lVar1 + 0x1c8) != 0) {\n      lVar3 = 0;\n      if (1 < *(long *)(lVar1 + 0x1e0)) {\n        lVar3 = (long)param_2;\n      }\n      if (*(long *)(lVar1 + 0x6a8) != 0) {\n        local_6c = 0;\n        if (1 < *(long *)(lVar1 + 0x6c8)) {\n          local_6c = param_2;\n        }\n        if (*(long *)(lVar1 + 0x778) != 0) {\n          lVar2 = (long)param_2;\n          if (*(long *)(lVar1 + 0x798) < 2) {\n            lVar2 = (long)*(int *)(lVar1 + 0xb8c);\n          }\n          goto LAB_00112da5;\n        }\n      }\n    }\n  }\n  else if (*(long *)(lVar1 + 0x1c8) != 0) {\n    lVar3 = 0;\n    lVar2 = 0;\n    local_6c = 0;\nLAB_00112da5:\n    (*DAT_00192e58)(&local_60,lVar3 * *(long *)(lVar1 + 0x220) + *(long *)(lVar1 + 0x1d0),&local_64,\n                    param_3,&local_64);\n    lVar1 = *(long *)(param_1 + 0x18);\n    if (*(long *)(lVar1 + 0x778) != 0) {\n      (*DAT_00192e50)(\"N\",&local_60,&local_5c,&local_58,\n                      lVar2 * *(long *)(lVar1 + 0x7d8) + *(long *)(lVar1 + 0x780),&local_60,param_5,\n                      &local_64,&local_58,param_3,&local_64);\n      lVar1 = *(long *)(param_1 + 0x18);\n      if (*(int *)(lVar1 + 0xbac) != 0) {\n        (*DAT_00192e60)(&local_60,&local_58,param_4,&local_64,param_3,&local_64);\n        goto LAB_00112e5a;\n      }\n      if (*(long *)(lVar1 + 0x6a8) != 0) {\n        (*DAT_00192e50)(\"N\",&local_60,&local_60,&local_58,\n                        *(long *)(lVar1 + 0x6b0) + (long)local_6c * *(long *)(lVar1 + 0x708),\n                        &local_60,param_4,&local_64,&local_58,param_3,&local_64);\n        goto LAB_00112e5a;\n      }\n    }\n  }\n  PyErr_SetString(_PyExc_AttributeError,\"Memoryview is not initialized\");\n  FUN_00111da0(\"statsmodels.tsa.statespace._simulation_smoother.zSimulationSmoother.generate_state\")\n  ;\nLAB_00112e5a:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n  __stack_chk_fail(0,0);\n}",
        "output": "```c\nundefined8 FUN_00112ce0(long param_1, int param_2, undefined8 param_3, undefined8 param_4, undefined8 param_5) {\n    long lVar1;\n    long lVar2;\n    long lVar3;\n    long in_FS_OFFSET;\n    int local_6c;\n    undefined4 local_64;\n    undefined4 local_60;\n    undefined4 local_5c;\n    undefined8 local_58;\n    undefined8 local_50;\n    long local_40;\n    \n    local_40 = *(long *)(in_FS_OFFSET + 0x28);\n    lVar1 = *(long *)(param_1 + 0x18);\n    local_64 = 1;\n    local_50 = 0;\n    local_60 = *(undefined4 *)(lVar1 + 0x20);\n    local_58 = 0x3ff0000000000000;\n    local_5c = *(undefined4 *)(lVar1 + 0x24);\n    \n    if (*(int *)(lVar1 + 0xb8c) == 0) {\n        if (*(long *)(lVar1 + 0x1c8) != 0) {\n            lVar3 = 0;\n            if (1 < *(long *)(lVar1 + 0x1e0)) {\n                lVar3 = (long)param_2;\n            }\n            if (*(long *)(lVar1 + 0x6a8) != 0) {\n                local_6c = 0;\n                if (1 < *(long *)(lVar1 + 0x6c8)) {\n                    local_6c = param_2;\n                }\n                if (*(long *)(lVar1 + 0x778) != 0) {\n                    lVar2 = (long)param_2;\n                    if (*(long *)(lVar1 + 0x798) < 2) {\n                        lVar2 = (long)*(int *)(lVar1 + 0xb8c);\n                    }\n                    goto LAB_00112da5;\n                }\n            }\n        }\n    } else if (*(long *)(lVar1 + 0x1c8) != 0) {\n        lVar3 = 0;\n        lVar2 = 0;\n        local_6c = 0;\n        \nLAB_00112da5:\n        (*DAT_00192e58)(&local_60, lVar3 * *(long *)(lVar1 + 0x220) + *(long *)(lVar1 + 0x1d0), &local_64, param_3, &local_64);\n        lVar1 = *(long *)(param_1 + 0x18);\n        \n        if (*(long *)(lVar1 + 0x778) != 0) {\n            (*DAT_00192e50)(\"N\", &local_60, &local_5c, &local_58, lVar2 * *(long *)(lVar1 + 0x7d8) + *(long *)(lVar1 + 0x780), &local_60, param_5, &local_64, &local_58, param_3, &local_64);\n            lVar1 = *(long *)(param_1 + 0x18);\n            \n            if (*(int *)(lVar1 + 0xbac) != 0) {\n                (*DAT_00192e60)(&local_60, &local_58, param_4, &local_64, param_3, &local_64);\n                goto LAB_00112e5a;\n            }\n            \n            if (*(long *)(lVar1 + 0x6a8) != 0) {\n                (*DAT_00192e50)(\"N\", &local_60, &local_60, &local_58, *(long *)(lVar1 + 0x6b0) + (long)local_6c * *(long *)(lVar1 + 0x708), &local_60, param_4, &local_64, &local_58, param_3, &local_64);\n                goto LAB_00112e5a;\n            }\n        }\n    }\n    \n    PyErr_SetString(_PyExc_AttributeError, \"Memoryview is not initialized\");\n    FUN_00111da0(\"statsmodels.tsa.statespace._simulation_smoother.zSimulationSmoother.generate_state\");\n    \nLAB_00112e5a:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return 0;\n    }\n    \n    __stack_chk_fail(0, 0);\n}\n```",
        "source_code": "static __pyx_t_double_complex __pyx_f_11statsmodels_3tsa_10statespace_20_simulation_smoother_19zSimulationSmoother_generate_state(struct __pyx_obj_11statsmodels_3tsa_10statespace_20_simulation_smoother_zSimulationSmoother *__pyx_v_self, int __pyx_v_t, __pyx_t_double_complex *__pyx_v_state, __pyx_t_double_complex *__pyx_v_input_state, __pyx_t_double_complex *__pyx_v_variates) {\n  int __pyx_v_inc;\n  int __pyx_v_k_states;\n  int __pyx_v_k_posdef;\n  int __pyx_v_state_intercept_t;\n  int __pyx_v_transition_t;\n  int __pyx_v_selection_t;\n  __pyx_t_double_complex __pyx_v_alpha;\n  __pyx_t_double_complex __pyx_r;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  int __pyx_t_2;\n  Py_ssize_t __pyx_t_3;\n  Py_ssize_t __pyx_t_4;\n  Py_ssize_t __pyx_t_5;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"generate_state\", 0);\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2317\n *     cdef np.complex128_t generate_state(self, int t, np.complex128_t * state, np.complex128_t * input_state, np.complex128_t * variates):\n *         cdef:\n *             int inc = 1             # <<<<<<<<<<<<<<\n *             int k_states = self.model.k_states\n *             int k_posdef = self.model.k_posdef\n */\n  __pyx_v_inc = 1;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2318\n *         cdef:\n *             int inc = 1\n *             int k_states = self.model.k_states             # <<<<<<<<<<<<<<\n *             int k_posdef = self.model.k_posdef\n *             int state_intercept_t = 0\n */\n  __pyx_t_1 = __pyx_v_self->model->k_states;\n  __pyx_v_k_states = __pyx_t_1;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2319\n *             int inc = 1\n *             int k_states = self.model.k_states\n *             int k_posdef = self.model.k_posdef             # <<<<<<<<<<<<<<\n *             int state_intercept_t = 0\n *             int transition_t = 0\n */\n  __pyx_t_1 = __pyx_v_self->model->k_posdef;\n  __pyx_v_k_posdef = __pyx_t_1;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2320\n *             int k_states = self.model.k_states\n *             int k_posdef = self.model.k_posdef\n *             int state_intercept_t = 0             # <<<<<<<<<<<<<<\n *             int transition_t = 0\n *             int selection_t = 0\n */\n  __pyx_v_state_intercept_t = 0;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2321\n *             int k_posdef = self.model.k_posdef\n *             int state_intercept_t = 0\n *             int transition_t = 0             # <<<<<<<<<<<<<<\n *             int selection_t = 0\n *         cdef:\n */\n  __pyx_v_transition_t = 0;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2322\n *             int state_intercept_t = 0\n *             int transition_t = 0\n *             int selection_t = 0             # <<<<<<<<<<<<<<\n *         cdef:\n *             np.complex128_t alpha = 1.0\n */\n  __pyx_v_selection_t = 0;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2324\n *             int selection_t = 0\n *         cdef:\n *             np.complex128_t alpha = 1.0             # <<<<<<<<<<<<<<\n * \n *         # Get indices for possibly time-varying arrays\n */\n  __pyx_v_alpha = __pyx_t_double_complex_from_parts(1.0, 0);\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2327\n * \n *         # Get indices for possibly time-varying arrays\n *         if not self.model.time_invariant:             # <<<<<<<<<<<<<<\n *             if self.model.state_intercept.shape[1] > 1:      state_intercept_t = t\n *             if self.model.transition.shape[2] > 1:           transition_t = t\n */\n  __pyx_t_2 = ((!(__pyx_v_self->model->time_invariant != 0)) != 0);\n  if (__pyx_t_2) {\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2328\n *         # Get indices for possibly time-varying arrays\n *         if not self.model.time_invariant:\n *             if self.model.state_intercept.shape[1] > 1:      state_intercept_t = t             # <<<<<<<<<<<<<<\n *             if self.model.transition.shape[2] > 1:           transition_t = t\n *             if self.model.selection.shape[2] > 1:            selection_t = t\n */\n    if (unlikely(!__pyx_v_self->model->state_intercept.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2328, __pyx_L1_error)}\n    __pyx_t_2 = (((__pyx_v_self->model->state_intercept.shape[1]) > 1) != 0);\n    if (__pyx_t_2) {\n      __pyx_v_state_intercept_t = __pyx_v_t;\n    }\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2329\n *         if not self.model.time_invariant:\n *             if self.model.state_intercept.shape[1] > 1:      state_intercept_t = t\n *             if self.model.transition.shape[2] > 1:           transition_t = t             # <<<<<<<<<<<<<<\n *             if self.model.selection.shape[2] > 1:            selection_t = t\n * \n */\n    if (unlikely(!__pyx_v_self->model->transition.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2329, __pyx_L1_error)}\n    __pyx_t_2 = (((__pyx_v_self->model->transition.shape[2]) > 1) != 0);\n    if (__pyx_t_2) {\n      __pyx_v_transition_t = __pyx_v_t;\n    }\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2330\n *             if self.model.state_intercept.shape[1] > 1:      state_intercept_t = t\n *             if self.model.transition.shape[2] > 1:           transition_t = t\n *             if self.model.selection.shape[2] > 1:            selection_t = t             # <<<<<<<<<<<<<<\n * \n *         # \\\\# = R_t eta_t + c_t\n */\n    if (unlikely(!__pyx_v_self->model->selection.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2330, __pyx_L1_error)}\n    __pyx_t_2 = (((__pyx_v_self->model->selection.shape[2]) > 1) != 0);\n    if (__pyx_t_2) {\n      __pyx_v_selection_t = __pyx_v_t;\n    }\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2327\n * \n *         # Get indices for possibly time-varying arrays\n *         if not self.model.time_invariant:             # <<<<<<<<<<<<<<\n *             if self.model.state_intercept.shape[1] > 1:      state_intercept_t = t\n *             if self.model.transition.shape[2] > 1:           transition_t = t\n */\n  }\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2333\n * \n *         # \\\\# = R_t eta_t + c_t\n *         blas.zcopy(&k_states, &self.model.state_intercept[0,state_intercept_t], &inc, state, &inc)             # <<<<<<<<<<<<<<\n *         blas.zgemv(\"N\", &k_states, &k_posdef,\n *                             &alpha, &self.model.selection[0,0,selection_t], &k_states,\n */\n  if (unlikely(!__pyx_v_self->model->state_intercept.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2333, __pyx_L1_error)}\n  __pyx_t_3 = 0;\n  __pyx_t_4 = __pyx_v_state_intercept_t;\n  __pyx_f_5scipy_6linalg_11cython_blas_zcopy((&__pyx_v_k_states), (&(*((__pyx_t_double_complex *) ( /* dim=1 */ (( /* dim=0 */ ((char *) (((__pyx_t_double_complex *) __pyx_v_self->model->state_intercept.data) + __pyx_t_3)) ) + __pyx_t_4 * __pyx_v_self->model->state_intercept.strides[1]) )))), (&__pyx_v_inc), __pyx_v_state, (&__pyx_v_inc));\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2335\n *         blas.zcopy(&k_states, &self.model.state_intercept[0,state_intercept_t], &inc, state, &inc)\n *         blas.zgemv(\"N\", &k_states, &k_posdef,\n *                             &alpha, &self.model.selection[0,0,selection_t], &k_states,             # <<<<<<<<<<<<<<\n *                                     variates, &inc,\n *                             &alpha, state, &inc)\n */\n  if (unlikely(!__pyx_v_self->model->selection.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2335, __pyx_L1_error)}\n  __pyx_t_4 = 0;\n  __pyx_t_3 = 0;\n  __pyx_t_5 = __pyx_v_selection_t;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2334\n *         # \\\\# = R_t eta_t + c_t\n *         blas.zcopy(&k_states, &self.model.state_intercept[0,state_intercept_t], &inc, state, &inc)\n *         blas.zgemv(\"N\", &k_states, &k_posdef,             # <<<<<<<<<<<<<<\n *                             &alpha, &self.model.selection[0,0,selection_t], &k_states,\n *                                     variates, &inc,\n */\n  __pyx_f_5scipy_6linalg_11cython_blas_zgemv(((char *)\"N\"), (&__pyx_v_k_states), (&__pyx_v_k_posdef), (&__pyx_v_alpha), (&(*((__pyx_t_double_complex *) ( /* dim=2 */ (( /* dim=1 */ (( /* dim=0 */ ((char *) (((__pyx_t_double_complex *) __pyx_v_self->model->selection.data) + __pyx_t_4)) ) + __pyx_t_3 * __pyx_v_self->model->selection.strides[1]) ) + __pyx_t_5 * __pyx_v_self->model->selection.strides[2]) )))), (&__pyx_v_k_states), __pyx_v_variates, (&__pyx_v_inc), (&__pyx_v_alpha), __pyx_v_state, (&__pyx_v_inc));\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2340\n * \n *         # alpha_{t+1} = T_t alpha_t + \\\\#\n *         if self.model.identity_transition:             # <<<<<<<<<<<<<<\n *             blas.zaxpy(&k_states, &alpha, input_state, &inc, state, &inc)\n *         else:\n */\n  __pyx_t_2 = (__pyx_v_self->model->identity_transition != 0);\n  if (__pyx_t_2) {\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2341\n *         # alpha_{t+1} = T_t alpha_t + \\\\#\n *         if self.model.identity_transition:\n *             blas.zaxpy(&k_states, &alpha, input_state, &inc, state, &inc)             # <<<<<<<<<<<<<<\n *         else:\n *             blas.zgemv(\"N\", &k_states, &k_states,\n */\n    __pyx_f_5scipy_6linalg_11cython_blas_zaxpy((&__pyx_v_k_states), (&__pyx_v_alpha), __pyx_v_input_state, (&__pyx_v_inc), __pyx_v_state, (&__pyx_v_inc));\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2340\n * \n *         # alpha_{t+1} = T_t alpha_t + \\\\#\n *         if self.model.identity_transition:             # <<<<<<<<<<<<<<\n *             blas.zaxpy(&k_states, &alpha, input_state, &inc, state, &inc)\n *         else:\n */\n    goto __pyx_L7;\n  }\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2343\n *             blas.zaxpy(&k_states, &alpha, input_state, &inc, state, &inc)\n *         else:\n *             blas.zgemv(\"N\", &k_states, &k_states,             # <<<<<<<<<<<<<<\n *                                 &alpha, &self.model.transition[0,0,transition_t], &k_states,\n *                                         input_state, &inc,\n */\n  /*else*/ {\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2344\n *         else:\n *             blas.zgemv(\"N\", &k_states, &k_states,\n *                                 &alpha, &self.model.transition[0,0,transition_t], &k_states,             # <<<<<<<<<<<<<<\n *                                         input_state, &inc,\n *                                 &alpha, state, &inc)\n */\n    if (unlikely(!__pyx_v_self->model->transition.memview)) {PyErr_SetString(PyExc_AttributeError,\"Memoryview is not initialized\");__PYX_ERR(0, 2344, __pyx_L1_error)}\n    __pyx_t_5 = 0;\n    __pyx_t_3 = 0;\n    __pyx_t_4 = __pyx_v_transition_t;\n\n    /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2343\n *             blas.zaxpy(&k_states, &alpha, input_state, &inc, state, &inc)\n *         else:\n *             blas.zgemv(\"N\", &k_states, &k_states,             # <<<<<<<<<<<<<<\n *                                 &alpha, &self.model.transition[0,0,transition_t], &k_states,\n *                                         input_state, &inc,\n */\n    __pyx_f_5scipy_6linalg_11cython_blas_zgemv(((char *)\"N\"), (&__pyx_v_k_states), (&__pyx_v_k_states), (&__pyx_v_alpha), (&(*((__pyx_t_double_complex *) ( /* dim=2 */ (( /* dim=1 */ (( /* dim=0 */ ((char *) (((__pyx_t_double_complex *) __pyx_v_self->model->transition.data) + __pyx_t_5)) ) + __pyx_t_3 * __pyx_v_self->model->transition.strides[1]) ) + __pyx_t_4 * __pyx_v_self->model->transition.strides[2]) )))), (&__pyx_v_k_states), __pyx_v_input_state, (&__pyx_v_inc), (&__pyx_v_alpha), __pyx_v_state, (&__pyx_v_inc));\n  }\n  __pyx_L7:;\n\n  /* \"statsmodels/tsa/statespace/_simulation_smoother.pyx\":2315\n *                             &alpha, obs, &inc)\n * \n *     cdef np.complex128_t generate_state(self, int t, np.complex128_t * state, np.complex128_t * input_state, np.complex128_t * variates):             # <<<<<<<<<<<<<<\n *         cdef:\n *             int inc = 1\n */\n\n  /* function exit code */\n  __pyx_r = __pyx_t_double_complex_from_parts(0, 0);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_WriteUnraisable(\"statsmodels.tsa.statespace._simulation_smoother.zSimulationSmoother.generate_state\", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);\n  __pyx_r = __pyx_t_double_complex_from_parts(0, 0);\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}",
        "parsed_output": "undefined8 FUN_00112ce0(long param_1, int param_2, undefined8 param_3, undefined8 param_4, undefined8 param_5) {\n    long lVar1;\n    long lVar2;\n    long lVar3;\n    long in_FS_OFFSET;\n    int local_6c;\n    undefined4 local_64;\n    undefined4 local_60;\n    undefined4 local_5c;\n    undefined8 local_58;\n    undefined8 local_50;\n    long local_40;\n    \n    local_40 = *(long *)(in_FS_OFFSET + 0x28);\n    lVar1 = *(long *)(param_1 + 0x18);\n    local_64 = 1;\n    local_50 = 0;\n    local_60 = *(undefined4 *)(lVar1 + 0x20);\n    local_58 = 0x3ff0000000000000;\n    local_5c = *(undefined4 *)(lVar1 + 0x24);\n    \n    if (*(int *)(lVar1 + 0xb8c) == 0) {\n        if (*(long *)(lVar1 + 0x1c8) != 0) {\n            lVar3 = 0;\n            if (1 < *(long *)(lVar1 + 0x1e0)) {\n                lVar3 = (long)param_2;\n            }\n            if (*(long *)(lVar1 + 0x6a8) != 0) {\n                local_6c = 0;\n                if (1 < *(long *)(lVar1 + 0x6c8)) {\n                    local_6c = param_2;\n                }\n                if (*(long *)(lVar1 + 0x778) != 0) {\n                    lVar2 = (long)param_2;\n                    if (*(long *)(lVar1 + 0x798) < 2) {\n                        lVar2 = (long)*(int *)(lVar1 + 0xb8c);\n                    }\n                    goto LAB_00112da5;\n                }\n            }\n        }\n    } else if (*(long *)(lVar1 + 0x1c8) != 0) {\n        lVar3 = 0;\n        lVar2 = 0;\n        local_6c = 0;\n        \nLAB_00112da5:\n        (*DAT_00192e58)(&local_60, lVar3 * *(long *)(lVar1 + 0x220) + *(long *)(lVar1 + 0x1d0), &local_64, param_3, &local_64);\n        lVar1 = *(long *)(param_1 + 0x18);\n        \n        if (*(long *)(lVar1 + 0x778) != 0) {\n            (*DAT_00192e50)(\"N\", &local_60, &local_5c, &local_58, lVar2 * *(long *)(lVar1 + 0x7d8) + *(long *)(lVar1 + 0x780), &local_60, param_5, &local_64, &local_58, param_3, &local_64);\n            lVar1 = *(long *)(param_1 + 0x18);\n            \n            if (*(int *)(lVar1 + 0xbac) != 0) {\n                (*DAT_00192e60)(&local_60, &local_58, param_4, &local_64, param_3, &local_64);\n                goto LAB_00112e5a;\n            }\n            \n            if (*(long *)(lVar1 + 0x6a8) != 0) {\n                (*DAT_00192e50)(\"N\", &local_60, &local_60, &local_58, *(long *)(lVar1 + 0x6b0) + (long)local_6c * *(long *)(lVar1 + 0x708), &local_60, param_4, &local_64, &local_58, param_3, &local_64);\n                goto LAB_00112e5a;\n            }\n        }\n    }\n    \n    PyErr_SetString(_PyExc_AttributeError, \"Memoryview is not initialized\");\n    FUN_00111da0(\"statsmodels.tsa.statespace._simulation_smoother.zSimulationSmoother.generate_state\");\n    \nLAB_00112e5a:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return 0;\n    }\n    \n    __stack_chk_fail(0, 0);\n}",
        "baseline_code_stripped": "undefined8\nFUN_00112ce0(long param_1,int param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5)\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  int local_6c;\n  undefined4 local_64;\n  undefined4 local_60;\n  undefined4 local_5c;\n  undefined8 local_58;\n  undefined8 local_50;\n  long local_40;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = *(long *)(param_1 + 0x18);\n  local_64 = 1;\n  local_50 = 0;\n  local_60 = *(undefined4 *)(lVar1 + 0x20);\n  local_58 = 0x3ff0000000000000;\n  local_5c = *(undefined4 *)(lVar1 + 0x24);\n  if (*(int *)(lVar1 + 0xb8c) == 0) {\n    if (*(long *)(lVar1 + 0x1c8) != 0) {\n      lVar3 = 0;\n      if (1 < *(long *)(lVar1 + 0x1e0)) {\n        lVar3 = (long)param_2;\n      }\n      if (*(long *)(lVar1 + 0x6a8) != 0) {\n        local_6c = 0;\n        if (1 < *(long *)(lVar1 + 0x6c8)) {\n          local_6c = param_2;\n        }\n        if (*(long *)(lVar1 + 0x778) != 0) {\n          lVar2 = (long)param_2;\n          if (*(long *)(lVar1 + 0x798) < 2) {\n            lVar2 = (long)*(int *)(lVar1 + 0xb8c);\n          }\n          goto LAB_00112da5;\n        }\n      }\n    }\n  }\n  else if (*(long *)(lVar1 + 0x1c8) != 0) {\n    lVar3 = 0;\n    lVar2 = 0;\n    local_6c = 0;\nLAB_00112da5:\n    (*DAT_00192e58)(&local_60,lVar3 * *(long *)(lVar1 + 0x220) + *(long *)(lVar1 + 0x1d0),&local_64,\n                    param_3,&local_64);\n    lVar1 = *(long *)(param_1 + 0x18);\n    if (*(long *)(lVar1 + 0x778) != 0) {\n      (*DAT_00192e50)(\"N\",&local_60,&local_5c,&local_58,\n                      lVar2 * *(long *)(lVar1 + 0x7d8) + *(long *)(lVar1 + 0x780),&local_60,param_5,\n                      &local_64,&local_58,param_3,&local_64);\n      lVar1 = *(long *)(param_1 + 0x18);\n      if (*(int *)(lVar1 + 0xbac) != 0) {\n        (*DAT_00192e60)(&local_60,&local_58,param_4,&local_64,param_3,&local_64);\n        goto LAB_00112e5a;\n      }\n      if (*(long *)(lVar1 + 0x6a8) != 0) {\n        (*DAT_00192e50)(\"N\",&local_60,&local_60,&local_58,\n                        *(long *)(lVar1 + 0x6b0) + (long)local_6c * *(long *)(lVar1 + 0x708),\n                        &local_60,param_4,&local_64,&local_58,param_3,&local_64);\n        goto LAB_00112e5a;\n      }\n    }\n  }\n  PyErr_SetString(_PyExc_AttributeError,\"Memoryview is not initialized\");\n  FUN_00111da0(\"statsmodels.tsa.statespace._simulation_smoother.zSimulationSmoother.generate_state\")\n  ;\nLAB_00112e5a:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n  __stack_chk_fail(0,0);\n}",
        "similarity_score_unixcoder": 0.6756019592285156,
        "similarity_score_baseline_stripped": 0.675404965877533
    },
    {
        "func_name": "slot_QOcspResponse___hash__",
        "normed_func_sha256": "0b296d92f8636ca7e86b4fecbd86eb21c738c9ac8e6b0314791c451819fecd54",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_00161c60(void)\n{\n  undefined4 uVar1;\n  QOcspResponse *pQVar2;\n  pQVar2 = (QOcspResponse *)(**(code **)(DAT_001ddbe0 + 0x2b8))();\n  uVar1 = 0;\n  if (pQVar2 != (QOcspResponse *)0x0) {\n    uVar1 = qHash(pQVar2,0);\n  }\n  return uVar1;\n}",
        "output": "```c\nundefined4 FUN_00161c60(void)\n{\n    undefined4 uVar1;\n    QOcspResponse *pQVar2;\n    \n    pQVar2 = (QOcspResponse *)(**(code **)(DAT_001ddbe0 + 0x2b8))();\n    uVar1 = 0;\n    \n    if (pQVar2 != (QOcspResponse *)0x0) {\n        uVar1 = qHash(pQVar2, 0);\n    }\n    \n    return uVar1;\n}\n```",
        "source_code": "static long slot_QOcspResponse___hash__(PyObject *sipSelf)\n{\n     ::QOcspResponse *sipCpp = reinterpret_cast< ::QOcspResponse *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf, sipType_QOcspResponse));\n\n    if (!sipCpp)\n        return 0L;\n\n\n    {\n        {\n            long sipRes = 0;\n\n#line 81 \"/home/abuild/rpmbuild/BUILD/PyQt5-5.15.9/sip/QtNetwork/qocspresponse.sip\"\n        sipRes = qHash(*sipCpp);\n#line 244 \"/home/abuild/rpmbuild/BUILD/PyQt5-5.15.9/build/QtNetwork/sipQtNetworkQOcspResponse.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    return 0;\n}",
        "parsed_output": "undefined4 FUN_00161c60(void)\n{\n    undefined4 uVar1;\n    QOcspResponse *pQVar2;\n    \n    pQVar2 = (QOcspResponse *)(**(code **)(DAT_001ddbe0 + 0x2b8))();\n    uVar1 = 0;\n    \n    if (pQVar2 != (QOcspResponse *)0x0) {\n        uVar1 = qHash(pQVar2, 0);\n    }\n    \n    return uVar1;\n}",
        "baseline_code_stripped": "undefined4 FUN_00161c60(void)\n{\n  undefined4 uVar1;\n  QOcspResponse *pQVar2;\n  pQVar2 = (QOcspResponse *)(**(code **)(DAT_001ddbe0 + 0x2b8))();\n  uVar1 = 0;\n  if (pQVar2 != (QOcspResponse *)0x0) {\n    uVar1 = qHash(pQVar2,0);\n  }\n  return uVar1;\n}",
        "similarity_score_unixcoder": 0.6286391615867615,
        "similarity_score_baseline_stripped": 0.6350752115249634
    },
    {
        "func_name": "glColorSubTable",
        "normed_func_sha256": "2364801c7017a6a794153dfddf4da5ab244b2c58ae079b057e0294d3611960fe",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid glColorSubTable(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                    undefined4 param_5,undefined4 param_6)\n{\n  int iVar1;\n  iVar1 = NtCurrentTeb();\n  iVar1 = *(int *)(iVar1 + 0xbe8);\n  if ((DAT_7a8e1a50 & 8) != 0) {\n    wine_dbg_log(3,&DAT_7a8e1a50,\"glColorSubTable\",\"(%d, %d, %d, %d, %d, %p)\\n\",param_1,param_2,\n                 param_3,param_4,param_5,param_6);\n  }\n  (**(code **)(iVar1 + 0x898))(param_1,param_2,param_3,param_4,param_5,param_6);\n  return;\n}",
        "output": "```c\nvoid glColorSubTable(undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4, undefined4 param_5, undefined4 param_6)\n{\n    int tebPtr = NtCurrentTeb();\n    int funcPtr = *(int *)(tebPtr + 0xbe8);\n    \n    if ((DAT_7a8e1a50 & 8) != 0) {\n        wine_dbg_log(3, &DAT_7a8e1a50, \"glColorSubTable\", \"(%d, %d, %d, %d, %d, %p)\\n\", param_1, param_2, param_3, param_4, param_5, param_6);\n    }\n    \n    (*(code **)(funcPtr + 0x898))(param_1, param_2, param_3, param_4, param_5, param_6);\n}\n```",
        "source_code": "static void WINAPI glColorSubTable( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void* data ) {\n  const struct opengl_funcs *funcs = NtCurrentTeb()->glTable;\n  TRACE(\"(%d, %d, %d, %d, %d, %p)\\n\", target, start, count, format, type, data );\n  funcs->ext.p_glColorSubTable( target, start, count, format, type, data );\n}",
        "parsed_output": "void glColorSubTable(undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4, undefined4 param_5, undefined4 param_6)\n{\n    int tebPtr = NtCurrentTeb();\n    int funcPtr = *(int *)(tebPtr + 0xbe8);\n    \n    if ((DAT_7a8e1a50 & 8) != 0) {\n        wine_dbg_log(3, &DAT_7a8e1a50, \"glColorSubTable\", \"(%d, %d, %d, %d, %d, %p)\\n\", param_1, param_2, param_3, param_4, param_5, param_6);\n    }\n    \n    (*(code **)(funcPtr + 0x898))(param_1, param_2, param_3, param_4, param_5, param_6);\n}",
        "baseline_code_stripped": "void glColorSubTable(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                    undefined4 param_5,undefined4 param_6)\n{\n  int iVar1;\n  iVar1 = NtCurrentTeb();\n  iVar1 = *(int *)(iVar1 + 0xbe8);\n  if ((DAT_7a8e1a50 & 8) != 0) {\n    wine_dbg_log(3,&DAT_7a8e1a50,\"glColorSubTable\",\"(%d, %d, %d, %d, %d, %p)\\n\",param_1,param_2,\n                 param_3,param_4,param_5,param_6);\n  }\n  (**(code **)(iVar1 + 0x898))(param_1,param_2,param_3,param_4,param_5,param_6);\n  return;\n}",
        "similarity_score_unixcoder": 0.6710869669914246,
        "similarity_score_baseline_stripped": 0.5819120407104492
    },
    {
        "func_name": "dt_image_set_aspect_ratio_if_different",
        "normed_func_sha256": "30a3c39745c11eadde56c03c3e646d671a1f6c24ae560fcd2d0e4336fbbbb9b6",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid dt_image_set_aspect_ratio_if_different(float param_1,int param_2,int param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  if (param_1 <= 0.0) {\n    return;\n  }\n  lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x72);\n  if (0.1 < ABS(*(float *)(lVar1 + 0x420) - param_1)) {\n    dt_image_cache_read_release(DAT_005d3ad0);\n    lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x77);\n    uVar2 = DAT_005d3ad0;\n    *(float *)(lVar1 + 0x420) = param_1;\n    dt_image_cache_write_release(uVar2,lVar1,0);\n  }\n  else {\n    dt_image_cache_read_release(DAT_005d3ad0);\n  }\n  lVar1 = DAT_005d3af8;\n  if ((param_3 != 0) && (*(int *)(DAT_005d3af8 + 0x40) == 0xe)) {\n    uVar2 = g_list_prepend(0,(long)param_2);\n    dt_collection_update_query(lVar1,3,0x10,uVar2);\n    return;\n  }\n  return;\n}",
        "output": "void dt_image_set_aspect_ratio_if_different(float aspect_ratio, int param_2, int param_3)\n{\n    long image_cache_entry;\n    undefined8 cache_handle;\n    \n    if (aspect_ratio <= 0.0) {\n        return;\n    }\n    \n    image_cache_entry = dt_image_cache_get(DAT_005d3ad0, param_2, 0x72);\n    \n    if (0.1 < ABS(*(float *)(image_cache_entry + 0x420) - aspect_ratio)) {\n        dt_image_cache_read_release(DAT_005d3ad0);\n        image_cache_entry = dt_image_cache_get(DAT_005d3ad0, param_2, 0x77);\n        cache_handle = DAT_005d3ad0;\n        *(float *)(image_cache_entry + 0x420) = aspect_ratio;\n        dt_image_cache_write_release(cache_handle, image_cache_entry, 0);\n    } else {\n        dt_image_cache_read_release(DAT_005d3ad0);\n    }\n    \n    image_cache_entry = DAT_005d3af8;\n    \n    if ((param_3 != 0) && (*(int *)(DAT_005d3af8 + 0x40) == 0xe)) {\n        cache_handle = g_list_prepend(0, (long)param_2);\n        dt_collection_update_query(image_cache_entry, 3, 0x10, cache_handle);\n        return;\n    }\n    \n    return;\n}",
        "source_code": "void dt_image_set_aspect_ratio_if_different(const int32_t imgid, const float aspect_ratio, const gboolean raise)\n{\n  if (aspect_ratio > .0f)\n  {\n    /* fetch image from cache */\n    dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'r');\n\n    /* set image aspect ratio */\n    if(fabs(image->aspect_ratio - aspect_ratio) > 0.1)\n    {\n      dt_image_cache_read_release(darktable.image_cache, image);\n      dt_image_t *wimage = dt_image_cache_get(darktable.image_cache, imgid, 'w');\n      wimage->aspect_ratio = aspect_ratio;\n      dt_image_cache_write_release(darktable.image_cache, wimage, DT_IMAGE_CACHE_SAFE);\n    }\n    else\n      dt_image_cache_read_release(darktable.image_cache, image);\n\n    if(raise && darktable.collection->params.sort == DT_COLLECTION_SORT_ASPECT_RATIO)\n      dt_collection_update_query(darktable.collection, DT_COLLECTION_CHANGE_RELOAD,\n                                 DT_COLLECTION_PROP_ASPECT_RATIO, g_list_prepend(NULL, GINT_TO_POINTER(imgid)));\n  }\n}",
        "parsed_output": "void dt_image_set_aspect_ratio_if_different(float aspect_ratio, int param_2, int param_3)\n{\n    long image_cache_entry;\n    undefined8 cache_handle;\n    \n    if (aspect_ratio <= 0.0) {\n        return;\n    }\n    \n    image_cache_entry = dt_image_cache_get(DAT_005d3ad0, param_2, 0x72);\n    \n    if (0.1 < ABS(*(float *)(image_cache_entry + 0x420) - aspect_ratio)) {\n        dt_image_cache_read_release(DAT_005d3ad0);\n        image_cache_entry = dt_image_cache_get(DAT_005d3ad0, param_2, 0x77);\n        cache_handle = DAT_005d3ad0;\n        *(float *)(image_cache_entry + 0x420) = aspect_ratio;\n        dt_image_cache_write_release(cache_handle, image_cache_entry, 0);\n    } else {\n        dt_image_cache_read_release(DAT_005d3ad0);\n    }\n    \n    image_cache_entry = DAT_005d3af8;\n    \n    if ((param_3 != 0) && (*(int *)(DAT_005d3af8 + 0x40) == 0xe)) {\n        cache_handle = g_list_prepend(0, (long)param_2);\n        dt_collection_update_query(image_cache_entry, 3, 0x10, cache_handle);\n        return;\n    }\n    \n    return;\n}",
        "baseline_code_stripped": "void dt_image_set_aspect_ratio_if_different(float param_1,int param_2,int param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  if (param_1 <= 0.0) {\n    return;\n  }\n  lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x72);\n  if (0.1 < ABS(*(float *)(lVar1 + 0x420) - param_1)) {\n    dt_image_cache_read_release(DAT_005d3ad0);\n    lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x77);\n    uVar2 = DAT_005d3ad0;\n    *(float *)(lVar1 + 0x420) = param_1;\n    dt_image_cache_write_release(uVar2,lVar1,0);\n  }\n  else {\n    dt_image_cache_read_release(DAT_005d3ad0);\n  }\n  lVar1 = DAT_005d3af8;\n  if ((param_3 != 0) && (*(int *)(DAT_005d3af8 + 0x40) == 0xe)) {\n    uVar2 = g_list_prepend(0,(long)param_2);\n    dt_collection_update_query(lVar1,3,0x10,uVar2);\n    return;\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.8019495010375977,
        "similarity_score_baseline_stripped": 0.7183497548103333
    }
]
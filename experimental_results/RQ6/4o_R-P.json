[
    {
        "func_name": "meth_QMutexLocker___enter__",
        "normed_func_sha256": "8d84728ebb9bcb2866951b1edf4427363fa90ccb07f1f16e1981d2c04137e495",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid meth_QWriteLocker___exit__(undefined4 param_1,undefined4 param_2)\n{\n  int iVar1;\n  uint uVar2;\n  undefined4 *puVar3;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined auStack_24 [4];\n  undefined auStack_20 [4];\n  undefined auStack_1c [4];\n  uint *local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  local_28 = 0;\n  local_2c = param_1;\n  iVar1 = (**(code **)(DAT_00234c4c + 0x140))\n                    (&local_28,param_2,\"BP0P0P0\",&local_2c,DAT_00218a0c,&local_18,auStack_24,\n                     auStack_20,auStack_1c);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_00234c4c + 0x150))\n              (local_28,\"QWriteLocker\",\"__exit__\",\"__exit__(self, object, object, object)\");\n    puVar3 = (undefined4 *)0x0;\n  }\n  else {\n    uVar2 = *local_18;\n    if ((uVar2 != 0) && ((uVar2 & 1) != 0)) {\n      *local_18 = uVar2 & 0xfffffffe;\n      QReadWriteLock::unlock();\n    }\n    puVar3 = &_Py_NoneStruct;\n    _Py_NoneStruct = _Py_NoneStruct + 1;\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(puVar3);\n}\n\n Revised code:\nstatic PyObject *meth_QWriteLocker___exit__(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n\n    {\n        PyObject * a0;\n        PyObject * a1;\n        PyObject * a2;\n         ::QWriteLocker *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"BP0P0P0\", &sipSelf, sipType_QWriteLocker, &sipCpp, &a0, &a1, &a2))\n        {\n#line 114 \"/builddir/build/BUILD/PyQt4_gpl_x11-4.12.3/sip/QtCore/qreadwritelock.sip\"\n        sipCpp->unlock();\n#line 174 \"/builddir/build/BUILD/PyQt4_gpl_x11-4.12.3/armv7hl-redhat-linux-gnueabi-python3/QtCore/sipQtCoreQWriteLocker.cpp\"\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QWriteLocker, sipName___exit__, doc_QWriteLocker___exit__);\n\n    return SIP_NULLPTR;\n}\n\n## Example:\n\n Input code:\nvoid FUN_0025a778(int param_1,undefined4 param_2)\n{\n  bool bVar1;\n  int iVar2;\n  int *piVar3;\n  int *local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  FUN_00270e20(&local_18,0x83,param_2);\n  piVar3 = *(int **)(param_1 + 0x10);\n  *(int **)(param_1 + 0x10) = local_18;\n  local_18 = piVar3;\n  if (*piVar3 != 0) {\n    if (*piVar3 == -1) goto LAB_0025a7f8;\n    DataMemoryBarrier(0xb);\n    do {\n      iVar2 = *piVar3;\n      bVar1 = (bool)hasExclusiveAccess(piVar3);\n    } while (!bVar1);\n    *piVar3 = iVar2 + -1;\n    DataMemoryBarrier(0xb);\n    if (iVar2 + -1 != 0) goto LAB_0025a7f8;\n  }\n  QArrayData::deallocate((QArrayData *)piVar3,1,4);\nLAB_0025a7f8:\n  if (local_14 != __stack_chk_guard) {\n    __stack_chk_fail();\n  }\n  return;\n}\n\n Revised code:\nvoid MSEBuilder::setPublicKey(const QByteArray& pData)\n{\n\tstatic const char TAG_PUBLIC_KEY = char(0x83);\n\tmPublicKey = Asn1Util::encode(TAG_PUBLIC_KEY, pData);\n}\n\n## Example:\n\n Input code:\nvoid meth_QTabletEvent_device(undefined4 param_1,undefined4 param_2)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 local_2c [2];\n  undefined4 local_24;\n  int local_20;\n  int local_1c;\n  local_24 = 0;\n  local_1c = __stack_chk_guard;\n  local_2c[0] = param_1;\n  iVar1 = (**(code **)(DAT_006a47c8 + 0xf4))\n                    (&local_24,param_2,&DAT_005aef44,local_2c,*(undefined4 *)(DAT_0060b568 + 0xa00),\n                     &local_20);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_006a47c8 + 0x104))\n              (local_24,\"QTabletEvent\",\"device\",s_QTabletEvent_device______QTablet_00684090);\n    uVar2 = 0;\n  }\n  else {\n    PyEval_SaveThread();\n    uVar2 = *(undefined4 *)(local_20 + 0x28);\n    PyEval_RestoreThread();\n    uVar2 = (**(code **)(DAT_006a47c8 + 0x48))(uVar2,*(undefined4 *)(DAT_0060b568 + 0xa08));\n  }\n  if (local_1c == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(uVar2);\n}\n\n Revised code:\nstatic PyObject *meth_QTabletEvent_device(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        const QTabletEvent *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_QTabletEvent, &sipCpp))\n        {\n            QTabletEvent::TabletDevice sipRes;\n\n            Py_BEGIN_ALLOW_THREADS\n            sipRes = sipCpp->device();\n            Py_END_ALLOW_THREADS\n\n            return sipConvertFromEnum(sipRes,sipType_QTabletEvent_TabletDevice);\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QTabletEvent, sipName_device, doc_QTabletEvent_device);\n\n    return NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid meth_QMutexLocker___enter__(int *param_1,undefined4 param_2)\n{\n  int iVar1;\n  int *piVar2;\n  int *local_24 [2];\n  undefined4 local_1c;\n  undefined auStack_18 [4];\n  int local_14;\n  local_14 = __stack_chk_guard;\n  local_1c = 0;\n  local_24[0] = param_1;\n  iVar1 = (**(code **)(DAT_0028fe00 + 0x140))\n                    (&local_1c,param_2,&DAT_00222c60,local_24,DAT_0028c910,auStack_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_0028fe00 + 0x150))\n              (local_1c,\"QMutexLocker\",\"__enter__\",\"__enter__(self) -> object\");\n    piVar2 = (int *)0x0;\n  }\n  else {\n    *local_24[0] = *local_24[0] + 1;\n    piVar2 = local_24[0];\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(piVar2);\n}",
        "output": "```c\nstatic PyObject *meth_QMutexLocker___enter__(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        ::QMutexLocker *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_QMutexLocker, &sipCpp))\n        {\n            Py_BEGIN_ALLOW_THREADS\n            sipCpp->relock();\n            Py_END_ALLOW_THREADS\n\n            Py_INCREF(sipSelf);\n            return sipSelf;\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QMutexLocker, sipName___enter__, doc_QMutexLocker___enter__);\n\n    return NULL;\n}\n```",
        "source_code": "static PyObject *meth_QMutexLocker___enter__(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n\n    {\n         ::QMutexLocker *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_QMutexLocker, &sipCpp))\n        {\n            PyObject * sipRes = SIP_NULLPTR;\n\n#line 37 \"/builddir/build/BUILD/PyQt5-5.13.2/armv7hl-redhat-linux-gnueabi-python3/sip/QtCore/qmutex.sip\"\n        // Just return a reference to self.\n        sipRes = sipSelf;\n        Py_INCREF(sipRes);\n#line 139 \"/builddir/build/BUILD/PyQt5-5.13.2/armv7hl-redhat-linux-gnueabi-python3/QtCore/sipQtCoreQMutexLocker.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QMutexLocker, sipName___enter__, doc_QMutexLocker___enter__);\n\n    return SIP_NULLPTR;\n}",
        "parsed_output": "static PyObject *meth_QMutexLocker___enter__(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        ::QMutexLocker *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_QMutexLocker, &sipCpp))\n        {\n            Py_BEGIN_ALLOW_THREADS\n            sipCpp->relock();\n            Py_END_ALLOW_THREADS\n\n            Py_INCREF(sipSelf);\n            return sipSelf;\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QMutexLocker, sipName___enter__, doc_QMutexLocker___enter__);\n\n    return NULL;\n}",
        "baseline_code_stripped": "void meth_QMutexLocker___enter__(int *param_1,undefined4 param_2)\n{\n  int iVar1;\n  int *piVar2;\n  int *local_24 [2];\n  undefined4 local_1c;\n  undefined auStack_18 [4];\n  int local_14;\n  local_14 = __stack_chk_guard;\n  local_1c = 0;\n  local_24[0] = param_1;\n  iVar1 = (**(code **)(DAT_0028fe00 + 0x140))\n                    (&local_1c,param_2,&DAT_00222c60,local_24,DAT_0028c910,auStack_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_0028fe00 + 0x150))\n              (local_1c,\"QMutexLocker\",\"__enter__\",\"__enter__(self) -> object\");\n    piVar2 = (int *)0x0;\n  }\n  else {\n    *local_24[0] = *local_24[0] + 1;\n    piVar2 = local_24[0];\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(piVar2);\n}",
        "similarity_score_unixcoder": 0.9468724727630615,
        "similarity_score_baseline_stripped": 0.5935357809066772
    },
    {
        "func_name": "Bwd::exec",
        "normed_func_sha256": "bb57c5b030ae8b75e8aaf13ac5a79bc437f43836efc7e7ddef812955a7247cc1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_001b3f0a(void)\n{\n  void *unaff_RBX;\n  long in_FS_OFFSET;\n  _object *in_stack_00000028;\n  long in_stack_00000058;\n  operator_delete(unaff_RBX,0x40);\n  Py::_XDECREF(in_stack_00000028);\n  if (in_stack_00000058 == *(long *)(in_FS_OFFSET + 0x28)) {\n    _Unwind_Resume();\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nPy::Object ParameterGrpPy::attach(const Py::Tuple& args)\r\n{\r\n    PyObject* obj;\r\n    if (!PyArg_ParseTuple(args.ptr(), \"O\", &obj))\r\n        throw Py::Exception();\r\n\r\n    Py::Object o(obj);\r\n    if (!o.hasAttr(std::string(\"onChange\")))\r\n        throw Py::TypeError(\"Object has no onChange attribute\");\r\n\r\n    for (ParameterGrpObserverList::iterator it = _observers.begin(); it != _observers.end(); ++it) {\r\n        if ((*it)->isEqual(o)) {\r\n            throw Py::RuntimeError(\"Object is already attached.\");\r\n        }\r\n    }\r\n\r\n    ParameterGrpObserver* obs = new ParameterGrpObserver(o);\r\n    _cParamGrp->Attach(obs);\r\n    _observers.push_back(obs);\r\n\r\n    return Py::None();\r\n}\n\n## Example:\n\n Input code:\nvoid FUN_00111b0d(void)\n{\n  long unaff_R15;\n  undefined8 in_stack_00000030;\n  undefined8 in_stack_00000038;\n  undefined8 in_stack_00000050;\n  undefined8 in_stack_00000070;\n  undefined8 in_stack_00000078;\n  undefined8 in_stack_00000088;\n  undefined8 in_stack_000000a0;\n  undefined8 in_stack_000000a8;\n  undefined8 param_11;\n  void *param_12;\n  if (param_12 != *(void **)(unaff_R15 + 0xa0)) {\n    operator_delete(*(void **)(unaff_R15 + 0xa0));\n  }\n  FUN_0011d010(param_11);\n  FUN_0011d010(in_stack_000000a8);\n  FUN_0011d010(in_stack_000000a0);\n  FUN_0011d010(in_stack_00000078);\n  FUN_0011d010(in_stack_00000038);\n  FUN_0011d010(in_stack_00000070);\n  FUN_0011d010(in_stack_00000030);\n  FUN_0011d010(in_stack_00000050);\n  FUN_0011d010(in_stack_00000088);\n  FUN_0011d010();\n  _Unwind_Resume();\n}\n\n Revised code:\nHPX_MAYBE_FORCEINLINE\n    typename boost::disable_if_c<\n        boost::is_function<typename boost::remove_pointer<typename util::decay<F>::type>::type>::value\n     || boost::is_member_function_pointer<typename util::decay<F>::type>::value\n     || boost::is_reference_wrapper<typename util::decay<F>::type>::value\n      , R\n    >::type\n    invoke_r(F && f, Arg0 && arg0 , Arg1 && arg1 , Arg2 && arg2 , Arg3 && arg3 , Arg4 && arg4 , Arg5 && arg5 , Arg6 && arg6 , Arg7 && arg7 , Arg8 && arg8 , Arg9 && arg9 , Arg10 && arg10 , Arg11 && arg11 , Arg12 && arg12 , Arg13 && arg13)\n    {\n        return\n            util::void_guard<R>(), std::forward<F>(f)\n                (std::forward<Arg0>( arg0 ) , std::forward<Arg1>( arg1 ) , std::forward<Arg2>( arg2 ) , std::forward<Arg3>( arg3 ) , std::forward<Arg4>( arg4 ) , std::forward<Arg5>( arg5 ) , std::forward<Arg6>( arg6 ) , std::forward<Arg7>( arg7 ) , std::forward<Arg8>( arg8 ) , std::forward<Arg9>( arg9 ) , std::forward<Arg10>( arg10 ) , std::forward<Arg11>( arg11 ) , std::forward<Arg12>( arg12 ) , std::forward<Arg13>( arg13 ));\n    }\n\n## Example:\n\n Input code:\nvoid FUN_0027710c(void)\n{\n  long in_FS_OFFSET;\n  undefined8 param_9;\n  undefined8 in_stack_00000040;\n  undefined8 in_stack_00000050;\n  undefined8 param_12;\n  undefined8 in_stack_000000d0;\n  undefined8 in_stack_000000d8;\n  undefined8 in_stack_00000118;\n  long in_stack_00000588;\n  FUN_003c59e0();\n  FUN_0039c500(param_12);\n  FUN_0039c500(&stack0x00000240);\n  FUN_0039c500(in_stack_00000050);\n  FUN_0039c500(in_stack_00000040);\n  FUN_0039c500(in_stack_00000118);\n  FUN_0039c500(in_stack_000000d8);\n  FUN_0039c500(in_stack_000000d0);\n  FUN_0039c500(&stack0x000002a0);\n  FUN_0039c500(&stack0x00000288);\n  FUN_0039c500(param_9);\n  if (in_stack_00000588 == *(long *)(in_FS_OFFSET + 0x28)) {\n    _Unwind_Resume();\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic void remove_bridges_from_contacts(\n        const PrintConfig   &print_config, \n        const Layer         &lower_layer,\n        const Polygons      &lower_layer_polygons,\n        const LayerRegion   &layerm,\n        float                fw, \n        Polygons            &contact_polygons)\n    {\n        // compute the area of bridging perimeters\n        Polygons bridges;\n        {\n            // Surface supporting this layer, expanded by 0.5 * nozzle_diameter, as we consider this kind of overhang to be sufficiently supported.\n            Polygons lower_grown_slices = expand(lower_layer_polygons,\n                //FIXME to mimic the decision in the perimeter generator, we should use half the external perimeter width.\n                0.5f * float(scale_(print_config.nozzle_diameter.get_at(layerm.region().config().perimeter_extruder-1))),\n                SUPPORT_SURFACES_OFFSET_PARAMETERS);\n            // Collect perimeters of this layer.\n            //FIXME split_at_first_point() could split a bridge mid-way\n        #if 0\n            Polylines overhang_perimeters = layerm.perimeters.as_polylines();\n            // workaround for Clipper bug, see Slic3r::Polygon::clip_as_polyline()\n            for (Polyline &polyline : overhang_perimeters)\n                polyline.points[0].x += 1;\n            // Trim the perimeters of this layer by the lower layer to get the unsupported pieces of perimeters.\n            overhang_perimeters = diff_pl(overhang_perimeters, lower_grown_slices);\n        #else\n            Polylines overhang_perimeters = diff_pl(layerm.perimeters.as_polylines(), lower_grown_slices);\n        #endif\n            \n            // only consider straight overhangs\n            // only consider overhangs having endpoints inside layer's slices\n            // convert bridging polylines into polygons by inflating them with their thickness\n            // since we're dealing with bridges, we can't assume width is larger than spacing,\n            // so we take the largest value and also apply safety offset to be ensure no gaps\n            // are left in between\n            Flow perimeter_bridge_flow = layerm.bridging_flow(frPerimeter);\n            //FIXME one may want to use a maximum of bridging flow width and normal flow width, as the perimeters are calculated using the normal flow\n            // and then turned to bridging flow, thus their centerlines are derived from non-bridging flow and expanding them by a bridging flow\n            // may not expand them to the edge of their respective islands.\n            const float w = float(0.5 * std::max(perimeter_bridge_flow.scaled_width(), perimeter_bridge_flow.scaled_spacing())) + scaled<float>(0.001);\n            for (Polyline &polyline : overhang_perimeters)\n                if (polyline.is_straight()) {\n                    // This is a bridge \n                    polyline.extend_start(fw);\n                    polyline.extend_end(fw);\n                    // Is the straight perimeter segment supported at both sides?\n                    Point pts[2]       = { polyline.first_point(), polyline.last_point() };\n                    bool  supported[2] = { false, false };\n                    for (size_t i = 0; i < lower_layer.lslices.size() && ! (supported[0] && supported[1]); ++ i)\n                        for (int j = 0; j < 2; ++ j)\n                            if (! supported[j] && lower_layer.lslices_bboxes[i].contains(pts[j]) && lower_layer.lslices[i].contains(pts[j]))\n                                supported[j] = true;\n                    if (supported[0] && supported[1])\n                        // Offset a polyline into a thick line.\n                        polygons_append(bridges, offset(polyline, w));\n                }\n            bridges = union_(bridges);\n        }\n        // remove the entire bridges and only support the unsupported edges\n        //FIXME the brided regions are already collected as layerm.bridged. Use it?\n        for (const Surface &surface : layerm.fill_surfaces.surfaces)\n            if (surface.surface_type == stBottomBridge && surface.bridge_angle != -1)\n                polygons_append(bridges, surface.expolygon);\n        //FIXME add the gap filled areas. Extrude the gaps with a bridge flow?\n        // Remove the unsupported ends of the bridges from the bridged areas.\n        //FIXME add supports at regular intervals to support long bridges!\n        bridges = diff(bridges,\n                // Offset unsupported edges into polygons.\n                offset(layerm.unsupported_bridge_edges, scale_(SUPPORT_MATERIAL_MARGIN), SUPPORT_SURFACES_OFFSET_PARAMETERS));\n        // Remove bridged areas from the supported areas.\n        contact_polygons = diff(contact_polygons, bridges, ApplySafetyOffset::Yes);\n\n        #ifdef SLIC3R_DEBUG\n            static int iRun = 0;\n            SVG::export_expolygons(debug_out_path(\"support-top-contacts-remove-bridges-run%d.svg\", iRun ++),\n                { { { union_ex(offset(layerm.unsupported_bridge_edges, scale_(SUPPORT_MATERIAL_MARGIN), SUPPORT_SURFACES_OFFSET_PARAMETERS)) }, { \"unsupported_bridge_edges\", \"orange\", 0.5f } },\n                  { { union_ex(contact_polygons) },            { \"contact_polygons\",           \"blue\",   0.5f } },\n                  { { union_ex(bridges) },                     { \"bridges\",                    \"red\",    \"black\", \"\", scaled<coord_t>(0.1f), 0.5f } } });\n        #endif /* SLIC3R_DEBUG */\n    }\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00278250(void)\n{\n  long in_stack_00000038;\n  long in_stack_00000090;\n  long in_stack_00000098;\n  long in_stack_000000a0;\n  long in_stack_000000a8;\n  void *in_stack_00000140;\n  __cxa_guard_abort();\n  if (in_stack_00000140 != (void *)0x0) {\n    operator_delete(in_stack_00000140);\n  }\n  in_stack_000000a0 = in_stack_00000038 + 0x10;\n  if (in_stack_000000a8 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x000000a0);\n  }\n  in_stack_00000090 = in_stack_00000038 + 0x10;\n  if (in_stack_00000098 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x00000090);\n    FUN_0027820b();\n    return;\n  }\n  FUN_005f9e00();\n  _Unwind_Resume();\n}",
        "output": "```cpp\nvoid cleanup_resources(void* resource_ptr, long offset, bool condition1, bool condition2)\n{\n    __cxa_guard_abort();\n\n    // Delete the resource if it exists\n    if (resource_ptr != nullptr) {\n        operator_delete(resource_ptr);\n    }\n\n    // Handle the first condition\n    long handle1 = offset + 0x10;\n    if (condition1) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase*)&handle1);\n    }\n\n    // Handle the second condition\n    long handle2 = offset + 0x10;\n    if (condition2) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase*)&handle2);\n        perform_additional_cleanup();\n        return;\n    }\n\n    // Fallback cleanup\n    perform_fallback_cleanup();\n    _Unwind_Resume();\n}\n```",
        "source_code": "void Bwd::exec(\n        _megdnn_tensor_in data, _megdnn_tensor_in rois, _megdnn_tensor_in trans,\n        _megdnn_tensor_in out_diff, _megdnn_tensor_in out_count,\n        _megdnn_tensor_out data_diff, _megdnn_tensor_out trans_diff,\n        _megdnn_workspace workspace) {\n    check_exec(\n            data.layout, rois.layout, trans.layout, out_diff.layout, out_count.layout,\n            data_diff.layout, trans_diff.layout, workspace.size);\n    auto kern = [data, rois, trans, out_diff, out_count, data_diff,\n                 trans_diff](const DeformablePSROIPoolingBase::Param& param) {\n        bool no_trans = param.no_trans;\n        size_t pool_h = param.pooled_h, pool_w = param.pooled_w;\n        size_t part_sz = param.part_size, sample_per_part = param.sample_per_part;\n        float trans_std = param.trans_std, scale = param.spatial_scale;\n        size_t nr_bbox = rois.layout[0];\n        size_t nr_cls = no_trans ? 1 : trans.layout[1] / 2;\n        size_t IC = data.layout[1], IH = data.layout[2], IW = data.layout[3];\n        const float* data_ptr = data.ptr<float>();\n        const float* rois_ptr = rois.ptr<float>();\n        const float* trans_ptr = trans.ptr<float>();\n        const float* out_diff_ptr = out_diff.ptr<float>();\n        const float* out_count_ptr = out_count.ptr<float>();\n        float* data_diff_ptr = data_diff.ptr<float>();\n        float* trans_diff_ptr = trans_diff.ptr<float>();\n        auto&& data_diff_elems = data_diff.layout.total_nr_elems();\n        auto&& trans_diff_elems = trans_diff.layout.total_nr_elems();\n        size_t data_diff_bytes = sizeof(float[data_diff_elems]);\n        size_t trans_diff_bytes = sizeof(float[trans_diff_elems]);\n        memset(data_diff_ptr, 0, data_diff_bytes);\n        memset(trans_diff_ptr, 0, trans_diff_bytes);\n        deformable_ps_roi_pool_backward_acc_kernel(\n                data_ptr, rois_ptr, trans_ptr, out_diff_ptr, out_count_ptr,\n                data_diff_ptr, trans_diff_ptr, IC, IH, IW, no_trans, nr_bbox, nr_cls,\n                pool_h, pool_w, part_sz, sample_per_part, trans_std, scale);\n    };\n    MEGDNN_DISPATCH_CPU_KERN_OPR(kern(param()));\n    return;\n}",
        "parsed_output": "pp\nvoid cleanup_resources(void* resource_ptr, long offset, bool condition1, bool condition2)\n{\n    __cxa_guard_abort();\n\n    // Delete the resource if it exists\n    if (resource_ptr != nullptr) {\n        operator_delete(resource_ptr);\n    }\n\n    // Handle the first condition\n    long handle1 = offset + 0x10;\n    if (condition1) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase*)&handle1);\n    }\n\n    // Handle the second condition\n    long handle2 = offset + 0x10;\n    if (condition2) {\n        atlas::util::ObjectHandleBase::release((ObjectHandleBase*)&handle2);\n        perform_additional_cleanup();\n        return;\n    }\n\n    // Fallback cleanup\n    perform_fallback_cleanup();\n    _Unwind_Resume();\n}",
        "baseline_code_stripped": "void FUN_00278250(void)\n{\n  long in_stack_00000038;\n  long in_stack_00000090;\n  long in_stack_00000098;\n  long in_stack_000000a0;\n  long in_stack_000000a8;\n  void *in_stack_00000140;\n  __cxa_guard_abort();\n  if (in_stack_00000140 != (void *)0x0) {\n    operator_delete(in_stack_00000140);\n  }\n  in_stack_000000a0 = in_stack_00000038 + 0x10;\n  if (in_stack_000000a8 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x000000a0);\n  }\n  in_stack_00000090 = in_stack_00000038 + 0x10;\n  if (in_stack_00000098 != 0) {\n    atlas::util::ObjectHandleBase::release((ObjectHandleBase *)&stack0x00000090);\n    FUN_0027820b();\n    return;\n  }\n  FUN_005f9e00();\n  _Unwind_Resume();\n}",
        "similarity_score_unixcoder": 0.36504247784614563,
        "similarity_score_baseline_stripped": 0.41310906410217285
    },
    {
        "func_name": "ComponentAction::createWidget",
        "normed_func_sha256": "20cfc8978db3889b40b1b6f2ce20b86bd2c0fa4953543fc07d3890bbb64e0f62",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_0820d910(QObject *param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  int *local_20 [3];\n  undefined4 uStack_14;\n  uStack_14 = 0x820d91b;\n  if (param_1[0xc4] == (QObject)0x0) {\n    return;\n  }\n  QLineEdit::text();\n  iVar1 = local_20[0][1];\n  if (*local_20[0] == 0) {\nLAB_0820da00:\n    QArrayData::deallocate((QArrayData *)local_20[0],2,4);\n  }\n  else if (*local_20[0] != -1) {\n    LOCK();\n    *local_20[0] = *local_20[0] + -1;\n    UNLOCK();\n    if (*local_20[0] == 0) goto LAB_0820da00;\n  }\n  if (iVar1 == 0) {\n    return;\n  }\n  QObject::disconnect(*(QObject **)(param_1 + 0x38),\"2currentPageChanged(int)\",param_1,\n                      \"1checkPage(int)\");\n  uVar2 = *(undefined4 *)(param_1 + 0x94);\n  QLineEdit::text();\n  FUN_0820d580(param_1,local_20,uVar2);\n  if (*local_20[0] != 0) {\n    if (*local_20[0] == -1) goto LAB_0820d9d3;\n    LOCK();\n    *local_20[0] = *local_20[0] + -1;\n    UNLOCK();\n    if (*local_20[0] != 0) goto LAB_0820d9d3;\n  }\n  QArrayData::deallocate((QArrayData *)local_20[0],2,4);\nLAB_0820d9d3:\n  QObject::connect((QObject *)local_20,*(char **)(param_1 + 0x38),\n                   (QObject *)\"2currentPageChanged(int)\",(char *)param_1,\n                   (ConnectionType)\"1checkPage(int)\");\n  QMetaObject::Connection::_Connection((Connection *)local_20);\n  return;\n}\n\n Revised code:\nvoid PdfViewerWidget::searchDocument()\n{\nif (!fileLoaded) return;\n//QRectF location;\nif (searchLineEdit->text().isEmpty()) return;\ndisconnect(pdfview, SIGNAL(currentPageChanged(int)), this, SLOT(checkPage(int)));\n//QMetaObject::invokeMethod(this, \"searchForwards\", Qt::QueuedConnection,Q_ARG(QString,searchLineEdit->text()));\nsearchForwards(searchLineEdit->text());\nconnect(pdfview, SIGNAL(currentPageChanged(int)), this, SLOT(checkPage(int)));\n//else location = searchBackwards(searchLineEdit->text());\n//QPoint target = pdfWidget->matrix().mapRect(location).center().toPoint();\n//scrollArea->ensureVisible(target.x(), target.y());\n}\n\n## Example:\n\n Input code:\nvoid FUN_00a29b90(long param_1)\n{\n  undefined8 uVar1;\n  char cVar2;\n  uint uVar3;\n  double dVar4;\n  double dVar5;\n  int *local_20;\n  dVar4 = (double)QDoubleSpinBox::value();\n  *(double *)(param_1 + 0x338) = dVar4 / *(double *)(param_1 + 0x328);\n  FUN_00991120(*(undefined8 *)(param_1 + 0x1c8));\n  QComboBox::currentText();\n  cVar2 = operator__((QString *)&local_20,(QString *)&DAT_011ff930);\n  if (cVar2 == '\\0') {\n    cVar2 = operator__((QString *)&local_20,(QString *)&DAT_011ff938);\n    if (cVar2 == '\\0') {\n      uVar1 = *(undefined8 *)(param_1 + 0xc0);\n      QComboBox::count();\n      QComboBox::setCurrentIndex((int)uVar1);\n    }\n  }\n  dVar4 = (double)QDoubleSpinBox::value();\n  dVar5 = (double)QDoubleSpinBox::value();\n  uVar3 = QComboBox::currentIndex();\n  if (uVar3 != dVar5 < dVar4) {\n    QObject::blockSignals(SUB81(*(undefined8 *)(param_1 + 0xd8),0));\n    QComboBox::setCurrentIndex((int)*(undefined8 *)(param_1 + 0xd8));\n    QObject::blockSignals(SUB81(*(undefined8 *)(param_1 + 0xd8),0));\n  }\n  if (*local_20 != 0) {\n    if (*local_20 != -1) {\n      LOCK();\n      *local_20 = *local_20 + -1;\n      UNLOCK();\n      if (*local_20 == 0) goto LAB_00a29c98;\n    }\n    return;\n  }\nLAB_00a29c98:\n  QArrayData::deallocate((QArrayData *)local_20,2,8);\n  return;\n}\n\n Revised code:\nvoid Prefs_DocumentSetup::setPageHeight(double h)\n{\n\tpageH = pageHeightSpinBox->value() / unitRatio;\n\tmarginsWidget->setPageHeight(pageH);\n\tQString psText=pageSizeComboBox->currentText();\n\tif (psText!=CommonStrings::trCustomPageSize && psText!=CommonStrings::customPageSize)\n\t\tpageSizeComboBox->setCurrentIndex(pageSizeComboBox->count()-1);\n\tint newOrientation = (pageWidthSpinBox->value() > pageHeightSpinBox->value()) ? landscapePage : portraitPage;\n\tif (newOrientation != pageOrientationComboBox->currentIndex())\n\t{\n\t\tpageOrientationComboBox->blockSignals(true);\n\t\tpageOrientationComboBox->setCurrentIndex(newOrientation);\n\t\tpageOrientationComboBox->blockSignals(false);\n\t}\n}\n\n## Example:\n\n Input code:\nvoid FUN_001c7310(long param_1)\n{\n  char cVar1;\n  int iVar2;\n  QStringList aQStack_68 [16];\n  int *local_58 [2];\n  int *local_48 [3];\n  iVar2 = QComboBox::currentIndex();\n  if (iVar2 < 0) goto LAB_001c73c4;\n  QComboBox::itemData((int)local_48,(int)*(undefined8 *)(*(long *)(param_1 + 0x38) + 0x18));\n  QVariant::toString();\n  QWidget::setToolTip(*(QString **)(*(long *)(param_1 + 0x38) + 0x18));\n  if (*local_58[0] == 0) {\nLAB_001c7380:\n    QArrayData::deallocate((QArrayData *)local_58[0],2,8);\n  }\n  else if (*local_58[0] != -1) {\n    LOCK();\n    *local_58[0] = *local_58[0] + -1;\n    UNLOCK();\n    if (*local_58[0] == 0) goto LAB_001c7380;\n  }\n  QVariant::_QVariant((QVariant *)local_48);\n  QmakeProjectManager::QmakeProFileNode::variableValue((QmakeVariable)aQStack_68);\n  if (*(int *)(param_1 + 0x28) == 2) {\n    local_58[0] = (int *)QString::fromLatin1_helper(\"debug_and_release\",0x11);\n    cVar1 = QtPrivate::QStringList_contains(aQStack_68,(QString *)local_58,1);\n    if (cVar1 != '\\0') {\n      local_48[0] = (int *)QString::fromLatin1_helper(\"debug_and_release_target\",0x18);\n      QtPrivate::QStringList_contains(aQStack_68,(QString *)local_48,1);\n      if (*local_48[0] == 0) {\nLAB_001c74e3:\n        QArrayData::deallocate((QArrayData *)local_48[0],2,8);\n      }\n      else if (*local_48[0] != -1) {\n        LOCK();\n        *local_48[0] = *local_48[0] + -1;\n        UNLOCK();\n        if (*local_48[0] == 0) goto LAB_001c74e3;\n      }\n    }\n    if (*local_58[0] == 0) {\nLAB_001c744a:\n      QArrayData::deallocate((QArrayData *)local_58[0],2,8);\n    }\n    else if (*local_58[0] != -1) {\n      LOCK();\n      *local_58[0] = *local_58[0] + -1;\n      UNLOCK();\n      if (*local_58[0] == 0) goto LAB_001c744a;\n    }\n    QAbstractButton::setChecked(SUB81(*(undefined8 *)(*(long *)(param_1 + 0x38) + 0xe0),0));\n    QAbstractButton::setChecked(SUB81(*(undefined8 *)(*(long *)(param_1 + 0x38) + 0xe8),0));\n  }\n  FUN_00156910(aQStack_68);\nLAB_001c73c4:\n  if (*(char *)(param_1 + 0x2c) == '\\0') {\n    FUN_001c5be0(param_1);\n    FUN_001ed750(param_1);\n  }\n  return;\n}\n\n Revised code:\nvoid InternalLibraryDetailsController::slotCurrentLibraryChanged()\n{\n    const int currentIndex = libraryDetailsWidget()->libraryComboBox->currentIndex();\n    if (currentIndex >= 0) {\n        libraryDetailsWidget()->libraryComboBox->setToolTip(\n                    libraryDetailsWidget()->libraryComboBox->itemData(\n                        currentIndex, Qt::ToolTipRole).toString());\n        QmakeProFileNode *proFileNode = m_proFileNodes.at(currentIndex);\n        const QStringList configVar = proFileNode->variableValue(ConfigVar);\n        if (creatorPlatform() == CreatorWindows) {\n            bool useSubfolders = false;\n            if (configVar.contains(QLatin1String(\"debug_and_release\"))\n                && configVar.contains(QLatin1String(\"debug_and_release_target\")))\n                useSubfolders = true;\n            libraryDetailsWidget()->useSubfoldersCheckBox->setChecked(useSubfolders);\n            libraryDetailsWidget()->addSuffixCheckBox->setChecked(!useSubfolders);\n        }\n    }\n\n    if (guiSignalsIgnored())\n        return;\n\n    updateGui();\n\n    emit completeChanged();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nQComboBox * FUN_002adc00(char *param_1,QWidget *param_2)\n{\n  QComboBox *this;\n  undefined8 uVar1;\n  int *local_28 [2];\n  this = (QComboBox *)operator_new(0x30);\n  QComboBox::QComboBox(this,param_2);\n  QWidget::setMinimumWidth((int)this);\n  QMetaObject::tr((char *)local_28,(char *)&PTR_staticMetaObject_006071e0,0x368dc0);\n  QWidget::setToolTip((QString *)this);\n  if (*local_28[0] != 0) {\n    if (*local_28[0] == -1) goto LAB_002adc7c;\n    LOCK();\n    *local_28[0] = *local_28[0] + -1;\n    UNLOCK();\n    if (*local_28[0] != 0) goto LAB_002adc7c;\n  }\n  QArrayData::deallocate((QArrayData *)local_28[0],2,8);\nLAB_002adc7c:\n  uVar1 = 0;\n  if ((*(long *)(param_1 + 0x10) != 0) && (*(int *)(*(long *)(param_1 + 0x10) + 4) != 0)) {\n    uVar1 = *(undefined8 *)(param_1 + 0x18);\n  }\n  FUN_002ae0f0(uVar1);\n  QComboBox::setModel((QAbstractItemModel *)this);\n  QComboBox::setCurrentIndex((int)this);\n  QObject::connect((QObject *)local_28,(char *)this,(QObject *)\"2activated(int)\",param_1,0x368df0);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  QObject::connect((QObject *)local_28,param_1,(QObject *)\"2currentIndexChanged(int)\",(char *)this,\n                   0x368e22);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  return this;\n}",
        "output": "```c++\nQComboBox *createComboBox(char *controller, QWidget *parent)\n{\n    QComboBox *comboBox = new QComboBox(parent);\n    comboBox->setMinimumWidth(0); // Set minimum width for the combo box\n\n    QString toolTipText = QMetaObject::tr(\"ToolTipText\", &staticMetaObject, 0x368dc0);\n    comboBox->setToolTip(toolTipText);\n\n    if (!toolTipText.isEmpty()) {\n        // Deallocate memory if necessary\n        toolTipText.clear();\n    }\n\n    QVariant modelData;\n    if (controller && *(int *)(*(long *)(controller + 0x10) + 4) != 0) {\n        modelData = *(QVariant *)(controller + 0x18);\n    }\n    setComboBoxModel(comboBox, modelData);\n\n    comboBox->setCurrentIndex(0);\n\n    QObject::connect(comboBox, SIGNAL(activated(int)), controller, SLOT(onActivated(int)));\n    QObject::connect(controller, SIGNAL(currentIndexChanged(int)), comboBox, SLOT(onCurrentIndexChanged(int)));\n\n    return comboBox;\n}\n```",
        "source_code": "QWidget  *ComponentAction::createWidget(QWidget *parent)\n{\n    QComboBox *comboBox = new QComboBox(parent);\n    comboBox->setMinimumWidth(120);\n    comboBox->setToolTip(tr(\"Edit sub components defined in this file.\"));\n    comboBox->setModel(m_componentView->standardItemModel());\n    comboBox->setCurrentIndex(-1);\n    connect(comboBox, SIGNAL(activated(int)), SLOT(emitCurrentComponentChanged(int)));\n    connect(this, SIGNAL(currentIndexChanged(int)), comboBox, SLOT(setCurrentIndex(int)));\n\n    return comboBox;\n}",
        "parsed_output": "++\nQComboBox *createComboBox(char *controller, QWidget *parent)\n{\n    QComboBox *comboBox = new QComboBox(parent);\n    comboBox->setMinimumWidth(0); // Set minimum width for the combo box\n\n    QString toolTipText = QMetaObject::tr(\"ToolTipText\", &staticMetaObject, 0x368dc0);\n    comboBox->setToolTip(toolTipText);\n\n    if (!toolTipText.isEmpty()) {\n        // Deallocate memory if necessary\n        toolTipText.clear();\n    }\n\n    QVariant modelData;\n    if (controller && *(int *)(*(long *)(controller + 0x10) + 4) != 0) {\n        modelData = *(QVariant *)(controller + 0x18);\n    }\n    setComboBoxModel(comboBox, modelData);\n\n    comboBox->setCurrentIndex(0);\n\n    QObject::connect(comboBox, SIGNAL(activated(int)), controller, SLOT(onActivated(int)));\n    QObject::connect(controller, SIGNAL(currentIndexChanged(int)), comboBox, SLOT(onCurrentIndexChanged(int)));\n\n    return comboBox;\n}",
        "baseline_code_stripped": "QComboBox * FUN_002adc00(char *param_1,QWidget *param_2)\n{\n  QComboBox *this;\n  undefined8 uVar1;\n  int *local_28 [2];\n  this = (QComboBox *)operator_new(0x30);\n  QComboBox::QComboBox(this,param_2);\n  QWidget::setMinimumWidth((int)this);\n  QMetaObject::tr((char *)local_28,(char *)&PTR_staticMetaObject_006071e0,0x368dc0);\n  QWidget::setToolTip((QString *)this);\n  if (*local_28[0] != 0) {\n    if (*local_28[0] == -1) goto LAB_002adc7c;\n    LOCK();\n    *local_28[0] = *local_28[0] + -1;\n    UNLOCK();\n    if (*local_28[0] != 0) goto LAB_002adc7c;\n  }\n  QArrayData::deallocate((QArrayData *)local_28[0],2,8);\nLAB_002adc7c:\n  uVar1 = 0;\n  if ((*(long *)(param_1 + 0x10) != 0) && (*(int *)(*(long *)(param_1 + 0x10) + 4) != 0)) {\n    uVar1 = *(undefined8 *)(param_1 + 0x18);\n  }\n  FUN_002ae0f0(uVar1);\n  QComboBox::setModel((QAbstractItemModel *)this);\n  QComboBox::setCurrentIndex((int)this);\n  QObject::connect((QObject *)local_28,(char *)this,(QObject *)\"2activated(int)\",param_1,0x368df0);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  QObject::connect((QObject *)local_28,param_1,(QObject *)\"2currentIndexChanged(int)\",(char *)this,\n                   0x368e22);\n  QMetaObject::Connection::_Connection((Connection *)local_28);\n  return this;\n}",
        "similarity_score_unixcoder": 0.7462478876113892,
        "similarity_score_baseline_stripped": 0.6004320979118347
    },
    {
        "func_name": "sipQgsCalloutWidget::sipProtectVirt_event",
        "normed_func_sha256": "ac69765da0ed4cf3151c8fbe35de79ff95d20beabfe09e2e7d72ebc0a4eb9190",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid sipQgsMetadataWidget::sipProtectVirt_changeEvent(bool param_1,QEvent *param_2)\n{\n  undefined3 in_stack_00000005;\n  if ((char)param_2 == '\\0') {\n    (**(code **)(*_param_1 + 0xb0))();\n    return;\n  }\n  QWidget::changeEvent((QEvent *)_param_1);\n  return;\n}\n\n Revised code:\nvoid sipQgsMetadataWidget::sipProtectVirt_changeEvent(bool sipSelfWasArg, ::QEvent*a0)\n{\n    (sipSelfWasArg ? ::QWidget::changeEvent(a0) : changeEvent(a0));\n}\n\n## Example:\n\n Input code:\nvoid sipQgsAuthCertEditors::sipProtectVirt_changeEvent(bool param_1,QEvent *param_2)\n{\n  undefined3 in_stack_00000005;\n  if ((char)param_2 == '\\0') {\n    (**(code **)(*_param_1 + 0xb0))();\n    return;\n  }\n  QWidget::changeEvent((QEvent *)_param_1);\n  return;\n}\n\n Revised code:\nstatic PyObject *meth_QgsAuthCertEditors_receivers(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n\n    {\n        PyObject * a0;\n        const sipQgsAuthCertEditors *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"BP0\", &sipSelf, sipType_QgsAuthCertEditors, &sipCpp, &a0))\n        {\n            int sipRes = 0;\n            sipErrorState sipError = sipErrorNone;\n\n#line 601 \"/usr/lib/python3.11/site-packages/PyQt5/bindings/QtCore/qobject.sip\"\n        // We need to handle the signal object.  Import the helper if it hasn't already\n        // been done.\n        typedef sipErrorState (*pyqt5_get_signal_signature_t)(PyObject *, const QObject *, const QByteArray &);\n        \n        static pyqt5_get_signal_signature_t pyqt5_get_signal_signature = 0;\n        \n        if (!pyqt5_get_signal_signature)\n        {\n            pyqt5_get_signal_signature = (pyqt5_get_signal_signature_t)sipImportSymbol(\"pyqt5_get_signal_signature\");\n            Q_ASSERT(pyqt5_get_signal_signature);\n        }\n        \n        QByteArray signal_signature;\n            \n        #if defined(SIP_PROTECTED_IS_PUBLIC)\n        if ((sipError = pyqt5_get_signal_signature(a0, sipCpp, signal_signature)) == sipErrorNone)\n        {\n            sipRes = sipCpp->receivers(signal_signature.constData());\n        }\n        #else\n        if ((sipError = pyqt5_get_signal_signature(a0, static_cast<const QObject *>(sipCpp), signal_signature)) == sipErrorNone)\n        {\n            sipRes = sipCpp->sipProtect_receivers(signal_signature.constData());\n        }\n        #endif\n        else if (sipError == sipErrorContinue)\n        {\n            sipError = sipBadCallableArg(0, a0);\n        }\n#line 13832 \"/home/abuild/rpmbuild/BUILD/qgis-3.28.8/build/python/gui/build/_gui/sip_guipart10.cpp\"\n\n            if (sipError == sipErrorFail)\n                return 0;\n\n            if (sipError == sipErrorNone)\n            {\n            return PyLong_FromLong(sipRes);\n            }\n\n            sipAddException(sipError, &sipParseErr);\n        }\n    }\n\n    sipNoMethod(sipParseErr, sipName_QgsAuthCertEditors, sipName_receivers, doc_QgsAuthCertEditors_receivers);\n\n    return SIP_NULLPTR;\n}\n\n## Example:\n\n Input code:\nvoid sipQgsDialog::sipProtectVirt_childEvent(bool param_1,QChildEvent *param_2)\n{\n  undefined3 in_stack_00000005;\n  if ((char)param_2 == '\\0') {\n    (**(code **)(*_param_1 + 0x20))();\n    return;\n  }\n  QObject::childEvent((QChildEvent *)_param_1);\n  return;\n}\n\n Revised code:\nvoid sipQgsDialog::sipProtectVirt_mouseMoveEvent(bool sipSelfWasArg, ::QMouseEvent*a0)\n{\n    (sipSelfWasArg ?  ::QWidget::mouseMoveEvent(a0) : mouseMoveEvent(a0));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sipQgsCalloutWidget::sipProtectVirt_event(bool param_1,QEvent *param_2)\n{\n  undefined3 in_stack_00000005;\n  if ((char)param_2 == '\\0') {\n    (**(code **)(*_param_1 + 0x14))();\n    return;\n  }\n  QWidget::event((QEvent *)_param_1);\n  return;\n}",
        "output": "```c\nvoid sipQgsCalloutWidget::sipProtectVirt_event(bool sipSelfWasArg, ::QEvent*a0)\n{\n    (sipSelfWasArg ? ::QWidget::event(a0) : event(a0));\n}\n```",
        "source_code": "bool sipQgsCalloutWidget::sipProtectVirt_event(bool sipSelfWasArg, ::QEvent*a0)\n{\n    return (sipSelfWasArg ? ::QWidget::event(a0) : event(a0));\n}",
        "parsed_output": "void sipQgsCalloutWidget::sipProtectVirt_event(bool sipSelfWasArg, ::QEvent*a0)\n{\n    (sipSelfWasArg ? ::QWidget::event(a0) : event(a0));\n}",
        "baseline_code_stripped": "void sipQgsCalloutWidget::sipProtectVirt_event(bool param_1,QEvent *param_2)\n{\n  undefined3 in_stack_00000005;\n  if ((char)param_2 == '\\0') {\n    (**(code **)(*_param_1 + 0x14))();\n    return;\n  }\n  QWidget::event((QEvent *)_param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.9851958155632019,
        "similarity_score_baseline_stripped": 0.7690246105194092
    },
    {
        "func_name": "deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0",
        "normed_func_sha256": "fe770ba5a4e665e092881b81fcb5444008a05e9be595e646a7286940b40a982e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid deriv2eri3_aB_K__0__G__1___TwoPRep_unit__0__S__1___Ab__up_0(long param_1)\n{\n  int iVar1;\n  long lVar2;\n  lVar2 = 0;\n  do {\n    *(undefined8 *)(*(long *)(param_1 + 0x2b8) + lVar2) = 0;\n    lVar2 = lVar2 + 8;\n  } while (lVar2 != 0x16260);\n  iVar1 = *(int *)(param_1 + 0x434);\n  if (0 < iVar1) {\n    lVar2 = param_1;\n    do {\n      deriv2eri3_aB_K__0__G__1___TwoPRep_unit__0__S__1___Ab__up_0_prereq\n                (lVar2,*(undefined8 *)(param_1 + 0x2b8));\n      lVar2 = lVar2 + 0x438;\n    } while (lVar2 != param_1 + 0x438 + (ulong)(iVar1 - 1) * 0x438);\n  }\n  lVar2 = *(long *)(param_1 + 0x2b8);\n  *(long *)(param_1 + 0x2c8) = lVar2;\n  *(long *)(param_1 + 0x2d0) = lVar2 + 0x10e0;\n  *(long *)(param_1 + 0x2d8) = lVar2 + 0x21c0;\n  *(long *)(param_1 + 0x2e0) = lVar2 + 0x32a0;\n  *(long *)(param_1 + 0x2e8) = lVar2 + 0x4380;\n  *(long *)(param_1 + 0x2f0) = lVar2 + 0x5460;\n  *(long *)(param_1 + 0x2f8) = lVar2 + 0x6540;\n  *(long *)(param_1 + 0x300) = lVar2 + 0x7620;\n  *(long *)(param_1 + 0x308) = lVar2 + 0x8700;\n  *(long *)(param_1 + 0x310) = lVar2 + 0x97e0;\n  *(long *)(param_1 + 0x318) = lVar2 + 0xa8c0;\n  *(long *)(param_1 + 800) = lVar2 + 0xb9a0;\n  *(long *)(param_1 + 0x328) = lVar2 + 0xca80;\n  *(long *)(param_1 + 0x330) = lVar2 + 0xdb60;\n  *(long *)(param_1 + 0x338) = lVar2 + 0xec40;\n  *(long *)(param_1 + 0x340) = lVar2 + 0xfd20;\n  *(long *)(param_1 + 0x348) = lVar2 + 0x10e00;\n  *(long *)(param_1 + 0x350) = lVar2 + 0x11ee0;\n  *(long *)(param_1 + 0x358) = lVar2 + 0x12fc0;\n  *(long *)(param_1 + 0x360) = lVar2 + 0x140a0;\n  *(long *)(param_1 + 0x368) = lVar2 + 0x15180;\n  return;\n}\n\n Revised code:\nvoid deriv2eri3_aB_K__0__G__1___TwoPRep_unit__0__S__1___Ab__up_0(const Libint_t* inteval) {\n\n_libint2_static_api_bzero_short_(inteval->stack+0*1,11340)\nconst int contrdepth = inteval->contrdepth;\n#ifdef __INTEL_COMPILER\n#pragma ivdep\n#endif\nfor(int c = 0; c<contrdepth; c++) {\nderiv2eri3_aB_K__0__G__1___TwoPRep_unit__0__S__1___Ab__up_0_prereq(inteval+c, inteval->stack);\n}\n\nLIBINT2_REALTYPE*const  stack = inteval->stack;\n{\nconst int hsi = 0;\n{\nconst int lsi = 0;\n{\nconst int vi = 0;\n}\n}\n}\nconst int hsi = 0;\nconst int lsi = 0;\nconst int vi = 0;\ninteval->targets[0] = &(inteval->stack[((hsi*540+0)*1+lsi)*1]);\ninteval->targets[1] = &(inteval->stack[((hsi*540+540)*1+lsi)*1]);\ninteval->targets[2] = &(inteval->stack[((hsi*540+1080)*1+lsi)*1]);\ninteval->targets[3] = &(inteval->stack[((hsi*540+1620)*1+lsi)*1]);\ninteval->targets[4] = &(inteval->stack[((hsi*540+2160)*1+lsi)*1]);\ninteval->targets[5] = &(inteval->stack[((hsi*540+2700)*1+lsi)*1]);\ninteval->targets[6] = &(inteval->stack[((hsi*540+3240)*1+lsi)*1]);\ninteval->targets[7] = &(inteval->stack[((hsi*540+3780)*1+lsi)*1]);\ninteval->targets[8] = &(inteval->stack[((hsi*540+4320)*1+lsi)*1]);\ninteval->targets[9] = &(inteval->stack[((hsi*540+4860)*1+lsi)*1]);\ninteval->targets[10] = &(inteval->stack[((hsi*540+5400)*1+lsi)*1]);\ninteval->targets[11] = &(inteval->stack[((hsi*540+5940)*1+lsi)*1]);\ninteval->targets[12] = &(inteval->stack[((hsi*540+6480)*1+lsi)*1]);\ninteval->targets[13] = &(inteval->stack[((hsi*540+7020)*1+lsi)*1]);\ninteval->targets[14] = &(inteval->stack[((hsi*540+7560)*1+lsi)*1]);\ninteval->targets[15] = &(inteval->stack[((hsi*540+8100)*1+lsi)*1]);\ninteval->targets[16] = &(inteval->stack[((hsi*540+8640)*1+lsi)*1]);\ninteval->targets[17] = &(inteval->stack[((hsi*540+9180)*1+lsi)*1]);\ninteval->targets[18] = &(inteval->stack[((hsi*540+9720)*1+lsi)*1]);\ninteval->targets[19] = &(inteval->stack[((hsi*540+10260)*1+lsi)*1]);\ninteval->targets[20] = &(inteval->stack[((hsi*540+10800)*1+lsi)*1]);\n/** Number of flops = 0 */\n}\n\n## Example:\n\n Input code:\nvoid _aB_H__0__K__1___TwoPRep_S__0__D__1___Ab__up_0(long param_1)\n{\n  int iVar1;\n  long lVar2;\n  lVar2 = 0;\n  do {\n    *(undefined8 *)(*(long *)(param_1 + 0x2d8) + lVar2) = 0;\n    lVar2 = lVar2 + 8;\n  } while (lVar2 != 0x5940);\n  iVar1 = *(int *)(param_1 + 0x55c);\n  if (0 < iVar1) {\n    lVar2 = param_1;\n    do {\n      _aB_H__0__K__1___TwoPRep_S__0__D__1___Ab__up_0_prereq(lVar2,*(undefined8 *)(param_1 + 0x2d8));\n      lVar2 = lVar2 + 0x560;\n    } while (param_1 + (long)iVar1 * 0x560 != lVar2);\n  }\n  lVar2 = *(long *)(param_1 + 0x2d8);\n  HRRPart1bra0ket0kp(param_1,lVar2 + 0xe700,lVar2 + 0x2418,lVar2 + 0x41a0,0x15);\n  lVar2 = *(long *)(param_1 + 0x2d8);\n  HRRPart1bra0ket0lp(param_1,lVar2 + 0x12de0,lVar2,lVar2 + 0x2418,0x15);\n  lVar2 = *(long *)(param_1 + 0x2d8);\n  HRRPart1bra0ket0kd(param_1,lVar2 + 0x5940,lVar2 + 0x12de0,lVar2 + 0xe700,0x15);\n  *(long *)(param_1 + 0x2e8) = *(long *)(param_1 + 0x2d8) + 0x5940;\n  return;\n}\n\n Revised code:\nvoid _aB_H__0__K__1___TwoPRep_S__0__D__1___Ab__up_0(const Libint_t* inteval) {\n\n_libint2_static_api_bzero_short_(inteval->stack+0*1,2856)\nconst int contrdepth = inteval->contrdepth;\n#ifdef __INTEL_COMPILER\n#pragma ivdep\n#endif\nfor(int c = 0; c<contrdepth; c++) {\n_aB_H__0__K__1___TwoPRep_S__0__D__1___Ab__up_0_prereq(inteval+c, inteval->stack);\n}\n\nLIBINT2_REALTYPE*const  stack = inteval->stack;\n{\nconst int hsi = 0;\n{\nconst int lsi = 0;\n{\nconst int vi = 0;\nHRRPart1bra0ket0kp(inteval, &(inteval->stack[((hsi*2268+7392)*1+lsi)*1]), &(inteval->stack[((hsi*945+1155)*1+lsi)*1]), &(inteval->stack[((hsi*756+2100)*1+lsi)*1]),21);\nHRRPart1bra0ket0lp(inteval, &(inteval->stack[((hsi*2835+9660)*1+lsi)*1]), &(inteval->stack[((hsi*1155+0)*1+lsi)*1]), &(inteval->stack[((hsi*945+1155)*1+lsi)*1]),21);\nHRRPart1bra0ket0kd(inteval, &(inteval->stack[((hsi*4536+2856)*1+lsi)*1]), &(inteval->stack[((hsi*2835+9660)*1+lsi)*1]), &(inteval->stack[((hsi*2268+7392)*1+lsi)*1]),21);\n}\n}\n}\nconst int hsi = 0;\nconst int lsi = 0;\nconst int vi = 0;\ninteval->targets[0] = &(inteval->stack[((hsi*4536+2856)*1+lsi)*1]);\n/** Number of flops = 0 */\n}\n\n## Example:\n\n Input code:\nvoid _aB_K__0__G__1___TwoPRep_S__0__F__1___Ab__up_0(long param_1)\n{\n  long lVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar5;\n  long lVar6;\n  undefined8 *puVar4;\n  puVar5 = *(undefined8 **)(param_1 + 0x2d8);\n  puVar3 = puVar5;\n  do {\n    puVar4 = puVar3 + 1;\n    *puVar3 = 0;\n    puVar3 = puVar4;\n  } while (puVar4 != puVar5 + 0xe10);\n  iVar2 = *(int *)(param_1 + 0x55c);\n  if (0 < iVar2) {\n    lVar6 = param_1;\n    do {\n      lVar1 = lVar6 + 0x560;\n      _aB_K__0__G__1___TwoPRep_S__0__F__1___Ab__up_0_prereq(lVar6);\n      puVar5 = *(undefined8 **)(param_1 + 0x2d8);\n      lVar6 = lVar1;\n    } while (lVar1 != param_1 + 0x560 + (ulong)(iVar2 - 1) * 0x560);\n  }\n  HRRPart1bra0ket0hp(param_1,puVar5 + 9000,puVar5 + 0x510,puVar5 + 0x900,0x24);\n  lVar6 = *(long *)(param_1 + 0x2d8);\n  HRRPart1bra0ket0gp(param_1,lVar6 + 0x16020,lVar6 + 0x4800,lVar6 + 0x5fa0,0x24);\n  lVar6 = *(long *)(param_1 + 0x2d8);\n  HRRPart1bra0ket0gd(param_1,lVar6 + 0x192c0,lVar6 + 72000,lVar6 + 0x16020,0x24);\n  lVar6 = *(long *)(param_1 + 0x2d8);\n  HRRPart1bra0ket0ip(param_1,lVar6 + 0x1f800,lVar6,lVar6 + 0x2880,0x24);\n  lVar6 = *(long *)(param_1 + 0x2d8);\n  HRRPart1bra0ket0hd(param_1,lVar6 + 0x25680,lVar6 + 0x1f800,lVar6 + 72000,0x24);\n  lVar6 = *(long *)(param_1 + 0x2d8);\n  HRRPart1bra0ket0gf(param_1,lVar6 + 0x7080,lVar6 + 0x25680,lVar6 + 0x192c0,0x24);\n  *(long *)(param_1 + 0x2e8) = *(long *)(param_1 + 0x2d8) + 0x7080;\n  return;\n}\n\n Revised code:\nvoid _aB_K__0__G__1___TwoPRep_S__0__F__1___Ab__up_0(const Libint_t* inteval) {\n\n_libint2_static_api_bzero_short_(inteval->stack+0*1,3600)\nconst int contrdepth = inteval->contrdepth;\n#ifdef __INTEL_COMPILER\n#pragma ivdep\n#endif\nfor(int c = 0; c<contrdepth; c++) {\n_aB_K__0__G__1___TwoPRep_S__0__F__1___Ab__up_0_prereq(inteval+c, inteval->stack);\n}\n\nLIBINT2_REALTYPE*const  stack = inteval->stack;\n{\nconst int hsi = 0;\n{\nconst int lsi = 0;\n{\nconst int vi = 0;\nHRRPart1bra0ket0hp(inteval, &(inteval->stack[((hsi*2268+9000)*1+lsi)*1]), &(inteval->stack[((hsi*1008+1296)*1+lsi)*1]), &(inteval->stack[((hsi*756+2304)*1+lsi)*1]),36);\nHRRPart1bra0ket0gp(inteval, &(inteval->stack[((hsi*1620+11268)*1+lsi)*1]), &(inteval->stack[((hsi*756+2304)*1+lsi)*1]), &(inteval->stack[((hsi*540+3060)*1+lsi)*1]),36);\nHRRPart1bra0ket0gd(inteval, &(inteval->stack[((hsi*3240+12888)*1+lsi)*1]), &(inteval->stack[((hsi*2268+9000)*1+lsi)*1]), &(inteval->stack[((hsi*1620+11268)*1+lsi)*1]),36);\nHRRPart1bra0ket0ip(inteval, &(inteval->stack[((hsi*3024+16128)*1+lsi)*1]), &(inteval->stack[((hsi*1296+0)*1+lsi)*1]), &(inteval->stack[((hsi*1008+1296)*1+lsi)*1]),36);\nHRRPart1bra0ket0hd(inteval, &(inteval->stack[((hsi*4536+19152)*1+lsi)*1]), &(inteval->stack[((hsi*3024+16128)*1+lsi)*1]), &(inteval->stack[((hsi*2268+9000)*1+lsi)*1]),36);\nHRRPart1bra0ket0gf(inteval, &(inteval->stack[((hsi*5400+3600)*1+lsi)*1]), &(inteval->stack[((hsi*4536+19152)*1+lsi)*1]), &(inteval->stack[((hsi*3240+12888)*1+lsi)*1]),36);\n}\n}\n}\nconst int hsi = 0;\nconst int lsi = 0;\nconst int vi = 0;\ninteval->targets[0] = &(inteval->stack[((hsi*5400+3600)*1+lsi)*1]);\n/** Number of flops = 0 */\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(long param_1)\n{\n  int iVar1;\n  long lVar2;\n  lVar2 = 0;\n  do {\n    *(undefined8 *)(*(long *)(param_1 + 0x1c0) + lVar2) = 0;\n    lVar2 = lVar2 + 8;\n  } while (lVar2 != 0x2880);\n  iVar1 = *(int *)(param_1 + 0x33c);\n  if (0 < iVar1) {\n    lVar2 = param_1;\n    do {\n      deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq\n                (lVar2,*(undefined8 *)(param_1 + 0x1c0));\n      lVar2 = lVar2 + 0x340;\n    } while (lVar2 != ((ulong)(iVar1 - 1) + 1) * 0x340 + param_1);\n  }\n  lVar2 = *(long *)(param_1 + 0x1c0);\n  *(long *)(param_1 + 0x1d0) = lVar2 + 0x21c0;\n  *(long *)(param_1 + 0x1d8) = lVar2 + 0x1b00;\n  *(long *)(param_1 + 0x1e0) = lVar2 + 0x1440;\n  *(long *)(param_1 + 0x1e8) = lVar2 + 0xd80;\n  *(long *)(param_1 + 0x1f0) = lVar2 + 0x6c0;\n  *(long *)(param_1 + 0x1f8) = lVar2;\n  return;\n}",
        "output": "```c\nvoid deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(const Libint_t* inteval) {\n\n_libint2_static_api_bzero_short_(inteval->stack+0*1,1344)\nconst int contrdepth = inteval->contrdepth;\n#ifdef __INTEL_COMPILER\n#pragma ivdep\n#endif\nfor(int c = 0; c<contrdepth; c++) {\nderiv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq(inteval+c, inteval->stack);\n}\n\nLIBINT2_REALTYPE*const  stack = inteval->stack;\n{\nconst int hsi = 0;\n{\nconst int lsi = 0;\n{\nconst int vi = 0;\n}\n}\n}\nconst int hsi = 0;\nconst int lsi = 0;\nconst int vi = 0;\ninteval->targets[0] = &(inteval->stack[((hsi*540+540)*1+lsi)*1]);\ninteval->targets[1] = &(inteval->stack[((hsi*540+864)*1+lsi)*1]);\ninteval->targets[2] = &(inteval->stack[((hsi*540+1080)*1+lsi)*1]);\ninteval->targets[3] = &(inteval->stack[((hsi*540+1296)*1+lsi)*1]);\ninteval->targets[4] = &(inteval->stack[((hsi*540+1512)*1+lsi)*1]);\ninteval->targets[5] = &(inteval->stack[((hsi*540+1728)*1+lsi)*1]);\n/** Number of flops = 0 */\n}\n```",
        "source_code": "void deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(const Libint_t* inteval) {\n\n_libint2_static_api_bzero_short_(inteval->stack+0*1,1296)\nconst int contrdepth = inteval->contrdepth;\n#ifdef __INTEL_COMPILER\n#pragma ivdep\n#endif\nfor(int c = 0; c<contrdepth; c++) {\nderiv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq(inteval+c, inteval->stack);\n}\n\nLIBINT2_REALTYPE*const  stack = inteval->stack;\n{\nconst int hsi = 0;\n{\nconst int lsi = 0;\n{\nconst int vi = 0;\n}\n}\n}\nconst int hsi = 0;\nconst int lsi = 0;\nconst int vi = 0;\ninteval->targets[0] = &(inteval->stack[((hsi*216+1080)*1+lsi)*1]);\ninteval->targets[1] = &(inteval->stack[((hsi*216+864)*1+lsi)*1]);\ninteval->targets[2] = &(inteval->stack[((hsi*216+648)*1+lsi)*1]);\ninteval->targets[3] = &(inteval->stack[((hsi*216+432)*1+lsi)*1]);\ninteval->targets[4] = &(inteval->stack[((hsi*216+216)*1+lsi)*1]);\ninteval->targets[5] = &(inteval->stack[((hsi*216+0)*1+lsi)*1]);\n/** Number of flops = 0 */\n}",
        "parsed_output": "void deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(const Libint_t* inteval) {\n\n_libint2_static_api_bzero_short_(inteval->stack+0*1,1344)\nconst int contrdepth = inteval->contrdepth;\n#ifdef __INTEL_COMPILER\n#pragma ivdep\n#endif\nfor(int c = 0; c<contrdepth; c++) {\nderiv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq(inteval+c, inteval->stack);\n}\n\nLIBINT2_REALTYPE*const  stack = inteval->stack;\n{\nconst int hsi = 0;\n{\nconst int lsi = 0;\n{\nconst int vi = 0;\n}\n}\n}\nconst int hsi = 0;\nconst int lsi = 0;\nconst int vi = 0;\ninteval->targets[0] = &(inteval->stack[((hsi*540+540)*1+lsi)*1]);\ninteval->targets[1] = &(inteval->stack[((hsi*540+864)*1+lsi)*1]);\ninteval->targets[2] = &(inteval->stack[((hsi*540+1080)*1+lsi)*1]);\ninteval->targets[3] = &(inteval->stack[((hsi*540+1296)*1+lsi)*1]);\ninteval->targets[4] = &(inteval->stack[((hsi*540+1512)*1+lsi)*1]);\ninteval->targets[5] = &(inteval->stack[((hsi*540+1728)*1+lsi)*1]);\n/** Number of flops = 0 */\n}",
        "baseline_code_stripped": "void deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0(long param_1)\n{\n  int iVar1;\n  long lVar2;\n  lVar2 = 0;\n  do {\n    *(undefined8 *)(*(long *)(param_1 + 0x1c0) + lVar2) = 0;\n    lVar2 = lVar2 + 8;\n  } while (lVar2 != 0x2880);\n  iVar1 = *(int *)(param_1 + 0x33c);\n  if (0 < iVar1) {\n    lVar2 = param_1;\n    do {\n      deriv2eri2_aB_D__0__K__1___TwoPRep_unit__0__unit__1___Ab__up_0_prereq\n                (lVar2,*(undefined8 *)(param_1 + 0x1c0));\n      lVar2 = lVar2 + 0x340;\n    } while (lVar2 != ((ulong)(iVar1 - 1) + 1) * 0x340 + param_1);\n  }\n  lVar2 = *(long *)(param_1 + 0x1c0);\n  *(long *)(param_1 + 0x1d0) = lVar2 + 0x21c0;\n  *(long *)(param_1 + 0x1d8) = lVar2 + 0x1b00;\n  *(long *)(param_1 + 0x1e0) = lVar2 + 0x1440;\n  *(long *)(param_1 + 0x1e8) = lVar2 + 0xd80;\n  *(long *)(param_1 + 0x1f0) = lVar2 + 0x6c0;\n  *(long *)(param_1 + 0x1f8) = lVar2;\n  return;\n}",
        "similarity_score_unixcoder": 0.9752755761146545,
        "similarity_score_baseline_stripped": 0.6332758665084839
    },
    {
        "func_name": "nestingLevelsPop",
        "normed_func_sha256": "fed6f55e68b006614df7e0874e422ccaab85dd29f146fcb432636f524f024aac",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined4 FUN_00123e00(long param_1)\n{\n  long lVar1;\n  lVar1 = FUN_00123cf0(param_1 + 0x1b0);\n  if (lVar1 != param_1 + 0x1b8) {\n    return *(undefined4 *)(lVar1 + 0x40);\n  }\n  return 0xffffffff;\n}\n\n Revised code:\nint OGRGMLASLayer::GetOGRFieldIndexFromXPath(const CPLString& osXPath) const\n{\n    const auto oIter = m_oMapFieldXPathToOGRFieldIdx.find(osXPath);\n    if( oIter == m_oMapFieldXPathToOGRFieldIdx.end() )\n        return -1;\n    return oIter->second;\n}\n\n## Example:\n\n Input code:\nlonglong FUN_0012c170(longlong param_1)\n{\n  longlong lVar1;\n  FUN_00150108();\n  lVar1 = FUN_001104a0(*(undefined8 *)(param_1 + 0xd0));\n  if (lVar1 != 0) {\n    FUN_0013f468(*(undefined8 *)(param_1 + 0x160),lVar1);\n  }\n  FUN_00150158(param_1);\n  return lVar1;\n}\n\n Revised code:\nstatic int\nipctran_ep_bind(void *arg)\n{\n\tipctran_ep *ep = arg;\n\tint         rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\tif ((rv = nng_stream_listener_listen(ep->listener)) != 0) {\n\t\tnni_listener_bump_error(ep->nlistener, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\treturn (rv);\n}\n\n## Example:\n\n Input code:\nlong FUN_00191104(undefined8 param_1,long param_2,undefined8 *param_3)\n{\n  long lVar1;\n  lVar1 = FUN_001336c0();\n  if (lVar1 < 0) {\n    return lVar1;\n  }\n  if (param_2 == 0) {\n    if (lVar1 == 0) {\n      FUN_001883bc(param_1);\n      return -1;\n    }\n  }\n  else {\n    if (param_2 != 0xc) {\n      return lVar1;\n    }\n    if (lVar1 == 0) {\n      *(undefined4 *)*param_3 = 0xffffffff;\n      return -1;\n    }\n  }\n  return (long)((int)lVar1 + -1);\n}\n\n Revised code:\nint QgsGrassElementDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 1)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 1;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 1)\n            *reinterpret_cast<int*>(_a[0]) = -1;\n        _id -= 1;\n    }\n    return _id;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_003cfbf8(long param_1)\n{\n  long lVar1;\n  lVar1 = FUN_003cfc54(param_1);\n  if (lVar1 == 0) {\n    FUN_003cd9b6(\"Assert(nl != NULL) failed!\");\n  }\n  FUN_003e6e64(*(undefined8 *)(lVar1 + 8));\n  *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + -1;\n  return;\n}",
        "output": "void XmlNodeList::RemoveNode(long param_1)\n{\n    long node = GetNode(param_1);\n    if (node == 0) {\n        throw std::runtime_error(\"Assert(nl != NULL) failed!\");\n    }\n    DeleteNode(*(void **)(node + 8));\n    *(int *)(param_1 + 8) -= 1;\n}",
        "source_code": "extern void nestingLevelsPop(NestingLevels *nls)\n{\n\tconst NestingLevel *nl = nestingLevelsGetCurrent(nls);\n\n\tAssert (nl != NULL);\n\tvStringClear(nl->name);\n\tnls->n--;\n}",
        "parsed_output": "void XmlNodeList::RemoveNode(long param_1)\n{\n    long node = GetNode(param_1);\n    if (node == 0) {\n        throw std::runtime_error(\"Assert(nl != NULL) failed!\");\n    }\n    DeleteNode(*(void **)(node + 8));\n    *(int *)(param_1 + 8) -= 1;\n}",
        "baseline_code_stripped": "void FUN_003cfbf8(long param_1)\n{\n  long lVar1;\n  lVar1 = FUN_003cfc54(param_1);\n  if (lVar1 == 0) {\n    FUN_003cd9b6(\"Assert(nl != NULL) failed!\");\n  }\n  FUN_003e6e64(*(undefined8 *)(lVar1 + 8));\n  *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + -1;\n  return;\n}",
        "similarity_score_unixcoder": 0.5099912881851196,
        "similarity_score_baseline_stripped": 0.41622424125671387
    },
    {
        "func_name": "QHttpNetworkConnection::qt_metacall",
        "normed_func_sha256": "9624e51b8d35c33a2f7d4c3d677f91eabbf69d0e44328b8e4af290b708d5287e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint FUN_00014f40(Call param_1,int param_2,void **param_3,undefined4 param_4)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall(param_1,param_2,param_3);\n  if ((-1 < iVar1) && (param_2 == 0)) {\n    if (iVar1 < 7) {\n      FUN_00014cc0(param_1,0,iVar1,param_4);\n    }\n    iVar1 = iVar1 + -7;\n  }\n  return iVar1;\n}\n\n Revised code:\nint QalculateEngine::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 7)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 7;\n    }\n    return _id;\n}\n\n## Example:\n\n Input code:\nint FUN_00056510(Call param_1,int param_2,void **param_3,undefined4 *param_4)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall(param_1,param_2,param_3);\n  if (-1 < iVar1) {\n    if (param_2 == 0) {\n      if (iVar1 == 0) {\n        FUN_000551b0(param_1,0,0,param_4);\n      }\n    }\n    else {\n      if (param_2 != 0xc) {\n        return iVar1;\n      }\n      if (iVar1 == 0) {\n        *(undefined4 *)*param_4 = 0xffffffff;\n      }\n    }\n    iVar1 = iVar1 + -1;\n  }\n  return iVar1;\n}\n\n Revised code:\nint Ios::Internal::LogTailFiles::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 1)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 1;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 1)\n            *reinterpret_cast<int*>(_a[0]) = -1;\n        _id -= 1;\n    }\n    return _id;\n}\n\n## Example:\n\n Input code:\nint FUN_00057c90(Call param_1,int param_2,void **param_3,undefined4 *param_4)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall(param_1,param_2,param_3);\n  if (-1 < iVar1) {\n    if (param_2 == 0) {\n      if (iVar1 < 2) {\n        FUN_00056ac0(param_1,0,iVar1,param_4);\n      }\n    }\n    else {\n      if (param_2 != 0xc) {\n        return iVar1;\n      }\n      if (iVar1 < 2) {\n        *(undefined4 *)*param_4 = 0xffffffff;\n      }\n    }\n    iVar1 = iVar1 + -2;\n  }\n  return iVar1;\n}\n\n Revised code:\nint GammaRay::ConnectionsExtensionInterface::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 2)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 2;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 2)\n            *reinterpret_cast<int*>(_a[0]) = -1;\n        _id -= 2;\n    }\n    return _id;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_00060360(Call param_1,int param_2,void **param_3,undefined4 param_4)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall(param_1,param_2,param_3);\n  if ((-1 < iVar1) && (param_2 == 0)) {\n    if (iVar1 == 0) {\n      FUN_00060330(param_1,0,0,param_4);\n    }\n    iVar1 = iVar1 + -1;\n  }\n  return iVar1;\n}",
        "output": "```c\nint MyNamespace::MyClass::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id == 0)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 1;\n    }\n    return _id;\n}\n```",
        "source_code": "int QHttpNetworkConnection::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 1)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 1;\n    }\n    return _id;\n}",
        "parsed_output": "int MyNamespace::MyClass::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id == 0)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 1;\n    }\n    return _id;\n}",
        "baseline_code_stripped": "int FUN_00060360(Call param_1,int param_2,void **param_3,undefined4 param_4)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall(param_1,param_2,param_3);\n  if ((-1 < iVar1) && (param_2 == 0)) {\n    if (iVar1 == 0) {\n      FUN_00060330(param_1,0,0,param_4);\n    }\n    iVar1 = iVar1 + -1;\n  }\n  return iVar1;\n}",
        "similarity_score_unixcoder": 0.9304538369178772,
        "similarity_score_baseline_stripped": 0.5951101779937744
    },
    {
        "func_name": "PythonQtWrapper_QTextInlineObject::qt_metacast",
        "normed_func_sha256": "52e45914ccb46f45a5c8374254562585c526c97b54779133ec2d5b88a0b516be",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __thiscall\nPythonQtWrapper_QDomDocumentType::qt_metacall\n          (PythonQtWrapper_QDomDocumentType *this,Call param_1,int param_2,void **param_3)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall((Call)this,param_1,(void **)param_2);\n  if ((-1 < iVar1) && (param_1 == 0)) {\n    if (iVar1 < 10) {\n      qt_static_metacall((QObject *)this,0,iVar1,param_3);\n    }\n    iVar1 = iVar1 + -10;\n  }\n  return iVar1;\n}\n\n Revised code:\nint PythonQtWrapper_QDomDocumentType::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 10)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 10;\n    }\n    return _id;\n}\n\n## Example:\n\n Input code:\nint __thiscall\nPythonQtWrapper_QRadioTuner::qt_metacall\n          (PythonQtWrapper_QRadioTuner *this,Call param_1,int param_2,void **param_3)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall((Call)this,param_1,(void **)param_2);\n  if (-1 < iVar1) {\n    if ((param_1 != 0) && (param_1 != 0xc)) {\n      return iVar1;\n    }\n    if (iVar1 < 0x15) {\n      qt_static_metacall((QObject *)this,param_1,iVar1,param_3);\n    }\n    iVar1 = iVar1 + -0x15;\n  }\n  return iVar1;\n}\n\n Revised code:\nint PythonQtWrapper_QRadioTuner::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 21)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 21;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 21)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 21;\n    }\n    return _id;\n}\n\n## Example:\n\n Input code:\nint __thiscall\nPythonQtWrapper_QImageReader::qt_metacall\n          (PythonQtWrapper_QImageReader *this,Call param_1,int param_2,void **param_3)\n{\n  int iVar1;\n  iVar1 = QObject::qt_metacall((Call)this,param_1,(void **)param_2);\n  if ((param_1 == 0) && (-1 < iVar1)) {\n    if (iVar1 < 0x2e) {\n      qt_static_metacall((QObject *)this,0,iVar1,param_3);\n      iVar1 = iVar1 + -0x2e;\n    }\n    else {\n      iVar1 = iVar1 + -0x2e;\n    }\n  }\n  return iVar1;\n}\n\n Revised code:\nint PythonQtWrapper_QImageReader::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QObject::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 46)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 46;\n    }\n    return _id;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall\nPythonQtWrapper_QTextInlineObject::qt_metacast\n          (PythonQtWrapper_QTextInlineObject *this,char *param_1)\n{\n  int iVar1;\n  if (param_1 == (char *)0x0) {\n    return;\n  }\n  iVar1 = strcmp(param_1,\"PythonQtWrapper_QTextInlineObject\");\n  if (iVar1 == 0) {\n    return;\n  }\n  QObject::qt_metacast((char *)this);\n  return;\n}",
        "output": "```cpp\nvoid *PythonQtWrapper_QTextInlineObject::qt_metacast(const char *_clname)\n{\n    if (!_clname)\n        return nullptr;\n    if (!strcmp(_clname, \"PythonQtWrapper_QTextInlineObject\"))\n        return this;\n    return QObject::qt_metacast(_clname);\n}\n```",
        "source_code": "void *PythonQtWrapper_QTextInlineObject::qt_metacast(const char *_clname)\n{\n    if (!_clname) return 0;\n    if (!strcmp(_clname, qt_meta_stringdata_PythonQtWrapper_QTextInlineObject))\n        return static_cast<void*>(const_cast< PythonQtWrapper_QTextInlineObject*>(this));\n    return QObject::qt_metacast(_clname);\n}",
        "parsed_output": "pp\nvoid *PythonQtWrapper_QTextInlineObject::qt_metacast(const char *_clname)\n{\n    if (!_clname)\n        return nullptr;\n    if (!strcmp(_clname, \"PythonQtWrapper_QTextInlineObject\"))\n        return this;\n    return QObject::qt_metacast(_clname);\n}",
        "baseline_code_stripped": "void __thiscall\nPythonQtWrapper_QTextInlineObject::qt_metacast\n          (PythonQtWrapper_QTextInlineObject *this,char *param_1)\n{\n  int iVar1;\n  if (param_1 == (char *)0x0) {\n    return;\n  }\n  iVar1 = strcmp(param_1,\"PythonQtWrapper_QTextInlineObject\");\n  if (iVar1 == 0) {\n    return;\n  }\n  QObject::qt_metacast((char *)this);\n  return;\n}",
        "similarity_score_unixcoder": 0.9344689249992371,
        "similarity_score_baseline_stripped": 0.8272057771682739
    },
    {
        "func_name": "visit",
        "normed_func_sha256": "ae88971c0f179255c3cfb93064a9d2d4bb4718c308e678b8275656461256d590",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nlong FUN_0043cb98(undefined8 param_1,undefined8 param_2)\n{\n  long lVar1;\n  lVar1 = FUN_00531468(param_1,param_2);\n  if (lVar1 == 0) {\n    FUN_0063c504(param_1);\n  }\n  FUN_0063b453(lVar1);\n  return lVar1;\n}\n\n Revised code:\nFILE *\nfopen_with_cleanup (char *filename, const char *mode)\n{\n  FILE *file = fopen (filename, mode);\n  if (file == NULL)\n    perror_with_name (filename);\n  make_cleanup_fclose (file);\n  return file;\n}\n\n## Example:\n\n Input code:\nvoid FUN_0017b150(undefined8 param_1,undefined8 param_2)\n{\n  long lVar1;\n  lVar1 = FUN_00165fc0();\n  if (lVar1 != 0) {\n    FUN_001b0330(param_2,lVar1);\n    return;\n  }\n  return;\n}\n\n Revised code:\nvoid LwpFooterLayout::ParseShadow(XFFooterStyle* pFooterStyle)\n{\n    XFShadow* pXFShadow = GetXFShadow();\n    if(pXFShadow)\n    {\n        pFooterStyle->SetShadow(pXFShadow);\n    }\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_00245830(undefined8 param_1,undefined8 param_2)\n{\n  longlong lVar1;\n  lVar1 = FUN_00244f50();\n  if (lVar1 != 0) {\n    return param_2;\n  }\n  return 2;\n}\n\n Revised code:\nint\ncheck_quorum_for_brick_start(glusterd_volinfo_t *volinfo,\n                             gf_boolean_t node_quorum)\n{\n    gf_boolean_t volume_quorum = _gf_false;\n    int ret = 0;\n\n    volume_quorum = glusterd_is_volume_in_server_quorum(volinfo);\n    if (volume_quorum) {\n        if (node_quorum)\n            ret = 1;\n    } else {\n        ret = 2;\n    }\n    return ret;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0046c108(undefined8 param_1,undefined8 param_2)\n{\n  longlong lVar1;\n  FUN_0032d060(param_2,param_1);\n  lVar1 = FUN_00460d10(param_1,param_2);\n  if (lVar1 == 0) {\n    FUN_00454ffc(param_1,param_2);\n  }\n  return;\n}",
        "output": "void\nprocess_and_handle_error(DataType1 param1, DataType2 param2)\n{\n    perform_initial_processing(param2, param1);\n    longlong result = perform_secondary_processing(param1, param2);\n    if (result == 0) {\n        handle_error_case(param1, param2);\n    }\n    return;\n}",
        "source_code": "void visit(AstIsUnbounded* nodep) override {\n        iterateChildren(nodep);\n        if (match_NodeUniop_0(nodep)) return;\n        if (match_IsUnbounded_0(nodep)) return;\n    }",
        "parsed_output": "void\nprocess_and_handle_error(DataType1 param1, DataType2 param2)\n{\n    perform_initial_processing(param2, param1);\n    longlong result = perform_secondary_processing(param1, param2);\n    if (result == 0) {\n        handle_error_case(param1, param2);\n    }\n    return;\n}",
        "baseline_code_stripped": "void FUN_0046c108(undefined8 param_1,undefined8 param_2)\n{\n  longlong lVar1;\n  FUN_0032d060(param_2,param_1);\n  lVar1 = FUN_00460d10(param_1,param_2);\n  if (lVar1 == 0) {\n    FUN_00454ffc(param_1,param_2);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.4373079240322113,
        "similarity_score_baseline_stripped": 0.4774513840675354
    },
    {
        "func_name": "==",
        "normed_func_sha256": "c750e63b0f21814df967a9bf10ce086aa010dac239cf3c1392cefdf2b2e407f9",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nulong FUN_0011c030(long *param_1,long *param_2)\n{\n  byte bVar1;\n  byte bVar2;\n  long lVar3;\n  long lVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  undefined8 uVar8;\n  lVar3 = *param_1;\n  lVar4 = *param_2;\n  if (lVar3 == lVar4) {\n    return 1;\n  }\n  bVar1 = *(byte *)(lVar3 + 1);\n  uVar7 = (uint)bVar1;\n  if (bVar1 == 0xff) {\n    uVar7 = FUN_0011bca0();\n    bVar2 = *(byte *)(lVar4 + 1);\n  }\n  else {\n    bVar2 = *(byte *)(lVar4 + 1);\n  }\n  if (bVar2 == 0xff) {\n    uVar5 = FUN_0011bca0(param_2);\n  }\n  else {\n    uVar5 = (uint)bVar2;\n  }\n  if (uVar7 != uVar5) {\n    return 0;\n  }\n  uVar8 = 0;\n  uVar7 = (uint)bVar1;\n  if (bVar1 == 0xff) {\n    uVar7 = FUN_0011bca0(param_1);\n  }\n  iVar6 = memcmp((void *)(lVar3 + 2),(void *)(lVar4 + 2),(long)(int)uVar7);\n  return CONCAT71((int7)((ulong)uVar8 >> 8),iVar6 == 0) & 0xffffffff;\n}\n\n Revised code:\nbool operator == (const c4_String &a, const c4_String &b)\n{\n    return a._value == b._value || (a.GetLength() == b.GetLength() && memcmp\n                                    (a.Data(), b.Data(), a.GetLength()) == 0);\n}\n\n## Example:\n\n Input code:\nbyte FUN_027977d0(long param_1,undefined8 param_2,long *param_3)\n{\n  uint uVar1;\n  byte bVar2;\n  uint uVar3;\n  long lVar4;\n  long lVar5;\n  int iVar6;\n  lVar4 = FUN_027a0220(param_1 + 0x70);\n  lVar5 = *(long *)(param_1 + 0x70);\n  if (lVar5 != 0) {\n    lVar5 = lVar5 + (ulong)*(uint *)(lVar5 + -4) * 0x28;\n  }\n  bVar2 = 0;\n  if ((lVar4 != lVar5) && (lVar4 = *(long *)(lVar4 + 0x20), lVar4 != 0)) {\n    uVar1 = *(uint *)(lVar4 + -8);\n    uVar3 = *(uint *)(*param_3 + 0x10) >> 8;\n    if (uVar3 == 0) {\n      uVar3 = FUN_0197de70();\n    }\n    iVar6 = 0;\n    lVar5 = *(long *)(lVar4 + (ulong)(uVar1 & uVar3) * 0x10);\n    while( true ) {\n      if (lVar5 == 0) {\n        return 0;\n      }\n      if ((lVar5 != -1) && (bVar2 = FUN_01976d04(lVar5,*param_3), (bVar2 & 1) != 0)) break;\n      iVar6 = iVar6 + 1;\n      uVar3 = (uVar1 & uVar3) + iVar6;\n      lVar5 = *(long *)(lVar4 + (ulong)(uVar1 & uVar3) * 0x10);\n    }\n  }\n  return bVar2;\n}\n\n Revised code:\nbool DatabaseTracker::creatingDatabase(const SecurityOriginData& origin, const String& name)\n{\n    ASSERT(m_databaseGuard.isHeld());\n\n    auto iterator = m_beingCreated.find(origin);\n    return iterator != m_beingCreated.end() && iterator->value.contains(name);\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_00556780(long *param_1,int param_2)\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long lVar4;\n  bool bVar5;\n  lVar4 = param_1[1];\n  if (lVar4 != *param_1) {\n    while( true ) {\n      lVar2 = *(long *)(lVar4 + -8);\n      iVar1 = *(int *)(lVar2 + 0xc);\n      if (iVar1 < param_2) break;\n      bVar5 = *(int *)(lVar2 + 8) == param_2;\n      uVar3 = CONCAT71((int7)((ulong)lVar2 >> 8),bVar5 || param_2 == iVar1);\n      if (bVar5 || param_2 == iVar1) {\n        return uVar3;\n      }\n      lVar4 = lVar4 + -8;\n      if (lVar4 == *param_1) {\n        return uVar3;\n      }\n    }\n  }\n  return 0;\n}\n\n Revised code:\nbool TextCharAttribList::HasBoundingAttrib( sal_Int32 nBound )\n{\n    for (std::vector<std::unique_ptr<TextCharAttrib> >::reverse_iterator it = maAttribs.rbegin(); it != maAttribs.rend(); ++it)\n    {\n        if ( (*it)->GetEnd() < nBound )\n            return false;\n\n        if ( ( (*it)->GetStart() == nBound ) || ( (*it)->GetEnd() == nBound ) )\n            return true;\n    }\n    return false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_0011c4e0(long *param_1,long *param_2)\n{\n  byte bVar1;\n  long lVar2;\n  long lVar3;\n  int iVar4;\n  undefined8 uVar5;\n  undefined4 extraout_var;\n  size_t sVar6;\n  uint uVar7;\n  uint uVar8;\n  uVar5 = 1;\n  lVar2 = *param_1;\n  lVar3 = *param_2;\n  if (lVar2 != lVar3) {\n    uVar8 = (uint)*(byte *)(lVar2 + 1);\n    if (*(byte *)(lVar2 + 1) == 0xff) {\n      sVar6 = strlen((char *)(lVar2 + 0x101));\n      bVar1 = *(byte *)(lVar3 + 1);\n      uVar8 = (int)sVar6 + 0xff;\n    }\n    else {\n      bVar1 = *(byte *)(lVar3 + 1);\n    }\n    if (bVar1 == 0xff) {\n      sVar6 = strlen((char *)(lVar3 + 0x101));\n      uVar7 = (int)sVar6 + 0xff;\n    }\n    else {\n      uVar7 = (uint)bVar1;\n    }\n    uVar5 = 0;\n    if (uVar7 == uVar8) {\n      iVar4 = memcmp((void *)(lVar2 + 2),(void *)(lVar3 + 2),(long)(int)uVar7);\n      return CONCAT71((int7)(CONCAT44(extraout_var,iVar4) >> 8),iVar4 == 0);\n    }\n  }\n  return uVar5;\n}",
        "output": "bool operator==(const c4_String& a, const c4_String& b)\n{\n    if (a._value == b._value)\n        return true;\n\n    uint lengthA = (a._value[1] == 0xFF) ? strlen(a._value + 0x101) + 0xFF : static_cast<uint>(a._value[1]);\n    uint lengthB = (b._value[1] == 0xFF) ? strlen(b._value + 0x101) + 0xFF : static_cast<uint>(b._value[1]);\n\n    return lengthA == lengthB && memcmp(a.Data(), b.Data(), lengthA) == 0;\n}",
        "source_code": "bool operator == (const c4_String &a, const c4_String &b) {\n  return a._value == b._value || a.GetLength() == b.GetLength() && memcmp\n    (a.Data(), b.Data(), a.GetLength()) == 0;\n}",
        "parsed_output": "bool operator==(const c4_String& a, const c4_String& b)\n{\n    if (a._value == b._value)\n        return true;\n\n    uint lengthA = (a._value[1] == 0xFF) ? strlen(a._value + 0x101) + 0xFF : static_cast<uint>(a._value[1]);\n    uint lengthB = (b._value[1] == 0xFF) ? strlen(b._value + 0x101) + 0xFF : static_cast<uint>(b._value[1]);\n\n    return lengthA == lengthB && memcmp(a.Data(), b.Data(), lengthA) == 0;\n}",
        "baseline_code_stripped": "undefined8 FUN_0011c4e0(long *param_1,long *param_2)\n{\n  byte bVar1;\n  long lVar2;\n  long lVar3;\n  int iVar4;\n  undefined8 uVar5;\n  undefined4 extraout_var;\n  size_t sVar6;\n  uint uVar7;\n  uint uVar8;\n  uVar5 = 1;\n  lVar2 = *param_1;\n  lVar3 = *param_2;\n  if (lVar2 != lVar3) {\n    uVar8 = (uint)*(byte *)(lVar2 + 1);\n    if (*(byte *)(lVar2 + 1) == 0xff) {\n      sVar6 = strlen((char *)(lVar2 + 0x101));\n      bVar1 = *(byte *)(lVar3 + 1);\n      uVar8 = (int)sVar6 + 0xff;\n    }\n    else {\n      bVar1 = *(byte *)(lVar3 + 1);\n    }\n    if (bVar1 == 0xff) {\n      sVar6 = strlen((char *)(lVar3 + 0x101));\n      uVar7 = (int)sVar6 + 0xff;\n    }\n    else {\n      uVar7 = (uint)bVar1;\n    }\n    uVar5 = 0;\n    if (uVar7 == uVar8) {\n      iVar4 = memcmp((void *)(lVar2 + 2),(void *)(lVar3 + 2),(long)(int)uVar7);\n      return CONCAT71((int7)(CONCAT44(extraout_var,iVar4) >> 8),iVar4 == 0);\n    }\n  }\n  return uVar5;\n}",
        "similarity_score_unixcoder": 0.8969901204109192,
        "similarity_score_baseline_stripped": 0.5299978852272034
    },
    {
        "func_name": "gen_vec_unpacks_hi_v8qi",
        "normed_func_sha256": "aae7a297ccb133c32b068d5715c4c0574804a336d54ae23be9812b4b81fb8e43",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid gen_aarch64_sqshrun_nv4si(rtx_def *param_1,rtx_def *param_2,rtx_def *param_3)\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  uVar1 = gen_rtvec(2);\n  iVar2 = rtx_alloc(0x14);\n  *(undefined *)(iVar2 + 2) = 0x41;\n  *(undefined4 *)(iVar2 + 8) = uVar1;\n  *(undefined4 *)(iVar2 + 0xc) = 0xcd;\n  iVar3 = rtx_alloc(0x19);\n  *(rtx_def **)(iVar3 + 8) = param_1;\n  *(undefined *)(iVar3 + 2) = 0;\n  *(int *)(iVar3 + 0xc) = iVar2;\n  return;\n}\n\n Revised code:\nrtx\ngen_vec_unpacks_hi_v4si (rtx operand0,\n\trtx operand1)\n{\n  rtx_insn *_val = 0;\n  start_sequence ();\n  {\n    rtx operands[2];\n    operands[0] = operand0;\n    operands[1] = operand1;\n#define FAIL return (end_sequence (), _val)\n#define DONE return (_val = get_insns (), end_sequence (), _val)\n#line 282 \"../../gcc-11.2.1-20210728/gcc/config/mips/mips-msa.md\"\n{\n  mips_expand_vec_unpack (operands, false/*unsigned_p*/, true/*high_p*/);\n  DONE;\n}\n#undef DONE\n#undef FAIL\n    operand0 = operands[0];\n    (void) operand0;\n    operand1 = operands[1];\n    (void) operand1;\n  }\n  emit (operand0, true);\n  emit (operand1, false);\n  _val = get_insns ();\n  end_sequence ();\n  return _val;\n}\n\n## Example:\n\n Input code:\nvoid gen_neon_vsublsv8qi(rtx_def *param_1,rtx_def *param_2,rtx_def *param_3)\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  uVar1 = gen_rtvec(2);\n  iVar2 = rtx_alloc(0x14);\n  *(undefined *)(iVar2 + 2) = 0x4f;\n  *(undefined4 *)(iVar2 + 8) = uVar1;\n  *(undefined4 *)(iVar2 + 0xc) = 0x149;\n  iVar3 = rtx_alloc(0x19);\n  *(rtx_def **)(iVar3 + 8) = param_1;\n  *(undefined *)(iVar3 + 2) = 0;\n  *(int *)(iVar3 + 0xc) = iVar2;\n  return;\n}\n\n Revised code:\nrtx\ngen_atomic_fetch_orhi (rtx operand0,\n\trtx operand1,\n\trtx operand2,\n\trtx operand3)\n{\n  rtx_insn *_val = 0;\n  start_sequence ();\n  {\n    rtx operands[4];\n    operands[0] = operand0;\n    operands[1] = operand1;\n    operands[2] = operand2;\n    operands[3] = operand3;\n#define FAIL return (end_sequence (), _val)\n#define DONE return (_val = get_insns (), end_sequence (), _val)\n#line 267 \"../../gcc-11.2.1-20210728/gcc/config/ia64/sync.md\"\n{\n  ia64_expand_atomic_op (IOR, operands[1], operands[2], operands[0], NULL,\n\t\t\t (enum memmodel) INTVAL (operands[3]));\n  DONE;\n}\n#undef DONE\n#undef FAIL\n    operand0 = operands[0];\n    (void) operand0;\n    operand1 = operands[1];\n    (void) operand1;\n    operand2 = operands[2];\n    (void) operand2;\n    operand3 = operands[3];\n    (void) operand3;\n  }\n  emit_insn (gen_rtx_SET (operand0,\n\tgen_rtx_IOR (HImode,\n\toperand1,\n\toperand2)));\n  emit_insn (gen_rtx_USE (VOIDmode,\n\toperand3));\n  _val = get_insns ();\n  end_sequence ();\n  return _val;\n}\n\n## Example:\n\n Input code:\nvoid gen_aarch64_uqrshrn_nsi(rtx_def *param_1,rtx_def *param_2,rtx_def *param_3)\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  uVar1 = gen_rtvec(2);\n  iVar2 = rtx_alloc(0x14);\n  *(undefined *)(iVar2 + 2) = 0xe;\n  *(undefined4 *)(iVar2 + 8) = uVar1;\n  *(undefined4 *)(iVar2 + 0xc) = 0xd2;\n  iVar3 = rtx_alloc(0x19);\n  *(rtx_def **)(iVar3 + 8) = param_1;\n  *(undefined *)(iVar3 + 2) = 0;\n  *(int *)(iVar3 + 0xc) = iVar2;\n  return;\n}\n\n Revised code:\nrtx\ngen_cbranchuta4 (rtx operand0,\n\trtx operand1,\n\trtx operand2,\n\trtx operand3)\n{\n  rtx_insn *_val = 0;\n  start_sequence ();\n  {\n    rtx operands[4];\n    operands[0] = operand0;\n    operands[1] = operand1;\n    operands[2] = operand2;\n    operands[3] = operand3;\n#define FAIL return (end_sequence (), _val)\n#define DONE return (_val = get_insns (), end_sequence (), _val)\n#line 342 \"../../gcc-11.2.1-20210728/gcc/config/avr/avr-dimode.md\"\n{\n    rtx acc_a = gen_rtx_REG (UTAmode, ACC_A);\n\n    avr_fix_inputs (operands, 1 << 2, regmask (UTAmode, ACC_A));\n    emit_move_insn (acc_a, operands[1]);\n\n    if (s8_operand (operands[2], VOIDmode))\n      {\n        emit_move_insn (gen_rtx_REG (QImode, REG_X), operands[2]);\n        emit_insn (gen_compare_const8_di2 ());\n      }\n    else if (const_operand (operands[2], GET_MODE (operands[2])))\n      {\n        emit_insn (gen_compare_const_uta2 (operands[2]));\n      }\n    else\n      {\n        emit_move_insn (gen_rtx_REG (UTAmode, ACC_B), operands[2]);\n        emit_insn (gen_compare_uta2 ());\n      }\n\n    emit_jump_insn (gen_conditional_jump (operands[0], operands[3]));\n    DONE;\n  }\n#undef DONE\n#undef FAIL\n    operand0 = operands[0];\n    (void) operand0;\n    operand1 = operands[1];\n    (void) operand1;\n    operand2 = operands[2];\n    (void) operand2;\n    operand3 = operands[3];\n    (void) operand3;\n  }\n  emit (gen_rtx_PARALLEL (VOIDmode,\n\tgen_rtvec (4,\n\t\toperand1,\n\t\toperand2,\n\t\tgen_rtx_fmt_ee (GET_CODE (operand0), VOIDmode,\n\t\tcc0_rtx,\n\t\tconst0_rtx),\n\t\tgen_rtx_LABEL_REF (VOIDmode,\n\toperand3))), false);\n  _val = get_insns ();\n  end_sequence ();\n  return _val;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid gen_aarch64_addpv2si(rtx_def *param_1,rtx_def *param_2,rtx_def *param_3)\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  uVar1 = gen_rtvec(2);\n  iVar2 = rtx_alloc(0x14);\n  *(undefined *)(iVar2 + 2) = 0x42;\n  *(undefined4 *)(iVar2 + 8) = uVar1;\n  *(undefined4 *)(iVar2 + 0xc) = 0xd6;\n  iVar3 = rtx_alloc(0x19);\n  *(rtx_def **)(iVar3 + 8) = param_1;\n  *(undefined *)(iVar3 + 2) = 0;\n  *(int *)(iVar3 + 0xc) = iVar2;\n  return;\n}",
        "output": "```c\nrtx\ngen_addpv2si (rtx operand0,\n\trtx operand1,\n\trtx operand2)\n{\n  rtx_insn *_val = 0;\n  start_sequence ();\n  {\n    rtx operands[3];\n    operands[0] = operand0;\n    operands[1] = operand1;\n    operands[2] = operand2;\n#define FAIL return (end_sequence (), _val)\n#define DONE return (_val = get_insns (), end_sequence (), _val)\n#line 198 \"../../gcc-11.2.1-20210728/gcc/config/aarch64/aarch64.md\"\n{\n  aarch64_expand_addp (operands);\n  DONE;\n}\n#undef DONE\n#undef FAIL\n    operand0 = operands[0];\n    (void) operand0;\n    operand1 = operands[1];\n    (void) operand1;\n    operand2 = operands[2];\n    (void) operand2;\n  }\n  emit (operand0, true);\n  emit (operand1, false);\n  emit (operand2, false);\n  _val = get_insns ();\n  end_sequence ();\n  return _val;\n}\n```",
        "source_code": "rtx\ngen_vec_unpacks_hi_v8qi (rtx operand0,\n\trtx operand1)\n{\n  rtx_insn *_val = 0;\n  start_sequence ();\n  {\n    rtx operands[2];\n    operands[0] = operand0;\n    operands[1] = operand1;\n#define FAIL return (end_sequence (), _val)\n#define DONE return (_val = get_insns (), end_sequence (), _val)\n#line 799 \"../../gcc-10.2.1-20200826/gcc/config/mips/loongson-mmi.md\"\n{\n  mips_expand_vec_unpack (operands, false, true);\n  DONE;\n}\n#undef DONE\n#undef FAIL\n    operand0 = operands[0];\n    (void) operand0;\n    operand1 = operands[1];\n    (void) operand1;\n  }\n  emit (operand0, true);\n  emit (operand1, false);\n  _val = get_insns ();\n  end_sequence ();\n  return _val;\n}",
        "parsed_output": "rtx\ngen_addpv2si (rtx operand0,\n\trtx operand1,\n\trtx operand2)\n{\n  rtx_insn *_val = 0;\n  start_sequence ();\n  {\n    rtx operands[3];\n    operands[0] = operand0;\n    operands[1] = operand1;\n    operands[2] = operand2;\n#define FAIL return (end_sequence (), _val)\n#define DONE return (_val = get_insns (), end_sequence (), _val)\n#line 198 \"../../gcc-11.2.1-20210728/gcc/config/aarch64/aarch64.md\"\n{\n  aarch64_expand_addp (operands);\n  DONE;\n}\n#undef DONE\n#undef FAIL\n    operand0 = operands[0];\n    (void) operand0;\n    operand1 = operands[1];\n    (void) operand1;\n    operand2 = operands[2];\n    (void) operand2;\n  }\n  emit (operand0, true);\n  emit (operand1, false);\n  emit (operand2, false);\n  _val = get_insns ();\n  end_sequence ();\n  return _val;\n}",
        "baseline_code_stripped": "void gen_aarch64_addpv2si(rtx_def *param_1,rtx_def *param_2,rtx_def *param_3)\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  uVar1 = gen_rtvec(2);\n  iVar2 = rtx_alloc(0x14);\n  *(undefined *)(iVar2 + 2) = 0x42;\n  *(undefined4 *)(iVar2 + 8) = uVar1;\n  *(undefined4 *)(iVar2 + 0xc) = 0xd6;\n  iVar3 = rtx_alloc(0x19);\n  *(rtx_def **)(iVar3 + 8) = param_1;\n  *(undefined *)(iVar3 + 2) = 0;\n  *(int *)(iVar3 + 0xc) = iVar2;\n  return;\n}",
        "similarity_score_unixcoder": 0.9108906388282776,
        "similarity_score_baseline_stripped": 0.6948696374893188
    },
    {
        "func_name": "DeliverPropertyEvent",
        "normed_func_sha256": "77620ddfa3768dbe89e4a1ce0e236b9da0899c6d79acb7632114f778d747d4a8",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_00eb8a81(long param_1)\n{\n  uint local_8;\n  uint local_4;\n  local_8 = **(ushort **)(param_1 + 0xb8) + 1;\n  if (0x100 < local_8) {\n    local_8 = 0x100;\n  }\n  if (*(char *)(param_1 + 0xe6) == '\\0') {\n    for (local_4 = 0; (int)local_4 < (int)local_8; local_4 = local_4 + 1) {\n      *(undefined2 *)((long)(int)local_4 * 2 + DAT_03f3bf60) =\n           *(undefined2 *)(param_1 + 8 + ((long)(int)local_4 + 0x70) * 2);\n    }\n  }\n  else {\n    for (local_4 = 0; (int)local_4 < (int)local_8; local_4 = local_4 + 1) {\n      if ((local_4 & 1) == 0) {\n        *(uint *)((long)((int)local_4 / 2) * 4 + DAT_03f3bf68) =\n             *(uint *)((long)((int)local_4 / 2) * 4 + DAT_03f3bf68) & 0xffff |\n             (uint)*(ushort *)(param_1 + 8 + ((long)(int)local_4 + 0x70) * 2) << 0x10;\n      }\n      else {\n        *(uint *)((long)((int)local_4 / 2) * 4 + DAT_03f3bf68) =\n             (uint)*(ushort *)(param_1 + 8 + ((long)(int)local_4 + 0x70) * 2) |\n             *(uint *)((long)((int)local_4 / 2) * 4 + DAT_03f3bf68) & 0xffff0000;\n      }\n    }\n  }\n  return;\n}\n\n Revised code:\nstatic void compute_checksum(struct atarirle_data *mo)\r\n{\r\n\tint reqsums = mo->spriteram[0].data[0] + 1;\r\n\tint i;\r\n\r\n\t//bprintf(0, _T(\"atarirle: compute_checksum(%d)\\n\"), reqsums);\r\n\r\n\t/* number of checksums is in the first word */\r\n\tif (reqsums > 256)\r\n\t\treqsums = 256;\r\n\r\n\t/* stuff them back */\r\n\tif (!mo->is32bit)\r\n\t{\r\n\t\tfor (i = 0; i < reqsums; i++)\r\n\t\t\tatarirle_0_spriteram[i] = BURN_ENDIAN_SWAP_INT16(mo->checksums[i]);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor (i = 0; i < reqsums; i++)\r\n\t\t\tif (i & 1)\r\n\t\t\t\tatarirle_0_spriteram32[i/2] = (atarirle_0_spriteram32[i/2] & 0xffff0000) | mo->checksums[i];\r\n\t\t\telse\r\n\t\t\t\tatarirle_0_spriteram32[i/2] = (atarirle_0_spriteram32[i/2] & 0x0000ffff) | (mo->checksums[i] << 16);\r\n\t}\r\n}\n\n## Example:\n\n Input code:\nvoid FUN_002acb58(undefined8 param_1,long param_2,undefined8 param_3)\n{\n  long local_10;\n  if (*(long *)(param_2 + 8) == 0) {\n    *(undefined8 *)(param_2 + 8) = param_3;\n  }\n  else {\n    for (local_10 = *(long *)(param_2 + 8); *(long *)(local_10 + 0x10) != 0;\n        local_10 = *(long *)(local_10 + 0x10)) {\n    }\n    *(undefined8 *)(local_10 + 0x10) = param_3;\n  }\n  return;\n}\n\n Revised code:\nvoid DinoXmlParser::appendAttributeObject(\n\t\tXmlTagObject *tagObject,\n\t\tXmlAttributeObject *attributeObject)\n\t{\n\n\t\t// No attribute exists yet\n\t\tif (tagObject->m_pFirstAttribute == 0) {\n\t\t\ttagObject->m_pFirstAttribute = attributeObject;\n\t\t}\n\t\t// At least one attribute exists\n\t\telse{\n\n\t\t\tXmlAttributeObject *currentAttribute = tagObject->m_pFirstAttribute;\n\n\t\t\t// Find the last attribute\n\t\t\twhile (currentAttribute->m_pNextAttribute != 0){\n\t\t\t\tcurrentAttribute = currentAttribute->m_pNextAttribute;\n\t\t\t}\n\n\t\t\t// Append given attribute\n\t\t\tcurrentAttribute->m_pNextAttribute = attributeObject;\n\n\t\t}\n\n\t}\n\n## Example:\n\n Input code:\nvoid FUN_0020bb00(byte *param_1,undefined4 param_2)\n{\n  long lVar1;\n  undefined4 local_c;\n  if (((byte *)0x1fff < param_1 + 0x1000) && (((ulong)param_1 & 0xffff800000000000) == 0)) {\n    *(undefined4 *)\n     (*(long *)(param_1 + 0x20) + 0x380 +\n     (ulong)(uint)(&DAT_004bc3c8)\n                  [(long)(int)(((uint)*param_1 + (uint)*param_1 * 4) * 2 + 0x24) * 0x10] * 4) =\n         param_2;\n    lVar1 = *(long *)(param_1 + 0x20);\n    if (*(char *)(lVar1 + 0x173c) != '\\0') {\n      local_c = param_2;\n      (**(code **)(*(long *)(*(long *)(lVar1 + 0x298) + 0x30) + 0x198))\n                (*(long *)(lVar1 + 0x298),0,\n                 *(long *)(lVar1 + 0x1718) + (long)(int)((uint)*param_1 * 2) * 4,&local_c,4);\n    }\n  }\n  return;\n}\n\n Revised code:\nvoid hdaR3StreamSetPosition(PHDASTREAM pStream, uint32_t u32LPIB)\n{\n    AssertPtrReturnVoid(pStream);\n\n    Log3Func((\"[SD%RU8] LPIB=%RU32 (DMA Position Buffer Enabled: %RTbool)\\n\",\n              pStream->u8SD, u32LPIB, pStream->pHDAState->fDMAPosition));\n\n    /* Update LPIB in any case. */\n    HDA_STREAM_REG(pStream->pHDAState, LPIB, pStream->u8SD) = u32LPIB;\n\n    /* Do we need to tell the current DMA position? */\n    if (pStream->pHDAState->fDMAPosition)\n    {\n        int rc2 = PDMDevHlpPCIPhysWrite(pStream->pHDAState->CTX_SUFF(pDevIns),\n                                        pStream->pHDAState->u64DPBase + (pStream->u8SD * 2 * sizeof(uint32_t)),\n                                        (void *)&u32LPIB, sizeof(uint32_t));\n        AssertRC(rc2);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 DeliverPropertyEvent(long param_1,long param_2)\n{\n  long **local_20 [2];\n  dixLookupResourceByType(local_20,*(undefined4 *)(param_1 + 4),RREventType,serverClient,1);\n  if (local_20[0] != (long **)0x0) {\n    for (local_20[0] = (long **)*local_20[0]; local_20[0] != (long **)0x0;\n        local_20[0] = (long **)*local_20[0]) {\n      while ((*(byte *)((long)local_20[0] + 0x1c) & 8) == 0) {\n        local_20[0] = (long **)*local_20[0];\n        if (local_20[0] == (long **)0x0) {\n          return 1;\n        }\n      }\n      *(undefined4 *)(param_2 + 4) = *(undefined4 *)((long)local_20[0][2] + 4);\n      WriteEventsToClient(local_20[0][1],1,param_2);\n    }\n  }\n  return 1;\n}",
        "output": "```c\nuint64_t DeliverPropertyEvent(long eventId, long eventData)\n{\n    long **resourceList[2];\n\n    // Look up the resource by type\n    dixLookupResourceByType(resourceList, *(uint32_t *)(eventId + 4), RREventType, serverClient, 1);\n\n    if (resourceList[0] != NULL)\n    {\n        // Iterate through the resource list\n        for (resourceList[0] = (long **)*resourceList[0]; resourceList[0] != NULL; resourceList[0] = (long **)*resourceList[0])\n        {\n            // Skip resources that do not have the required flag\n            while ((*(uint8_t *)((long)resourceList[0] + 0x1c) & 8) == 0)\n            {\n                resourceList[0] = (long **)*resourceList[0];\n                if (resourceList[0] == NULL)\n                {\n                    return 1;\n                }\n            }\n\n            // Set event data and write events to the client\n            *(uint32_t *)(eventData + 4) = *(uint32_t *)((long)resourceList[0][2] + 4);\n            WriteEventsToClient(resourceList[0][1], 1, eventData);\n        }\n    }\n\n    return 1;\n}\n```",
        "source_code": "static int\nDeliverPropertyEvent(WindowPtr pWin, void *value)\n{\n    xRROutputPropertyNotifyEvent *event = value;\n    RREventPtr *pHead, pRREvent;\n    dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,\n\t\t\t    RREventType, serverClient, DixReadAccess);\n    if (!pHead)\n\treturn WT_WALKCHILDREN;\n    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next)\n    {\n\tif (!(pRREvent->mask & RROutputPropertyNotifyMask))\n\t    continue;\n\tevent->window = pRREvent->window->drawable.id;\n\tWriteEventsToClient(pRREvent->client, 1, (xEvent *)event);\n    }\n    return WT_WALKCHILDREN;\n}",
        "parsed_output": "uint64_t DeliverPropertyEvent(long eventId, long eventData)\n{\n    long **resourceList[2];\n\n    // Look up the resource by type\n    dixLookupResourceByType(resourceList, *(uint32_t *)(eventId + 4), RREventType, serverClient, 1);\n\n    if (resourceList[0] != NULL)\n    {\n        // Iterate through the resource list\n        for (resourceList[0] = (long **)*resourceList[0]; resourceList[0] != NULL; resourceList[0] = (long **)*resourceList[0])\n        {\n            // Skip resources that do not have the required flag\n            while ((*(uint8_t *)((long)resourceList[0] + 0x1c) & 8) == 0)\n            {\n                resourceList[0] = (long **)*resourceList[0];\n                if (resourceList[0] == NULL)\n                {\n                    return 1;\n                }\n            }\n\n            // Set event data and write events to the client\n            *(uint32_t *)(eventData + 4) = *(uint32_t *)((long)resourceList[0][2] + 4);\n            WriteEventsToClient(resourceList[0][1], 1, eventData);\n        }\n    }\n\n    return 1;\n}",
        "baseline_code_stripped": "undefined8 DeliverPropertyEvent(long param_1,long param_2)\n{\n  long **local_20 [2];\n  dixLookupResourceByType(local_20,*(undefined4 *)(param_1 + 4),RREventType,serverClient,1);\n  if (local_20[0] != (long **)0x0) {\n    for (local_20[0] = (long **)*local_20[0]; local_20[0] != (long **)0x0;\n        local_20[0] = (long **)*local_20[0]) {\n      while ((*(byte *)((long)local_20[0] + 0x1c) & 8) == 0) {\n        local_20[0] = (long **)*local_20[0];\n        if (local_20[0] == (long **)0x0) {\n          return 1;\n        }\n      }\n      *(undefined4 *)(param_2 + 4) = *(undefined4 *)((long)local_20[0][2] + 4);\n      WriteEventsToClient(local_20[0][1],1,param_2);\n    }\n  }\n  return 1;\n}",
        "similarity_score_unixcoder": 0.7445331811904907,
        "similarity_score_baseline_stripped": 0.6649596691131592
    },
    {
        "func_name": "zfs_path_order",
        "normed_func_sha256": "8ecc29eef5c51f652c6c1d1a65848dc597bfee0aac2cc16b6e9e41f47f5b3017",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nlong __imlib_FindBestLoaderForFile(undefined8 param_1,int param_2)\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  int iVar4;\n  void *__ptr;\n  char *__s2;\n  __int32_t **pp_Var5;\n  char *pcVar6;\n  char cVar7;\n  int iVar8;\n  char **ppcVar9;\n  __ptr = (void *)FUN_0011c050();\n  __s2 = (char *)FUN_0011c480(__ptr);\n  free(__ptr);\n  cVar7 = *__s2;\n  lVar3 = DAT_00261de8;\n  if (cVar7 != '\\0') {\n    pp_Var5 = __ctype_tolower_loc();\n    pcVar6 = __s2;\n    do {\n      *pcVar6 = (char)(*pp_Var5)[cVar7];\n      pcVar6 = pcVar6 + 1;\n      cVar7 = *pcVar6;\n      lVar3 = DAT_00261de8;\n    } while (cVar7 != '\\0');\n  }\n  do {\n    if (lVar3 == 0) {\n      free(__s2);\n      return 0;\n    }\n    iVar1 = *(int *)(lVar3 + 8);\n    if (0 < iVar1) {\n      ppcVar9 = *(char ***)(lVar3 + 0x10);\n      iVar8 = 0;\n      do {\n        iVar4 = strcmp(*ppcVar9,__s2);\n        if (iVar4 == 0) {\n          if (param_2 == 0) {\n            lVar2 = *(long *)(lVar3 + 0x20);\n          }\n          else {\n            lVar2 = *(long *)(lVar3 + 0x28);\n          }\n          if (lVar2 != 0) {\n            free(__s2);\n            return lVar3;\n          }\n        }\n        iVar8 = iVar8 + 1;\n        ppcVar9 = ppcVar9 + 1;\n      } while (iVar8 != iVar1);\n    }\n    lVar3 = *(long *)(lVar3 + 0x30);\n  } while( true );\n}\n\n Revised code:\nImlibLoader        *\n__imlib_FindBestLoaderForFile(const char *file, int for_save)\n{\n   char               *extension, *lower, *rfile;\n   ImlibLoader        *l = NULL;\n\n   /* use the file extension for a \"best guess\" as to what loader to try */\n   /* first at any rate */\n\n   rfile = __imlib_FileRealFile(file);\n   extension = __imlib_FileExtension(rfile);\n   free(rfile);\n   /* change the extensiont o all lower case as all \"types\" are listed as */\n   /* lower case strings from the loader that represent all the possible */\n   /* extensions that file format could have */\n   lower = extension;\n   while (*lower)\n     {\n        *lower = tolower(*lower);\n        lower++;\n     }\n   if (!extension)\n      return NULL;\n   /* go through the loaders - first loader that claims to handle that */\n   /* image type (extension wise) wins as a first guess to use - NOTE */\n   /* this is an OPTIMISATION - it is possible the file has no extension */\n   /* or has an unrecognised one but still is loadable by a loader. */\n   /* if thkis initial loader failes to load the load mechanism will */\n   /* systematically go from most recently used to least recently used */\n   /* loader until one succeeds - or none are left and all have failed */\n   /* and only if all fail does the laod fail. the lao9der that does */\n   /* succeed gets it way to the head of the list so it's going */\n   /* to be used first next time in this search mechanims - this */\n   /* assumes you tend to laod a few image types and ones generally */\n   /* of the same format */\n   l = loaders;\n   while (l)\n     {\n        int                 i;\n\n        /* go through all the formats that loader supports */\n        for (i = 0; i < l->num_formats; i++)\n          {\n             /* does it match ? */\n             if (!strcmp(l->formats[i], extension))\n               {\n                  /* does it provide the function we need? */\n                  if ((for_save && l->save) || (!for_save && l->load))\n                    {\n                       /* free the memory allocated for the extension */\n                       free(extension);\n                       /* return the loader */\n                       return l;\n                    }\n               }\n          }\n        l = l->next;\n     }\n   /* free the memory allocated for the extension */\n   free(extension);\n   /* return the loader */\n   return l;\n}\n\n## Example:\n\n Input code:\nundefined4 ug_create_dir_all(char *param_1,int param_2)\n{\n  char *pcVar1;\n  int iVar2;\n  char *__dest;\n  char *pcVar3;\n  size_t sVar4;\n  if (param_2 == -1) {\n    sVar4 = strlen(param_1);\n    param_2 = (int)sVar4;\n  }\n  pcVar1 = param_1 + param_2;\n  pcVar3 = param_1;\n  do {\n    if (pcVar1 <= pcVar3) goto LAB_0013f548;\n    while (*pcVar3 != '/') {\n      do {\n        pcVar3 = pcVar3 + 1;\n        if (pcVar1 == pcVar3) break;\n      } while (*pcVar3 != '/');\n      while( true ) {\n        sVar4 = (long)pcVar3 - (long)param_1;\n        __dest = (char *)g_malloc(sVar4 + 1);\n        __dest[sVar4] = '\\0';\n        strncpy(__dest,param_1,sVar4);\n        iVar2 = ug_create_dir(__dest);\n        if ((iVar2 == -1) && (iVar2 = ug_file_is_exist(__dest), iVar2 == 0)) {\n          g_free(__dest);\n          return 0xffffffff;\n        }\n        g_free(__dest);\n        if (pcVar3 < pcVar1) break;\nLAB_0013f548:\n        if (pcVar3 == pcVar1) {\n          return 0;\n        }\n      }\n    }\n    pcVar3 = pcVar3 + 1;\n  } while( true );\n}\n\n Revised code:\nint  ug_create_dir_all (const char* dir, int len)\n{\n\tconst char*   dir_end;\n\tconst char*   element_end;\t// path element\n\tchar*         element_os;\n\n\tif (len == -1)\n\t\tlen = strlen (dir);\n\tdir_end = dir + len;\n\telement_end = dir;\n\n\tfor (;;) {\n\t\t// skip directory separator \"\\\\\\\\\" or \"//\"\n\t\tfor (;  element_end < dir_end;  element_end++) {\n\t\t\tif (*element_end != UG_DIR_SEPARATOR)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (element_end == dir_end)\n\t\t\treturn 0;\n\t\t// get directory name [dir, element_end)\n\t\tfor (;  element_end < dir_end;  element_end++) {\n\t\t\tif (*element_end == UG_DIR_SEPARATOR)\n\t\t\t\tbreak;\n\t\t}\n\t\telement_os = (char*) ug_malloc (element_end - dir + 1);\n\t\telement_os[element_end - dir] = 0;\n\t\tstrncpy (element_os, dir, element_end - dir);\n\n\t\tif (element_os == NULL)\n\t\t\tbreak;\n\t\tif (ug_create_dir (element_os) == -1) {\n\t\t\tif (ug_file_is_exist (element_os) == FALSE) {\n\t\t\t\tug_free (element_os);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tug_free (element_os);\n\t}\n\treturn -1;\n}\n\n## Example:\n\n Input code:\nchar * FUN_000189d0(char *param_1,char **param_2,int param_3)\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s2;\n  char **ppcVar3;\n  ppcVar3 = _DAT_00041694;\n  if (param_3 != 0) {\n    ppcVar3 = _DAT_00041690;\n  }\n  iVar1 = strcmp(param_1,\"default\");\n  if (iVar1 == 0) {\n    return *param_2;\n  }\n  pcVar2 = (char *)0x0;\n  if (ppcVar3 != (char **)0x0) {\n    pcVar2 = (char *)0x0;\n    do {\n      __s2 = *ppcVar3;\n      iVar1 = strcmp(param_1,__s2);\n      if (iVar1 == 0) {\n        pcVar2 = __s2;\n      }\n      ppcVar3 = (char **)ppcVar3[1];\n    } while ((ppcVar3 != (char **)0x0) && (iVar1 != 0));\n  }\n  return pcVar2;\n}\n\n Revised code:\nstatic encodinginfo \nfindEncoding(char *encpath, encodinglist deviceEncodings, Rboolean isPDF)\n{\n    encodinglist enclist = isPDF ? PDFloadedEncodings : loadedEncodings;\n    encodinginfo encoding = NULL;\n    int found = 0;\n    /*\n     * \"default\" is a special encoding which means use the\n     * default (FIRST) encoding set up ON THIS DEVICE.\n     */\n    if (!strcmp(encpath, \"default\")) {\n\tfound = 1;\n\tencoding = deviceEncodings->encoding;\n    } else {\n\twhile (enclist && !found) {\n\t    found = !strcmp(encpath, enclist->encoding->encpath);\n\t    if (found)\n\t\tencoding = enclist->encoding;\n\t    enclist = enclist->next;\n\t}\n    }\n    return encoding;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint zfs_path_order(char *param_1,int *param_2)\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s;\n  size_t sVar3;\n  long lVar4;\n  int iVar5;\n  pcVar2 = getenv(\"ZPOOL_IMPORT_PATH\");\n  if (pcVar2 == (char *)0x0) {\n    lVar4 = 0;\n    do {\n      pcVar2 = (&zpool_default_import_path)[lVar4];\n      sVar3 = strlen(pcVar2);\n      iVar5 = strncmp(param_1,pcVar2,sVar3);\n      if (iVar5 == 0) {\n        *param_2 = (int)lVar4;\n        return iVar5;\n      }\n      lVar4 = lVar4 + 1;\n    } while (lVar4 != 9);\n    return 2;\n  }\n  pcVar2 = strdup(pcVar2);\n  __s = strtok(pcVar2,\":\");\n  if (__s != (char *)0x0) {\n    iVar5 = 0;\n    do {\n      sVar3 = strlen(__s);\n      iVar1 = strncmp(param_1,__s,sVar3);\n      if (iVar1 == 0) {\n        *param_2 = iVar5;\n        iVar5 = 0;\n        goto LAB_00134212;\n      }\n      iVar5 = iVar5 + 1;\n      __s = strtok((char *)0x0,\":\");\n    } while (__s != (char *)0x0);\n  }\n  iVar5 = 2;\nLAB_00134212:\n  free(pcVar2);\n  return iVar5;\n}",
        "output": "```c\nint zfs_path_order(const char *path, int *order)\n{\n    const char *env_path = getenv(\"ZPOOL_IMPORT_PATH\");\n    char *tokenized_path = NULL;\n    char *current_token = NULL;\n    size_t token_length;\n    int index = 0;\n\n    // If the environment variable is not set, use the default import paths\n    if (env_path == NULL) {\n        for (index = 0; index < 9; index++) {\n            const char *default_path = zpool_default_import_path[index];\n            size_t default_path_length = strlen(default_path);\n\n            if (strncmp(path, default_path, default_path_length) == 0) {\n                *order = index;\n                return 0; // Match found\n            }\n        }\n        return 2; // No match found\n    }\n\n    // Duplicate the environment variable string for tokenization\n    tokenized_path = strdup(env_path);\n    if (tokenized_path == NULL) {\n        return 2; // Memory allocation failure\n    }\n\n    // Tokenize the environment variable using \":\" as the delimiter\n    current_token = strtok(tokenized_path, \":\");\n    while (current_token != NULL) {\n        token_length = strlen(current_token);\n\n        if (strncmp(path, current_token, token_length) == 0) {\n            *order = index;\n            free(tokenized_path);\n            return 0; // Match found\n        }\n\n        index++;\n        current_token = strtok(NULL, \":\");\n    }\n\n    free(tokenized_path);\n    return 2; // No match found\n}\n```",
        "source_code": "int\nzfs_path_order(char *name, int *order)\n{\n\tint i = 0, error = ENOENT;\n\tchar *dir, *env, *envdup;\n\n\tenv = getenv(\"ZPOOL_IMPORT_PATH\");\n\tif (env) {\n\t\tenvdup = strdup(env);\n\t\tdir = strtok(envdup, \":\");\n\t\twhile (dir) {\n\t\t\tif (strncmp(name, dir, strlen(dir)) == 0) {\n\t\t\t\t*order = i;\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdir = strtok(NULL, \":\");\n\t\t\ti++;\n\t\t}\n\t\tfree(envdup);\n\t} else {\n\t\tfor (i = 0; i < DEFAULT_IMPORT_PATH_SIZE; i++) {\n\t\t\tif (strncmp(name, zpool_default_import_path[i],\n\t\t\t    strlen(zpool_default_import_path[i])) == 0) {\n\t\t\t\t*order = i;\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (error);\n}",
        "parsed_output": "int zfs_path_order(const char *path, int *order)\n{\n    const char *env_path = getenv(\"ZPOOL_IMPORT_PATH\");\n    char *tokenized_path = NULL;\n    char *current_token = NULL;\n    size_t token_length;\n    int index = 0;\n\n    // If the environment variable is not set, use the default import paths\n    if (env_path == NULL) {\n        for (index = 0; index < 9; index++) {\n            const char *default_path = zpool_default_import_path[index];\n            size_t default_path_length = strlen(default_path);\n\n            if (strncmp(path, default_path, default_path_length) == 0) {\n                *order = index;\n                return 0; // Match found\n            }\n        }\n        return 2; // No match found\n    }\n\n    // Duplicate the environment variable string for tokenization\n    tokenized_path = strdup(env_path);\n    if (tokenized_path == NULL) {\n        return 2; // Memory allocation failure\n    }\n\n    // Tokenize the environment variable using \":\" as the delimiter\n    current_token = strtok(tokenized_path, \":\");\n    while (current_token != NULL) {\n        token_length = strlen(current_token);\n\n        if (strncmp(path, current_token, token_length) == 0) {\n            *order = index;\n            free(tokenized_path);\n            return 0; // Match found\n        }\n\n        index++;\n        current_token = strtok(NULL, \":\");\n    }\n\n    free(tokenized_path);\n    return 2; // No match found\n}",
        "baseline_code_stripped": "int zfs_path_order(char *param_1,int *param_2)\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s;\n  size_t sVar3;\n  long lVar4;\n  int iVar5;\n  pcVar2 = getenv(\"ZPOOL_IMPORT_PATH\");\n  if (pcVar2 == (char *)0x0) {\n    lVar4 = 0;\n    do {\n      pcVar2 = (&zpool_default_import_path)[lVar4];\n      sVar3 = strlen(pcVar2);\n      iVar5 = strncmp(param_1,pcVar2,sVar3);\n      if (iVar5 == 0) {\n        *param_2 = (int)lVar4;\n        return iVar5;\n      }\n      lVar4 = lVar4 + 1;\n    } while (lVar4 != 9);\n    return 2;\n  }\n  pcVar2 = strdup(pcVar2);\n  __s = strtok(pcVar2,\":\");\n  if (__s != (char *)0x0) {\n    iVar5 = 0;\n    do {\n      sVar3 = strlen(__s);\n      iVar1 = strncmp(param_1,__s,sVar3);\n      if (iVar1 == 0) {\n        *param_2 = iVar5;\n        iVar5 = 0;\n        goto LAB_00134212;\n      }\n      iVar5 = iVar5 + 1;\n      __s = strtok((char *)0x0,\":\");\n    } while (__s != (char *)0x0);\n  }\n  iVar5 = 2;\nLAB_00134212:\n  free(pcVar2);\n  return iVar5;\n}",
        "similarity_score_unixcoder": 0.8045796155929565,
        "similarity_score_baseline_stripped": 0.7060284614562988
    },
    {
        "func_name": "clusapi_dissect_ExecuteBatch_request",
        "normed_func_sha256": "55b0a3ad89538e6e87291546534ffaa4fa4c3d75ebfeac6a25c39903c0d8808d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_01cf16c0(undefined4 param_1,undefined4 param_2,undefined4 param_3,uint param_4)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  undefined *local_38;\n  undefined4 local_34;\n  undefined local_30;\n  undefined2 local_2f;\n  uint local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x1cf16cd;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  local_30 = 0x6a;\n  uVar1 = *(uint *)(*(int *)(param_4 & 0xfffffff0) + 8);\n  if (DAT_036761d8 != '\\0') {\n    FUN_022c9b70(0x6a);\n  }\n  local_2c = param_4;\n  local_28 = 0;\n  local_34 = 0xffffffff;\n  local_2f = CONCAT11(local_2f._1_1_,\n                      (byte)((uVar1 >> 8 & 1) << 5) | (byte)((uVar1 >> 8 & 1) << 6) |\n                      ((uVar1 & 0x200) != 0) << 7);\n  local_2f = local_2f & 0xfee0;\n  local_24 = param_2;\n  local_38 = &local_30;\n  FUN_01cefcb0(param_1,param_3,&local_38,&local_34,0);\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  FUN_0270ae70();\n}\n\n Revised code:\nSema::AssignConvertType\nSema::CheckAssignmentConstraints(SourceLocation Loc,\n                                 QualType LHSType, QualType RHSType) {\n  // Fake up an opaque expression.  We don't actually care about what\n  // cast operations are required, so if CheckAssignmentConstraints\n  // adds casts to this they'll be wasted, but fortunately that doesn't\n  // usually happen on valid code.\n  OpaqueValueExpr RHSExpr(Loc, RHSType, VK_RValue);\n  ExprResult RHSPtr = &RHSExpr;\n  CastKind K = CK_Invalid;\n\n  return CheckAssignmentConstraints(LHSType, RHSPtr, K, /*ConvertRHS=*/false);\n}\n\n## Example:\n\n Input code:\nvoid FUN_001a6cc0(undefined4 param_1,undefined4 param_2)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  uint local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  local_14 = 0;\n  uVar1 = FUN_0004f740(param_1);\n  local_14 = FUN_0004f740(param_2);\n  local_14 = local_14 | uVar1;\n  FUN_0004ec40(**(undefined4 **)(*(int *)(DAT_003079c4 + 0x11c) + 0x1b4),&local_14);\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  FUN_00215c20();\n}\n\n Revised code:\nPyObject* SbkPySide_QtCore_QTextStream_NumberFlag___or__(PyObject* self, PyObject* pyArg)\n{\n    ::QTextStream::NumberFlags cppResult, cppSelf, cppArg;\n#ifdef IS_PY3K\n    cppSelf = (::QTextStream::NumberFlags)PyLong_AsLong(self);\n    cppArg = (QTextStream::NumberFlags)PyLong_AsLong(pyArg);\n#else\n    cppSelf = (::QTextStream::NumberFlags)PyInt_AsLong(self);\n    cppArg = (QTextStream::NumberFlags)PyInt_AsLong(pyArg);\n#endif\n\n    cppResult = cppSelf | cppArg;\n    return Shiboken::Conversions::copyToPython(SBK_CONVERTER(SbkPySide_QtCoreTypes[SBK_QFLAGS_QTEXTSTREAM_NUMBERFLAG__IDX]), &cppResult);\n}\n\n## Example:\n\n Input code:\nundefined4 __regparm2\nFUN_00034300(undefined4 *param_1_00,undefined4 param_2_00,undefined4 param_1,undefined4 param_2,\n            undefined4 param_3,undefined4 param_4,undefined4 param_5,undefined4 param_6,int param_7,\n            undefined4 param_8,int param_9)\n{\n  undefined4 uVar1;\n  int in_GS_OFFSET;\n  undefined local_30 [16];\n  int local_20;\n  uVar1 = 0;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  if (param_9 != 0) {\n    uVar1 = FUN_00033ba0(param_1,param_2,param_3,param_4,param_7,param_8,param_6,local_30);\n    if (*(code **)(param_7 + 0x78) != (code *)0x0) {\n      (**(code **)(param_7 + 0x78))(param_2_00,*(undefined4 *)(param_7 + 0x74));\n    }\n    FUN_00033e20(*param_1_00,param_7,param_5,param_9);\n    if (*(code **)(param_7 + 0x7c) != (code *)0x0) {\n      (**(code **)(param_7 + 0x7c))(param_2_00,*(undefined4 *)(param_7 + 0x74));\n    }\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return uVar1;\n  }\n  FUN_000ada00();\n}\n\n Revised code:\nNK_LIB int\nnk_do_button_symbol(nk_flags *state,\n    struct nk_command_buffer *out, struct nk_rect bounds,\n    enum nk_symbol_type symbol, enum nk_button_behavior behavior,\n    const struct nk_style_button *style, const struct nk_input *in,\n    const struct nk_user_font *font)\n{\n    int ret;\n    struct nk_rect content;\n\n    NK_ASSERT(state);\n    NK_ASSERT(style);\n    NK_ASSERT(font);\n    NK_ASSERT(out);\n    if (!out || !style || !font || !state)\n        return nk_false;\n\n    ret = nk_do_button(state, out, bounds, style, in, behavior, &content);\n    if (style->draw_begin) style->draw_begin(out, style->userdata);\n    nk_draw_button_symbol(out, &bounds, &content, *state, style, symbol, font);\n    if (style->draw_end) style->draw_end(out, style->userdata);\n    return ret;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_016d95d0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 int param_5,undefined4 param_6)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  undefined local_24 [4];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x16d95d9;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  *(char **)(param_5 + 0x40) = \"ExecuteBatch\";\n  FUN_01c10c80(param_4,param_5,param_6,DAT_04aab91c,0);\n  uVar1 = FUN_00e603b0(param_5,param_6);\n  if (*(int *)(param_5 + 0x14) == 0) {\n    if ((*(int *)(param_5 + 0x18) == 0) && ((uVar1 & 3) != 0)) {\n      uVar1 = (uVar1 + 4) - (int)uVar1 % 4;\n    }\n    dissect_dcerpc_uint32(param_1,uVar1,param_3,param_4,param_6,DAT_04aab918,local_24);\n  }\n  FUN_00e603b0(param_5,param_6);\n  DAT_043ed2c4 = 1;\n  if (*(int *)(param_5 + 0x14) == 0) {\n    FUN_00e618e0(param_4,param_5,param_6,FUN_016c1630,1,\"Pointer to LpData (uint8)\",DAT_04aab928,0,0\n                );\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    FUN_00e603b0();\n    return;\n  }\n  FUN_01e4ff70();\n}",
        "output": "```c\nvoid ExecuteBatchOperation(uint32_t param_1, uint32_t param_2, uint32_t param_3, uint32_t param_4,\n                           int context, uint32_t param_6) {\n    uint32_t adjustedValue;\n    int stackGuard;\n    uint8_t localBuffer[4];\n\n    stackGuard = *(int *)(__builtin_frame_address(0) + 0x14);\n    *(char **)(context + 0x40) = \"ExecuteBatch\";\n\n    PerformOperation(param_4, context, param_6, GLOBAL_CONSTANT_1, 0);\n    adjustedValue = CalculateValue(context, param_6);\n\n    if (*(int *)(context + 0x14) == 0) {\n        if ((*(int *)(context + 0x18) == 0) && ((adjustedValue & 3) != 0)) {\n            adjustedValue = (adjustedValue + 4) - (adjustedValue % 4);\n        }\n        ProcessData(param_1, adjustedValue, param_3, param_4, param_6, GLOBAL_CONSTANT_2, localBuffer);\n    }\n\n    CalculateValue(context, param_6);\n    GLOBAL_FLAG = 1;\n\n    if (*(int *)(context + 0x14) == 0) {\n        HandlePointerData(param_4, context, param_6, CallbackFunction, 1, \n                          \"Pointer to LpData (uint8)\", GLOBAL_CONSTANT_3, 0, 0);\n    }\n\n    if (stackGuard == *(int *)(__builtin_frame_address(0) + 0x14)) {\n        CalculateValue();\n        return;\n    }\n\n    HandleError();\n}\n```",
        "source_code": "static int\nclusapi_dissect_ExecuteBatch_request(tvbuff_t *tvb _U_, int offset _U_, packet_info *pinfo _U_, proto_tree *tree _U_, dcerpc_info* di _U_, guint8 *drep _U_)\n{\n\tdi->dcerpc_procedure_name=\"ExecuteBatch\";\n\toffset = clusapi_dissect_element_ExecuteBatch_hKey(tvb, offset, pinfo, tree, di, drep);\n\toffset = dissect_deferred_pointers(pinfo, tvb, offset, di, drep);\n\toffset = clusapi_dissect_element_ExecuteBatch_cbData(tvb, offset, pinfo, tree, di, drep);\n\toffset = dissect_deferred_pointers(pinfo, tvb, offset, di, drep);\n\toffset = clusapi_dissect_element_ExecuteBatch_lpData(tvb, offset, pinfo, tree, di, drep);\n\toffset = dissect_deferred_pointers(pinfo, tvb, offset, di, drep);\n\treturn offset;\n}",
        "parsed_output": "void ExecuteBatchOperation(uint32_t param_1, uint32_t param_2, uint32_t param_3, uint32_t param_4,\n                           int context, uint32_t param_6) {\n    uint32_t adjustedValue;\n    int stackGuard;\n    uint8_t localBuffer[4];\n\n    stackGuard = *(int *)(__builtin_frame_address(0) + 0x14);\n    *(char **)(context + 0x40) = \"ExecuteBatch\";\n\n    PerformOperation(param_4, context, param_6, GLOBAL_CONSTANT_1, 0);\n    adjustedValue = CalculateValue(context, param_6);\n\n    if (*(int *)(context + 0x14) == 0) {\n        if ((*(int *)(context + 0x18) == 0) && ((adjustedValue & 3) != 0)) {\n            adjustedValue = (adjustedValue + 4) - (adjustedValue % 4);\n        }\n        ProcessData(param_1, adjustedValue, param_3, param_4, param_6, GLOBAL_CONSTANT_2, localBuffer);\n    }\n\n    CalculateValue(context, param_6);\n    GLOBAL_FLAG = 1;\n\n    if (*(int *)(context + 0x14) == 0) {\n        HandlePointerData(param_4, context, param_6, CallbackFunction, 1, \n                          \"Pointer to LpData (uint8)\", GLOBAL_CONSTANT_3, 0, 0);\n    }\n\n    if (stackGuard == *(int *)(__builtin_frame_address(0) + 0x14)) {\n        CalculateValue();\n        return;\n    }\n\n    HandleError();\n}",
        "baseline_code_stripped": "void FUN_016d95d0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 int param_5,undefined4 param_6)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  undefined local_24 [4];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x16d95d9;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  *(char **)(param_5 + 0x40) = \"ExecuteBatch\";\n  FUN_01c10c80(param_4,param_5,param_6,DAT_04aab91c,0);\n  uVar1 = FUN_00e603b0(param_5,param_6);\n  if (*(int *)(param_5 + 0x14) == 0) {\n    if ((*(int *)(param_5 + 0x18) == 0) && ((uVar1 & 3) != 0)) {\n      uVar1 = (uVar1 + 4) - (int)uVar1 % 4;\n    }\n    dissect_dcerpc_uint32(param_1,uVar1,param_3,param_4,param_6,DAT_04aab918,local_24);\n  }\n  FUN_00e603b0(param_5,param_6);\n  DAT_043ed2c4 = 1;\n  if (*(int *)(param_5 + 0x14) == 0) {\n    FUN_00e618e0(param_4,param_5,param_6,FUN_016c1630,1,\"Pointer to LpData (uint8)\",DAT_04aab928,0,0\n                );\n  }\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    FUN_00e603b0();\n    return;\n  }\n  FUN_01e4ff70();\n}",
        "similarity_score_unixcoder": 0.42030641436576843,
        "similarity_score_baseline_stripped": 0.5408616065979004
    },
    {
        "func_name": "i915_gem_get_caching_ioctl",
        "normed_func_sha256": "d7ca38517563582bcd295bdd7ad5d73df77006ef6d2006ea262eb5227919df61",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint i915_gem_set_tiling_ioctl(long param_1,int *param_2,long param_3)\n{\n  uint uVar1;\n  long lVar2;\n  uint uVar3;\n  int iVar4;\n  uint *puVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  puVar5 = (uint *)radix_tree_lookup(param_3 + 0x38,(long)*param_2);\n  if ((puVar5 == (uint *)0x0) || (uVar7 = *puVar5, uVar7 == 0)) {\n    return -2;\n  }\n  uVar6 = uVar7 + 1;\n  if ((uVar7 < 0x7fffffff) && ((int)uVar7 <= (int)uVar6)) {\n    do {\n      LOCK();\n      uVar1 = *puVar5;\n      if (uVar7 == uVar1) {\n        *puVar5 = uVar6;\n        uVar3 = uVar7;\n      }\n      else {\n        uVar3 = *puVar5;\n      }\n      UNLOCK();\n      if (uVar7 == uVar1) {\n        if (uVar7 == 0) {\n          return -2;\n        }\n        uVar7 = param_2[1];\n        uVar6 = param_2[2];\n        lVar2 = *(long *)(puVar5 + 2);\n        if (uVar7 == 0) {\nLAB_00145d2e:\n          param_2[3] = 0;\n          param_2[2] = 0;\n        }\n        else {\n          iVar4 = -0x16;\n          if (2 < uVar7) goto LAB_00145d4f;\n          if (*(byte *)(lVar2 + 0x625) < 7) {\n            if (*(byte *)(lVar2 + 0x625) < 4) {\n              if (((0x2000 < uVar6) || (uVar6 == 0)) || ((uVar6 - 1 & uVar6) != 0))\n              goto LAB_00145d4f;\n            }\n            else if (0x2007f < uVar6) goto LAB_00145d4f;\n          }\n          else if (0x4007f < uVar6) goto LAB_00145d4f;\n          iVar8 = 0x80;\n          if (((*(byte *)(lVar2 + 0x626) & 2) == 0) && (iVar8 = 0x200, uVar7 == 2)) {\n            iVar8 = (-(uint)(*(int *)(lVar2 + 0x628) - 5U < 2) & 0x180) + 0x80;\n          }\n          iVar4 = -0x16;\n          if ((uVar6 == 0) || ((iVar8 - 1U & uVar6) != 0)) goto LAB_00145d4f;\n          iVar4 = *(int *)(param_1 + 0x3f3c);\n          iVar8 = *(int *)(param_1 + 0x3f40);\n          if (uVar7 == 1) {\n            param_2[3] = iVar4;\n          }\n          else {\n            param_2[3] = iVar8;\n            iVar4 = iVar8;\n          }\n          if (iVar4 == 6) {\n            param_2[3] = 1;\n          }\n          else if (iVar4 == 7) {\n            param_2[3] = 2;\n          }\n          else if (iVar4 == 5) {\n            param_2[1] = 0;\n            goto LAB_00145d2e;\n          }\n        }\n        iVar4 = mutex_lock_interruptible(param_1 + 0x70);\n        if (iVar4 == 0) {\n          iVar4 = i915_gem_object_set_tiling(puVar5,param_2[1],param_2[2]);\n          mutex_unlock(param_1 + 0x70);\n          param_2[2] = puVar5[0x68] & 0xffffff80;\n          param_2[1] = puVar5[0x68] & 0x7f;\n        }\nLAB_00145d4f:\n        LOCK();\n        *puVar5 = *puVar5 - 1;\n        UNLOCK();\n        if ((int)*puVar5 < 0) {\n          do {\n            invalidInstructionException();\n          } while( true );\n        }\n        if (*puVar5 != 0) {\n          return iVar4;\n        }\n        drm_gem_object_free(puVar5);\n        return iVar4;\n      }\n      if (uVar3 == 0) {\n        return -2;\n      }\n      uVar6 = uVar3 + 1;\n    } while (((uVar3 != 0x7fffffff) && (-1 < (int)uVar3)) &&\n            (uVar7 = uVar3, (int)uVar3 <= (int)uVar6));\n  }\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n Revised code:\nint\ni915_gem_set_tiling_ioctl(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file)\n{\n\tstruct drm_i915_gem_set_tiling *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tint err;\n\n\tobj = i915_gem_object_lookup(file, args->handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tif (!i915_tiling_ok(obj, args->tiling_mode, args->stride)) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (args->tiling_mode == I915_TILING_NONE) {\n\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\n\t\targs->stride = 0;\n\t} else {\n\t\tif (args->tiling_mode == I915_TILING_X)\n\t\t\targs->swizzle_mode = to_i915(dev)->mm.bit_6_swizzle_x;\n\t\telse\n\t\t\targs->swizzle_mode = to_i915(dev)->mm.bit_6_swizzle_y;\n\n\t\t/* Hide bit 17 swizzling from the user.  This prevents old Mesa\n\t\t * from aborting the application on sw fallbacks to bit 17,\n\t\t * and we use the pread/pwrite bit17 paths to swizzle for it.\n\t\t * If there was a user that was relying on the swizzle\n\t\t * information for drm_intel_bo_map()ed reads/writes this would\n\t\t * break it, but we don't have any of those.\n\t\t */\n\t\tif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_17)\n\t\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_9;\n\t\tif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_10_17)\n\t\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_9_10;\n\n\t\t/* If we can't handle the swizzling, make it untiled. */\n\t\tif (args->swizzle_mode == I915_BIT_6_SWIZZLE_UNKNOWN) {\n\t\t\targs->tiling_mode = I915_TILING_NONE;\n\t\t\targs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\n\t\t\targs->stride = 0;\n\t\t}\n\t}\n\n\terr = mutex_lock_interruptible(&dev->struct_mutex);\n\tif (err)\n\t\tgoto err;\n\n\terr = i915_gem_object_set_tiling(obj, args->tiling_mode, args->stride);\n\tmutex_unlock(&dev->struct_mutex);\n\n\t/* We have to maintain this existing ABI... */\n\targs->stride = i915_gem_object_get_stride(obj);\n\targs->tiling_mode = i915_gem_object_get_tiling(obj);\n\nerr:\n\ti915_gem_object_put(obj);\n\treturn err;\n}\n\n## Example:\n\n Input code:\nundefined4 __fastcall FUN_006ca0b0(int param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  uint *puVar4;\n  uint uVar5;\n  iVar1 = *(int *)(param_1 + 0xc);\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x28) != 0x17)) {\n    if (*(int *)(iVar1 + 0x28) == 0x18) {\n      return 1;\n    }\n    switch(*(undefined4 *)(iVar1 + 0xc)) {\n    case 8:\n      uVar5 = 0;\n      iVar3 = FUN_006c83b0();\n      if (0 < iVar3) {\n        puVar4 = (uint *)(*(int *)(*(int *)(iVar1 + 0x20) + 0xc) + *(int *)(iVar1 + 0x20));\n        do {\n          if (*puVar4 != (((uVar5 | 0xffffff00) << 8 | uVar5 & 0xff) << 8 | uVar5 & 0xff)) {\n            return 0;\n          }\n          uVar5 = uVar5 + 1;\n          puVar4 = puVar4 + 1;\n        } while ((int)uVar5 < iVar3);\n      }\n      return 1;\n    case 0x10:\n    case 0x18:\n    case 0x20:\n      uVar2 = FUN_006c78d0();\n      return uVar2;\n    }\n  }\n  return 0;\n}\n\n Revised code:\nbool QImage::isGrayscale() const\n{\n    if (!d)\n        return false;\n\n    if (d->format == QImage::Format_Alpha8)\n        return false;\n\n    if (d->format == QImage::Format_Grayscale8)\n        return true;\n\n    switch (depth()) {\n    case 32:\n    case 24:\n    case 16:\n        return allGray();\n    case 8: {\n        Q_ASSERT(d->format == QImage::Format_Indexed8);\n        for (int i = 0; i < colorCount(); i++)\n            if (d->colortable.at(i) != qRgb(i,i,i))\n                return false;\n        return true;\n        }\n    }\n    return false;\n}\n\n## Example:\n\n Input code:\nvoid cx8802_request_acquire(long *param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  long lVar3;\n  int iVar4;\n  int *piVar5;\n  __fentry__();\n  lVar3 = *param_1;\n  iVar1 = *(int *)(lVar3 + 0xc30);\n  if ((iVar1 != 0) && (iVar1 != *(int *)(param_1 + 3))) {\n    __x86_return_thunk();\n    return;\n  }\n  if (*(int *)(param_1 + 3) == 1) {\n    uVar2 = *(undefined4 *)(lVar3 + 0xb98);\n    piVar5 = (int *)(lVar3 + 0xa70);\n    *(undefined4 *)(lVar3 + 0xb98) = 0;\n    *(undefined4 *)(lVar3 + 0xb9c) = uVar2;\n    iVar4 = 0;\n    do {\n      if (*piVar5 == 8) {\n        *(int *)(lVar3 + 0xb98) = iVar4;\n        break;\n      }\n      iVar4 = iVar4 + 1;\n      piVar5 = piVar5 + 6;\n    } while (iVar4 != 8);\n  }\n  if (param_1[8] != 0) {\n    *(int *)(lVar3 + 0xc34) = *(int *)(lVar3 + 0xc34) + 1;\n    if (iVar1 == 0) {\n      *(undefined4 *)(lVar3 + 0xc30) = *(undefined4 *)(param_1 + 3);\n      __x86_indirect_thunk_rax();\n    }\n    if (1 < debug + 1U) {\n      _printk(&DAT_00101f90,\"cx8802_request_acquire\",\n              *(undefined4 *)(*(long *)(lVar3 + 0x48) + 0x350010));\n    }\n  }\n  __x86_return_thunk();\n  return;\n}\n\n Revised code:\nstatic int cx8802_request_acquire(struct cx8802_driver *drv)\n{\n\tstruct cx88_core *core = drv->core;\n\tunsigned int\ti;\n\n\t/* Fail a request for hardware if the device is busy. */\n\tif (core->active_type_id != CX88_BOARD_NONE &&\n\t    core->active_type_id != drv->type_id)\n\t\treturn -EBUSY;\n\n\tif (drv->type_id == CX88_MPEG_DVB) {\n\t\t/* When switching to DVB, always set the input to the tuner */\n\t\tcore->last_analog_input = core->input;\n\t\tcore->input = 0;\n\t\tfor (i = 0;\n\t\t     i < (sizeof(core->board.input) /\n\t\t\t  sizeof(struct cx88_input));\n\t\t     i++) {\n\t\t\tif (core->board.input[i].type == CX88_VMUX_DVB) {\n\t\t\t\tcore->input = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (drv->advise_acquire) {\n\t\tcore->active_ref++;\n\t\tif (core->active_type_id == CX88_BOARD_NONE) {\n\t\t\tcore->active_type_id = drv->type_id;\n\t\t\tdrv->advise_acquire(drv);\n\t\t}\n\n\t\tdprintk(1, \"Post acquire GPIO=%x\\n\", cx_read(MO_GP0_IO));\n\t}\n\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 i915_gem_get_caching_ioctl(void)\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  undefined8 uVar5;\n  uVar5 = __fentry__();\n  if ((*(byte *)((int)uVar5 + 0x1451) & 8) == 0) {\n    __rcu_read_lock();\n    iVar2 = idr_find();\n    if (iVar2 == 0) {\n      uVar4 = 0xfffffffe;\n    }\n    else {\n      bVar1 = *(byte *)(iVar2 + 0x150) & 7;\n      if (bVar1 < 3) {\n        uVar3 = (uint)(bVar1 != 0);\n      }\n      else {\n        uVar3 = (uint)(bVar1 == 3) * 2;\n      }\n      *(uint *)((int)((ulonglong)uVar5 >> 0x20) + 4) = uVar3;\n      uVar4 = 0;\n    }\n    __rcu_read_unlock();\n  }\n  else {\n    uVar4 = 0xffffffed;\n  }\n  return uVar4;\n}",
        "output": "```c\nint i915_gem_get_caching_ioctl(struct drm_device *dev, void *data, struct drm_file *file)\n{\n    struct drm_i915_gem_caching *args = data;\n    struct drm_i915_gem_object *obj;\n\n    if (!i915_gem_object_lookup(file, args->handle, &obj))\n        return -ENOENT;\n\n    switch (obj->cache_level) {\n    case I915_CACHE_NONE:\n        args->caching = 0;\n        break;\n    case I915_CACHE_LLC:\n        args->caching = 1;\n        break;\n    case I915_CACHE_L3_LLC:\n        args->caching = 2;\n        break;\n    default:\n        args->caching = -1;\n        break;\n    }\n\n    i915_gem_object_put(obj);\n    return 0;\n}\n```",
        "source_code": "int i915_gem_get_caching_ioctl(struct drm_device *dev, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct drm_i915_gem_caching *args = data;\n\tstruct drm_i915_gem_object *obj;\n\tint err = 0;\n\n\tif (IS_DGFX(to_i915(dev)))\n\t\treturn -ENODEV;\n\n\trcu_read_lock();\n\tobj = i915_gem_object_lookup_rcu(file, args->handle);\n\tif (!obj) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tswitch (obj->cache_level) {\n\tcase I915_CACHE_LLC:\n\tcase I915_CACHE_L3_LLC:\n\t\targs->caching = I915_CACHING_CACHED;\n\t\tbreak;\n\n\tcase I915_CACHE_WT:\n\t\targs->caching = I915_CACHING_DISPLAY;\n\t\tbreak;\n\n\tdefault:\n\t\targs->caching = I915_CACHING_NONE;\n\t\tbreak;\n\t}\nout:\n\trcu_read_unlock();\n\treturn err;\n}",
        "parsed_output": "int i915_gem_get_caching_ioctl(struct drm_device *dev, void *data, struct drm_file *file)\n{\n    struct drm_i915_gem_caching *args = data;\n    struct drm_i915_gem_object *obj;\n\n    if (!i915_gem_object_lookup(file, args->handle, &obj))\n        return -ENOENT;\n\n    switch (obj->cache_level) {\n    case I915_CACHE_NONE:\n        args->caching = 0;\n        break;\n    case I915_CACHE_LLC:\n        args->caching = 1;\n        break;\n    case I915_CACHE_L3_LLC:\n        args->caching = 2;\n        break;\n    default:\n        args->caching = -1;\n        break;\n    }\n\n    i915_gem_object_put(obj);\n    return 0;\n}",
        "baseline_code_stripped": "undefined4 i915_gem_get_caching_ioctl(void)\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  undefined8 uVar5;\n  uVar5 = __fentry__();\n  if ((*(byte *)((int)uVar5 + 0x1451) & 8) == 0) {\n    __rcu_read_lock();\n    iVar2 = idr_find();\n    if (iVar2 == 0) {\n      uVar4 = 0xfffffffe;\n    }\n    else {\n      bVar1 = *(byte *)(iVar2 + 0x150) & 7;\n      if (bVar1 < 3) {\n        uVar3 = (uint)(bVar1 != 0);\n      }\n      else {\n        uVar3 = (uint)(bVar1 == 3) * 2;\n      }\n      *(uint *)((int)((ulonglong)uVar5 >> 0x20) + 4) = uVar3;\n      uVar4 = 0;\n    }\n    __rcu_read_unlock();\n  }\n  else {\n    uVar4 = 0xffffffed;\n  }\n  return uVar4;\n}",
        "similarity_score_unixcoder": 0.9188904762268066,
        "similarity_score_baseline_stripped": 0.561419665813446
    },
    {
        "func_name": "_wrap_SoSFInt32_getTypeId",
        "normed_func_sha256": "b59dcfe1e26cd0492e75f1eed33c276b3a0a700cf0cdbdea1768cca02339f945",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_003392f0(undefined8 param_1,long param_2)\n{\n  undefined2 uVar1;\n  int iVar2;\n  undefined2 *puVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  undefined8 *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = (undefined8 *)0x0;\n  if (param_2 != 0) {\n    iVar2 = FUN_00652950(param_2,&local_28,DAT_00a99d30,0);\n    if (-1 < iVar2) {\n      uVar1 = (**(code **)*local_28)();\n      uVar4 = DAT_00a9a450;\n      puVar3 = (undefined2 *)operator_new(2);\n      *puVar3 = uVar1;\n      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        uVar4 = FUN_00654fd0(puVar3,uVar4,1);\n        return uVar4;\n      }\n      goto LAB_003393aa;\n    }\n    if (iVar2 == -1) {\n      iVar2 = -5;\n    }\n    uVar4 = FUN_002d9070(iVar2);\n    PyErr_SetString(uVar4,\n                    \"in method \\'SoPickStyle_getTypeId\\', argument 1 of type \\'SoPickStyle const *\\'\"\n                   );\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\nLAB_003393aa:\n  __stack_chk_fail();\n}\n\n Revised code:\nSWIGINTERN PyObject *_wrap_SoPickStyle_getTypeId(PyObject *self, PyObject *args) {\n  PyObject *resultobj = 0;\n  SoPickStyle *arg1 = (SoPickStyle *) 0 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  PyObject *swig_obj[1] ;\n  SoType result;\n  \n  if (!args) SWIG_fail;\n  swig_obj[0] = args;\n  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_SoPickStyle, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"SoPickStyle_getTypeId\" \"', argument \" \"1\"\" of type '\" \"SoPickStyle const *\"\"'\"); \n  }\n  arg1 = reinterpret_cast< SoPickStyle * >(argp1);\n  result = ((SoPickStyle const *)arg1)->getTypeId();\n  resultobj = SWIG_NewPointerObj((new SoType(result)), SWIGTYPE_p_SoType, SWIG_POINTER_OWN |  0 );\n  return resultobj;\nfail:\n  return NULL;\n}\n\n## Example:\n\n Input code:\nvoid FUN_0029cab4(int **param_1,undefined4 param_2)\n{\n  char cVar1;\n  undefined4 *puVar2;\n  int in_GS_OFFSET;\n  undefined4 uStack_30;\n  undefined auStack_2c [12];\n  int **local_20;\n  undefined local_1c [4];\n  undefined local_18 [8];\n  undefined4 local_10;\n  puVar2 = (undefined4 *)auStack_2c;\n  uStack_30 = 0x29cabc;\n  local_20 = param_1;\n  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  cVar1 = (**(code **)(**param_1 + 0x24))(*param_1);\n  if (cVar1 == '\\0') {\n    (**(code **)(**local_20 + 0xc))(local_18,*local_20);\n    FUN_001e2b9e(local_1c);\n    puVar2 = &uStack_30;\n  }\n  else {\n    (**(code **)(**local_20 + 0x28))(*local_20,param_2);\n  }\n  if (*(int *)((int)puVar2 + 0x1c) != *(int *)(in_GS_OFFSET + 0x14)) {\n    *(undefined4 *)((int)puVar2 + -4) = 0x29cb5b;\n    FUN_00640f70();\n  }\n  return;\n}\n\n Revised code:\nint mhfw( int w ) {\n\tif ( item->hasHeightForWidth() ) {\n\t    return item->heightForWidth( w );\n\t} else {\n\t    return item->minimumSize().height();\n\t}\n    }\n\n## Example:\n\n Input code:\nint * FUN_000c86f0(int *param_1,undefined4 param_2)\n{\n  undefined4 uVar1;\n  int *piVar2;\n  int *piVar3;\n  int iVar4;\n  undefined *extraout_EDX;\n  undefined *puVar5;\n  int unaff_EDI;\n  int in_GS_OFFSET;\n  undefined *puStack_38;\n  undefined auStack_30 [16];\n  int local_20;\n  FUN_0008aba4();\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  piVar2 = (int *)__dynamic_cast(param_2,*(undefined4 *)(unaff_EDI + 0xd6e83),\n                                 *(undefined4 *)(unaff_EDI + 0xd77af),0);\n  if (piVar2 == (int *)0x0) {\n    uVar1 = __cxa_allocate_exception(0x34);\n    FUN_00147e80();\n    FUN_00056ef0();\n    puVar5 = auStack_30;\n    if (puStack_38 != puVar5) {\n      operator_delete(puStack_38);\n      puVar5 = extraout_EDX;\n    }\n    __cxa_throw(uVar1,*(undefined4 *)(&UNK_000d6cbf + unaff_EDI),unaff_EDI + -0x49239,puVar5);\n  }\n  piVar3 = (int *)operator_new(0xc);\n  *piVar3 = unaff_EDI + 0xd17bf;\n  iVar4 = (**(code **)(*param_1 + 0x2c))(param_1);\n  piVar3[1] = iVar4;\n  iVar4 = (**(code **)(*piVar2 + 0x2c))(piVar2);\n  piVar3[2] = iVar4;\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return piVar3;\n  }\n  FUN_0014b350();\n}\n\n Revised code:\nAbstractMask*\nMask< D >::minus_mask( const AbstractMask& other ) const\n{\n  const Mask* other_d = dynamic_cast< const Mask* >( &other );\n  if ( other_d == 0 )\n  {\n    throw BadProperty( \"Masks must have same number of dimensions.\" );\n  }\n  return new DifferenceMask< D >( *this, *other_d );\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_0015fe10(undefined4 param_1,int param_2)\n{\n  int iVar1;\n  undefined2 *puVar2;\n  undefined4 uVar3;\n  undefined4 *puVar4;\n  int in_GS_OFFSET;\n  undefined4 uStack_30;\n  undefined auStack_2c [10];\n  undefined2 local_22;\n  undefined local_1e [10];\n  int *local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  local_14 = (int *)0x0;\n  if (param_2 != 0) {\n    iVar1 = FUN_004c32b0(0);\n    if (-1 < iVar1) {\n      (**(code **)(*local_14 + 8))(local_1e,local_14);\n      puVar2 = (undefined2 *)operator_new(2);\n      puVar4 = &uStack_30;\n      *puVar2 = local_22;\n      if (local_14 == *(int **)(in_GS_OFFSET + 0x14)) {\n        uVar3 = FUN_004c6e90();\n        return uVar3;\n      }\n      goto LAB_0015fee8;\n    }\n    uStack_30 = 0x15febf;\n    uVar3 = FUN_00107260();\n    PyErr_SetString(uVar3,\n                    \"in method \\'SoSFInt32_getTypeId\\', argument 1 of type \\'SoSFInt32 const *\\'\");\n  }\n  puVar4 = (undefined4 *)auStack_2c;\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return 0;\n  }\nLAB_0015fee8:\n  *(undefined **)((int)puVar4 + -4) = &UNK_0015feed;\n  FUN_004c9df0();\n}",
        "output": "```c\nSWIGINTERN PyObject *_wrap_SoSFInt32_getTypeId(PyObject *self, PyObject *args) {\n  PyObject *resultobj = 0;\n  SoSFInt32 *arg1 = (SoSFInt32 *) 0;\n  void *argp1 = 0;\n  int res1 = 0;\n  PyObject *swig_obj[1];\n  SoType result;\n\n  if (!args) SWIG_fail;\n  swig_obj[0] = args;\n  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_SoSFInt32, 0 | 0);\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"SoSFInt32_getTypeId\" \"', argument \" \"1\"\" of type '\" \"SoSFInt32 const *\"\"'\");\n  }\n  arg1 = reinterpret_cast<SoSFInt32 *>(argp1);\n  result = ((SoSFInt32 const *)arg1)->getTypeId();\n  resultobj = SWIG_NewPointerObj((new SoType(result)), SWIGTYPE_p_SoType, SWIG_POINTER_OWN | 0);\n  return resultobj;\nfail:\n  return NULL;\n}\n```",
        "source_code": "SWIGINTERN PyObject *_wrap_SoSFInt32_getTypeId(PyObject *self, PyObject *args) {\n  PyObject *resultobj = 0;\n  SoSFInt32 *arg1 = (SoSFInt32 *) 0 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  PyObject *swig_obj[1] ;\n  SoType result;\n  \n  if (!args) SWIG_fail;\n  swig_obj[0] = args;\n  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_SoSFInt32, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"SoSFInt32_getTypeId\" \"', argument \" \"1\"\" of type '\" \"SoSFInt32 const *\"\"'\"); \n  }\n  arg1 = reinterpret_cast< SoSFInt32 * >(argp1);\n  result = ((SoSFInt32 const *)arg1)->getTypeId();\n  resultobj = SWIG_NewPointerObj((new SoType(result)), SWIGTYPE_p_SoType, SWIG_POINTER_OWN |  0 );\n  return resultobj;\nfail:\n  return NULL;\n}",
        "parsed_output": "SWIGINTERN PyObject *_wrap_SoSFInt32_getTypeId(PyObject *self, PyObject *args) {\n  PyObject *resultobj = 0;\n  SoSFInt32 *arg1 = (SoSFInt32 *) 0;\n  void *argp1 = 0;\n  int res1 = 0;\n  PyObject *swig_obj[1];\n  SoType result;\n\n  if (!args) SWIG_fail;\n  swig_obj[0] = args;\n  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_SoSFInt32, 0 | 0);\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"SoSFInt32_getTypeId\" \"', argument \" \"1\"\" of type '\" \"SoSFInt32 const *\"\"'\");\n  }\n  arg1 = reinterpret_cast<SoSFInt32 *>(argp1);\n  result = ((SoSFInt32 const *)arg1)->getTypeId();\n  resultobj = SWIG_NewPointerObj((new SoType(result)), SWIGTYPE_p_SoType, SWIG_POINTER_OWN | 0);\n  return resultobj;\nfail:\n  return NULL;\n}",
        "baseline_code_stripped": "undefined4 FUN_0015fe10(undefined4 param_1,int param_2)\n{\n  int iVar1;\n  undefined2 *puVar2;\n  undefined4 uVar3;\n  undefined4 *puVar4;\n  int in_GS_OFFSET;\n  undefined4 uStack_30;\n  undefined auStack_2c [10];\n  undefined2 local_22;\n  undefined local_1e [10];\n  int *local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  local_14 = (int *)0x0;\n  if (param_2 != 0) {\n    iVar1 = FUN_004c32b0(0);\n    if (-1 < iVar1) {\n      (**(code **)(*local_14 + 8))(local_1e,local_14);\n      puVar2 = (undefined2 *)operator_new(2);\n      puVar4 = &uStack_30;\n      *puVar2 = local_22;\n      if (local_14 == *(int **)(in_GS_OFFSET + 0x14)) {\n        uVar3 = FUN_004c6e90();\n        return uVar3;\n      }\n      goto LAB_0015fee8;\n    }\n    uStack_30 = 0x15febf;\n    uVar3 = FUN_00107260();\n    PyErr_SetString(uVar3,\n                    \"in method \\'SoSFInt32_getTypeId\\', argument 1 of type \\'SoSFInt32 const *\\'\");\n  }\n  puVar4 = (undefined4 *)auStack_2c;\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return 0;\n  }\nLAB_0015fee8:\n  *(undefined **)((int)puVar4 + -4) = &UNK_0015feed;\n  FUN_004c9df0();\n}",
        "similarity_score_unixcoder": 0.97679603099823,
        "similarity_score_baseline_stripped": 0.6062556505203247
    },
    {
        "func_name": "AreaSelectionWidget::updateSelectedAreaOnDragBottom",
        "normed_func_sha256": "34bbb36a2808605e71cc2ffe83d99a5f5ca014df23c7ad1523eebb95714c8276",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_00424ca0(double *param_1)\n{\n  double dVar1;\n  char cVar2;\n  long lVar3;\n  float fVar4;\n  if (param_1 == (double *)0x0) {\n    return 0xffffffff;\n  }\n  cVar2 = *(char *)((long)param_1 + 0x10e);\n  dVar1 = param_1[1];\n  fVar4 = *(float *)param_1[0x19] + *(float *)((long)param_1 + 0xec);\n  *(float *)param_1[0x19] = fVar4;\n  if ((cVar2 != '\\0') && (dVar1 < (double)fVar4)) {\n    lVar3 = FUN_002384e0();\n    if ((lVar3 != 0) && (*(char *)(lVar3 + 0x40116) != '\\0')) {\n      *(float *)param_1[0x19] = (float)*param_1;\n      return 0;\n    }\n    *(float *)param_1[0x19] = (float)dVar1;\n    return 0;\n  }\n  return 0;\n}\n\n Revised code:\nstatic int setting_fraction_action_right_default(\n      rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   double               max = 0.0f;\n   if (!setting)\n      return -1;\n   max = setting->max;\n   (void)wraparound; \n   *setting->value.target.fraction =\n      *setting->value.target.fraction + setting->step;\n   if (setting->enforce_maxrange)\n   {\n      if (*setting->value.target.fraction > max)\n      {\n         settings_t *settings = config_get_ptr();\n         double          min  = setting->min;\n         if (settings && settings->bools.menu_navigation_wraparound_enable)\n            *setting->value.target.fraction = min;\n         else\n            *setting->value.target.fraction = max;\n      }\n   }\n   return 0;\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_0052ea30(long param_1,long param_2,long param_3)\n{\n  ulong uVar1;\n  double dVar2;\n  double dVar3;\n  if (*(ulong *)(param_1 + 0x29d48) == 0) {\n    dVar2 = 0.0;\n  }\n  else {\n    uVar1 = (*(ulong *)(param_3 + 0xd8 + (long)*(int *)(param_2 + 0x44) * 8) /\n            *(ulong *)(param_1 + 0x29d48)) * 100;\n    if ((long)uVar1 < 0) {\n      dVar2 = (double)(uVar1 >> 1) + (double)(uVar1 >> 1);\n    }\n    else {\n      dVar2 = (double)uVar1;\n    }\n  }\n  uVar1 = *(ulong *)(param_3 + 0x38 + (long)*(int *)(param_2 + 0x48) * 8);\n  dVar3 = (double)uVar1;\n  if ((long)uVar1 < 0) {\n    dVar3 = (double)(uVar1 >> 1 | (ulong)((uint)uVar1 & 1));\n    dVar3 = dVar3 + dVar3;\n  }\n  if (dVar3 != 0.0) {\n    return CONCAT44((int)((ulong)(dVar2 / dVar3) >> 0x20),(float)(dVar2 / dVar3));\n  }\n  return 0;\n}\n\n Revised code:\nstatic float\nhsw__sampler_balance__ps_eu_active__read(struct brw_context *brw,\n                                         const struct brw_perf_query_info *query,\n                                         uint64_t *accumulator)\n{\n   /* RPN equation: A 27 READ $EuCoresTotalCount UDIV 100 UMUL $GpuCoreClocks FDIV */\n   uint64_t tmp0 = accumulator[query->a_offset + 27];\n   uint64_t tmp1 = tmp0;\n   uint64_t tmp2 = brw->perfquery.sys_vars.n_eus;\n   uint64_t tmp3 = tmp2 ? tmp1 / tmp2 : 0;\n   uint64_t tmp4 = tmp3 * 100;\n   double tmp5 = tmp4;\n   double tmp6 = hsw__sampler_balance__gpu_core_clocks__read(brw, query, accumulator);\n   double tmp7 = tmp6 ? tmp5 / tmp6 : 0;\n\n   return tmp7;\n}\n\n## Example:\n\n Input code:\nvoid FUN_14006b580(longlong param_1,longlong param_2)\n{\n  double dVar1;\n  double dVar2;\n  double dVar3;\n  double dVar4;\n  double dVar5;\n  undefined local_38 [48];\n  FUN_14006c4a0(local_38);\n  dVar4 = 1.0 - *(double *)(param_1 + 8) / 255.0;\n  dVar3 = 1.0 - *(double *)(param_1 + 0x10) / 255.0;\n  dVar2 = 1.0 - *(double *)(param_1 + 0x18) / 255.0;\n  dVar1 = dVar4;\n  if (1.0 <= dVar4) {\n    dVar1 = 1.0;\n  }\n  dVar5 = dVar3;\n  if (dVar1 <= dVar3) {\n    dVar5 = dVar1;\n  }\n  dVar1 = dVar2;\n  if (dVar5 <= dVar2) {\n    dVar1 = dVar5;\n  }\n  *(double *)(param_2 + 0x20) = dVar1;\n  if (0.001 <= (double)((ulonglong)(dVar1 - 1.0) & 0x7fffffffffffffff)) {\n    dVar5 = 1.0 - dVar1;\n    dVar2 = (dVar2 - dVar1) / dVar5;\n    dVar3 = (dVar3 - dVar1) / dVar5;\n    dVar5 = (dVar4 - dVar1) / dVar5;\n  }\n  else {\n    dVar2 = 0.0;\n    dVar3 = 0.0;\n    dVar5 = 0.0;\n  }\n  *(double *)(param_2 + 8) = dVar5;\n  *(double *)(param_2 + 0x10) = dVar3;\n  *(double *)(param_2 + 0x18) = dVar2;\n  return;\n}\n\n Revised code:\nvoid CmykConverter::ToColorSpace(Rgb *color, Cmyk *item) {\n        Cmy cmy;\n\n        CmyConverter::ToColorSpace(color, &cmy);\n        double k = 1.0;\n        k = std::min(k, cmy.c);\n        k = std::min(k, cmy.m);\n        k = std::min(k, cmy.y);\n\n        item->k = k;\n        if (std::abs(item->k - 1) < 1e-3) {\n            item->c = 0;\n            item->m = 0;\n            item->y = 0;\n        }\n        else {\n            item->c = (cmy.c - k) / (1 - k);\n            item->m = (cmy.m - k) / (1 - k);\n            item->y = (cmy.y - k) / (1 - k);\n        }\n    }\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00122ca0(long param_1,long param_2)\n{\n  long lVar1;\n  double dVar2;\n  double dVar3;\n  double dVar4;\n  double dVar5;\n  lVar1 = *(long *)(param_1 + 0x38);\n  dVar4 = *(double *)(lVar1 + 0x110);\n  dVar3 = (double)*(int *)(param_2 + 4);\n  dVar5 = dVar4 + 6.0;\n  dVar2 = *(double *)(lVar1 + 0xe8) + *(double *)(lVar1 + 0xf8) + *(double *)(lVar1 + 0xb0);\n  if (dVar5 <= dVar3) {\n    if (dVar3 <= dVar2) {\n      dVar4 = dVar3 - dVar4;\n    }\n    else {\n      dVar4 = dVar2 - dVar4;\n    }\n  }\n  else {\n    dVar4 = dVar5 - dVar4;\n  }\n  if (*(char *)(lVar1 + 0x170) != '\\0') {\n    dVar3 = *(double *)(lVar1 + 0x168) * dVar4;\n    if ((dVar3 < dVar5) || (dVar2 < dVar3)) {\n      return;\n    }\n    *(double *)(lVar1 + 0x118) = dVar3;\n  }\n  *(double *)(lVar1 + 0x120) = dVar4;\n  FUN_00122ad0(param_1,1);\n  return;\n}",
        "output": "```c\nvoid UpdateValues(long param_1, long param_2) {\n    long data_ptr = *(long *)(param_1 + 0x38);\n    double base_value = *(double *)(data_ptr + 0x110);\n    double input_value = (double)*(int *)(param_2 + 4);\n    double threshold = base_value + 6.0;\n    double max_value = *(double *)(data_ptr + 0xe8) + \n                       *(double *)(data_ptr + 0xf8) + \n                       *(double *)(data_ptr + 0xb0);\n\n    double result_value;\n    if (threshold <= input_value) {\n        if (input_value <= max_value) {\n            result_value = input_value - base_value;\n        } else {\n            result_value = max_value - base_value;\n        }\n    } else {\n        result_value = threshold - base_value;\n    }\n\n    if (*(char *)(data_ptr + 0x170) != '\\0') {\n        double scaled_value = *(double *)(data_ptr + 0x168) * result_value;\n        if (scaled_value < threshold || scaled_value > max_value) {\n            return;\n        }\n        *(double *)(data_ptr + 0x118) = scaled_value;\n    }\n\n    *(double *)(data_ptr + 0x120) = result_value;\n    PerformAction(param_1, 1);\n}\n```",
        "source_code": "void AreaSelectionWidget::updateSelectedAreaOnDragBottom(const QPoint& mousePosition)\n{\n    Q_D (AreaSelectionWidget);\n\n    // the drag handle size in the bounds calculations ensure that the\n    // box does not get too small to reach the drag handles with the mouse\n    const qreal topBound    = d->rectSelectedArea.y() + d->DRAG_HANDLE_SIZE;\n    const qreal bottomBound = d->rectDisplayArea.y() + d->rectDisplayArea.height() + d->outOfBoundsDisplayAreaMargin;\n    const qreal mouseY      = mousePosition.y();\n    qreal       newHeight   = 0.;\n\n    if (mouseY < topBound) {\n        newHeight = topBound - d->rectSelectedArea.y();\n    } else if (mouseY > bottomBound) {\n        newHeight = bottomBound - d->rectSelectedArea.y();\n    } else {\n        newHeight = mouseY - d->rectSelectedArea.y();\n    }\n\n    if (d->proportionsLocked) {\n        const auto newWidth = newHeight * d->proportions;\n        if (newWidth < topBound || newWidth > bottomBound) return;\n        d->rectSelectedArea.setWidth(newWidth);\n    }\n    d->rectSelectedArea.setHeight(newHeight);\n\n    updateSelectedAreaSize(true);\n}",
        "parsed_output": "void UpdateValues(long param_1, long param_2) {\n    long data_ptr = *(long *)(param_1 + 0x38);\n    double base_value = *(double *)(data_ptr + 0x110);\n    double input_value = (double)*(int *)(param_2 + 4);\n    double threshold = base_value + 6.0;\n    double max_value = *(double *)(data_ptr + 0xe8) + \n                       *(double *)(data_ptr + 0xf8) + \n                       *(double *)(data_ptr + 0xb0);\n\n    double result_value;\n    if (threshold <= input_value) {\n        if (input_value <= max_value) {\n            result_value = input_value - base_value;\n        } else {\n            result_value = max_value - base_value;\n        }\n    } else {\n        result_value = threshold - base_value;\n    }\n\n    if (*(char *)(data_ptr + 0x170) != '\\0') {\n        double scaled_value = *(double *)(data_ptr + 0x168) * result_value;\n        if (scaled_value < threshold || scaled_value > max_value) {\n            return;\n        }\n        *(double *)(data_ptr + 0x118) = scaled_value;\n    }\n\n    *(double *)(data_ptr + 0x120) = result_value;\n    PerformAction(param_1, 1);\n}",
        "baseline_code_stripped": "void FUN_00122ca0(long param_1,long param_2)\n{\n  long lVar1;\n  double dVar2;\n  double dVar3;\n  double dVar4;\n  double dVar5;\n  lVar1 = *(long *)(param_1 + 0x38);\n  dVar4 = *(double *)(lVar1 + 0x110);\n  dVar3 = (double)*(int *)(param_2 + 4);\n  dVar5 = dVar4 + 6.0;\n  dVar2 = *(double *)(lVar1 + 0xe8) + *(double *)(lVar1 + 0xf8) + *(double *)(lVar1 + 0xb0);\n  if (dVar5 <= dVar3) {\n    if (dVar3 <= dVar2) {\n      dVar4 = dVar3 - dVar4;\n    }\n    else {\n      dVar4 = dVar2 - dVar4;\n    }\n  }\n  else {\n    dVar4 = dVar5 - dVar4;\n  }\n  if (*(char *)(lVar1 + 0x170) != '\\0') {\n    dVar3 = *(double *)(lVar1 + 0x168) * dVar4;\n    if ((dVar3 < dVar5) || (dVar2 < dVar3)) {\n      return;\n    }\n    *(double *)(lVar1 + 0x118) = dVar3;\n  }\n  *(double *)(lVar1 + 0x120) = dVar4;\n  FUN_00122ad0(param_1,1);\n  return;\n}",
        "similarity_score_unixcoder": 0.506480872631073,
        "similarity_score_baseline_stripped": 0.37720635533332825
    },
    {
        "func_name": "sipwxScrolledWindow::AcceptsFocusRecursively",
        "normed_func_sha256": "fa24614a30142c5737effbb6f084ebc4d2f5db768ef04caf8f87f137e4ac80c8",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __thiscall sipwxListView::AcceptsFocus(sipwxListView *this)\n{\n  _object *p_Var1;\n  PyGILState_STATE local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__core + 0x164))\n                     (&local_18,this + 0x259,*(undefined4 *)(this + 0x250),0,\"AcceptsFocus\");\n  if (p_Var1 == (_object *)0x0) {\n    wxControlContainerBase::AcceptsFocus();\n  }\n  else {\n    sipVH__core_5(local_18,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0,\n                  *(_sipSimpleWrapper **)(this + 0x250),p_Var1);\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nbool sipwxListView::AcceptsFocus() const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[5]),sipPySelf,SIP_NULLPTR,sipName_AcceptsFocus);\n\n    if (!sipMeth)\n        return  ::wxListView::AcceptsFocus();\n\n    extern bool sipVH__core_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);\n\n    return sipVH__core_5(sipGILState, 0, sipPySelf, sipMeth);\n}\n\n## Example:\n\n Input code:\nvoid __thiscall sipwxFontPickerCtrl::AcceptsFocusFromKeyboard(sipwxFontPickerCtrl *this)\n{\n  char cVar1;\n  _object *p_Var2;\n  long in_FS_OFFSET;\n  PyGILState_STATE local_24;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  p_Var2 = (_object *)\n           (**(code **)(sipAPI__core + 0x2c8))\n                     (&local_24,this + 0x316,*(undefined8 *)(this + 0x308),0,\n                      \"AcceptsFocusFromKeyboard\");\n  if (p_Var2 == (_object *)0x0) {\n    cVar1 = wxControlContainerBase::AcceptsFocus();\n    if ((cVar1 == '\\0') && (this[0x2e1] != (sipwxFontPickerCtrl)0x0)) {\n      wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n    }\n  }\n  else {\n    sipVH__core_5(local_24,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0,\n                  *(_sipSimpleWrapper **)(this + 0x308),p_Var2);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nbool sipwxFontPickerCtrl::AcceptsFocusFromKeyboard() const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[6]),sipPySelf,SIP_NULLPTR,sipName_AcceptsFocusFromKeyboard);\n\n    if (!sipMeth)\n        return  ::wxFontPickerCtrl::AcceptsFocusFromKeyboard();\n\n    extern bool sipVH__core_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);\n\n    return sipVH__core_5(sipGILState, 0, sipPySelf, sipMeth);\n}\n\n## Example:\n\n Input code:\nvoid __thiscall sipwxWizard::DoGetClientSize(sipwxWizard *this,int *param_1,int *param_2)\n{\n  _object *p_Var1;\n  PyGILState_STATE local_c;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__adv + 0x2c8))\n                     (&local_c,this + 0x45f,*(undefined8 *)(this + 0x440),0,\"DoGetClientSize\");\n  if (p_Var1 == (_object *)0x0) {\n    wxTopLevelWindowGTK::DoGetClientSize((int *)this,param_1);\n  }\n  else {\n    sipVH__adv_19(local_c,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0,\n                  *(_sipSimpleWrapper **)(this + 0x440),p_Var1,param_1,param_2);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid sipwxWizard::DoGetClientSize(int*width,int*height) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[23]),sipPySelf,SIP_NULLPTR,sipName_DoGetClientSize);\n\n    if (!sipMeth)\n    {\n         ::wxWizard::DoGetClientSize(width,height);\n        return;\n    }\n\n    extern void sipVH__adv_19(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);\n\n    sipVH__adv_19(sipGILState, 0, sipPySelf, sipMeth, width, height);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall sipwxScrolledWindow::AcceptsFocusRecursively(sipwxScrolledWindow *this)\n{\n  _object *p_Var1;\n  int iVar2;\n  PyGILState_STATE local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__core + 0x164))\n                     (&local_18,this + 0x223,*(undefined4 *)(this + 0x200),0,\n                      \"AcceptsFocusRecursively\");\n  if (p_Var1 == (_object *)0x0) {\n    iVar2 = wxControlContainerBase::AcceptsFocus();\n    if ((iVar2 == 0) && (this[0x19d] != (sipwxScrolledWindow)0x0)) {\n      wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n    }\n  }\n  else {\n    sipVH__core_5(local_18,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0,\n                  *(_sipSimpleWrapper **)(this + 0x200),p_Var1);\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```cpp\nbool sipwxScrolledWindow::AcceptsFocusRecursively() const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[5]), sipPySelf, SIP_NULLPTR, sipName_AcceptsFocusRecursively);\n\n    if (!sipMeth)\n    {\n        if (!::wxScrolledWindow::AcceptsFocus() && hasChildrenAcceptingFocus())\n            return true;\n        return false;\n    }\n\n    extern bool sipVH__core_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);\n\n    return sipVH__core_5(sipGILState, 0, sipPySelf, sipMeth);\n}\n```",
        "source_code": "bool sipwxScrolledWindow::AcceptsFocusRecursively() const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[31]),sipPySelf,SIP_NULLPTR,sipName_AcceptsFocusRecursively);\n\n    if (!sipMeth)\n        return  ::wxScrolledWindow::AcceptsFocusRecursively();\n\n    extern bool sipVH__core_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);\n\n    return sipVH__core_5(sipGILState, 0, sipPySelf, sipMeth);\n}",
        "parsed_output": "pp\nbool sipwxScrolledWindow::AcceptsFocusRecursively() const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[5]), sipPySelf, SIP_NULLPTR, sipName_AcceptsFocusRecursively);\n\n    if (!sipMeth)\n    {\n        if (!::wxScrolledWindow::AcceptsFocus() && hasChildrenAcceptingFocus())\n            return true;\n        return false;\n    }\n\n    extern bool sipVH__core_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);\n\n    return sipVH__core_5(sipGILState, 0, sipPySelf, sipMeth);\n}",
        "baseline_code_stripped": "void __thiscall sipwxScrolledWindow::AcceptsFocusRecursively(sipwxScrolledWindow *this)\n{\n  _object *p_Var1;\n  int iVar2;\n  PyGILState_STATE local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__core + 0x164))\n                     (&local_18,this + 0x223,*(undefined4 *)(this + 0x200),0,\n                      \"AcceptsFocusRecursively\");\n  if (p_Var1 == (_object *)0x0) {\n    iVar2 = wxControlContainerBase::AcceptsFocus();\n    if ((iVar2 == 0) && (this[0x19d] != (sipwxScrolledWindow)0x0)) {\n      wxControlContainerBase::HasAnyChildrenAcceptingFocus();\n    }\n  }\n  else {\n    sipVH__core_5(local_18,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)0x0,\n                  *(_sipSimpleWrapper **)(this + 0x200),p_Var1);\n  }\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.9690014719963074,
        "similarity_score_baseline_stripped": 0.8062808513641357
    },
    {
        "func_name": "list_proxy",
        "normed_func_sha256": "a8dcc98c790ab023e80287e34d6bada9230b6bc50b21ad8c3133ef0ea80b47d0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool FUN_00106cd0(long *param_1,undefined8 param_2,undefined4 param_3)\n{\n  int iVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  bool bVar3;\n  undefined8 local_48;\n  undefined local_3c [2];\n  undefined local_3a [2];\n  char local_38;\n  char local_37;\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00105ec0(param_2,param_3,0,local_3c,0xc);\n  if (iVar1 != 0) {\n    iVar2 = byte_diff(local_3c,2,*param_1 + 2);\n    if (((iVar2 == 0) && (local_38 == '\\0')) && (local_37 == '\\x01')) {\n      local_48 = 0;\n      iVar1 = FUN_00105fa0(param_2,param_3,iVar1,&local_48);\n      if (iVar1 != 0) {\n        iVar2 = FUN_00107970(local_48,*param_1 + 0xe);\n        if (iVar2 == 0) {\n          alloc_free(local_48);\n        }\n        else {\n          alloc_free(local_48);\n          iVar1 = FUN_00105ec0(param_2,param_3,iVar1,local_3c,4);\n          if (iVar1 != 0) {\n            iVar1 = byte_diff(local_3c,2,(long)param_1 + 0x6c);\n            if (iVar1 == 0) {\n              iVar1 = byte_diff(local_3a,2,&DAT_0010a660);\n              bVar3 = iVar1 != 0;\n              goto LAB_00106d19;\n            }\n          }\n        }\n      }\n    }\n  }\n  bVar3 = true;\nLAB_00106d19:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar3;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic int\nirrelevant(struct dns_transmit *d, char *buf, unsigned int len)\n{\n\tchar            out[12];\n\tchar           *dn;\n\tunsigned int    pos;\n\n\tpos = dns_packet_copy(buf, len, 0, out, 12);\n\tif (!pos)\n\t\treturn 1;\n\tif (byte_diff(out, 2, d->query + 2))\n\t\treturn 1;\n\tif (out[4] != 0)\n\t\treturn 1;\n\tif (out[5] != 1)\n\t\treturn 1;\n\tdn = 0;\n\tpos = dns_packet_getname(buf, len, pos, &dn);\n\tif (!pos)\n\t\treturn 1;\n\tif (!dns_domain_equal(dn, d->query + 14)) {\n\t\talloc_free(dn);\n\t\treturn 1;\n\t}\n\talloc_free(dn);\n\tpos = dns_packet_copy(buf, len, pos, out, 4);\n\tif (!pos)\n\t\treturn 1;\n\tif (byte_diff(out, 2, d->qtype))\n\t\treturn 1;\n\tif (byte_diff(out + 2, 2, DNS_C_IN))\n\t\treturn 1;\n\treturn 0;\n}\n\n## Example:\n\n Input code:\nint FUN_0010dad0(long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4)\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  long local_68;\n  undefined8 local_60;\n  undefined local_58 [24];\n  long local_40;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*(int *)(param_1 + 0x4e8) == 0) {\n    iVar1 = (**(code **)(DAT_00148d90 + 0x928))\n                      (param_2,s_namespace_eval___itcl___proc__fi_00148020,0xffffffff,0);\n    if (iVar1 != 0) goto LAB_0010dc49;\n    *(undefined4 *)(param_1 + 0x4e8) = 1;\n  }\n  iVar1 = (**(code **)(DAT_00148d90 + 0x930))(param_2,param_3,param_4,0);\n  local_60 = 0;\n  iVar2 = FUN_0011bf10(param_2,&local_60,&local_68);\n  if (iVar2 == 0) {\n    lVar3 = (**(code **)(DAT_00148d90 + 0x498))(local_68 + 0x180,local_58);\n    while (lVar3 != 0) {\n      uVar4 = (**(code **)(DAT_00148d90 + 0x158))(**(undefined8 **)(lVar3 + 0x18),0);\n      __fprintf_chk(_stderr,2,\"delopt!%s!\\n\",uVar4);\n      lVar3 = (**(code **)(DAT_00148d90 + 0x618))(local_58);\n    }\n    lVar3 = (**(code **)(DAT_00148d90 + 0x498))(local_68 + 0x78,local_58);\n    while (lVar3 != 0) {\n      uVar4 = (**(code **)(DAT_00148d90 + 0x158))(**(undefined8 **)(lVar3 + 0x18),0);\n      __fprintf_chk(_stderr,2,\"opt!%s!\\n\",uVar4);\n      lVar3 = (**(code **)(DAT_00148d90 + 0x618))(local_58);\n    }\n  }\n  else {\n    iVar1 = 1;\n  }\nLAB_0010dc49:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic int\nItcl_BiInitOptionsCmd(\n    void *clientData,   /* info for all known objects */\n    Tcl_Interp *interp,      /* current interpreter */\n    int objc,                /* number of arguments */\n    Tcl_Obj *const objv[])   /* argument objects */\n{\n    int result;\n    ItclObjectInfo *infoPtr = (ItclObjectInfo*)clientData;\n    ItclClass *iclsPtr;\n    ItclObject *ioPtr;\n    ItclDelegatedOption *idoptPtr;\n    ItclOption *ioptPtr;\n    FOREACH_HASH_DECLS;\n\n    /* instead ::itcl::builtin::initoptions in ../library/itclHullCmds.tcl is used !! */\n    ItclShowArgs(1, \"Itcl_BiInitOptionsCmd\", objc, objv);\n    if (!infoPtr->itclHullCmdsInitted) {\n        result =  Tcl_EvalEx(interp, initHullCmdsScript, -1, 0);\n        if (result != TCL_OK) {\n            return result;\n        }\n        infoPtr->itclHullCmdsInitted = 1;\n    }\n    result = Tcl_EvalObjv(interp, objc, objv, 0);\n    iclsPtr = NULL;\n    if (Itcl_GetContext(interp, &iclsPtr, &ioPtr) != TCL_OK) {\n        return TCL_ERROR;\n    }\n    /* first handle delegated options */\n    FOREACH_HASH_VALUE(idoptPtr, &ioPtr->objectDelegatedOptions) {\nfprintf(stderr, \"delopt!%s!\\n\", Tcl_GetString(idoptPtr->namePtr));\n    }\n    FOREACH_HASH_VALUE(ioptPtr, &ioPtr->objectOptions) {\nfprintf(stderr, \"opt!%s!\\n\", Tcl_GetString(ioptPtr->namePtr));\n    }\n    return result;\n}\n\n## Example:\n\n Input code:\nint FUN_001cc535(uint param_1)\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  int local_2c;\n  undefined8 *local_28;\n  undefined8 *local_20;\n  char local_14 [4];\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2c = 0;\n  if (param_1 == 0) {\n    for (local_28 = DAT_002f1160; local_28 != (undefined8 *)0x0; local_28 = (undefined8 *)*local_28)\n    {\n      for (local_20 = (undefined8 *)local_28[2]; local_20 != (undefined8 *)0x0;\n          local_20 = (undefined8 *)*local_20) {\n        FUN_001cc30a(local_20,(long)local_28 + 0xc);\n        local_2c = local_2c + 1;\n      }\n    }\n  }\n  else {\n    sprintf(local_14,\"%3.3d\",(ulong)param_1);\n    lVar1 = FUN_001ce3ba(param_1);\n    if (lVar1 != 0) {\n      for (local_20 = *(undefined8 **)(lVar1 + 0x10); local_20 != (undefined8 *)0x0;\n          local_20 = (undefined8 *)*local_20) {\n        FUN_001cc30a(local_20,lVar1 + 0xc);\n        local_2c = local_2c + 1;\n      }\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_2c;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic int show_numeric_list (int numeric)\n{\n\tNumericList *tmp;\n\tHook\t*list;\n\tchar\tbuf[4];\n\tint\tcnt = 0;\n\n\tif (numeric)\n\t{\n\t\tsprintf(buf, \"%3.3d\", numeric);\n\t\tif ((tmp = find_numeric_list(numeric)))\n\t\t{\n\t\t\tfor (list = tmp->list; list; list = list->next, cnt++)\n\t\t\t\tshow_hook(list, tmp->name);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (tmp = numeric_list; tmp; tmp = tmp->next)\n\t\t{\n\t\t\tfor (list = tmp->list; list; list = list->next, cnt++)\n\t\t\t\tshow_hook(list, tmp->name);\n\t\t}\n\t}\n\treturn (cnt);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0010bf30(undefined8 param_1,undefined8 param_2,undefined8 *param_3)\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  char *pcVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  long in_FS_OFFSET;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  byte *local_28;\n  long local_20;\n  bVar9 = 0;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar4 = \"anonymous\";\n  if (DAT_0011ae88 != 0) {\n    pcVar4 = DAT_0011ae90;\n  }\n  lVar2 = FUN_001108f0(param_1,&PTR_DAT_0011a020,pcVar4,&DAT_0011a480,&DAT_0011a488,0,DAT_0011ae68);\n  if (lVar2 != 0) {\n    prot_printf(*(undefined8 *)(lVar2 + 0x960),\"LIST %s %s\\r\\n\",*param_3,param_3[1]);\n    iVar1 = FUN_0010bea0(lVar2,&local_28);\n    bVar7 = false;\n    bVar8 = iVar1 == 0;\n    if (bVar8) {\n      lVar3 = 4;\n      pbVar5 = local_28;\n      pbVar6 = &DAT_0011446a;\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar5 < *pbVar6;\n        bVar8 = *pbVar5 == *pbVar6;\n        pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n        pbVar6 = pbVar6 + (ulong)bVar9 * -2 + 1;\n      } while (bVar8);\n      if ((!bVar7 && !bVar8) == bVar7) {\n        iVar1 = FUN_0010bea0(lVar2,&local_28);\n        while ((iVar1 == 0 && (*local_28 != 0x2e))) {\n          prot_printf(DAT_0011ae70,\"%s\");\n          iVar1 = FUN_0010bea0(lVar2,&local_28);\n        }\n      }\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nstatic void process_list_command(void *connection, void *output, char **args)\n{\n    int result;\n    long session;\n    char *username = \"anonymous\";\n    byte *line;\n    long stack_check;\n\n    stack_check = *(long *)(__builtin_frame_address(0) + 0x28);\n\n    if (global_username_flag != 0) {\n        username = global_username;\n    }\n\n    session = initialize_session(connection, &session_data, username, &session_param1, &session_param2, 0, global_session_flag);\n    if (session != 0) {\n        prot_printf(*(void **)(session + 0x960), \"LIST %s %s\\r\\n\", args[0], args[1]);\n        result = read_line(session, &line);\n\n        if (result == 0) {\n            if (memcmp(line, \"OK\\r\\n\", 4) == 0) {\n                while ((result = read_line(session, &line)) == 0 && *line != '.') {\n                    prot_printf(global_output, \"%s\");\n                }\n            }\n        }\n    }\n\n    if (stack_check != *(long *)(__builtin_frame_address(0) + 0x28)) {\n        __stack_chk_fail();\n    }\n}\n```",
        "source_code": "static void list_proxy(const char *server,\n                       void *data __attribute__((unused)), void *rock)\n{\n    struct enum_rock *erock = (struct enum_rock *) rock;\n    struct backend *be;\n    int r;\n    char *result;\n    be = proxy_findserver(server, &nntp_protocol,\n                          nntp_authstate ? nntp_userid : \"anonymous\",\n                          &backend_cached, &backend_current, NULL, nntp_in);\n    if (!be) return;\n    prot_printf(be->out, \"LIST %s %s\\r\\n\", erock->cmd, erock->wild);\n    r = read_response(be, 0, &result);\n    if (!r && !strncmp(result, \"215 \", 4)) {\n        while (!(r = read_response(be, 0, &result)) && result[0] != '.') {\n            prot_printf(nntp_out, \"%s\", result);\n        }\n    }\n}",
        "parsed_output": "static void process_list_command(void *connection, void *output, char **args)\n{\n    int result;\n    long session;\n    char *username = \"anonymous\";\n    byte *line;\n    long stack_check;\n\n    stack_check = *(long *)(__builtin_frame_address(0) + 0x28);\n\n    if (global_username_flag != 0) {\n        username = global_username;\n    }\n\n    session = initialize_session(connection, &session_data, username, &session_param1, &session_param2, 0, global_session_flag);\n    if (session != 0) {\n        prot_printf(*(void **)(session + 0x960), \"LIST %s %s\\r\\n\", args[0], args[1]);\n        result = read_line(session, &line);\n\n        if (result == 0) {\n            if (memcmp(line, \"OK\\r\\n\", 4) == 0) {\n                while ((result = read_line(session, &line)) == 0 && *line != '.') {\n                    prot_printf(global_output, \"%s\");\n                }\n            }\n        }\n    }\n\n    if (stack_check != *(long *)(__builtin_frame_address(0) + 0x28)) {\n        __stack_chk_fail();\n    }\n}",
        "baseline_code_stripped": "void FUN_0010bf30(undefined8 param_1,undefined8 param_2,undefined8 *param_3)\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  char *pcVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  long in_FS_OFFSET;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  byte *local_28;\n  long local_20;\n  bVar9 = 0;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar4 = \"anonymous\";\n  if (DAT_0011ae88 != 0) {\n    pcVar4 = DAT_0011ae90;\n  }\n  lVar2 = FUN_001108f0(param_1,&PTR_DAT_0011a020,pcVar4,&DAT_0011a480,&DAT_0011a488,0,DAT_0011ae68);\n  if (lVar2 != 0) {\n    prot_printf(*(undefined8 *)(lVar2 + 0x960),\"LIST %s %s\\r\\n\",*param_3,param_3[1]);\n    iVar1 = FUN_0010bea0(lVar2,&local_28);\n    bVar7 = false;\n    bVar8 = iVar1 == 0;\n    if (bVar8) {\n      lVar3 = 4;\n      pbVar5 = local_28;\n      pbVar6 = &DAT_0011446a;\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar5 < *pbVar6;\n        bVar8 = *pbVar5 == *pbVar6;\n        pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n        pbVar6 = pbVar6 + (ulong)bVar9 * -2 + 1;\n      } while (bVar8);\n      if ((!bVar7 && !bVar8) == bVar7) {\n        iVar1 = FUN_0010bea0(lVar2,&local_28);\n        while ((iVar1 == 0 && (*local_28 != 0x2e))) {\n          prot_printf(DAT_0011ae70,\"%s\");\n          iVar1 = FUN_0010bea0(lVar2,&local_28);\n        }\n      }\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.7199664115905762,
        "similarity_score_baseline_stripped": 0.5603045225143433
    },
    {
        "func_name": "R_swig_FbcAnd_getAssociation__SWIG_1",
        "normed_func_sha256": "163478e34f4a479021cd20133268322d1faaa79a581ed237cad4937ed8b97982",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined4 R_swig_ListOfSpecies_get__SWIG_3(undefined4 param_1,SEXPREC *param_2)\n{\n  int *piVar1;\n  void **ppvVar2;\n  undefined4 uVar3;\n  int iVar4;\n  uint uVar5;\n  undefined4 uVar6;\n  char *pcVar7;\n  int *local_2c;\n  void **local_28;\n  int local_24;\n  local_24 = __stack_chk_guard;\n  local_2c = (int *)0x0;\n  uVar3 = vmaxget();\n  iVar4 = SWIG_R_ConvertPtr(param_1,&local_2c,DAT_00ce4450,0);\n  piVar1 = local_2c;\n  if (iVar4 < 0) {\n    pcVar7 = \"in method \\'ListOfSpecies_get\\', argument 1 of type \\'ListOfSpecies const *\\'\";\n  }\n  else {\n    local_28 = (void **)0x0;\n    uVar5 = SWIG_AsPtr_std_string(param_2,(basic_string **)&local_28);\n    ppvVar2 = local_28;\n    if ((int)uVar5 < 0) {\n      pcVar7 = \"in method \\'ListOfSpecies_get\\', argument 2 of type \\'std::string const &\\'\";\n    }\n    else {\n      if (local_28 != (void **)0x0) {\n        iVar4 = (**(code **)(*piVar1 + 0x178))(piVar1,local_28);\n        uVar6 = R_NilValue;\n        if (iVar4 != 0) {\n          uVar6 = R_MakeExternalPtr(DAT_00ce468c,R_NilValue);\n          uVar6 = R_MakeExternalPtr(iVar4,uVar6,R_NilValue);\n          SET_S4_OBJECT();\n        }\n        if ((uVar5 & 0x200) != 0) {\n          if ((void **)*ppvVar2 != ppvVar2 + 2) {\n            operator_delete(*ppvVar2,(int)ppvVar2[2] + 1);\n          }\n          operator_delete(ppvVar2,0x18);\n        }\n        vmaxset(uVar3);\n        goto LAB_003fd9d4;\n      }\n      pcVar7 = \n      \"invalid null reference in method \\'ListOfSpecies_get\\', argument 2 of type \\'std::string const &\\'\"\n      ;\n    }\n  }\n  Rf_warning(pcVar7);\n  uVar6 = Rf_ScalarLogical(R_NaInt);\nLAB_003fd9d4:\n  if (local_24 != __stack_chk_guard) {\n    __stack_chk_fail();\n  }\n  return uVar6;\n}\n\n Revised code:\nSWIGEXPORT SEXP\nR_swig_ListOfSpecies_get__SWIG_3 ( SEXP self, SEXP sid)\n{\n  Species *result = 0 ;\n  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;\n  std::string *arg2 = 0 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  int res2 = SWIG_OLDOBJ ;\n  unsigned int r_nprotect = 0;\n  SEXP r_ans = R_NilValue ;\n  VMAXTYPE r_vmax = vmaxget() ;\n  \n  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_ListOfSpecies, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"ListOfSpecies_get\" \"', argument \" \"1\"\" of type '\" \"ListOfSpecies const *\"\"'\"); \n  }\n  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);\n  {\n    std::string *ptr = (std::string *)0;\n    res2 = SWIG_AsPtr_std_string(sid, &ptr);\n    if (!SWIG_IsOK(res2)) {\n      SWIG_exception_fail(SWIG_ArgError(res2), \"in method '\" \"ListOfSpecies_get\" \"', argument \" \"2\"\" of type '\" \"std::string const &\"\"'\"); \n    }\n    if (!ptr) {\n      SWIG_exception_fail(SWIG_ValueError, \"invalid null reference \" \"in method '\" \"ListOfSpecies_get\" \"', argument \" \"2\"\" of type '\" \"std::string const &\"\"'\"); \n    }\n    arg2 = ptr;\n  }\n  result = (Species *)((ListOfSpecies const *)arg1)->get((std::string const &)*arg2);\n  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );\n  \n  if (SWIG_IsNewObj(res2)) delete arg2;\n  vmaxset(r_vmax);\n  if(r_nprotect)  Rf_unprotect(r_nprotect);\n  \n  return r_ans;\n}\n\n## Example:\n\n Input code:\nundefined8 R_swig_SedListOfSurfaces_get__SWIG_0(undefined8 param_1,undefined8 param_2)\n{\n  long *plVar1;\n  undefined4 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  long lVar5;\n  long *local_10;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  local_10 = (long *)0x0;\n  uVar3 = vmaxget(&__stack_chk_guard,0);\n  uVar4 = SWIG_R_ConvertPtr_lto_priv_0(param_1,&local_10,DAT_0049ea30,0);\n  plVar1 = local_10;\n  if ((int)uVar4 < 0) {\n    if ((int)uVar4 == -1) {\n      uVar4 = 0xfffffffb;\n    }\n    SWIG_Error_lto_priv_0\n              (uVar4,\n               \"in method \\'SedListOfSurfaces_get\\', argument 1 of type \\'SedListOfSurfaces *\\'\");\n    uVar3 = SWIG_ErrorType_lto_priv_0(DAT_0049ecb0);\n    Rf_error(\"%s %s\",uVar3,&DAT_0049ecb8);\n  }\n  uVar2 = Rf_asInteger(param_2);\n  if (*(code **)(*plVar1 + 0x158) == SedListOfSurfaces::get) {\n    lVar5 = SedListOf::get((uint)plVar1);\n  }\n  else {\n    lVar5 = (**(code **)(*plVar1 + 0x158))(plVar1,uVar2);\n  }\n  uVar4 = _R_NilValue;\n  if (lVar5 != 0) {\n    uVar4 = R_MakeExternalPtr(DAT_0049eae0,_R_NilValue,_R_NilValue);\n    uVar4 = R_MakeExternalPtr(lVar5,uVar4,_R_NilValue);\n    SET_S4_OBJECT();\n  }\n  vmaxset(uVar3);\n  if (local_8 == ___stack_chk_guard) {\n    return uVar4;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nSWIGEXPORT SEXP\nR_swig_SedListOfSurfaces_get__SWIG_0 ( SEXP self, SEXP n)\n{\n  SedSurface *result = 0 ;\n  SedListOfSurfaces *arg1 = (SedListOfSurfaces *) 0 ;\n  unsigned int arg2 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  int val2 ;\n  int ecode2 = 0 ;\n  unsigned int r_nprotect = 0;\n  SEXP r_ans = R_NilValue ;\n  VMAXTYPE r_vmax = vmaxget() ;\n  \n  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_SedListOfSurfaces, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"SedListOfSurfaces_get\" \"', argument \" \"1\"\" of type '\" \"SedListOfSurfaces *\"\"'\"); \n  }\n  arg1 = reinterpret_cast< SedListOfSurfaces * >(argp1);\n  ecode2 = SWIG_AsVal_int(n, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"SedListOfSurfaces_get\" \"', argument \" \"2\"\" of type '\" \"unsigned int\"\"'\");\n  } \n  arg2 = static_cast< unsigned int >(val2);\n  result = (SedSurface *)(arg1)->get(arg2);\n  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SedSurface, 0 |  0 );\n  vmaxset(r_vmax);\n  if(r_nprotect)  Rf_unprotect(r_nprotect);\n  \n  return r_ans;\n  fail: SWIGUNUSED;\n  Rf_error(\"%s %s\", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);\n  return R_NilValue;\n}\n\n## Example:\n\n Input code:\nundefined4 R_swig_ListOfCurveElements_remove__SWIG_0(undefined4 param_1,undefined4 param_2)\n{\n  int *piVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  SBase *pSVar5;\n  undefined4 uVar6;\n  int *local_38;\n  undefined *local_34 [2];\n  undefined auStack_2c [16];\n  int local_1c;\n  local_1c = __stack_chk_guard;\n  local_38 = (int *)0x0;\n  uVar2 = vmaxget();\n  iVar3 = SWIG_R_ConvertPtr(param_1,&local_38,DAT_00c3e3a4,0);\n  piVar1 = local_38;\n  if (iVar3 < 0) {\n    Rf_warning(\n              \"in method \\'ListOfCurveElements_remove\\', argument 1 of type \\'ListOfCurveElements *\\'\"\n              );\n    uVar4 = Rf_ScalarLogical(R_NaInt);\n  }\n  else {\n    uVar4 = Rf_asInteger(param_2);\n    pSVar5 = (SBase *)(**(code **)(*piVar1 + 0x168))(piVar1,uVar4);\n    local_34[0] = auStack_2c;\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_34,\"render\",(forward_iterator_tag)\"\");\n    uVar6 = GetDowncastSwigTypeForPackage(pSVar5,(basic_string *)local_34);\n    uVar4 = R_NilValue;\n    if (pSVar5 != (SBase *)0x0) {\n      uVar4 = R_MakeExternalPtr(uVar6,R_NilValue,R_NilValue);\n      uVar4 = R_MakeExternalPtr(pSVar5,uVar4,R_NilValue);\n      SET_S4_OBJECT();\n    }\n    if (local_34[0] != auStack_2c) {\n      operator_delete(local_34[0]);\n    }\n    vmaxset(uVar2);\n  }\n  if (local_1c == __stack_chk_guard) {\n    return uVar4;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nSWIGEXPORT SEXP\nR_swig_ListOfCurveElements_remove__SWIG_0 ( SEXP self, SEXP n)\n{\n  RenderPoint *result = 0 ;\n  ListOfCurveElements *arg1 = (ListOfCurveElements *) 0 ;\n  unsigned int arg2 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  int val2 ;\n  int ecode2 = 0 ;\n  unsigned int r_nprotect = 0;\n  SEXP r_ans = R_NilValue ;\n  VMAXTYPE r_vmax = vmaxget() ;\n  \n  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_ListOfCurveElements, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"ListOfCurveElements_remove\" \"', argument \" \"1\"\" of type '\" \"ListOfCurveElements *\"\"'\"); \n  }\n  arg1 = reinterpret_cast< ListOfCurveElements * >(argp1);\n  ecode2 = SWIG_AsVal_int(n, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"ListOfCurveElements_remove\" \"', argument \" \"2\"\" of type '\" \"unsigned int\"\"'\");\n  } \n  arg2 = static_cast< unsigned int >(val2);\n  result = (RenderPoint *)(arg1)->remove(arg2);\n  {\n    r_ans = SWIG_R_NewPointerObj(result, GetDowncastSwigTypeForPackage(result, \"render\"), SWIG_POINTER_OWN |  0 );\n  }\n  \n  \n  vmaxset(r_vmax);\n  if(r_nprotect)  Rf_unprotect(r_nprotect);\n  \n  return r_ans;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 R_swig_FbcAnd_getAssociation__SWIG_1(undefined4 param_1,undefined4 param_2)\n{\n  FbcAnd *this;\n  undefined4 uVar1;\n  int iVar2;\n  uint uVar3;\n  SBase *pSVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  FbcAnd *local_40;\n  int *local_3c;\n  undefined4 local_38;\n  int local_34 [4];\n  int local_24;\n  local_24 = __stack_chk_guard;\n  local_40 = (FbcAnd *)0x0;\n  uVar1 = vmaxget();\n  iVar2 = SWIG_R_ConvertPtr_lto_priv_0(param_1,&local_40,DAT_00c20584,0);\n  this = local_40;\n  if (iVar2 < 0) {\n    if (iVar2 == -1) {\n      iVar2 = -5;\n    }\n    SWIG_Error_lto_priv_0\n              (iVar2,\"in method \\'FbcAnd_getAssociation\\', argument 1 of type \\'FbcAnd const *\\'\");\n    uVar1 = SWIG_ErrorType_lto_priv_0(DAT_00c20adc);\n    Rf_error(\"%s %s\",uVar1,&DAT_00c20ae0);\n  }\n  uVar3 = Rf_asInteger(param_2);\n  pSVar4 = (SBase *)FbcAnd::getAssociation(this,uVar3);\n  local_34[0] = 0x636266;\n  local_38 = 3;\n  local_3c = local_34;\n  uVar5 = GetDowncastSwigTypeForPackage(pSVar4,(basic_string *)&local_3c);\n  uVar6 = R_NilValue;\n  if (pSVar4 != (SBase *)0x0) {\n    uVar6 = R_MakeExternalPtr(uVar5,R_NilValue,R_NilValue);\n    uVar6 = R_MakeExternalPtr(pSVar4,uVar6,R_NilValue);\n    SET_S4_OBJECT();\n  }\n  if (local_3c != local_34) {\n    operator_delete(local_3c,local_34[0] + 1);\n  }\n  vmaxset(uVar1);\n  if (local_24 == __stack_chk_guard) {\n    return uVar6;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nSWIGEXPORT SEXP\nR_swig_FbcAnd_getAssociation__SWIG_1 (SEXP self, SEXP n)\n{\n  SBase *result = 0;\n  FbcAnd const *arg1 = (FbcAnd const *)0;\n  unsigned int arg2;\n  void *argp1 = 0;\n  int res1 = 0;\n  int val2;\n  int ecode2 = 0;\n  unsigned int r_nprotect = 0;\n  SEXP r_ans = R_NilValue;\n  VMAXTYPE r_vmax = vmaxget();\n\n  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_FbcAnd, 0 | 0);\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"FbcAnd_getAssociation\" \"', argument \" \"1\"\" of type '\" \"FbcAnd const *\"\"'\");\n  }\n  arg1 = reinterpret_cast<FbcAnd const *>(argp1);\n  ecode2 = SWIG_AsVal_int(n, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"FbcAnd_getAssociation\" \"', argument \" \"2\"\" of type '\" \"unsigned int\"\"'\");\n  }\n  arg2 = static_cast<unsigned int>(val2);\n  result = (SBase const *)(arg1)->getAssociation(arg2);\n  {\n    r_ans = SWIG_R_NewPointerObj(result, GetDowncastSwigTypeForPackage(result, \"cbf\"), SWIG_POINTER_OWN | 0);\n  }\n\n  vmaxset(r_vmax);\n  if (r_nprotect) Rf_unprotect(r_nprotect);\n\n  return r_ans;\n  fail: SWIGUNUSED;\n  Rf_error(\"%s %s\", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);\n  return R_NilValue;\n}\n```",
        "source_code": "SWIGEXPORT SEXP\nR_swig_FbcAnd_getAssociation__SWIG_1 ( SEXP self, SEXP n)\n{\n  FbcAssociation *result = 0 ;\n  FbcAnd *arg1 = (FbcAnd *) 0 ;\n  unsigned int arg2 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  int val2 ;\n  int ecode2 = 0 ;\n  unsigned int r_nprotect = 0;\n  SEXP r_ans = R_NilValue ;\n  VMAXTYPE r_vmax = vmaxget() ;\n  \n  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_FbcAnd, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"FbcAnd_getAssociation\" \"', argument \" \"1\"\" of type '\" \"FbcAnd const *\"\"'\"); \n  }\n  arg1 = reinterpret_cast< FbcAnd * >(argp1);\n  ecode2 = SWIG_AsVal_int(n, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"FbcAnd_getAssociation\" \"', argument \" \"2\"\" of type '\" \"unsigned int\"\"'\");\n  } \n  arg2 = static_cast< unsigned int >(val2);\n  result = (FbcAssociation *)((FbcAnd const *)arg1)->getAssociation(arg2);\n  {\n    r_ans = SWIG_R_NewPointerObj(result, GetDowncastSwigTypeForPackage(result, \"fbc\"), 0 |  0 );\n  }\n  vmaxset(r_vmax);\n  if(r_nprotect)  Rf_unprotect(r_nprotect);\n  \n  return r_ans;\n  fail: SWIGUNUSED;\n  Rf_error(\"%s %s\", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);\n  return R_NilValue;\n}",
        "parsed_output": "SWIGEXPORT SEXP\nR_swig_FbcAnd_getAssociation__SWIG_1 (SEXP self, SEXP n)\n{\n  SBase *result = 0;\n  FbcAnd const *arg1 = (FbcAnd const *)0;\n  unsigned int arg2;\n  void *argp1 = 0;\n  int res1 = 0;\n  int val2;\n  int ecode2 = 0;\n  unsigned int r_nprotect = 0;\n  SEXP r_ans = R_NilValue;\n  VMAXTYPE r_vmax = vmaxget();\n\n  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_FbcAnd, 0 | 0);\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"FbcAnd_getAssociation\" \"', argument \" \"1\"\" of type '\" \"FbcAnd const *\"\"'\");\n  }\n  arg1 = reinterpret_cast<FbcAnd const *>(argp1);\n  ecode2 = SWIG_AsVal_int(n, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"FbcAnd_getAssociation\" \"', argument \" \"2\"\" of type '\" \"unsigned int\"\"'\");\n  }\n  arg2 = static_cast<unsigned int>(val2);\n  result = (SBase const *)(arg1)->getAssociation(arg2);\n  {\n    r_ans = SWIG_R_NewPointerObj(result, GetDowncastSwigTypeForPackage(result, \"cbf\"), SWIG_POINTER_OWN | 0);\n  }\n\n  vmaxset(r_vmax);\n  if (r_nprotect) Rf_unprotect(r_nprotect);\n\n  return r_ans;\n  fail: SWIGUNUSED;\n  Rf_error(\"%s %s\", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);\n  return R_NilValue;\n}",
        "baseline_code_stripped": "undefined4 R_swig_FbcAnd_getAssociation__SWIG_1(undefined4 param_1,undefined4 param_2)\n{\n  FbcAnd *this;\n  undefined4 uVar1;\n  int iVar2;\n  uint uVar3;\n  SBase *pSVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  FbcAnd *local_40;\n  int *local_3c;\n  undefined4 local_38;\n  int local_34 [4];\n  int local_24;\n  local_24 = __stack_chk_guard;\n  local_40 = (FbcAnd *)0x0;\n  uVar1 = vmaxget();\n  iVar2 = SWIG_R_ConvertPtr_lto_priv_0(param_1,&local_40,DAT_00c20584,0);\n  this = local_40;\n  if (iVar2 < 0) {\n    if (iVar2 == -1) {\n      iVar2 = -5;\n    }\n    SWIG_Error_lto_priv_0\n              (iVar2,\"in method \\'FbcAnd_getAssociation\\', argument 1 of type \\'FbcAnd const *\\'\");\n    uVar1 = SWIG_ErrorType_lto_priv_0(DAT_00c20adc);\n    Rf_error(\"%s %s\",uVar1,&DAT_00c20ae0);\n  }\n  uVar3 = Rf_asInteger(param_2);\n  pSVar4 = (SBase *)FbcAnd::getAssociation(this,uVar3);\n  local_34[0] = 0x636266;\n  local_38 = 3;\n  local_3c = local_34;\n  uVar5 = GetDowncastSwigTypeForPackage(pSVar4,(basic_string *)&local_3c);\n  uVar6 = R_NilValue;\n  if (pSVar4 != (SBase *)0x0) {\n    uVar6 = R_MakeExternalPtr(uVar5,R_NilValue,R_NilValue);\n    uVar6 = R_MakeExternalPtr(pSVar4,uVar6,R_NilValue);\n    SET_S4_OBJECT();\n  }\n  if (local_3c != local_34) {\n    operator_delete(local_3c,local_34[0] + 1);\n  }\n  vmaxset(uVar1);\n  if (local_24 == __stack_chk_guard) {\n    return uVar6;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.9868183732032776,
        "similarity_score_baseline_stripped": 0.7560737133026123
    },
    {
        "func_name": "pyvte_register_classes",
        "normed_func_sha256": "4bd35d7a33e51270fa4b586a0ac2f1582f9738d197f34693497f65563c03b29e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined * FUN_00099130(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  code *pcVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  int local_18;\n  int local_14;\n  local_14 = 0x9913b;\n  iVar2 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"O!O!:GtkEntry.populate_popup\",&PTR_DAT_00200a0c,&DAT_001f78e0,\n                     &local_14,&DAT_001f9920,&local_18);\n  if (iVar2 != 0) {\n    uVar3 = (**(code **)(DAT_00205d58 + 0x20))(param_1);\n    uVar3 = g_type_class_ref(uVar3);\n    uVar4 = gtk_entry_get_type();\n    iVar2 = g_type_check_class_cast(uVar3,uVar4);\n    if (*(int *)(iVar2 + 0x16c) != 0) {\n      iVar2 = g_type_check_class_cast(uVar3,uVar4);\n      pcVar1 = *(code **)(iVar2 + 0x16c);\n      uVar5 = gtk_menu_get_type();\n      uVar5 = g_type_check_instance_cast(*(undefined4 *)(local_18 + 8),uVar5);\n      uVar4 = g_type_check_instance_cast(*(undefined4 *)(local_14 + 8),uVar4);\n      (*pcVar1)(uVar4,uVar5);\n      g_type_class_unref(uVar3);\n      __Py_NoneStruct = __Py_NoneStruct + 1;\n      return &_Py_NoneStruct;\n    }\n    PyErr_SetString(_PyExc_NotImplementedError,\n                    \"virtual method GtkEntry.populate_popup not implemented\");\n    g_type_class_unref(uVar3);\n  }\n  return (undefined *)0x0;\n}\n\n Revised code:\nstatic PyObject *\n_wrap_GtkEntry__do_populate_popup(PyObject *cls, PyObject *args, PyObject *kwargs)\n{\n    gpointer klass;\n    static char *kwlist[] = { \"self\", \"menu\", NULL };\n    PyGObject *self, *menu;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs,\"O!O!:GtkEntry.populate_popup\", kwlist, &PyGtkEntry_Type, &self, &PyGtkMenu_Type, &menu))\n        return NULL;\n    klass = g_type_class_ref(pyg_type_from_object(cls));\n    if (GTK_ENTRY_CLASS(klass)->populate_popup)\n        GTK_ENTRY_CLASS(klass)->populate_popup(GTK_ENTRY(self->obj), GTK_MENU(menu->obj));\n    else {\n        PyErr_SetString(PyExc_NotImplementedError, \"virtual method GtkEntry.populate_popup not implemented\");\n        g_type_class_unref(klass);\n        return NULL;\n    }\n    g_type_class_unref(klass);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\n## Example:\n\n Input code:\nvoid FUN_00547ab0(undefined8 param_1)\n{\n  ulong uVar1;\n  long lVar2;\n  undefined8 uVar3;\n  if (DAT_009603b0 == 0) {\n    uVar3 = gtk_plug_get_type();\n    DAT_009603b0 = g_type_register_static(uVar3,\"EggTrayIcon\",&DAT_008b2f40,0);\n  }\n  lVar2 = g_type_check_instance_cast(param_1,DAT_009603b0);\n  uVar1 = *(ulong *)(lVar2 + 0x140);\n  if (uVar1 != 0) {\n    uVar3 = gtk_widget_get_display(param_1);\n    uVar3 = gdk_window_lookup_for_display(uVar3,uVar1 & 0xffffffff);\n    gdk_window_remove_filter(uVar3,FUN_005481c0,lVar2);\n  }\n  uVar3 = gtk_widget_get_screen(param_1);\n  uVar3 = gdk_screen_get_root_window(uVar3);\n  gdk_window_remove_filter(uVar3,FUN_005481c0,lVar2);\n  uVar3 = gtk_widget_get_type();\n  lVar2 = g_type_check_class_cast(DAT_009609c0,uVar3);\n  if (*(long *)(lVar2 + 0xe8) != 0) {\n    lVar2 = g_type_check_class_cast(DAT_009609c0,uVar3);\n    (**(code **)(lVar2 + 0xe8))(param_1);\n    return;\n  }\n  return;\n}\n\n Revised code:\nstatic void\negg_tray_icon_unrealize (GtkWidget *widget)\n{\n#ifdef GDK_WINDOWING_X11\n  EggTrayIcon *icon = EGG_TRAY_ICON (widget);\n  GdkWindow *root_window;\n\n  if (icon->manager_window != None)\n    {\n      GdkWindow *gdkwin;\n\n      gdkwin = gdk_window_lookup_for_display (gtk_widget_get_display (widget),\n                                              icon->manager_window);\n\n      gdk_window_remove_filter (gdkwin, egg_tray_icon_manager_filter, icon);\n    }\n\n  root_window = gdk_screen_get_root_window (gtk_widget_get_screen (widget));\n\n  gdk_window_remove_filter (root_window, egg_tray_icon_manager_filter, icon);\n\n  if (GTK_WIDGET_CLASS (parent_class)->unrealize)\n    (* GTK_WIDGET_CLASS (parent_class)->unrealize) (widget);\n#else\n  wxUnusedVar(widget);\n#endif\n}\n\n## Example:\n\n Input code:\nuint convertTo_QDialogButtonBox_StandardButtons\n               (int param_1,undefined4 *param_2,int param_3,undefined4 param_4)\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined4 *puVar4;\n  uint uVar5;\n  iVar2 = *(int *)(param_1 + 4);\n  iVar1 = *(int *)(PTR_DAT_00506fa4 + 0x14);\n  if (param_3 == 0) {\n    if ((iVar2 != iVar1) && (iVar2 = PyType_IsSubtype(iVar2,iVar1), iVar2 == 0)) {\n      iVar2 = (**(code **)(DAT_0050a390 + 0x30))(param_1,PTR_DAT_00506fa8,2);\n      return (uint)(iVar2 != 0);\n    }\n    return 1;\n  }\n  if ((iVar2 != iVar1) && (iVar2 = PyType_IsSubtype(iVar2,iVar1), iVar2 == 0)) {\n    uVar3 = (**(code **)(DAT_0050a390 + 0x34))(param_1,PTR_DAT_00506fa8,param_4,2,0,param_3);\n    *param_2 = uVar3;\n    return 0;\n  }\n  uVar3 = PyInt_AsLong(param_1);\n  puVar4 = (undefined4 *)operator_new(4);\n  *puVar4 = uVar3;\n  *param_2 = puVar4;\n  uVar5 = (**(code **)(DAT_0050a390 + 0x50))();\n  return uVar5;\n}\n\n Revised code:\nstatic int convertTo_QDialogButtonBox_StandardButtons(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)\n{\n     ::QDialogButtonBox::StandardButtons **sipCppPtr = reinterpret_cast< ::QDialogButtonBox::StandardButtons **>(sipCppPtrV);\n\n#line 121 \"sip/QtCore/qglobal.sip\"\n// Allow an instance of the base enum whenever a QDialogButtonBox::StandardButtons is expected.\n\nif (sipIsErr == NULL)\n    return (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_QDialogButtonBox_StandardButton)) ||\n            sipCanConvertToType(sipPy, sipType_QDialogButtonBox_StandardButtons, SIP_NO_CONVERTORS));\n\nif (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_QDialogButtonBox_StandardButton)))\n{\n    *sipCppPtr = new QDialogButtonBox::StandardButtons(int(SIPLong_AsLong(sipPy)));\n\n    return sipGetState(sipTransferObj);\n}\n\n*sipCppPtr = reinterpret_cast<QDialogButtonBox::StandardButtons *>(sipConvertToType(sipPy, sipType_QDialogButtonBox_StandardButtons, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));\n\nreturn 0;\n#line 521 \"/builddir/build/BUILD/PyQt5_gpl-5.9/i686-redhat-linux-gnu/QtWidgets/sipQtWidgetsQDialogButtonBoxStandardButtons.cpp\"\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid pyvte_register_classes(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  iVar1 = PyImport_ImportModule(&DAT_00019d94);\n  if (iVar1 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"could not import gtk\");\n    return;\n  }\n  uVar2 = PyModule_GetDict();\n  _DAT_0002b6b4 = PyDict_GetItemString(uVar2,\"MenuShell\");\n  if (_DAT_0002b6b4 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name MenuShell from gtk\");\n    return;\n  }\n  _DAT_0002b6b0 = PyDict_GetItemString(uVar2,\"Widget\");\n  if (_DAT_0002b6b0 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name Widget from gtk\");\n    return;\n  }\n  iVar1 = PyImport_ImportModule(\"gtk.gdk\");\n  if (iVar1 != 0) {\n    uVar2 = PyModule_GetDict();\n    _DAT_0002b6b8 = PyDict_GetItemString(uVar2,\"Pixbuf\");\n    if (_DAT_0002b6b8 == 0) {\n      PyErr_SetString(_PyExc_ImportError,\"cannot import name Pixbuf from gtk.gdk\");\n    }\n    else {\n      pcVar4 = *_PyGObject_API;\n      uVar2 = vte_terminal_get_type();\n      uVar3 = Py_BuildValue(&DAT_00019e64,_DAT_0002b6b0);\n      (*pcVar4)(param_1,\"VteTerminal\",uVar2,PyVteTerminal_Type,uVar3);\n    }\n    return;\n  }\n  PyErr_SetString(_PyExc_ImportError,\"could not import gtk.gdk\");\n  return;\n}",
        "output": "```c\nstatic void\npyvte_register_classes(PyObject *module)\n{\n    PyObject *gtk_module, *gtk_dict, *gtk_gdk_module, *gtk_gdk_dict;\n    PyObject *MenuShell, *Widget, *Pixbuf;\n\n    gtk_module = PyImport_ImportModule(\"gtk\");\n    if (!gtk_module) {\n        PyErr_SetString(PyExc_ImportError, \"could not import gtk\");\n        return;\n    }\n\n    gtk_dict = PyModule_GetDict(gtk_module);\n    MenuShell = PyDict_GetItemString(gtk_dict, \"MenuShell\");\n    if (!MenuShell) {\n        PyErr_SetString(PyExc_ImportError, \"cannot import name MenuShell from gtk\");\n        return;\n    }\n\n    Widget = PyDict_GetItemString(gtk_dict, \"Widget\");\n    if (!Widget) {\n        PyErr_SetString(PyExc_ImportError, \"cannot import name Widget from gtk\");\n        return;\n    }\n\n    gtk_gdk_module = PyImport_ImportModule(\"gtk.gdk\");\n    if (gtk_gdk_module) {\n        gtk_gdk_dict = PyModule_GetDict(gtk_gdk_module);\n        Pixbuf = PyDict_GetItemString(gtk_gdk_dict, \"Pixbuf\");\n        if (!Pixbuf) {\n            PyErr_SetString(PyExc_ImportError, \"cannot import name Pixbuf from gtk.gdk\");\n        } else {\n            PyObject *vte_type = Py_BuildValue(\"(O)\", Widget);\n            _PyGObject_API[0](module, \"VteTerminal\", vte_terminal_get_type(), &PyVteTerminal_Type, vte_type);\n        }\n        return;\n    }\n\n    PyErr_SetString(PyExc_ImportError, \"could not import gtk.gdk\");\n    return;\n}\n```",
        "source_code": "void\npyvte_register_classes(PyObject *d)\n{\n    PyObject *module;\n\n    if ((module = PyImport_ImportModule(\"gtk\")) != NULL) {\n        PyObject *moddict = PyModule_GetDict(module);\n\n        _PyGtkMenuShell_Type = (PyTypeObject *)PyDict_GetItemString(moddict, \"MenuShell\");\n        if (_PyGtkMenuShell_Type == NULL) {\n            PyErr_SetString(PyExc_ImportError,\n                \"cannot import name MenuShell from gtk\");\n            return;\n        }\n        _PyGtkWidget_Type = (PyTypeObject *)PyDict_GetItemString(moddict, \"Widget\");\n        if (_PyGtkWidget_Type == NULL) {\n            PyErr_SetString(PyExc_ImportError,\n                \"cannot import name Widget from gtk\");\n            return;\n        }\n    } else {\n        PyErr_SetString(PyExc_ImportError,\n            \"could not import gtk\");\n        return;\n    }\n    if ((module = PyImport_ImportModule(\"gtk.gdk\")) != NULL) {\n        PyObject *moddict = PyModule_GetDict(module);\n\n        _PyGdkPixbuf_Type = (PyTypeObject *)PyDict_GetItemString(moddict, \"Pixbuf\");\n        if (_PyGdkPixbuf_Type == NULL) {\n            PyErr_SetString(PyExc_ImportError,\n                \"cannot import name Pixbuf from gtk.gdk\");\n            return;\n        }\n    } else {\n        PyErr_SetString(PyExc_ImportError,\n            \"could not import gtk.gdk\");\n        return;\n    }\n\n\n#line 1540 \"vte.c\"\n    pygobject_register_class(d, \"VteTerminal\", VTE_TYPE_TERMINAL, &PyVteTerminal_Type, Py_BuildValue(\"(O)\", &PyGtkWidget_Type));\n}",
        "parsed_output": "static void\npyvte_register_classes(PyObject *module)\n{\n    PyObject *gtk_module, *gtk_dict, *gtk_gdk_module, *gtk_gdk_dict;\n    PyObject *MenuShell, *Widget, *Pixbuf;\n\n    gtk_module = PyImport_ImportModule(\"gtk\");\n    if (!gtk_module) {\n        PyErr_SetString(PyExc_ImportError, \"could not import gtk\");\n        return;\n    }\n\n    gtk_dict = PyModule_GetDict(gtk_module);\n    MenuShell = PyDict_GetItemString(gtk_dict, \"MenuShell\");\n    if (!MenuShell) {\n        PyErr_SetString(PyExc_ImportError, \"cannot import name MenuShell from gtk\");\n        return;\n    }\n\n    Widget = PyDict_GetItemString(gtk_dict, \"Widget\");\n    if (!Widget) {\n        PyErr_SetString(PyExc_ImportError, \"cannot import name Widget from gtk\");\n        return;\n    }\n\n    gtk_gdk_module = PyImport_ImportModule(\"gtk.gdk\");\n    if (gtk_gdk_module) {\n        gtk_gdk_dict = PyModule_GetDict(gtk_gdk_module);\n        Pixbuf = PyDict_GetItemString(gtk_gdk_dict, \"Pixbuf\");\n        if (!Pixbuf) {\n            PyErr_SetString(PyExc_ImportError, \"cannot import name Pixbuf from gtk.gdk\");\n        } else {\n            PyObject *vte_type = Py_BuildValue(\"(O)\", Widget);\n            _PyGObject_API[0](module, \"VteTerminal\", vte_terminal_get_type(), &PyVteTerminal_Type, vte_type);\n        }\n        return;\n    }\n\n    PyErr_SetString(PyExc_ImportError, \"could not import gtk.gdk\");\n    return;\n}",
        "baseline_code_stripped": "void pyvte_register_classes(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  iVar1 = PyImport_ImportModule(&DAT_00019d94);\n  if (iVar1 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"could not import gtk\");\n    return;\n  }\n  uVar2 = PyModule_GetDict();\n  _DAT_0002b6b4 = PyDict_GetItemString(uVar2,\"MenuShell\");\n  if (_DAT_0002b6b4 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name MenuShell from gtk\");\n    return;\n  }\n  _DAT_0002b6b0 = PyDict_GetItemString(uVar2,\"Widget\");\n  if (_DAT_0002b6b0 == 0) {\n    PyErr_SetString(_PyExc_ImportError,\"cannot import name Widget from gtk\");\n    return;\n  }\n  iVar1 = PyImport_ImportModule(\"gtk.gdk\");\n  if (iVar1 != 0) {\n    uVar2 = PyModule_GetDict();\n    _DAT_0002b6b8 = PyDict_GetItemString(uVar2,\"Pixbuf\");\n    if (_DAT_0002b6b8 == 0) {\n      PyErr_SetString(_PyExc_ImportError,\"cannot import name Pixbuf from gtk.gdk\");\n    }\n    else {\n      pcVar4 = *_PyGObject_API;\n      uVar2 = vte_terminal_get_type();\n      uVar3 = Py_BuildValue(&DAT_00019e64,_DAT_0002b6b0);\n      (*pcVar4)(param_1,\"VteTerminal\",uVar2,PyVteTerminal_Type,uVar3);\n    }\n    return;\n  }\n  PyErr_SetString(_PyExc_ImportError,\"could not import gtk.gdk\");\n  return;\n}",
        "similarity_score_unixcoder": 0.9423992037773132,
        "similarity_score_baseline_stripped": 0.75553959608078
    },
    {
        "func_name": "snd_emu10k1_free",
        "normed_func_sha256": "7916cc23f04be8d9309dac74c5a2d12fe29e327d0cb85d34a8ecca374c1f4b56",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid snd_ymfpci_pcm_4ch(long param_1,undefined4 param_2)\n{\n  int iVar1;\n  long local_10;\n  iVar1 = snd_pcm_new(*(undefined8 *)(param_1 + 0x11b0),\"YMFPCI - Rear\",param_2,1,0,&local_10);\n  if (-1 < iVar1) {\n    *(long *)(local_10 + 0x748) = param_1;\n    snd_pcm_set_ops(local_10,0,snd_ymfpci_playback_4ch_ops);\n    *(undefined8 *)(local_10 + 100) = 0x2d20494350464d59;\n    *(undefined4 *)(local_10 + 0x1c) = 0;\n    *(undefined8 *)(local_10 + 0x6c) = 0x4350207261655220;\n    *(undefined2 *)(local_10 + 0x74) = 0x4d;\n    *(long *)(param_1 + 0x11d0) = local_10;\n    snd_pcm_lib_preallocate_pages_for_all\n              (local_10,2,*(long *)(param_1 + 0x11a8) + 0x98,0x10000,0x40000);\n    snd_pcm_add_chmap_ctls(local_10,0,surround_map,2,0,0);\n  }\n  return;\n}\n\n Revised code:\nint snd_ymfpci_pcm_4ch(struct snd_ymfpci *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\tif ((err = snd_pcm_new(chip->card, \"YMFPCI - Rear\", device, 1, 0, &pcm)) < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ymfpci_playback_4ch_ops);\n\n\t/* global setup */\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"YMFPCI - Rear PCM\");\n\tchip->pcm_4ch = pcm;\n\n\tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t      snd_dma_pci_data(chip->pci), 64*1024, 256*1024);\n\n\treturn snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     surround_map, 2, 0, NULL);\n}\n\n## Example:\n\n Input code:\nundefined8 snd_soc_unregister_card(undefined8 *param_1)\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  __fentry__();\n  if (*(char *)(param_1 + 0x10) == '\\0') {\n    return 0;\n  }\n  *(undefined *)(param_1 + 0x10) = 0;\n  iVar2 = 0;\n  snd_soc_dapm_shutdown();\n  if (0 < *(int *)(param_1 + 0x1e)) {\n    do {\n      lVar1 = (long)iVar2;\n      iVar2 = iVar2 + 1;\n      flush_delayed_work(lVar1 * 0x6f0 + param_1[0x1d] + 0x660);\n    } while (iVar2 < *(int *)(param_1 + 0x1e));\n  }\n  iVar2 = 0;\n  if (0 < *(int *)(param_1 + 0x22)) {\n    do {\n      iVar3 = iVar2 + 1;\n      soc_remove_aux_dev_isra_45(param_1[0x23],iVar2);\n      iVar2 = iVar3;\n    } while (iVar3 < *(int *)(param_1 + 0x22));\n  }\n  soc_remove_dai_links(param_1);\n  debugfs_remove_recursive(param_1[0x4f]);\n  if ((code *)param_1[0x13] != (code *)0x0) {\n    (*(code *)param_1[0x13])(param_1);\n  }\n  snd_soc_dapm_free(param_1 + 0x3f);\n  snd_card_free(param_1[4]);\n  if ((descriptor_43968[34] & 4) != 0) {\n    __dynamic_dev_dbg(descriptor_43968,param_1[3],\"ASoC: Unregistered card \\'%s\\'\\n\",*param_1);\n  }\n  return 0;\n}\n\n Revised code:\nint snd_soc_unregister_card(struct snd_soc_card *card)\n{\n\tif (card->instantiated) {\n\t\tcard->instantiated = false;\n\t\tsnd_soc_dapm_shutdown(card);\n\t\tsoc_cleanup_card_resources(card);\n\t\tdev_dbg(card->dev, \"ASoC: Unregistered card '%s'\\n\", card->name);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\nundefined4 snd_pcm_dump_hw_setup(int param_1,int param_2)\n{\n  undefined4 uVar1;\n  if (param_1 == 0) {\n    __assert_fail(\"pcm\",\"pcm.c\",0x6c3,\"snd_pcm_dump_hw_setup\");\n  }\n  if (param_2 != 0) {\n    if (*(int *)(param_1 + 0x20) == 0) {\n      (*(code *)snd_err_msg)(\"pcm.c\",0x6c6,\"snd_pcm_dump_hw_setup\",0,\"PCM not set up\");\n      uVar1 = 0xfffffffb;\n    }\n    else {\n      uVar1 = snd_pcm_stream_name(*(undefined4 *)(param_1 + 0xc));\n      snd_output_printf(param_2,\"  stream       : %s\\n\",uVar1);\n      uVar1 = snd_pcm_access_name(*(undefined4 *)(param_1 + 0x24));\n      snd_output_printf(param_2,\"  access       : %s\\n\",uVar1);\n      uVar1 = snd_pcm_format_name(*(undefined4 *)(param_1 + 0x28));\n      snd_output_printf(param_2,\"  format       : %s\\n\",uVar1);\n      uVar1 = snd_pcm_subformat_name(*(undefined4 *)(param_1 + 0x2c));\n      snd_output_printf(param_2,\"  subformat    : %s\\n\",uVar1);\n      snd_output_printf(param_2,\"  channels     : %u\\n\",*(undefined4 *)(param_1 + 0x30));\n      snd_output_printf(param_2,\"  rate         : %u\\n\",*(undefined4 *)(param_1 + 0x34));\n      snd_output_printf(param_2,\"  exact rate   : %g (%u/%u)\\n\",\n                        (double)(ulonglong)*(uint *)(param_1 + 0x80) /\n                        (double)(ulonglong)*(uint *)(param_1 + 0x84),*(uint *)(param_1 + 0x80),\n                        *(uint *)(param_1 + 0x84));\n      snd_output_printf(param_2,\"  msbits       : %u\\n\",*(undefined4 *)(param_1 + 0x7c));\n      snd_output_printf(param_2,\"  buffer_size  : %lu\\n\",*(undefined4 *)(param_1 + 0x90));\n      snd_output_printf(param_2,\"  period_size  : %lu\\n\",*(undefined4 *)(param_1 + 0x38));\n      snd_output_printf(param_2,\"  period_time  : %u\\n\",*(undefined4 *)(param_1 + 0x3c));\n      snd_output_printf(param_2,\"  tick_time    : %u\\n\",*(undefined4 *)(param_1 + 0x4c));\n      uVar1 = 0;\n    }\n    return uVar1;\n  }\n  __assert_fail(\"out\",\"pcm.c\",0x6c4,\"snd_pcm_dump_hw_setup\");\n}\n\n Revised code:\nint snd_pcm_dump_hw_setup(snd_pcm_t *pcm, snd_output_t *out)\n{\n\tassert(pcm);\n\tassert(out);\n\tif (CHECK_SANITY(! pcm->setup)) {\n\t\tSNDMSG(\"PCM not set up\");\n\t\treturn -EIO;\n\t}\n        snd_output_printf(out, \"  stream       : %s\\n\", snd_pcm_stream_name(pcm->stream));\n\tsnd_output_printf(out, \"  access       : %s\\n\", snd_pcm_access_name(pcm->access));\n\tsnd_output_printf(out, \"  format       : %s\\n\", snd_pcm_format_name(pcm->format));\n\tsnd_output_printf(out, \"  subformat    : %s\\n\", snd_pcm_subformat_name(pcm->subformat));\n\tsnd_output_printf(out, \"  channels     : %u\\n\", pcm->channels);\n\tsnd_output_printf(out, \"  rate         : %u\\n\", pcm->rate);\n\tsnd_output_printf(out, \"  exact rate   : %g (%u/%u)\\n\", (double) pcm->rate_num / pcm->rate_den, pcm->rate_num, pcm->rate_den);\n\tsnd_output_printf(out, \"  msbits       : %u\\n\", pcm->msbits);\n\tsnd_output_printf(out, \"  buffer_size  : %lu\\n\", pcm->buffer_size);\n\tsnd_output_printf(out, \"  period_size  : %lu\\n\", pcm->period_size);\n\tsnd_output_printf(out, \"  period_time  : %u\\n\", pcm->period_time);\n\tsnd_output_printf(out, \"  tick_time    : %u\\n\", pcm->tick_time);\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 snd_emu10k1_free(int *param_1)\n{\n  char cVar1;\n  if (*(long *)(param_1 + 2) == 0) {\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  else {\n    snd_emu10k1_fx8010_tram_setup(param_1,0);\n    snd_emu10k1_done(param_1);\n    snd_emu10k1_free_efx(param_1);\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  if (cVar1 == '\\x01') {\n    snd_emu1010_fpga_write(param_1,4,0);\n  }\n  cancel_delayed_work_sync(param_1 + 0x468);\n  release_firmware(*(undefined8 *)(param_1 + 2000));\n  release_firmware(*(undefined8 *)(param_1 + 0x7d2));\n  if (-1 < *param_1) {\n    free_irq(*param_1,param_1);\n  }\n  if (*(long *)(param_1 + 0x3e) != 0) {\n    snd_emu10k1_synth_free(param_1);\n    *(undefined8 *)(param_1 + 0x3e) = 0;\n  }\n  snd_util_memhdr_free(*(undefined8 *)(param_1 + 0x3c));\n  if (*(long *)(param_1 + 0x18) != 0) {\n    snd_dma_free_pages(param_1 + 0x14);\n  }\n  if (*(long *)(param_1 + 0x24) != 0) {\n    snd_dma_free_pages(param_1 + 0x20);\n  }\n  vfree(*(undefined8 *)(param_1 + 0x48));\n  vfree(*(undefined8 *)(param_1 + 0x4a));\n  vfree(*(undefined8 *)(param_1 + 0x7d4));\n  snd_emu10k1_efx_free_pm_buffer(param_1);\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free_pm_buffer(param_1);\n  }\n  if (*(long *)(param_1 + 2) != 0) {\n    pci_release_regions(*(undefined8 *)(param_1 + 0x19c));\n  }\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free(param_1);\n  }\n  pci_disable_device(*(undefined8 *)(param_1 + 0x19c));\n  kfree(param_1);\n  return 0;\n}",
        "output": "```c\nint snd_emu10k1_free(struct snd_emu10k1 *emu)\n{\n\tif (emu->fx8010.pcm == NULL) {\n\t\tif (emu->card->shutdown) {\n\t\t\tsnd_emu1010_fpga_write(emu, 4, 0);\n\t\t}\n\t} else {\n\t\tsnd_emu10k1_fx8010_tram_setup(emu, 0);\n\t\tsnd_emu10k1_done(emu);\n\t\tsnd_emu10k1_free_efx(emu);\n\t\tif (emu->card->shutdown) {\n\t\t\tsnd_emu1010_fpga_write(emu, 4, 0);\n\t\t}\n\t}\n\n\tcancel_delayed_work_sync(&emu->delayed_work);\n\trelease_firmware(emu->firmware);\n\trelease_firmware(emu->fx8010.firmware);\n\n\tif (emu->irq >= 0) {\n\t\tfree_irq(emu->irq, emu);\n\t}\n\n\tif (emu->synth) {\n\t\tsnd_emu10k1_synth_free(emu);\n\t\temu->synth = NULL;\n\t}\n\n\tsnd_util_memhdr_free(emu->memhdr);\n\n\tif (emu->dma_pages) {\n\t\tsnd_dma_free_pages(&emu->dma);\n\t}\n\n\tif (emu->dma_fx8010_pages) {\n\t\tsnd_dma_free_pages(&emu->dma_fx8010);\n\t}\n\n\tvfree(emu->page_ptr);\n\tvfree(emu->fx8010.page_ptr);\n\tvfree(emu->fx8010.code);\n\n\tsnd_emu10k1_efx_free_pm_buffer(emu);\n\n\tif (emu->card->p16v) {\n\t\tsnd_p16v_free_pm_buffer(emu);\n\t}\n\n\tif (emu->fx8010.pcm) {\n\t\tpci_release_regions(emu->pci);\n\t}\n\n\tif (emu->card->p16v) {\n\t\tsnd_p16v_free(emu);\n\t}\n\n\tpci_disable_device(emu->pci);\n\tkfree(emu);\n\n\treturn 0;\n}\n```",
        "source_code": "static int snd_emu10k1_free(struct snd_emu10k1 *emu)\n{\n\tif (emu->port) {\t/* avoid access to already used hardware */\n\t\tsnd_emu10k1_fx8010_tram_setup(emu, 0);\n\t\tsnd_emu10k1_done(emu);\n\t\tsnd_emu10k1_free_efx(emu);\n\t}\n\tif (emu->card_capabilities->emu_model == EMU_MODEL_EMU1010) {\n\t\t/* Disable 48Volt power to Audio Dock */\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_PWR, 0);\n\t}\n\tcancel_delayed_work_sync(&emu->emu1010.firmware_work);\n\trelease_firmware(emu->firmware);\n\trelease_firmware(emu->dock_fw);\n\tif (emu->irq >= 0)\n\t\tfree_irq(emu->irq, emu);\n\t/* remove reserved page */\n\tif (emu->reserved_page) {\n\t\tsnd_emu10k1_synth_free(emu,\n\t\t\t(struct snd_util_memblk *)emu->reserved_page);\n\t\temu->reserved_page = NULL;\n\t}\n\tsnd_util_memhdr_free(emu->memhdr);\n\tif (emu->silent_page.area)\n\t\tsnd_dma_free_pages(&emu->silent_page);\n\tif (emu->ptb_pages.area)\n\t\tsnd_dma_free_pages(&emu->ptb_pages);\n\tvfree(emu->page_ptr_table);\n\tvfree(emu->page_addr_table);\n#ifdef CONFIG_PM_SLEEP\n\tfree_pm_buffer(emu);\n#endif\n\tif (emu->port)\n\t\tpci_release_regions(emu->pci);\n\tif (emu->card_capabilities->ca0151_chip) /* P16V */\n\t\tsnd_p16v_free(emu);\n\tpci_disable_device(emu->pci);\n\tkfree(emu);\n\treturn 0;\n}",
        "parsed_output": "int snd_emu10k1_free(struct snd_emu10k1 *emu)\n{\n\tif (emu->fx8010.pcm == NULL) {\n\t\tif (emu->card->shutdown) {\n\t\t\tsnd_emu1010_fpga_write(emu, 4, 0);\n\t\t}\n\t} else {\n\t\tsnd_emu10k1_fx8010_tram_setup(emu, 0);\n\t\tsnd_emu10k1_done(emu);\n\t\tsnd_emu10k1_free_efx(emu);\n\t\tif (emu->card->shutdown) {\n\t\t\tsnd_emu1010_fpga_write(emu, 4, 0);\n\t\t}\n\t}\n\n\tcancel_delayed_work_sync(&emu->delayed_work);\n\trelease_firmware(emu->firmware);\n\trelease_firmware(emu->fx8010.firmware);\n\n\tif (emu->irq >= 0) {\n\t\tfree_irq(emu->irq, emu);\n\t}\n\n\tif (emu->synth) {\n\t\tsnd_emu10k1_synth_free(emu);\n\t\temu->synth = NULL;\n\t}\n\n\tsnd_util_memhdr_free(emu->memhdr);\n\n\tif (emu->dma_pages) {\n\t\tsnd_dma_free_pages(&emu->dma);\n\t}\n\n\tif (emu->dma_fx8010_pages) {\n\t\tsnd_dma_free_pages(&emu->dma_fx8010);\n\t}\n\n\tvfree(emu->page_ptr);\n\tvfree(emu->fx8010.page_ptr);\n\tvfree(emu->fx8010.code);\n\n\tsnd_emu10k1_efx_free_pm_buffer(emu);\n\n\tif (emu->card->p16v) {\n\t\tsnd_p16v_free_pm_buffer(emu);\n\t}\n\n\tif (emu->fx8010.pcm) {\n\t\tpci_release_regions(emu->pci);\n\t}\n\n\tif (emu->card->p16v) {\n\t\tsnd_p16v_free(emu);\n\t}\n\n\tpci_disable_device(emu->pci);\n\tkfree(emu);\n\n\treturn 0;\n}",
        "baseline_code_stripped": "undefined8 snd_emu10k1_free(int *param_1)\n{\n  char cVar1;\n  if (*(long *)(param_1 + 2) == 0) {\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  else {\n    snd_emu10k1_fx8010_tram_setup(param_1,0);\n    snd_emu10k1_done(param_1);\n    snd_emu10k1_free_efx(param_1);\n    cVar1 = *(char *)(*(long *)(param_1 + 6) + 0x18);\n  }\n  if (cVar1 == '\\x01') {\n    snd_emu1010_fpga_write(param_1,4,0);\n  }\n  cancel_delayed_work_sync(param_1 + 0x468);\n  release_firmware(*(undefined8 *)(param_1 + 2000));\n  release_firmware(*(undefined8 *)(param_1 + 0x7d2));\n  if (-1 < *param_1) {\n    free_irq(*param_1,param_1);\n  }\n  if (*(long *)(param_1 + 0x3e) != 0) {\n    snd_emu10k1_synth_free(param_1);\n    *(undefined8 *)(param_1 + 0x3e) = 0;\n  }\n  snd_util_memhdr_free(*(undefined8 *)(param_1 + 0x3c));\n  if (*(long *)(param_1 + 0x18) != 0) {\n    snd_dma_free_pages(param_1 + 0x14);\n  }\n  if (*(long *)(param_1 + 0x24) != 0) {\n    snd_dma_free_pages(param_1 + 0x20);\n  }\n  vfree(*(undefined8 *)(param_1 + 0x48));\n  vfree(*(undefined8 *)(param_1 + 0x4a));\n  vfree(*(undefined8 *)(param_1 + 0x7d4));\n  snd_emu10k1_efx_free_pm_buffer(param_1);\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free_pm_buffer(param_1);\n  }\n  if (*(long *)(param_1 + 2) != 0) {\n    pci_release_regions(*(undefined8 *)(param_1 + 0x19c));\n  }\n  if (*(char *)(*(long *)(param_1 + 6) + 0x12) != '\\0') {\n    snd_p16v_free(param_1);\n  }\n  pci_disable_device(*(undefined8 *)(param_1 + 0x19c));\n  kfree(param_1);\n  return 0;\n}",
        "similarity_score_unixcoder": 0.9631496071815491,
        "similarity_score_baseline_stripped": 0.8360658884048462
    },
    {
        "func_name": "convertFrom_QList_0100QDnsHostAddressRecord",
        "normed_func_sha256": "6cadc0caffb7273788f1974ca5bb6effe345d68f63efb69a004f9417d034c88f",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nlong * convertFrom_QList_0100QBluetoothAddress(long *param_1,undefined8 param_2)\n{\n  int iVar1;\n  QBluetoothAddress *pQVar2;\n  int iVar3;\n  long *plVar4;\n  QBluetoothAddress *this;\n  long lVar5;\n  long lVar6;\n  plVar4 = (long *)PyList_New((long)(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8)));\n  if (plVar4 == (long *)0x0) {\nLAB_00130bf6:\n    plVar4 = (long *)0x0;\n  }\n  else {\n    lVar5 = *param_1;\n    iVar1 = *(int *)(lVar5 + 8);\n    if (0 < *(int *)(lVar5 + 0xc) - iVar1) {\n      lVar6 = 0;\n      do {\n        pQVar2 = *(QBluetoothAddress **)(lVar5 + 0x10 + (iVar1 + lVar6) * 8);\n        this = (QBluetoothAddress *)operator_new(8);\n        QBluetoothAddress::QBluetoothAddress(this,pQVar2);\n        lVar5 = (**(code **)(DAT_00367a80 + 0x88))\n                          (this,*(undefined8 *)(PTR_PTR_DAT_003643e0 + 0x28),param_2);\n        if (lVar5 == 0) {\n          QBluetoothAddress::_QBluetoothAddress(this);\n          operator_delete(this,8);\n          *plVar4 = *plVar4 + -1;\n          if (*plVar4 == 0) {\n            (**(code **)(plVar4[1] + 0x30))(plVar4);\n            return (long *)0x0;\n          }\n          goto LAB_00130bf6;\n        }\n        iVar3 = (int)lVar6;\n        *(long *)(plVar4[3] + lVar6 * 8) = lVar5;\n        lVar5 = *param_1;\n        lVar6 = lVar6 + 1;\n        iVar1 = *(int *)(lVar5 + 8);\n      } while (iVar3 + 1 < *(int *)(lVar5 + 0xc) - iVar1);\n    }\n  }\n  return plVar4;\n}\n\n Revised code:\nstatic void *init_type_QLowEnergyService_ServiceTypes(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)\n{\n    QLowEnergyService::ServiceTypes *sipCpp = 0;\n\n    {\n        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, \"\"))\n        {\n            sipCpp = new QLowEnergyService::ServiceTypes();\n\n            return sipCpp;\n        }\n    }\n\n    {\n        int a0;\n\n        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, \"i\", &a0))\n        {\n            sipCpp = new QLowEnergyService::ServiceTypes(a0);\n\n            return sipCpp;\n        }\n    }\n\n    {\n        const QLowEnergyService::ServiceTypes* a0;\n        int a0State = 0;\n\n        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, \"J1\", sipType_QLowEnergyService_ServiceTypes, &a0, &a0State))\n        {\n            sipCpp = new QLowEnergyService::ServiceTypes(*a0);\n            sipReleaseType(const_cast<QLowEnergyService::ServiceTypes *>(a0),sipType_QLowEnergyService_ServiceTypes,a0State);\n\n            return sipCpp;\n        }\n    }\n\n    return NULL;\n}\n\n## Example:\n\n Input code:\nlong * convertFrom_QList_0100QNdefRecord(long *param_1,undefined8 param_2)\n{\n  int iVar1;\n  QNdefRecord *pQVar2;\n  long *plVar3;\n  QNdefRecord *this;\n  long lVar4;\n  long lVar5;\n  long lVar6;\n  plVar3 = (long *)PyList_New((long)(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8)));\n  if (plVar3 == (long *)0x0) {\nLAB_0010d461:\n    plVar3 = (long *)0x0;\n  }\n  else {\n    lVar4 = *param_1;\n    iVar1 = *(int *)(lVar4 + 8);\n    if (0 < *(int *)(lVar4 + 0xc) - iVar1) {\n      lVar6 = 0;\n      do {\n        pQVar2 = *(QNdefRecord **)(lVar4 + 0x10 + (iVar1 + lVar6) * 8);\n        this = (QNdefRecord *)operator_new(8);\n        QNdefRecord::QNdefRecord(this,pQVar2);\n        lVar4 = (**(code **)(DAT_0012caf8 + 0x90))(this,PTR_DAT_0012c908,param_2);\n        if (lVar4 == 0) {\n          QNdefRecord::_QNdefRecord(this);\n          operator_delete(this,8);\n          *plVar3 = *plVar3 + -1;\n          if (*plVar3 == 0) {\n            _Py_Dealloc(plVar3);\n            return (long *)0x0;\n          }\n          goto LAB_0010d461;\n        }\n        lVar5 = lVar6 + 1;\n        PyList_SetItem(plVar3,lVar6,lVar4);\n        lVar4 = *param_1;\n        iVar1 = *(int *)(lVar4 + 8);\n        lVar6 = lVar5;\n      } while ((int)lVar5 < *(int *)(lVar4 + 0xc) - iVar1);\n    }\n  }\n  return plVar3;\n}\n\n Revised code:\nstatic PyObject *convertFrom_QList_0100QNdefRecord(void *sipCppV, PyObject *sipTransferObj)\n{\n   QList< ::QNdefRecord> *sipCpp = reinterpret_cast<QList< ::QNdefRecord> *>(sipCppV);\n\n#line 42 \"sip/QtCore/qpycore_qlist.sip\"\n    PyObject *l = PyList_New(sipCpp->size());\n\n    if (!l)\n        return 0;\n\n    for (int i = 0; i < sipCpp->size(); ++i)\n    {\n        QNdefRecord *t = new QNdefRecord(sipCpp->at(i));\n        PyObject *tobj = sipConvertFromNewType(t, sipType_QNdefRecord,\n                sipTransferObj);\n\n        if (!tobj)\n        {\n            delete t;\n            Py_DECREF(l);\n\n            return 0;\n        }\n\n        PyList_SetItem(l, i, tobj);\n    }\n\n    return l;\n#line 176 \"/builddir/build/BUILD/PyQt5-5.13.2/x86_64-redhat-linux-gnu-python3/QtNfc/sipQtNfcQList0100QNdefRecord.cpp\"\n}\n\n## Example:\n\n Input code:\nlong * convertFrom_QStringList(long *param_1,undefined8 param_2)\n{\n  int iVar1;\n  int *piVar2;\n  long *plVar3;\n  long lVar4;\n  int **this;\n  long lVar5;\n  long lVar6;\n  plVar3 = (long *)PyList_New((long)(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8)));\n  if (plVar3 == (long *)0x0) {\nLAB_002aaddc:\n    plVar3 = (long *)0x0;\n  }\n  else {\n    lVar4 = *param_1;\n    iVar1 = *(int *)(lVar4 + 8);\n    if (0 < *(int *)(lVar4 + 0xc) - iVar1) {\n      lVar6 = 0;\n      do {\n        this = (int **)operator_new(8);\n        piVar2 = *(int **)(lVar4 + 0x10 + (iVar1 + lVar6) * 8);\n        *this = piVar2;\n        if (1 < *piVar2 + 1U) {\n          LOCK();\n          *piVar2 = *piVar2 + 1;\n          UNLOCK();\n        }\n        lVar4 = (**(code **)(DAT_0040b5b8 + 0x90))(this,PTR_DAT_00409488,param_2);\n        if (lVar4 == 0) {\n          QString::_QString((QString *)this);\n          operator_delete(this,8);\n          *plVar3 = *plVar3 + -1;\n          if (*plVar3 == 0) {\n            _Py_Dealloc(plVar3);\n            return (long *)0x0;\n          }\n          goto LAB_002aaddc;\n        }\n        lVar5 = lVar6 + 1;\n        PyList_SetItem(plVar3,lVar6,lVar4);\n        lVar4 = *param_1;\n        iVar1 = *(int *)(lVar4 + 8);\n        lVar6 = lVar5;\n      } while ((int)lVar5 < *(int *)(lVar4 + 0xc) - iVar1);\n    }\n  }\n  return plVar3;\n}\n\n Revised code:\nstatic PyObject *convertFrom_QStringList(void *sipCppV, PyObject *sipTransferObj)\n{\n    ::QStringList *sipCpp = reinterpret_cast< ::QStringList *>(sipCppV);\n\n#line 40 \"/builddir/build/BUILD/PyQt5-5.13.2/x86_64-redhat-linux-gnu-python3/sip/QtCore/qstringlist.sip\"\n    PyObject *l = PyList_New(sipCpp->size());\n\n    if (!l)\n        return 0;\n\n    for (int i = 0; i < sipCpp->size(); ++i)\n    {\n        QString *t = new QString(sipCpp->at(i));\n        PyObject *tobj = sipConvertFromNewType(t, sipType_QString,\n                sipTransferObj);\n\n        if (!tobj)\n        {\n            delete t;\n            Py_DECREF(l);\n\n            return 0;\n        }\n\n        PyList_SetItem(l, i, tobj);\n    }\n\n    return l;\n#line 173 \"/builddir/build/BUILD/PyQt5-5.13.2/x86_64-redhat-linux-gnu-python3/QtCore/sipQtCoreQStringList.cpp\"\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nlong * convertFrom_QList_0100QDnsHostAddressRecord(long *param_1,undefined8 param_2)\n{\n  int iVar1;\n  int iVar2;\n  long *plVar3;\n  QDnsHostAddressRecord *this;\n  long lVar4;\n  long lVar5;\n  plVar3 = (long *)PyList_New((long)(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8)));\n  if (plVar3 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  lVar4 = *param_1;\n  iVar1 = *(int *)(lVar4 + 8);\n  if (0 < *(int *)(lVar4 + 0xc) - iVar1) {\n    lVar5 = 0;\n    do {\n      this = (QDnsHostAddressRecord *)operator_new(8);\n      QDnsHostAddressRecord::QDnsHostAddressRecord\n                (this,(QDnsHostAddressRecord *)(lVar4 + 0x10 + (iVar1 + lVar5) * 8));\n      lVar4 = (**(code **)(DAT_003be900 + 0x88))\n                        (this,*(undefined8 *)(PTR_PTR_DAT_003acda0 + 0x68),param_2);\n      if (lVar4 == 0) {\n        QDnsHostAddressRecord::_QDnsHostAddressRecord(this);\n        operator_delete(this);\n        *plVar3 = *plVar3 + -1;\n        if (*plVar3 != 0) {\n          return (long *)0x0;\n        }\n        (**(code **)(plVar3[1] + 0x30))(plVar3);\n        return (long *)0x0;\n      }\n      iVar2 = (int)lVar5;\n      *(long *)(plVar3[3] + lVar5 * 8) = lVar4;\n      lVar4 = *param_1;\n      lVar5 = lVar5 + 1;\n      iVar1 = *(int *)(lVar4 + 8);\n    } while (iVar2 + 1 < *(int *)(lVar4 + 0xc) - iVar1);\n  }\n  return plVar3;\n}",
        "output": "```c\nstatic PyObject *convertFrom_QList_0100QDnsHostAddressRecord(void *sipCppV, PyObject *sipTransferObj)\n{\n    QList< ::QDnsHostAddressRecord> *sipCpp = reinterpret_cast<QList< ::QDnsHostAddressRecord> *>(sipCppV);\n\n    PyObject *l = PyList_New(sipCpp->size());\n\n    if (!l)\n        return 0;\n\n    for (int i = 0; i < sipCpp->size(); ++i)\n    {\n        QDnsHostAddressRecord *t = new QDnsHostAddressRecord(sipCpp->at(i));\n        PyObject *tobj = sipConvertFromNewType(t, sipType_QDnsHostAddressRecord, sipTransferObj);\n\n        if (!tobj)\n        {\n            delete t;\n            Py_DECREF(l);\n\n            return 0;\n        }\n\n        PyList_SetItem(l, i, tobj);\n    }\n\n    return l;\n}\n```",
        "source_code": "static PyObject *convertFrom_QList_0100QDnsHostAddressRecord(void *sipCppV, PyObject *sipTransferObj)\n{\n   QList<QDnsHostAddressRecord> *sipCpp = reinterpret_cast<QList<QDnsHostAddressRecord> *>(sipCppV);\n\n#line 40 \"sip/QtCore/qpycore_qlist.sip\"\n    PyObject *l = PyList_New(sipCpp->size());\n\n    if (!l)\n        return 0;\n\n    for (int i = 0; i < sipCpp->size(); ++i)\n    {\n        QDnsHostAddressRecord *t = new QDnsHostAddressRecord(sipCpp->at(i));\n        PyObject *tobj = sipConvertFromNewType(t, sipType_QDnsHostAddressRecord,\n                sipTransferObj);\n\n        if (!tobj)\n        {\n            delete t;\n            Py_DECREF(l);\n\n            return 0;\n        }\n\n        PyList_SET_ITEM(l, i, tobj);\n    }\n\n    return l;\n#line 175 \"/builddir/build/BUILD/PyQt-gpl-5.4.1/QtNetwork/sipQtNetworkQList0100QDnsHostAddressRecord.cpp\"\n}",
        "parsed_output": "static PyObject *convertFrom_QList_0100QDnsHostAddressRecord(void *sipCppV, PyObject *sipTransferObj)\n{\n    QList< ::QDnsHostAddressRecord> *sipCpp = reinterpret_cast<QList< ::QDnsHostAddressRecord> *>(sipCppV);\n\n    PyObject *l = PyList_New(sipCpp->size());\n\n    if (!l)\n        return 0;\n\n    for (int i = 0; i < sipCpp->size(); ++i)\n    {\n        QDnsHostAddressRecord *t = new QDnsHostAddressRecord(sipCpp->at(i));\n        PyObject *tobj = sipConvertFromNewType(t, sipType_QDnsHostAddressRecord, sipTransferObj);\n\n        if (!tobj)\n        {\n            delete t;\n            Py_DECREF(l);\n\n            return 0;\n        }\n\n        PyList_SetItem(l, i, tobj);\n    }\n\n    return l;\n}",
        "baseline_code_stripped": "long * convertFrom_QList_0100QDnsHostAddressRecord(long *param_1,undefined8 param_2)\n{\n  int iVar1;\n  int iVar2;\n  long *plVar3;\n  QDnsHostAddressRecord *this;\n  long lVar4;\n  long lVar5;\n  plVar3 = (long *)PyList_New((long)(*(int *)(*param_1 + 0xc) - *(int *)(*param_1 + 8)));\n  if (plVar3 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  lVar4 = *param_1;\n  iVar1 = *(int *)(lVar4 + 8);\n  if (0 < *(int *)(lVar4 + 0xc) - iVar1) {\n    lVar5 = 0;\n    do {\n      this = (QDnsHostAddressRecord *)operator_new(8);\n      QDnsHostAddressRecord::QDnsHostAddressRecord\n                (this,(QDnsHostAddressRecord *)(lVar4 + 0x10 + (iVar1 + lVar5) * 8));\n      lVar4 = (**(code **)(DAT_003be900 + 0x88))\n                        (this,*(undefined8 *)(PTR_PTR_DAT_003acda0 + 0x68),param_2);\n      if (lVar4 == 0) {\n        QDnsHostAddressRecord::_QDnsHostAddressRecord(this);\n        operator_delete(this);\n        *plVar3 = *plVar3 + -1;\n        if (*plVar3 != 0) {\n          return (long *)0x0;\n        }\n        (**(code **)(plVar3[1] + 0x30))(plVar3);\n        return (long *)0x0;\n      }\n      iVar2 = (int)lVar5;\n      *(long *)(plVar3[3] + lVar5 * 8) = lVar4;\n      lVar4 = *param_1;\n      lVar5 = lVar5 + 1;\n      iVar1 = *(int *)(lVar4 + 8);\n    } while (iVar2 + 1 < *(int *)(lVar4 + 0xc) - iVar1);\n  }\n  return plVar3;\n}",
        "similarity_score_unixcoder": 0.9408077001571655,
        "similarity_score_baseline_stripped": 0.5882964134216309
    },
    {
        "func_name": "lanczos_sum",
        "normed_func_sha256": "aa926806698568afe804827d3a7e0634e6e70b210e8b7d1b88bdb9f046cdbad7",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_004491a0(void)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 local_44 [16];\n  puVar2 = local_44;\n  for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {\n    *puVar2 = 0xcccccccc;\n    puVar2 = puVar2 + 1;\n  }\n  DAT_03c1378a = 0x20;\n  DAT_03c1378b = 0;\n  DAT_03c138a8 = 0x200;\n  DAT_03c138aa = 0x200;\n  return;\n}\n\n Revised code:\nstatic void COM_SetupNullState(void)\n{\n\t//the null state has some specific default values\n//\tnullentitystate.drawflags = /*SCALE_ORIGIN_ORIGIN*/96;\n\tnullentitystate.colormod[0] = 32;\n\tnullentitystate.colormod[1] = 32;\n\tnullentitystate.colormod[2] = 32;\n//\tnullentitystate.glowmod[0] = 32;\n//\tnullentitystate.glowmod[1] = 32;\n//\tnullentitystate.glowmod[2] = 32;\n\tnullentitystate.alpha = 0;\t//fte has 255 by default, with 0 for invisible. fitz uses 1 for invisible, 0 default, and 255=full alpha\n\tnullentitystate.scale = 16;\n//\tnullentitystate.solidsize = 0;//ES_SOLID_BSP;\n}\n\n## Example:\n\n Input code:\nvoid FUN_029b3d70(undefined4 param_1,undefined4 param_2)\n{\n  undefined4 *puVar1;\n  int iVar2;\n  undefined4 local_40 [4];\n  undefined4 local_30;\n  undefined4 local_2c;\n  undefined local_28 [8];\n  undefined local_20 [16];\n  puVar1 = local_40;\n  for (iVar2 = 0xc; iVar2 != 0; iVar2 = iVar2 + -1) {\n    *puVar1 = &DAT_cccccccc;\n    puVar1 = puVar1 + 1;\n  }\n  local_40[3] = thunk_FUN_029c71b0();\n  local_40[2] = thunk_FUN_02aaa860(local_20,param_1);\n  local_40[1] = thunk_FUN_029c71b0();\n  puVar1 = (undefined4 *)thunk_FUN_02aaa860(local_28,param_2);\n  local_30 = *puVar1;\n  local_2c = puVar1[1];\n  thunk_FUN_026ffc10(local_30,local_2c);\n  return;\n}\n\n Revised code:\nvoid MachineBlockPlacement::findDuplicateCandidates(\n    SmallVectorImpl<MachineBasicBlock *> &Candidates,\n    MachineBasicBlock *BB,\n    BlockFilterSet *BlockFilter) {\n  MachineBasicBlock *Fallthrough = nullptr;\n  BranchProbability DefaultBranchProb = BranchProbability::getZero();\n  BlockFrequency BBDupThreshold(scaleThreshold(BB));\n  SmallVector<MachineBasicBlock *, 8> Preds(BB->predecessors());\n  SmallVector<MachineBasicBlock *, 8> Succs(BB->successors());\n\n  // Sort for highest frequency.\n  auto CmpSucc = [&](MachineBasicBlock *A, MachineBasicBlock *B) {\n    return MBPI->getEdgeProbability(BB, A) > MBPI->getEdgeProbability(BB, B);\n  };\n  auto CmpPred = [&](MachineBasicBlock *A, MachineBasicBlock *B) {\n    return MBFI->getBlockFreq(A) > MBFI->getBlockFreq(B);\n  };\n  llvm::stable_sort(Succs, CmpSucc);\n  llvm::stable_sort(Preds, CmpPred);\n\n  auto SuccIt = Succs.begin();\n  if (SuccIt != Succs.end()) {\n    DefaultBranchProb = MBPI->getEdgeProbability(BB, *SuccIt).getCompl();\n  }\n\n  // For each predecessors of BB, compute the benefit of duplicating BB,\n  // if it is larger than the threshold, add it into Candidates.\n  //\n  // If we have following control flow.\n  //\n  //     PB1 PB2 PB3 PB4\n  //      \\   |  /    /\\\n  //       \\  | /    /  \\\n  //        \\ |/    /    \\\n  //         BB----/     OB\n  //         /\\\n  //        /  \\\n  //      SB1 SB2\n  //\n  // And it can be partially duplicated as\n  //\n  //   PB2+BB\n  //      |  PB1 PB3 PB4\n  //      |   |  /    /\\\n  //      |   | /    /  \\\n  //      |   |/    /    \\\n  //      |  BB----/     OB\n  //      |\\ /|\n  //      | X |\n  //      |/ \\|\n  //     SB2 SB1\n  //\n  // The benefit of duplicating into a predecessor is defined as\n  //         Orig_taken_branch - Duplicated_taken_branch\n  //\n  // The Orig_taken_branch is computed with the assumption that predecessor\n  // jumps to BB and the most possible successor is laid out after BB.\n  //\n  // The Duplicated_taken_branch is computed with the assumption that BB is\n  // duplicated into PB, and one successor is layout after it (SB1 for PB1 and\n  // SB2 for PB2 in our case). If there is no available successor, the combined\n  // block jumps to all BB's successor, like PB3 in this example.\n  //\n  // If a predecessor has multiple successors, so BB can't be duplicated into\n  // it. But it can beneficially fall through to BB, and duplicate BB into other\n  // predecessors.\n  for (MachineBasicBlock *Pred : Preds) {\n    BlockFrequency PredFreq = getBlockCountOrFrequency(Pred);\n\n    if (!TailDup.canTailDuplicate(BB, Pred)) {\n      // BB can't be duplicated into Pred, but it is possible to be layout\n      // below Pred.\n      if (!Fallthrough && isBestSuccessor(BB, Pred, BlockFilter)) {\n        Fallthrough = Pred;\n        if (SuccIt != Succs.end())\n          SuccIt++;\n      }\n      continue;\n    }\n\n    BlockFrequency OrigCost = PredFreq + PredFreq * DefaultBranchProb;\n    BlockFrequency DupCost;\n    if (SuccIt == Succs.end()) {\n      // Jump to all successors;\n      if (Succs.size() > 0)\n        DupCost += PredFreq;\n    } else {\n      // Fallthrough to *SuccIt, jump to all other successors;\n      DupCost += PredFreq;\n      DupCost -= PredFreq * MBPI->getEdgeProbability(BB, *SuccIt);\n    }\n\n    assert(OrigCost >= DupCost);\n    OrigCost -= DupCost;\n    if (OrigCost > BBDupThreshold) {\n      Candidates.push_back(Pred);\n      if (SuccIt != Succs.end())\n        SuccIt++;\n    }\n  }\n\n  // No predecessors can optimally fallthrough to BB.\n  // So we can change one duplication into fallthrough.\n  if (!Fallthrough) {\n    if ((Candidates.size() < Preds.size()) && (Candidates.size() > 0)) {\n      Candidates[0] = Candidates.back();\n      Candidates.pop_back();\n    }\n  }\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_0016b13d(long param_1)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  code **local_10;\n  uVar1 = FUN_002506a2();\n  *(undefined4 *)(param_1 + 4) = uVar1;\n  if ((DAT_00290e00 != (code *)0x0) && (iVar2 = (*DAT_00290e00)(DAT_00290e08,param_1), iVar2 == 0))\n  {\n    return 0;\n  }\n  for (local_10 = DAT_00290e10; local_10 != (code **)0x0; local_10 = (code **)local_10[2]) {\n    (**local_10)(local_10[1],param_1);\n  }\n  iVar2 = FUN_0016aa9e(param_1,1,0,0,0);\n  if (iVar2 < 1) {\n    uVar3 = 0xffffffff;\n  }\n  else {\n    FUN_0016cf2d(param_1);\n    uVar3 = 1;\n  }\n  return uVar3;\n}\n\n Revised code:\nint\nSDL_PushEvent(SDL_Event * event)\n{\n    SDL_EventWatcher *curr;\n\n    event->common.timestamp = SDL_GetTicks();\n\n    if (SDL_EventOK && !SDL_EventOK(SDL_EventOKParam, event)) {\n        return 0;\n    }\n\n    for (curr = SDL_event_watchers; curr; curr = curr->next) {\n        curr->callback(curr->userdata, event);\n    }\n\n    if (SDL_PeepEvents(event, 1, SDL_ADDEVENT, 0, 0) <= 0) {\n        return -1;\n    }\n\n    SDL_GestureProcessEvent(event);\n\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_004b6e60(void)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 local_c4 [48];\n  puVar2 = local_c4;\n  for (iVar1 = 0x30; iVar1 != 0; iVar1 = iVar1 + -1) {\n    *puVar2 = 0xcccccccc;\n    puVar2 = puVar2 + 1;\n  }\n  return DAT_0067f96c;\n}",
        "output": "static int InitializeDefaultState(void)\n{\n    int i;\n    int defaultValue = 0xcccccccc;\n    int localArray[48];\n\n    // Initialize the local array with the default value\n    for (i = 0; i < 48; i++) {\n        localArray[i] = defaultValue;\n    }\n\n    // Return a global configuration value\n    return globalConfigValue;\n}",
        "source_code": "static T lanczos_sum(const T& z)\n   {\n      lanczos_initializer<lanczos31UDT, T>::force_instantiate(); // Ensure our constants get initialized before main()\n      static const T num[31] = {\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.2579646553333513328235723061836959833277e46)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.2444796504337453845497419271639377138264e46)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.1119885499016017172212179730662673475329e46)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.3301983829072723658949204487793889113715e45)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.7041171040503851585152895336505379417066e44)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.1156687509001223855125097826246939403504e44)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1522559363393940883866575697565974893306000)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 164914363507650839510801418717701057005700)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 14978522943127593263654178827041568394060)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1156707153701375383907746879648168666774)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 76739431129980851159755403434593664173.2)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 4407916278928188620282281495575981079.306)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 220487883931812802092792125175269667.3004)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 9644828280794966468052381443992828.433924)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 369996467042247229310044531282837.6549068)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 12468380890717344610932904378961.13494291)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 369289245210898235894444657859.0529720075)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 9607992460262594951559461829.34885209022)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 219225935074853412540086410.981421315799)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 4374309943598658046326340.720767382079549)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 76008779092264509404014.10530947173485581)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1143503533822162444712.335663112617754987)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 14779233719977576920.37884890049671578409)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 162409028440678302.9992838032166348069916)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1496561553388385.733407609544964535634135)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 11347624460661.81008311053190661436107043)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 68944915931.32004991941950530448472223832)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 322701221.6391432296123937035480931903651)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1092364.213992634267819050120261755371294)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 2380.151399852411512711176940867823024864)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 2.506628274631000502415765284811045253007)),\n      };\n      static const T denom[31] = {\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.8841761993739701954543616e31)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.3502799997985980526649278464e32)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 0.622621928420356134910574592e32)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 66951000306085302338993639424000)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 49361465831621147825759587123200)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 26751280755793398822580822142976)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 11139316913434780466101123891200)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 3674201658710345201899117607040)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 981347603630155088295475765440)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 215760462268683520394805979744)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 39539238727270799376544542000)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 6097272817323042122728617800)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 796974693974455191377937300)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 88776380550648116217781890)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 8459574446076318147830625)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 691254538651580660999025)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 48487623689430693038025)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 2918939500751087661105)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 150566737512021319125)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 6634460278534540725)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 248526574856284725)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 7860403394108265)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 207912996295875)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 4539323721075)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 80328850875)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1122686019)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 11921175)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 90335)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 435)),\n         static_cast<T>(BOOST_MATH_HUGE_CONSTANT(T, 150, 1)),\n      };\n      return boost::math::tools::evaluate_rational(num, denom, z, 31);\n   }",
        "parsed_output": "static int InitializeDefaultState(void)\n{\n    int i;\n    int defaultValue = 0xcccccccc;\n    int localArray[48];\n\n    // Initialize the local array with the default value\n    for (i = 0; i < 48; i++) {\n        localArray[i] = defaultValue;\n    }\n\n    // Return a global configuration value\n    return globalConfigValue;\n}",
        "baseline_code_stripped": "undefined4 FUN_004b6e60(void)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 local_c4 [48];\n  puVar2 = local_c4;\n  for (iVar1 = 0x30; iVar1 != 0; iVar1 = iVar1 + -1) {\n    *puVar2 = 0xcccccccc;\n    puVar2 = puVar2 + 1;\n  }\n  return DAT_0067f96c;\n}",
        "similarity_score_unixcoder": 0.3805968761444092,
        "similarity_score_baseline_stripped": 0.44867292046546936
    },
    {
        "func_name": "f_13576",
        "normed_func_sha256": "f19258ac0f7d10f978bc48a10be9d2a0a304f0d67a4220eac22a7c83851526c7",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid f_14272(int param_1,int param_2,int param_3,int param_4)\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  code *pcVar4;\n  undefined4 local_68;\n  code *local_64;\n  undefined4 local_60;\n  int local_5c;\n  int local_58;\n  undefined4 local_54;\n  int local_50;\n  undefined4 local_4c;\n  code *local_48;\n  undefined4 *local_44;\n  undefined4 local_40;\n  int local_38;\n  int iStack_34;\n  undefined auStack_30 [4];\n  int local_2c;\n  undefined4 *local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  local_1c = __stack_chk_guard;\n  iVar3 = param_3;\n  if ((int)(auStack_30 + -C_stack_limit) < 0x39) {\n    iVar3 = param_1;\n    local_38 = param_3;\n    iStack_34 = param_4;\n    C_save_and_reclaim_args(trf_14272,4,param_1,param_2);\n  }\n  iVar1 = C_i_pairp(iVar3);\n  if (iVar1 == 6) goto LAB_00056510;\n  iVar1 = C_i_pairp(param_4,&local_2c);\n  if (iVar1 == 6) goto LAB_00056510;\n  local_24 = *(undefined4 *)(iVar3 + 4);\n  local_68 = 0x24000006;\n  local_40 = *(undefined4 *)(param_4 + 4);\n  local_64 = f_14301;\n  local_60 = *(undefined4 *)(param_1 + 8);\n  local_54 = *(undefined4 *)(param_1 + 0xc);\n  local_28 = &local_4c;\n  local_4c = 0x24000003;\n  local_48 = f_14175;\n  local_2c = *(int *)(DAT_0021dca4 + 4);\n  uVar2 = 4;\n  pcVar4 = *(code **)(local_2c + 4);\n  local_5c = iVar3;\n  local_58 = param_4;\n  local_50 = param_2;\n  local_44 = &local_68;\n  local_20 = local_40;\n  do {\n    (*pcVar4)(uVar2);\nLAB_00056510:\n    uVar2 = 2;\n    local_28 = *(undefined4 **)(*(int *)(param_1 + 0x10) + 8);\n    pcVar4 = *(code **)(param_2 + 4);\n    local_2c = param_2;\n  } while( true );\n}\n\n Revised code:\nstatic void C_fcall f_14272(C_word t0,C_word t1,C_word t2,C_word t3){\nC_word tmp;\nC_word t4;\nC_word t5;\nC_word t6;\nC_word t7;\nC_word t8;\nC_word t9;\nC_word t10;\nC_word t11;\nC_word t12;\nC_word *a;\nif(!C_demand(C_calculate_demand(11,0,3))){\nC_save_and_reclaim_args((void *)trf_14272,4,t0,t1,t2,t3);}\na=C_alloc(11);\nt4=C_i_pairp(t2);\nt5=(C_truep(t4)?C_i_pairp(t3):C_SCHEME_FALSE);\nif(C_truep(t5)){\nt6=(*a=C_CLOSURE_TYPE|6,a[1]=(C_word)f_14301,a[2]=((C_word*)t0)[2],a[3]=t2,a[4]=t3,a[5]=((C_word*)t0)[3],a[6]=t1,tmp=(C_word)a,a+=7,tmp);\nt7=C_slot(t2,C_fix(0));\nt8=C_slot(t3,C_fix(0));\nt9=t6;\nt10=t8;\nt11=(*a=C_CLOSURE_TYPE|3,a[1]=(C_word)f_14175,a[2]=t9,a[3]=t10,tmp=(C_word)a,a+=4,tmp);\n/* compiler.scm:1651: foreign-type-convert-argument */\nt12=*((C_word*)lf[251]+1);{\nC_word av2[4];\nav2[0]=t12;\nav2[1]=t11;\nav2[2]=t7;\nav2[3]=t10;\n((C_proc)(void*)(*((C_word*)t12+1)))(4,av2);}}\nelse{\nt6=t1;{\nC_word av2[2];\nav2[0]=t6;\nav2[1]=C_slot(((C_word*)t0)[4],C_fix(1));\n((C_proc)(void*)(*((C_word*)t6+1)))(2,av2);}}}\n\n## Example:\n\n Input code:\nvoid f_14286(int param_1,int param_2,int param_3,int param_4)\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  code *pcVar4;\n  undefined4 local_68;\n  code *local_64;\n  undefined4 local_60;\n  int local_5c;\n  int local_58;\n  undefined4 local_54;\n  int local_50;\n  undefined4 local_4c;\n  code *local_48;\n  undefined4 *local_44;\n  undefined4 local_40;\n  int local_38;\n  int iStack_34;\n  undefined auStack_30 [4];\n  int local_2c;\n  undefined4 *local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  local_1c = __stack_chk_guard;\n  iVar3 = param_3;\n  if ((int)(auStack_30 + -C_stack_limit) < 0x39) {\n    iVar3 = param_1;\n    local_38 = param_3;\n    iStack_34 = param_4;\n    C_save_and_reclaim_args(trf_14286,4,param_1,param_2);\n  }\n  iVar1 = C_i_pairp(iVar3);\n  if (iVar1 == 6) goto LAB_00055e6c;\n  iVar1 = C_i_pairp(param_4,&local_2c);\n  if (iVar1 == 6) goto LAB_00055e6c;\n  local_24 = *(undefined4 *)(iVar3 + 4);\n  local_68 = 0x24000006;\n  local_40 = *(undefined4 *)(param_4 + 4);\n  local_64 = f_14315;\n  local_60 = *(undefined4 *)(param_1 + 8);\n  local_54 = *(undefined4 *)(param_1 + 0xc);\n  local_28 = &local_4c;\n  local_4c = 0x24000003;\n  local_48 = f_14189;\n  local_2c = *(int *)(DAT_00217ce4 + 4);\n  uVar2 = 4;\n  pcVar4 = *(code **)(local_2c + 4);\n  local_5c = iVar3;\n  local_58 = param_4;\n  local_50 = param_2;\n  local_44 = &local_68;\n  local_20 = local_40;\n  do {\n    (*pcVar4)(uVar2);\nLAB_00055e6c:\n    uVar2 = 2;\n    local_28 = *(undefined4 **)(*(int *)(param_1 + 0x10) + 8);\n    pcVar4 = *(code **)(param_2 + 4);\n    local_2c = param_2;\n  } while( true );\n}\n\n Revised code:\nstatic void C_fcall f_14286(C_word t0,C_word t1,C_word t2,C_word t3){\nC_word tmp;\nC_word t4;\nC_word t5;\nC_word t6;\nC_word t7;\nC_word t8;\nC_word t9;\nC_word t10;\nC_word t11;\nC_word t12;\nC_word *a;\nif(C_unlikely(!C_demand(C_calculate_demand(11,0,3)))){\nC_save_and_reclaim_args((void *)trf_14286,4,t0,t1,t2,t3);}\na=C_alloc(11);\nt4=C_i_pairp(t2);\nt5=(C_truep(t4)?C_i_pairp(t3):C_SCHEME_FALSE);\nif(C_truep(t5)){\nt6=(*a=C_CLOSURE_TYPE|6,a[1]=(C_word)f_14315,a[2]=((C_word*)t0)[2],a[3]=t2,a[4]=t3,a[5]=((C_word*)t0)[3],a[6]=t1,tmp=(C_word)a,a+=7,tmp);\nt7=C_slot(t2,C_fix(0));\nt8=C_slot(t3,C_fix(0));\nt9=t6;\nt10=t8;\nt11=(*a=C_CLOSURE_TYPE|3,a[1]=(C_word)f_14189,a[2]=t9,a[3]=t10,tmp=(C_word)a,a+=4,tmp);\n/* compiler.scm:1651: foreign-type-convert-argument */\nt12=*((C_word*)lf[251]+1);{\nC_word av2[4];\nav2[0]=t12;\nav2[1]=t11;\nav2[2]=t7;\nav2[3]=t10;\n((C_proc)(void*)(*((C_word*)t12+1)))(4,av2);}}\nelse{\nt6=t1;{\nC_word av2[2];\nav2[0]=t6;\nav2[1]=C_slot(((C_word*)t0)[4],C_fix(1));\n((C_proc)(void*)(*((C_word*)t6+1)))(2,av2);}}}\n\n## Example:\n\n Input code:\nvoid f_9211_lto_priv_0(int param_1,code *param_2,int param_3,int param_4,code *param_5)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  code **ppcVar3;\n  undefined4 *puVar4;\n  undefined4 *puVar5;\n  code *pcVar6;\n  undefined8 uVar7;\n  undefined4 local_80 [14];\n  int local_48;\n  int local_44;\n  code *local_40;\n  undefined auStack_38 [4];\n  code **local_34;\n  code *local_30;\n  undefined4 *local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  local_1c = __stack_chk_guard;\n  pcVar6 = param_2;\n  if ((int)(auStack_38 + -C_stack_limit) >> 2 <= C_scratch_usage + 0x15) {\n    local_40 = param_5;\n    local_48 = param_3;\n    local_44 = param_4;\n    param_4 = C_save_and_reclaim_args(trf_9211_lto_priv_0,5,param_1);\n    param_5 = param_2;\n  }\n  puVar4 = local_80;\n  uVar7 = CONCAT44(&local_30,param_4);\n  puVar5 = puVar4;\n  if (param_3 != 0xe && param_4 != 0xe) goto LAB_001557bc;\n  uVar1 = 2;\n  local_2c = (undefined4 *)&SUB_0000001e;\n  param_5 = *(code **)(pcVar6 + 4);\n  ppcVar3 = &local_30;\n  local_30 = pcVar6;\n  do {\n    uVar7 = (*param_5)(uVar1,ppcVar3);\n    puVar5 = puVar4;\nLAB_001557bc:\n    local_34 = (code **)((ulonglong)uVar7 >> 0x20);\n    puVar5[4] = param_5;\n    *puVar5 = 0x24000006;\n    puVar5[6] = pcVar6;\n    puVar5[1] = f_9224_lto_priv_0;\n    puVar5[2] = param_3;\n    uVar1 = *(undefined4 *)(param_1 + 8);\n    puVar5[3] = (int)uVar7;\n    puVar5[5] = uVar1;\n    puVar5[0xd] = param_3;\n    puVar5[7] = 0x24000009;\n    puVar5[0xf] = (int)uVar7;\n    puVar5[8] = f_9236_lto_priv_0;\n    uVar1 = *(undefined4 *)(param_1 + 0xc);\n    puVar5[9] = puVar5;\n    puVar5[10] = uVar1;\n    puVar5[0xb] = *(undefined4 *)(param_1 + 0x10);\n    puVar5[0xc] = param_5;\n    puVar4 = puVar5 + 7;\n    puVar5[0xe] = *(undefined4 *)(param_1 + 0x14);\n    puVar5[0x10] = *(undefined4 *)(param_1 + 0x18);\n    uVar2 = C_i_car();\n    local_24 = C_i_car(param_3);\n    local_30 = *(code **)(DAT_00290854 + 4);\n    local_20 = *(undefined4 *)(*(int *)(param_1 + 0x14) + 4);\n    uVar1 = 5;\n    param_5 = *(code **)(local_30 + 4);\n    ppcVar3 = local_34;\n    local_2c = puVar4;\n    local_28 = uVar2;\n  } while( true );\n}\n\n Revised code:\nstatic void C_fcall f_9211(C_word t0,C_word t1,C_word t2,C_word t3,C_word t4){\nC_word tmp;\nC_word t5;\nC_word t6;\nC_word t7;\nC_word t8;\nC_word t9;\nC_word t10;\nC_word t11;\nC_word *a;\nif(C_unlikely(!C_demand(C_calculate_demand(17,0,4)))){\nC_save_and_reclaim_args((void *)trf_9211,5,t0,t1,t2,t3,t4);}\na=C_alloc(17);\nt5=C_i_nullp(t2);\nt6=(C_truep(t5)?t5:C_i_nullp(t3));\nif(C_truep(t6)){\nt7=C_SCHEME_UNDEFINED;\nt8=t1;{\nC_word av2[2];\nav2[0]=t8;\nav2[1]=t7;\n((C_proc)(void*)(*((C_word*)t8+1)))(2,av2);}}\nelse{\nt7=(*a=C_CLOSURE_TYPE|6,a[1]=(C_word)f_9224,a[2]=t2,a[3]=t3,a[4]=t4,a[5]=((C_word*)t0)[2],a[6]=t1,tmp=(C_word)a,a+=7,tmp);\nt8=(*a=C_CLOSURE_TYPE|9,a[1]=(C_word)f_9236,a[2]=t7,a[3]=((C_word*)t0)[3],a[4]=((C_word*)t0)[4],a[5]=t4,a[6]=t2,a[7]=((C_word*)t0)[5],a[8]=t3,a[9]=((C_word*)t0)[6],tmp=(C_word)a,a+=10,tmp);\nt9=C_i_car(t3);\nt10=C_i_car(t2);\n/* scrutinizer.scm:392: match-types */\nt11=*((C_word*)lf[140]+1);{\nC_word av2[5];\nav2[0]=t11;\nav2[1]=t8;\nav2[2]=t9;\nav2[3]=t10;\nav2[4]=((C_word*)((C_word*)t0)[5])[1];\n((C_proc)(void*)(*((C_word*)t11+1)))(5,av2);}}}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid f_13576(int param_1,code *param_2,int param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  undefined4 local_58;\n  code *local_54;\n  undefined4 local_50;\n  code *pcStack_4c;\n  int local_48;\n  undefined4 local_44;\n  code *local_40;\n  undefined4 *local_3c;\n  undefined4 local_38;\n  undefined4 local_34;\n  undefined4 local_30;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  local_1c = __stack_chk_guard;\n  if ((int)&local_40 - C_stack_limit < 0x39) {\n    local_48 = param_3;\n    C_save_and_reclaim_args(trf_13576,3,param_1);\n  }\n  if (param_3 != 0xe) goto LAB_0009a088;\n  uVar2 = 2;\n  local_3c = (undefined4 *)&DAT_00000006;\n  pcVar1 = *(code **)(param_2 + 4);\n  local_40 = param_2;\n  do {\n    param_2 = pcVar1;\n    (*param_2)(uVar2,&local_40);\nLAB_0009a088:\n    local_58 = 0x24000005;\n    local_54 = f_13586;\n    local_50 = *(undefined4 *)(param_1 + 8);\n    local_44 = *(undefined4 *)(param_1 + 0xc);\n    pcStack_4c = param_2;\n    local_48 = param_3;\n    local_28 = C_i_caar(param_3);\n    local_38 = *(undefined4 *)(param_1 + 0x10);\n    local_24 = *(undefined4 *)(*(int *)(param_3 + 4) + 8);\n    local_40 = *(code **)(DAT_00214554 + 4);\n    local_34 = *(undefined4 *)(param_1 + 0x14);\n    local_30 = *(undefined4 *)(param_1 + 8);\n    local_20 = *(undefined4 *)(param_1 + 0x1c);\n    local_2c = *(undefined4 *)(param_1 + 0x18);\n    uVar2 = 9;\n    pcVar1 = *(code **)(local_40 + 4);\n    local_3c = &local_58;\n  } while( true );\n}",
        "output": "```c\nstatic void C_fcall f_13576(C_word t0, C_word t1, C_word t2) {\n    C_word tmp;\n    C_word t3;\n    C_word t4;\n    C_word t5;\n    C_word t6;\n    C_word t7;\n    C_word t8;\n    C_word t9;\n    C_word t10;\n    C_word *a;\n\n    if (C_unlikely(!C_demand(C_calculate_demand(11, 0, 2)))) {\n        C_save_and_reclaim_args((void *)trf_13576, 3, t0, t1, t2);\n    }\n\n    a = C_alloc(11);\n    t3 = C_i_nullp(t2);\n\n    if (C_truep(t3)) {\n        t4 = t1;\n        {\n            C_word av2[2];\n            av2[0] = t4;\n            av2[1] = C_SCHEME_UNDEFINED;\n            ((C_proc)(void *)(*((C_word *)t4 + 1)))(2, av2);\n        }\n    } else {\n        t4 = (*a = C_CLOSURE_TYPE | 5, a[1] = (C_word)f_13586, a[2] = ((C_word *)t0)[2], a[3] = t2, a[4] = ((C_word *)t0)[3], a[5] = t1, tmp = (C_word)a, a += 6, tmp);\n        t5 = C_i_caar(t2);\n        t6 = C_slot(t2, C_fix(1));\n        t7 = C_slot(((C_word *)t0)[4], C_fix(0));\n        t8 = C_slot(((C_word *)t0)[4], C_fix(1));\n        t9 = C_slot(((C_word *)t0)[4], C_fix(2));\n        t10 = *((C_word *)lf[251] + 1);\n        {\n            C_word av2[5];\n            av2[0] = t10;\n            av2[1] = t4;\n            av2[2] = t5;\n            av2[3] = t6;\n            av2[4] = t7;\n            ((C_proc)(void *)(*((C_word *)t10 + 1)))(5, av2);\n        }\n    }\n}\n```",
        "source_code": "static void C_fcall f_13576(C_word t0,C_word t1,C_word t2){\nC_word tmp;\nC_word t3;\nC_word t4;\nC_word t5;\nC_word t6;\nC_word t7;\nC_word t8;\nC_word *a;\nif(C_unlikely(!C_demand(C_calculate_demand(6,0,8)))){\nC_save_and_reclaim_args((void *)trf_13576,3,t0,t1,t2);}\na=C_alloc(6);\nif(C_truep(C_i_nullp(t2))){\nt3=t1;{\nC_word av2[2];\nav2[0]=t3;\nav2[1]=C_SCHEME_FALSE;\n((C_proc)(void*)(*((C_word*)t3+1)))(2,av2);}}\nelse{\nt3=(*a=C_CLOSURE_TYPE|5,a[1]=(C_word)f_13586,a[2]=((C_word*)t0)[2],a[3]=t1,a[4]=t2,a[5]=((C_word*)t0)[3],tmp=(C_word)a,a+=6,tmp);\nt4=C_i_caar(t2);\nt5=t2;\nt6=C_u_i_car(t5);\nt7=C_u_i_cdr(t6);\n/* optimizer.scm:614: simplify-named-call */\nt8=*((C_word*)lf[142]+1);{\nC_word av2[9];\nav2[0]=t8;\nav2[1]=t3;\nav2[2]=((C_word*)t0)[4];\nav2[3]=((C_word*)t0)[5];\nav2[4]=((C_word*)t0)[2];\nav2[5]=((C_word*)t0)[6];\nav2[6]=t4;\nav2[7]=t7;\nav2[8]=((C_word*)t0)[7];\n((C_proc)(void*)(*((C_word*)t8+1)))(9,av2);}}}",
        "parsed_output": "static void C_fcall f_13576(C_word t0, C_word t1, C_word t2) {\n    C_word tmp;\n    C_word t3;\n    C_word t4;\n    C_word t5;\n    C_word t6;\n    C_word t7;\n    C_word t8;\n    C_word t9;\n    C_word t10;\n    C_word *a;\n\n    if (C_unlikely(!C_demand(C_calculate_demand(11, 0, 2)))) {\n        C_save_and_reclaim_args((void *)trf_13576, 3, t0, t1, t2);\n    }\n\n    a = C_alloc(11);\n    t3 = C_i_nullp(t2);\n\n    if (C_truep(t3)) {\n        t4 = t1;\n        {\n            C_word av2[2];\n            av2[0] = t4;\n            av2[1] = C_SCHEME_UNDEFINED;\n            ((C_proc)(void *)(*((C_word *)t4 + 1)))(2, av2);\n        }\n    } else {\n        t4 = (*a = C_CLOSURE_TYPE | 5, a[1] = (C_word)f_13586, a[2] = ((C_word *)t0)[2], a[3] = t2, a[4] = ((C_word *)t0)[3], a[5] = t1, tmp = (C_word)a, a += 6, tmp);\n        t5 = C_i_caar(t2);\n        t6 = C_slot(t2, C_fix(1));\n        t7 = C_slot(((C_word *)t0)[4], C_fix(0));\n        t8 = C_slot(((C_word *)t0)[4], C_fix(1));\n        t9 = C_slot(((C_word *)t0)[4], C_fix(2));\n        t10 = *((C_word *)lf[251] + 1);\n        {\n            C_word av2[5];\n            av2[0] = t10;\n            av2[1] = t4;\n            av2[2] = t5;\n            av2[3] = t6;\n            av2[4] = t7;\n            ((C_proc)(void *)(*((C_word *)t10 + 1)))(5, av2);\n        }\n    }\n}",
        "baseline_code_stripped": "void f_13576(int param_1,code *param_2,int param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  undefined4 local_58;\n  code *local_54;\n  undefined4 local_50;\n  code *pcStack_4c;\n  int local_48;\n  undefined4 local_44;\n  code *local_40;\n  undefined4 *local_3c;\n  undefined4 local_38;\n  undefined4 local_34;\n  undefined4 local_30;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  local_1c = __stack_chk_guard;\n  if ((int)&local_40 - C_stack_limit < 0x39) {\n    local_48 = param_3;\n    C_save_and_reclaim_args(trf_13576,3,param_1);\n  }\n  if (param_3 != 0xe) goto LAB_0009a088;\n  uVar2 = 2;\n  local_3c = (undefined4 *)&DAT_00000006;\n  pcVar1 = *(code **)(param_2 + 4);\n  local_40 = param_2;\n  do {\n    param_2 = pcVar1;\n    (*param_2)(uVar2,&local_40);\nLAB_0009a088:\n    local_58 = 0x24000005;\n    local_54 = f_13586;\n    local_50 = *(undefined4 *)(param_1 + 8);\n    local_44 = *(undefined4 *)(param_1 + 0xc);\n    pcStack_4c = param_2;\n    local_48 = param_3;\n    local_28 = C_i_caar(param_3);\n    local_38 = *(undefined4 *)(param_1 + 0x10);\n    local_24 = *(undefined4 *)(*(int *)(param_3 + 4) + 8);\n    local_40 = *(code **)(DAT_00214554 + 4);\n    local_34 = *(undefined4 *)(param_1 + 0x14);\n    local_30 = *(undefined4 *)(param_1 + 8);\n    local_20 = *(undefined4 *)(param_1 + 0x1c);\n    local_2c = *(undefined4 *)(param_1 + 0x18);\n    uVar2 = 9;\n    pcVar1 = *(code **)(local_40 + 4);\n    local_3c = &local_58;\n  } while( true );\n}",
        "similarity_score_unixcoder": 0.9203007221221924,
        "similarity_score_baseline_stripped": 0.727569580078125
    },
    {
        "func_name": "_file_lock_resource",
        "normed_func_sha256": "d0fba9e85cb6773ff43f667f15fe8c48cfefc9fd71efc7d106be2fcc253667fa",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_0043d660(long param_1)\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  char *__s2;\n  int *piVar4;\n  long in_FS_OFFSET;\n  char local_1028 [4104];\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_0043d580();\n  if (iVar1 != 0) {\n    FUN_0042c710(iVar1);\n    uVar3 = 0;\n    goto LAB_0043d736;\n  }\n  lVar2 = FUN_0043a250(*(undefined8 *)(param_1 + 0xd8));\n  *(long *)(param_1 + 0xe0) = lVar2;\n  if (lVar2 == 0) {\n    FUN_0042c710(0);\n    uVar3 = 0;\n    goto LAB_0043d736;\n  }\n  uVar3 = FUN_0043a330(lVar2);\n  __snprintf_chk(local_1028,0x1000,1,0x1000,\"%s/%s\",*(undefined8 *)(param_1 + 0xb0),uVar3);\n  if (*(long *)(param_1 + 0xc0) == 0) {\nLAB_0043d710:\n    lVar2 = FUN_0043f360(local_1028);\n    *(long *)(param_1 + 0xc0) = lVar2;\n    if ((lVar2 == 0) && (piVar4 = (int *)FUN_0042c670(), *piVar4 != 0)) {\n      FUN_0042c710();\n      uVar3 = 0;\n      goto LAB_0043d736;\n    }\n  }\n  else {\n    __s2 = (char *)FUN_00440ff0();\n    iVar1 = strcmp(local_1028,__s2);\n    if (iVar1 != 0) {\n      FUN_00441260(*(undefined8 *)(param_1 + 0xc0));\n      *(undefined8 *)(param_1 + 0xc0) = 0;\n      goto LAB_0043d710;\n    }\n    if (*(long *)(param_1 + 0xc0) == 0) goto LAB_0043d710;\n  }\n  *(undefined4 *)(param_1 + 0xd0) = 1;\n  uVar3 = FUN_0043cfd0(param_1);\nLAB_0043d736:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n Revised code:\nicalcomponent* icaldirset_get_first_component(icalset* set)\n{\n  icaldirset *dset = (icaldirset*)set;\n\n    icalerrorenum error;\n    char path[ICAL_PATH_MAX];\n\n  error = icaldirset_read_directory(dset);\n\n    if (error != ICAL_NO_ERROR){\n\ticalerror_set_errno(error);\n\treturn 0;\n    }\n\n  dset->directory_iterator = pvl_head(dset->directory);\n    \n  if (dset->directory_iterator == 0){\n\ticalerror_set_errno(error);\n\treturn 0;\n    }\n    \n  snprintf(path,ICAL_PATH_MAX,\"%s/%s\",\n\t   dset->dir,\n\t   (char*)pvl_data(dset->directory_iterator));\n\n    /* If the next cluster we need is different than the current cluster, \n       delete the current one and get a new one */\n\n  if(dset->cluster != 0 && strcmp(path,icalcluster_key(dset->cluster)) != 0 ){\n    icalcluster_free(dset->cluster);\n    dset->cluster = 0;\n    }\n    \n  if (dset->cluster == 0){\n    dset->cluster = icalfileset_produce_icalcluster(path);\n\n    if (dset->cluster == 0){\n\t    error = icalerrno;\n\t}\n    } \n\n    if (error != ICAL_NO_ERROR){\n\ticalerror_set_errno(error);\n\treturn 0;\n    }\n\n  dset->first_component = 1;\n\n  return icaldirset_get_next_component(set);\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_00109280(long param_1,long *param_2,undefined4 *param_3)\n{\n  long *plVar1;\n  long *plVar2;\n  long lVar3;\n  long lVar4;\n  int iVar5;\n  undefined4 uVar6;\n  long in_FS_OFFSET;\n  undefined8 local_70;\n  undefined8 local_68;\n  long local_60;\n  undefined8 local_58;\n  undefined8 *local_50;\n  undefined8 local_48;\n  long local_40;\n  plVar1 = *(long **)(param_1 + 0x30);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  plVar2 = *(long **)(*plVar1 + 0x20);\n  lVar3 = *(long *)(*plVar2 + 0x10);\n  if (*(char *)(plVar2 + 1) == '\\0') {\n    iVar5 = FUN_0010eaf0(*plVar1,0);\n    if (iVar5 != 0) {\n      uVar6 = 0xffffffff;\n      goto LAB_001093c4;\n    }\n  }\n  CRYPTO_THREAD_write_lock(*(undefined8 *)(lVar3 + 0x30));\n  plVar2 = *(long **)(**(long **)(param_1 + 0x30) + 0x20);\n  local_50 = &local_70;\n  lVar4 = *plVar2;\n  local_58 = 0;\n  local_48 = 8;\n  local_70 = 1;\n  iVar5 = (**(code **)(**(long **)(lVar4 + 0x10) + 0xd8))(plVar2[3],&local_58,1);\n  if (iVar5 == 0) {\n    ERR_clear_error();\n    do {\n      iVar5 = (**(code **)(**(long **)(lVar4 + 0x10) + 0xe0))(plVar2[3],&local_68,1,&local_60);\n      if (iVar5 != 0) {\n        FUN_001099a0(0x76,iVar5,\"p11_cert.c\",0xac);\n        break;\n      }\n      ERR_clear_error();\n      if (local_60 == 0) {\n        (**(code **)(**(long **)(lVar4 + 0x10) + 0xe8))(plVar2[3]);\n        CRYPTO_THREAD_unlock(*(undefined8 *)(lVar3 + 0x30));\n        if (param_2 != (long *)0x0) {\n          *param_2 = plVar1[6];\n        }\n        uVar6 = 0;\n        if (param_3 != (undefined4 *)0x0) {\n          *param_3 = *(undefined4 *)(plVar1 + 5);\n        }\n        goto LAB_001093c4;\n      }\n      iVar5 = FUN_00108c90(param_1,local_68,0);\n    } while (iVar5 == 0);\n    (**(code **)(**(long **)(lVar4 + 0x10) + 0xe8))(plVar2[3]);\n    CRYPTO_THREAD_unlock(*(undefined8 *)(lVar3 + 0x30));\n  }\n  else {\n    FUN_001099a0(0x6a,iVar5,\"p11_cert.c\",0x98);\n    CRYPTO_THREAD_unlock(*(undefined8 *)(lVar3 + 0x30));\n  }\n  uVar6 = 0xffffffff;\n  FUN_001091d0(param_1);\nLAB_001093c4:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar6;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nint pkcs11_enumerate_certs(PKCS11_TOKEN *token,\n\t\tPKCS11_CERT **certp, unsigned int *countp)\n{\n\tPKCS11_SLOT *slot = TOKEN2SLOT(token);\n\tPKCS11_CTX *ctx = SLOT2CTX(slot);\n\tPKCS11_TOKEN_private *tpriv = PRIVTOKEN(token);\n\tPKCS11_SLOT_private *spriv = PRIVSLOT(slot);\n\tPKCS11_CTX_private *cpriv = PRIVCTX(ctx);\n\tint rv;\n\n\t/* Make sure we have a session */\n\tif (!spriv->haveSession && PKCS11_open_session(slot, 0))\n\t\treturn -1;\n\n\tCRYPTO_THREAD_write_lock(cpriv->rwlock);\n\trv = pkcs11_find_certs(token);\n\tCRYPTO_THREAD_unlock(cpriv->rwlock);\n\tif (rv < 0) {\n\t\tpkcs11_destroy_certs(token);\n\t\treturn -1;\n\t}\n\n\tif (certp)\n\t\t*certp = tpriv->certs;\n\tif (countp)\n\t\t*countp = tpriv->ncerts;\n\treturn 0;\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_00389600(char param_1)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  long lVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  undefined *local_58 [2];\n  undefined local_48 [24];\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00b8aa20 == 0x1f) {\n    if (param_1 == '\\0') {\n      local_58[0] = local_48;\n      FUN_00274380(local_58,\"You can\\'t grasp things well enough to throw them.\");\n      FUN_005c9b70(local_58);\n      if (local_58[0] != local_48) {\n        operator_delete(local_58[0]);\n      }\n    }\n  }\n  else {\n    uVar1 = FUN_0037d680(DAT_00b8b9b8._4_4_);\n    if ((char)uVar1 == '\\0') {\n      if (param_1 == '\\0') {\n        FUN_005bb740(7);\n      }\n    }\n    else if (DAT_00b8d764 == 0) {\nLAB_00389760:\n      if (DAT_00b8d520 == 0) {\n        uVar2 = 0;\n        goto LAB_00389634;\n      }\n      if (param_1 == '\\0') {\n        FUN_005bb740(5);\n        uVar2 = uVar1;\n        goto LAB_00389634;\n      }\n    }\n    else {\n      lVar3 = FUN_00275420(&DAT_00b8a940);\n      if ((lVar3 == 0) || (uVar2 = FUN_00689fd0(lVar3), (char)uVar2 == '\\0')) {\n        if (param_1 == '\\0') {\n          uVar4 = FUN_003824d0(0);\n          FUN_005c6840(\"You cannot throw anything while %s.\",uVar4);\n          uVar2 = uVar1;\n          goto LAB_00389634;\n        }\n      }\n      else {\n        if (*(char *)(lVar3 + 1) == '\\x1c') goto LAB_00389760;\n        if (param_1 == '\\0') {\n          uVar4 = FUN_003824d0(0);\n          FUN_0069cf40(local_58,lVar3,7,0,0,1,0);\n          FUN_005c6840(\"You cannot shoot with your %s while %s.\",local_58[0],uVar4,0);\n          if (local_58[0] != local_48) {\n            operator_delete(local_58[0]);\n          }\n          goto LAB_00389634;\n        }\n      }\n    }\n  }\n  uVar2 = 1;\nLAB_00389634:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n Revised code:\nbool fire_warn_if_impossible(bool silent)\n{\n    if (you.species == SP_FELID)\n    {\n        if (!silent)\n            mpr(\"You can't grasp things well enough to throw them.\");\n        return true;\n    }\n    if (!form_can_wield())\n    {\n        if (!silent)\n            canned_msg(MSG_PRESENT_FORM);\n        return true;\n    }\n    if (you.attribute[ATTR_HELD])\n    {\n        const item_def *weapon = you.weapon();\n        if (!weapon || !is_range_weapon(*weapon))\n        {\n            if (!silent)\n                mprf(\"You cannot throw anything while %s.\", held_status());\n            return true;\n        }\n        else if (weapon->sub_type != WPN_BLOWGUN)\n        {\n            if (!silent)\n            {\n                mprf(\"You cannot shoot with your %s while %s.\",\n                     weapon->name(DESC_BASENAME).c_str(), held_status());\n            }\n            return true;\n        }\n    }\n    if (you.berserk())\n    {\n        if (!silent)\n            canned_msg(MSG_TOO_BERSERK);\n        return true;\n    }\n    return false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_0026ef42(undefined8 param_1,long param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_1018 [4104];\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = is_orphan_vg(param_2);\n  if (iVar1 == 0) {\n    iVar1 = is_global_vg(param_2);\n    if (iVar1 != 0) goto LAB_0026efa1;\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/V_%s\",&DAT_003a8f80,param_2);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x37,0xffffffff,\"Too long locking filename %s/V_%s.\",\n                &DAT_003a8f80,param_2);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  else {\nLAB_0026efa1:\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/P_%s\",&DAT_003a8f80,param_2 + 1);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x32,0xffffffff,\"Too long locking filename %s/P_%s.\",\n                &DAT_003a8f80,param_2 + 1);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  iVar1 = lock_file(local_1018,param_3);\n  if (iVar1 == 0) {\n    print_log(7,\"locking/file_locking.c\",0x3c,0,\"<backtrace>\");\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 1;\n  }\nLAB_0026f0f0:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return uVar2;\n}",
        "output": "```c\nbool lock_volume(const char* volume_name, uint32_t lock_type)\n{\n    char lock_filename[4096];\n    int result;\n\n    // Check if the volume is an orphan volume group\n    if (is_orphan_vg(volume_name)) {\n        // Generate lock filename for orphan volume group\n        result = snprintf(lock_filename, sizeof(lock_filename), \"%s/P_%s\", LOCK_DIR, volume_name + 1);\n        if (result < 0 || result >= sizeof(lock_filename)) {\n            log_error(\"Too long locking filename %s/P_%s.\", LOCK_DIR, volume_name + 1);\n            return false;\n        }\n    } \n    else {\n        // Check if the volume is a global volume group\n        if (is_global_vg(volume_name)) {\n            // Generate lock filename for global volume group\n            result = snprintf(lock_filename, sizeof(lock_filename), \"%s/P_%s\", LOCK_DIR, volume_name + 1);\n            if (result < 0 || result >= sizeof(lock_filename)) {\n                log_error(\"Too long locking filename %s/P_%s.\", LOCK_DIR, volume_name + 1);\n                return false;\n            }\n        } \n        else {\n            // Generate lock filename for regular volume group\n            result = snprintf(lock_filename, sizeof(lock_filename), \"%s/V_%s\", LOCK_DIR, volume_name);\n            if (result < 0 || result >= sizeof(lock_filename)) {\n                log_error(\"Too long locking filename %s/V_%s.\", LOCK_DIR, volume_name);\n                return false;\n            }\n        }\n    }\n\n    // Attempt to lock the file\n    if (!lock_file(lock_filename, lock_type)) {\n        log_debug(\"<backtrace>\");\n        return false;\n    }\n\n    return true;\n}\n```",
        "source_code": "static int _file_lock_resource(struct cmd_context *cmd, const char *resource,\n\t\t\t       uint32_t flags, const struct logical_volume *lv)\n{\n\tchar lockfile[PATH_MAX];\n\tif (is_orphan_vg(resource) || is_global_vg(resource)) {\n\t\tif (dm_snprintf(lockfile, sizeof(lockfile),\n\t\t\t\t\"%s/P_%s\", _lock_dir, resource + 1) < 0) {\n\t\t\tlog_error(\"Too long locking filename %s/P_%s.\", _lock_dir, resource + 1);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tif (dm_snprintf(lockfile, sizeof(lockfile), \"%s/V_%s\", _lock_dir, resource) < 0) {\n\t\t\tlog_error(\"Too long locking filename %s/V_%s.\", _lock_dir, resource);\n\t\t\treturn 0;\n\t\t}\n\tif (!lock_file(lockfile, flags))\n\t\treturn_0;\n\treturn 1;\n}",
        "parsed_output": "bool lock_volume(const char* volume_name, uint32_t lock_type)\n{\n    char lock_filename[4096];\n    int result;\n\n    // Check if the volume is an orphan volume group\n    if (is_orphan_vg(volume_name)) {\n        // Generate lock filename for orphan volume group\n        result = snprintf(lock_filename, sizeof(lock_filename), \"%s/P_%s\", LOCK_DIR, volume_name + 1);\n        if (result < 0 || result >= sizeof(lock_filename)) {\n            log_error(\"Too long locking filename %s/P_%s.\", LOCK_DIR, volume_name + 1);\n            return false;\n        }\n    } \n    else {\n        // Check if the volume is a global volume group\n        if (is_global_vg(volume_name)) {\n            // Generate lock filename for global volume group\n            result = snprintf(lock_filename, sizeof(lock_filename), \"%s/P_%s\", LOCK_DIR, volume_name + 1);\n            if (result < 0 || result >= sizeof(lock_filename)) {\n                log_error(\"Too long locking filename %s/P_%s.\", LOCK_DIR, volume_name + 1);\n                return false;\n            }\n        } \n        else {\n            // Generate lock filename for regular volume group\n            result = snprintf(lock_filename, sizeof(lock_filename), \"%s/V_%s\", LOCK_DIR, volume_name);\n            if (result < 0 || result >= sizeof(lock_filename)) {\n                log_error(\"Too long locking filename %s/V_%s.\", LOCK_DIR, volume_name);\n                return false;\n            }\n        }\n    }\n\n    // Attempt to lock the file\n    if (!lock_file(lock_filename, lock_type)) {\n        log_debug(\"<backtrace>\");\n        return false;\n    }\n\n    return true;\n}",
        "baseline_code_stripped": "undefined8 FUN_0026ef42(undefined8 param_1,long param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_1018 [4104];\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = is_orphan_vg(param_2);\n  if (iVar1 == 0) {\n    iVar1 = is_global_vg(param_2);\n    if (iVar1 != 0) goto LAB_0026efa1;\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/V_%s\",&DAT_003a8f80,param_2);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x37,0xffffffff,\"Too long locking filename %s/V_%s.\",\n                &DAT_003a8f80,param_2);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  else {\nLAB_0026efa1:\n    iVar1 = dm_snprintf(local_1018,0x1000,\"%s/P_%s\",&DAT_003a8f80,param_2 + 1);\n    if (iVar1 < 0) {\n      print_log(3,\"locking/file_locking.c\",0x32,0xffffffff,\"Too long locking filename %s/P_%s.\",\n                &DAT_003a8f80,param_2 + 1);\n      uVar2 = 0;\n      goto LAB_0026f0f0;\n    }\n  }\n  iVar1 = lock_file(local_1018,param_3);\n  if (iVar1 == 0) {\n    print_log(7,\"locking/file_locking.c\",0x3c,0,\"<backtrace>\");\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 1;\n  }\nLAB_0026f0f0:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return uVar2;\n}",
        "similarity_score_unixcoder": 0.8324753642082214,
        "similarity_score_baseline_stripped": 0.6461787223815918
    },
    {
        "func_name": "dealloc_KMJobManager_JobFilter",
        "normed_func_sha256": "5427e3fe5bc20e178b28086e6103e14e942871ba7b85af2009f0b13e6f84fe7e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_000fe9a4(int param_1)\n{\n  if (*(int *)(param_1 + 0x1c) != 0) {\n    FUN_0008b94c(*(undefined4 *)(param_1 + 0x34));\n    return;\n  }\n  return;\n}\n\n Revised code:\nvoid WalletView::usedReceivingAddresses()\n{\n    if(!walletModel)\n        return;\n\n    GUIUtil::bringToFront(usedReceivingAddressesPage);\n}\n\n## Example:\n\n Input code:\nvoid FUN_00de38d0(undefined4 param_1,int param_2)\n{\n  FUN_00e98790();\n  if ((*(uint *)(param_2 + 0x10) & 0x100) == 0) {\n    return;\n  }\n  FUN_00de3680(param_1);\n  return;\n}\n\n Revised code:\nvoid SVGFEImageElement::removedFrom(ContainerNode* rootParent)\n{\n    SVGFilterPrimitiveStandardAttributes::removedFrom(rootParent);\n    if (rootParent->inDocument())\n        clearResourceReferences();\n}\n\n## Example:\n\n Input code:\nvoid FUN_004f1220(long param_1)\n{\n  if ((*(byte *)(param_1 + 0x20) & 2) != 0) {\n    *(undefined8 *)(*(long *)(param_1 + 0x18) + 0x150) = 0;\n  }\n  if ((*(uint *)(param_1 + 0x20) & 4) == 0) {\n    return;\n  }\n  FUN_004f1200(*(undefined8 *)(param_1 + 0x18));\n  return;\n}\n\n Revised code:\nstatic void dealloc_KEditToolbar(sipWrapper *sipSelf)\n{\n    if (sipIsDerived(sipSelf))\n        reinterpret_cast<sipKEditToolbar *>(sipSelf->u.cppPtr)->sipPySelf = NULL;\n\n    if (sipIsPyOwned(sipSelf))\n    {\n        release_KEditToolbar(sipSelf->u.cppPtr,sipSelf->flags);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00021390(int param_1)\n{\n  if ((*(byte *)(param_1 + 0x10) & 4) == 0) {\n    return;\n  }\n  FUN_00021360(*(undefined4 *)(param_1 + 0xc),0);\n  return;\n}",
        "output": "static void handleEvent(Event* event)\n{\n    if (!(event->flags & EventFlag::Processed))\n        return;\n\n    processEvent(event->data, 0);\n}",
        "source_code": "static void dealloc_KMJobManager_JobFilter(sipWrapper *sipSelf)\n{\n    if (sipIsPyOwned(sipSelf))\n    {\n        release_KMJobManager_JobFilter(sipSelf->u.cppPtr,0);\n    }\n}",
        "parsed_output": "static void handleEvent(Event* event)\n{\n    if (!(event->flags & EventFlag::Processed))\n        return;\n\n    processEvent(event->data, 0);\n}",
        "baseline_code_stripped": "void FUN_00021390(int param_1)\n{\n  if ((*(byte *)(param_1 + 0x10) & 4) == 0) {\n    return;\n  }\n  FUN_00021360(*(undefined4 *)(param_1 + 0xc),0);\n  return;\n}",
        "similarity_score_unixcoder": 0.2951468229293823,
        "similarity_score_baseline_stripped": 0.3705351948738098
    },
    {
        "func_name": "read_some_at",
        "normed_func_sha256": "22876c97c441a52ff8f9c3a58ad5158f419a006f145da58c42f0cb8924fab1e4",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __thiscall\nC4GUI::ComboBox::MouseInput\n          (ComboBox *this,CMouse *param_1,int param_2,int param_3,int param_4,uint param_5)\n{\n  char cVar1;\n  long lVar2;\n  if ((byte)this[0x2b9] < (param_2 == 1)) {\n    lVar2 = (**(code **)(*(long *)this + 0xa8))();\n    if ((lVar2 == 0) || (*(int *)(this + 0xa8) != ContextMenu::iGlobalMenuIndex)) {\n      *(undefined4 *)(this + 0xa8) = 0;\n    }\n    else if (*(int *)(this + 0xa8) != 0) {\n      return;\n    }\n    cVar1 = DoDropdown(this);\n    if (cVar1 != '\\0') {\n      return;\n    }\n  }\n  Control::MouseInput((Control *)this,param_1,param_2,param_3,param_4,param_5);\n  return;\n}\n\n Revised code:\nvoid ComboBox::MouseInput(CMouse &rMouse, int32_t iButton, int32_t iX, int32_t iY, DWORD dwKeyParam)\n\t{\n\t\t// left-click activates menu\n\t\tif (!fReadOnly) if (iButton == C4MC_Button_LeftDown)\n\t\t\t{\n\t\t\t\t// recheck open menu\n\t\t\t\tScreen *pScr = GetScreen();\n\t\t\t\tif (!pScr || (iOpenMenu != pScr->GetLastContextMenuIndex())) iOpenMenu = 0;\n\t\t\t\tif (iOpenMenu)\n\t\t\t\t\t// left-click with combo down: abort has been done by screen; ignore\n\t\t\t\t\treturn;\n\t\t\t\telse\n\t\t\t\t\t// otherwise, open it\n\t\t\t\t\tif (DoDropdown()) return;\n\t\t\t}\n\t\t// inherited\n\t\tControl::MouseInput(rMouse, iButton, iX, iY, dwKeyParam);\n\t}\n\n## Example:\n\n Input code:\nvoid __thiscall sipQgsColorBox::dragLeaveEvent(sipQgsColorBox *this,QDragLeaveEvent *param_1)\n{\n  longlong lVar1;\n  longlong in_r13;\n  undefined4 local_1c;\n  longlong local_18;\n  local_18 = *(longlong *)(in_r13 + -0x7010);\n  lVar1 = (***(code ***)(sipAPI__gui + 0x2c8))\n                    (&local_1c,this + 0x6c,*(undefined8 *)(this + 0x58),0,\"dragLeaveEvent\");\n  if (lVar1 == 0) {\n    FUN_0052d0c0(this,param_1);\n  }\n  else {\n    FUN_00549220(local_1c,0,*(undefined8 *)(this + 0x58),lVar1,param_1);\n  }\n  if (local_18 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  FUN_0053aba0();\n}\n\n Revised code:\nint sipQgsColorBox::metric( ::QPaintDevice::PaintDeviceMetric a0) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[39]),sipPySelf,NULL,sipName_metric);\n\n    if (!sipMeth)\n        return  ::QgsColorBox::metric(a0);\n\n    extern int sipVH__gui_7(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QPaintDevice::PaintDeviceMetric);\n\n    return sipVH__gui_7(sipGILState, 0, sipPySelf, sipMeth, a0);\n}\n\n## Example:\n\n Input code:\nvoid __thiscall FUN_004549e0(void *this,HDROP param_1)\n{\n  POINT ptParentClientCoords;\n  HWND hWnd;\n  void *pvVar1;\n  BOOL BVar2;\n  UINT iFile;\n  int iVar3;\n  void *pvStack_21c;\n  UINT UStack_218;\n  tagPOINT local_214;\n  undefined4 auStack_20c [130];\n  uint local_4;\n  local_4 = DAT_0055bff8 ^ (uint)&pvStack_21c;\n  if (param_1 != (HDROP)0x0) {\n    DragQueryPoint(param_1,&local_214);\n    ptParentClientCoords.y = local_214.y;\n    ptParentClientCoords.x = local_214.x;\n    hWnd = RealChildWindowFromPoint(*(HWND *)(*(int *)((int)this + 4) + 0xc),ptParentClientCoords);\n    if (hWnd != (HWND)0x0) {\n      if ((*(HWND *)((int)this + 0x480) == hWnd) || (*(HWND *)((int)this + 0x340) == hWnd)) {\n        iVar3 = 0;\n      }\n      else {\n        if ((*(HWND *)((int)this + 0x440) != hWnd) && (*(HWND *)((int)this + 0x3bc) != hWnd)) {\n          SendMessageW(hWnd,0x233,(WPARAM)param_1,0);\n          goto LAB_00454b0c;\n        }\n        iVar3 = 1;\n      }\n      FUN_00452de0(this,iVar3);\n      UStack_218 = DragQueryFileW(param_1,0xffffffff,(LPWSTR)0x0,0);\n      pvStack_21c = (void *)0x0;\n      if (0 < (int)UStack_218) {\n        iFile = 0;\n        do {\n          DragQueryFileW(param_1,iFile,(LPWSTR)auStack_20c,0x104);\n          pvVar1 = (void *)FUN_0046de20(this,auStack_20c,0,'\\0',0xffffffff,(undefined4 *)0x0,0,0);\n          if (pvVar1 != (void *)0x0) {\n            pvStack_21c = pvVar1;\n          }\n          iFile = iFile + 1;\n        } while ((int)iFile < (int)UStack_218);\n        if (pvStack_21c != (void *)0x0) {\n          FUN_00452f70(this,pvStack_21c);\n        }\n      }\n      DragFinish(param_1);\n      BVar2 = IsIconic(*(HWND *)(*(int *)((int)this + 4) + 0xc));\n      if (BVar2 != 0) {\n        ShowWindow(*(HWND *)(*(int *)((int)this + 4) + 0xc),9);\n      }\n      SetForegroundWindow(*(HWND *)(*(int *)((int)this + 4) + 0xc));\n    }\n  }\nLAB_00454b0c:\n  ___security_check_cookie_4(local_4 ^ (uint)&pvStack_21c);\n  return;\n}\n\n Revised code:\nvoid Notepad_plus::dropFiles(HDROP hdrop)\r\n{\r\n\tif (hdrop)\r\n\t{\r\n\t\t// Determinate in which view the file(s) is (are) dropped\r\n\t\tPOINT p;\r\n\t\t::DragQueryPoint(hdrop, &p);\r\n\t\tHWND hWin = ::RealChildWindowFromPoint(_pPublicInterface->getHSelf(), p);\r\n\t\tif (!hWin) return;\r\n\r\n\t\tif ((_mainEditView.getHSelf() == hWin) || (_mainDocTab.getHSelf() == hWin))\r\n\t\t\tswitchEditViewTo(MAIN_VIEW);\r\n\t\telse if ((_subEditView.getHSelf() == hWin) || (_subDocTab.getHSelf() == hWin))\r\n\t\t\tswitchEditViewTo(SUB_VIEW);\r\n\t\telse\r\n\t\t{\r\n\t\t\t::SendMessage(hWin, WM_DROPFILES, (WPARAM)hdrop, 0);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint filesDropped = ::DragQueryFile(hdrop, 0xffffffff, NULL, 0);\r\n\t\tBufferID lastOpened = BUFFER_INVALID;\r\n\t\tfor (int i = 0 ; i < filesDropped ; ++i)\r\n\t\t{\r\n\t\t\tTCHAR pathDropped[MAX_PATH];\r\n\t\t\t::DragQueryFile(hdrop, i, pathDropped, MAX_PATH);\r\n\t\t\tBufferID test = doOpen(pathDropped);\r\n\t\t\tif (test != BUFFER_INVALID)\r\n\t\t\t\tlastOpened = test;\r\n            //setLangStatus(_pEditView->getCurrentDocType());\r\n\t\t}\r\n\t\tif (lastOpened != BUFFER_INVALID) {\r\n\t\t\tswitchToFile(lastOpened);\r\n\t\t}\r\n\t\t::DragFinish(hdrop);\r\n\t\t// Put Notepad_plus to forefront\r\n\t\t// May not work for Win2k, but OK for lower versions\r\n\t\t// Note: how to drop a file to an iconic window?\r\n\t\t// Actually, it is the Send To command that generates a drop.\r\n\t\tif (::IsIconic(_pPublicInterface->getHSelf()))\r\n\t\t{\r\n\t\t\t::ShowWindow(_pPublicInterface->getHSelf(), SW_RESTORE);\r\n\t\t}\r\n\t\t::SetForegroundWindow(_pPublicInterface->getHSelf());\r\n\t}\r\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nulong __thiscall\nCOleDropTarget::OnDragEnter\n          (COleDropTarget *this,CWnd *param_1,COleDataObject *param_2,ulong param_3,CPoint param_4)\n{\n  ulong uVar1;\n  uVar1 = OnDragEnter(this,param_1,param_2,param_3,param_4);\n  return uVar1;\n}",
        "output": "```c++\nDWORD COleDropTarget::OnDragEnter(CWnd *pWnd, COleDataObject *pDataObject, DWORD dwKeyState, CPoint point)\n{\n    return OnDragEnter(pWnd, pDataObject, dwKeyState, point);\n}\n```",
        "source_code": "size_t read_some_at(implementation_type& impl, uint64_t offset,\r\n      const MutableBufferSequence& buffers, boost::system::error_code& ec)\r\n  {\r\n    boost::asio::mutable_buffer buffer =\r\n      buffer_sequence_adapter<boost::asio::mutable_buffer,\r\n        MutableBufferSequence>::first(buffers);\r\n    return do_read(impl, offset, buffer, ec);\r\n  }",
        "parsed_output": "++\nDWORD COleDropTarget::OnDragEnter(CWnd *pWnd, COleDataObject *pDataObject, DWORD dwKeyState, CPoint point)\n{\n    return OnDragEnter(pWnd, pDataObject, dwKeyState, point);\n}",
        "baseline_code_stripped": "ulong __thiscall\nCOleDropTarget::OnDragEnter\n          (COleDropTarget *this,CWnd *param_1,COleDataObject *param_2,ulong param_3,CPoint param_4)\n{\n  ulong uVar1;\n  uVar1 = OnDragEnter(this,param_1,param_2,param_3,param_4);\n  return uVar1;\n}",
        "similarity_score_unixcoder": 0.16457128524780273,
        "similarity_score_baseline_stripped": 0.2316918671131134
    },
    {
        "func_name": "lock_sec_rec_cons_read_sees",
        "normed_func_sha256": "a26d76f3057dd92f798a56ff71f5a80a588fd4e6d8f8570c1f04c4b84f408f6d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_1000e950(longlong param_1,uint param_2,uint param_3,uint param_4,longlong param_5)\n{\n  uint uVar1;\n  if (param_5 != 0) {\n    uVar1 = 0;\n    if (param_3 < param_2) {\n      uVar1 = 0xff;\n    }\n    if ((*(uint *)(param_1 + 0x338) & 2) != 0) {\n      *(uint *)(param_1 + 0x32c) = *(uint *)(param_1 + 0x32c) & uVar1;\n      return;\n    }\n    *(uint *)(param_1 + 0x32c) = uVar1;\n    *(uint *)(param_1 + 0x338) = *(uint *)(param_1 + 0x338) | 2;\n    return;\n  }\n  if ((*(uint *)(param_1 + 0x32c) & 1) != 0) {\n    return;\n  }\n  if (*(int *)(param_1 + 0x110) != 0) {\n    return;\n  }\n  *(undefined4 *)(param_1 + 0x110) = 1;\n  *(uint *)(param_1 + 0x114) = (param_4 & 0xfffffffc) + *(int *)(param_1 + 0xa4);\n  return;\n}\n\n Revised code:\nvoid HELPER(J4_cmpgtui_fp1_jump_nt)(CPUHexagonState *env, int32_t RsV, int32_t UiV, int32_t riV, uint32_t part1)\n{\n    uint32_t slot __attribute__((unused)) = 4;\n    {fPART1(fWRITE_P1(f8BITSOF((fCAST4u(RsV)>UiV)))) fBRANCH_SPECULATE_STALL(fLSBNEW1NOT,,SPECULATE_NOT_TAKEN,13,0) if (fLSBNEW1NOT) {fIMMEXT(riV); fPCALIGN(riV); fBRANCH(fREAD_PC()+riV,COF_TYPE_JUMP);}}\n}\n\n## Example:\n\n Input code:\nundefined4 __thiscall FUN_006636e0(int param_1_00,uint *param_1)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(**(int **)(param_1_00 + 0x14) + 0x23) >> 6 & 0xf;\n  if (((uVar1 == 7) || (uVar1 == 10)) &&\n     ((uVar1 = *param_1, (uVar1 & 3) != 1 ||\n      (((0x7f < *(byte *)(*(int *)(uVar1 - 1) + 7) && (*(char *)(*(int *)(uVar1 - 1) + 7) != -0x80))\n       || (uVar1 = FUN_00561610(), *param_1 != uVar1)))))) {\n    return 0;\n  }\n  return 1;\n}\n\n Revised code:\nbool IC::IsNameCompatibleWithMonomorphicPrototypeFailure(Handle<Object> name) {\n  if (target()->is_keyed_stub()) {\n    // Determine whether the failure is due to a name failure.\n    if (!name->IsName()) return false;\n    Name* stub_name = target()->FindFirstName();\n    if (*name != stub_name) return false;\n  }\n\n  return true;\n}\n\n## Example:\n\n Input code:\nuint FUN_0010f5f0(int param_1,int param_2)\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uVar3 = *(uint *)(param_2 + 8);\n  bVar1 = *(byte *)(param_1 + 0x5afc);\n  uVar2 = bVar1 & 0x20;\n  if ((bVar1 & 0x20) == 0) {\n    uVar4 = ((bVar1 ^ 0x40) << 0x19) >> 0x1f;\n    if (0x1e < uVar3) {\n      uVar4 = 1;\n    }\n    if (uVar4 == 0) {\n      uVar2 = 1 << (uVar3 & 0xff);\n      if ((uVar2 & 0x22222221) != 0) goto LAB_0010f654;\n      uVar2 = uVar2 & 0x44444440;\n      if (uVar2 != 0) {\n        return (uint)(*(int *)(param_2 + 0x14) == 0x40);\n      }\n    }\n  }\n  else {\n    if (0x1f < uVar3) {\n      return 0;\n    }\n    uVar2 = 1 << (uVar3 & 0xff);\n    if ((uVar2 & 0xccc0ccc1) != 0) {\nLAB_0010f654:\n      return (uint)(*(uint *)(param_2 + 0x14) < 0x41);\n    }\n    uVar2 = uVar2 & 0xc;\n    if (uVar2 != 0) {\n      return (uint)(*(int *)(param_2 + 0x14) == 0x20);\n    }\n  }\n  return uVar2;\n}\n\n Revised code:\nBOOL_32 Gfx9Lib::IsValidDisplaySwizzleMode(\n    const ADDR2_COMPUTE_SURFACE_INFO_INPUT* pIn) const\n{\n    BOOL_32 support = FALSE;\n    const AddrSwizzleMode swizzleMode = pIn->swizzleMode;\n    if (m_settings.isDce12)\n    {\n        switch (swizzleMode)\n        {\n            case ADDR_SW_256B_D:\n            case ADDR_SW_256B_R:\n                support = (pIn->bpp == 32);\n                break;\n            case ADDR_SW_LINEAR:\n            case ADDR_SW_4KB_D:\n            case ADDR_SW_4KB_R:\n            case ADDR_SW_64KB_D:\n            case ADDR_SW_64KB_R:\n            case ADDR_SW_VAR_D:\n            case ADDR_SW_VAR_R:\n            case ADDR_SW_4KB_D_X:\n            case ADDR_SW_4KB_R_X:\n            case ADDR_SW_64KB_D_X:\n            case ADDR_SW_64KB_R_X:\n            case ADDR_SW_VAR_D_X:\n            case ADDR_SW_VAR_R_X:\n                support = (pIn->bpp <= 64);\n                break;\n            default:\n                break;\n        }\n    }\n    else if (m_settings.isDcn1)\n    {\n        switch (swizzleMode)\n        {\n            case ADDR_SW_4KB_D:\n            case ADDR_SW_64KB_D:\n            case ADDR_SW_VAR_D:\n            case ADDR_SW_64KB_D_T:\n            case ADDR_SW_4KB_D_X:\n            case ADDR_SW_64KB_D_X:\n            case ADDR_SW_VAR_D_X:\n                support = (pIn->bpp == 64);\n                break;\n            case ADDR_SW_LINEAR:\n            case ADDR_SW_4KB_S:\n            case ADDR_SW_64KB_S:\n            case ADDR_SW_VAR_S:\n            case ADDR_SW_64KB_S_T:\n            case ADDR_SW_4KB_S_X:\n            case ADDR_SW_64KB_S_X:\n            case ADDR_SW_VAR_S_X:\n                support = (pIn->bpp <= 64);\n                break;\n            default:\n                break;\n        }\n    }\n    else\n    {\n        ADDR_NOT_IMPLEMENTED();\n    }\n    return support;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nuint FUN_00c80530(uint param_1,int param_2,int param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(int *)(param_2 + 0x10) + 0x24) >> 0xb & 1;\n  if (uVar1 != 0) {\n    return uVar1;\n  }\n  param_1 = param_1 & -_DAT_01715a4c;\n  if ((param_1 & 0xfff) == 0) {\n    uVar1 = 1;\n    if (*(uint *)(param_3 + 8) <= *(uint *)(param_1 + 0x38)) {\n      if ((*(uint *)(param_3 + 8) == *(uint *)(param_1 + 0x38)) &&\n         (*(uint *)(param_1 + 0x3c) < *(uint *)(param_3 + 0xc))) {\n        uVar1 = 1;\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n    return uVar1;\n  }\n  __assert_fail(\"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n                \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\",0x22,\n                \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\");\n}",
        "output": "```c\nbool IsAlignedAndWithinBounds(uintptr_t ptr, const Metadata* meta, const Bounds* bounds) {\n    // Check if the alignment condition is met\n    if ((meta->flags >> 11) & 1) {\n        return true;\n    }\n\n    // Ensure the pointer is aligned to the required boundary\n    ptr &= ~AlignmentMask;\n    if ((ptr & 0xFFF) == 0) {\n        // Check if the bounds are satisfied\n        if (bounds->upperLimit <= *(uint32_t*)(ptr + OffsetUpper)) {\n            if ((bounds->upperLimit == *(uint32_t*)(ptr + OffsetUpper)) &&\n                (*(uint32_t*)(ptr + OffsetLower) < bounds->lowerLimit)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Alignment assertion failure\n    __assert_fail(\n        \"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n        \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\",\n        34,\n        \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\"\n    );\n}\n```",
        "source_code": "bool\nlock_sec_rec_cons_read_sees(\n/*========================*/\n\tconst rec_t*\t\trec,\t/*!< in: user record which\n\t\t\t\t\tshould be read or passed over\n\t\t\t\t\tby a read cursor */\n\tconst dict_index_t*\tindex,\t/*!< in: index */\n\tconst ReadView*\tview)\t/*!< in: consistent read view */\n{\n\tut_ad(page_rec_is_user_rec(rec));\n\tut_ad(!index->is_primary());\n\tut_ad(!rec_is_metadata(rec, *index));\n\n\t/* NOTE that we might call this function while holding the search\n\tsystem latch. */\n\n\tif (index->table->is_temporary()) {\n\n\t\t/* Temp-tables are not shared across connections and multiple\n\t\ttransactions from different connections cannot simultaneously\n\t\toperate on same temp-table and so read of temp-table is\n\t\talways consistent read. */\n\n\t\treturn(true);\n\t}\n\n\ttrx_id_t\tmax_trx_id = page_get_max_trx_id(page_align(rec));\n\n\tut_ad(max_trx_id > 0);\n\n\treturn(view->sees(max_trx_id));\n}",
        "parsed_output": "bool IsAlignedAndWithinBounds(uintptr_t ptr, const Metadata* meta, const Bounds* bounds) {\n    // Check if the alignment condition is met\n    if ((meta->flags >> 11) & 1) {\n        return true;\n    }\n\n    // Ensure the pointer is aligned to the required boundary\n    ptr &= ~AlignmentMask;\n    if ((ptr & 0xFFF) == 0) {\n        // Check if the bounds are satisfied\n        if (bounds->upperLimit <= *(uint32_t*)(ptr + OffsetUpper)) {\n            if ((bounds->upperLimit == *(uint32_t*)(ptr + OffsetUpper)) &&\n                (*(uint32_t*)(ptr + OffsetLower) < bounds->lowerLimit)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Alignment assertion failure\n    __assert_fail(\n        \"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n        \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\",\n        34,\n        \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\"\n    );\n}",
        "baseline_code_stripped": "uint FUN_00c80530(uint param_1,int param_2,int param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(int *)(param_2 + 0x10) + 0x24) >> 0xb & 1;\n  if (uVar1 != 0) {\n    return uVar1;\n  }\n  param_1 = param_1 & -_DAT_01715a4c;\n  if ((param_1 & 0xfff) == 0) {\n    uVar1 = 1;\n    if (*(uint *)(param_3 + 8) <= *(uint *)(param_1 + 0x38)) {\n      if ((*(uint *)(param_3 + 8) == *(uint *)(param_1 + 0x38)) &&\n         (*(uint *)(param_1 + 0x3c) < *(uint *)(param_3 + 0xc))) {\n        uVar1 = 1;\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n    return uVar1;\n  }\n  __assert_fail(\"reinterpret_cast<size_t>(ptr) % Alignment == 0\",\n                \"/home/abuild/rpmbuild/BUILD/mariadb-10.5.10/include/assume_aligned.h\",0x22,\n                \"T my_assume_aligned(T) [with unsigned int Alignment = 4096; T = unsigned char*]\");\n}",
        "similarity_score_unixcoder": 0.5298433303833008,
        "similarity_score_baseline_stripped": 0.562998354434967
    },
    {
        "func_name": "dino_entities_call_set_id",
        "normed_func_sha256": "e8c587dc368c66bdda52014c3bdeaea5cb523d64e123325b3f623b49dfe9ad4f",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_00036ef8(int param_1,int param_2)\n{\n  int iVar1;\n  undefined4 uVar2;\n  if (param_1 == 0) {\n    g_return_if_fail_warning(0,\"slingshot_backend_app_set_target\",\"self != NULL\");\n  }\n  else {\n    iVar1 = slingshot_backend_app_get_target(param_1);\n    if (param_2 != iVar1) {\n      uVar2 = FUN_00034980(param_2);\n      if (*(int *)(*(int *)(param_1 + 0xc) + 0x54) != 0) {\n        g_object_unref(*(undefined4 *)(*(int *)(param_1 + 0xc) + 0x54));\n        *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x54) = 0;\n      }\n      *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x54) = uVar2;\n      g_object_notify_by_pspec(param_1,DAT_000cf19c);\n    }\n  }\n  return;\n}\n\n Revised code:\nstatic void\nslingshot_backend_app_set_target (SlingshotBackendApp* self,\n                                  SynapseMatch* value)\n{\n#line 54 \"/builddir/build/BUILD/applications-menu-2.4.0/src/Backend/App.vala\"\n\tg_return_if_fail (self != NULL);\n#line 54 \"/builddir/build/BUILD/applications-menu-2.4.0/src/Backend/App.vala\"\n\tif (slingshot_backend_app_get_target (self) != value) {\n#line 1620 \"App.c\"\n\t\tSynapseMatch* _tmp0_;\n#line 54 \"/builddir/build/BUILD/applications-menu-2.4.0/src/Backend/App.vala\"\n\t\t_tmp0_ = _g_object_ref0 (value);\n#line 54 \"/builddir/build/BUILD/applications-menu-2.4.0/src/Backend/App.vala\"\n\t\t_g_object_unref0 (self->priv->_target);\n#line 54 \"/builddir/build/BUILD/applications-menu-2.4.0/src/Backend/App.vala\"\n\t\tself->priv->_target = _tmp0_;\n#line 54 \"/builddir/build/BUILD/applications-menu-2.4.0/src/Backend/App.vala\"\n\t\tg_object_notify_by_pspec ((GObject *) self, slingshot_backend_app_properties[SLINGSHOT_BACKEND_APP_TARGET_PROPERTY]);\n#line 1630 \"App.c\"\n\t}\n}\n\n## Example:\n\n Input code:\nvoid user_list_set_current_user(int param_1,int param_2)\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  if (param_1 == 0) {\n    g_return_if_fail_warning(0,\"user_list_set_current_user\",\"self != NULL\");\n    return;\n  }\n  iVar3 = *(int *)(param_1 + 0xc);\n  iVar1 = *(int *)(iVar3 + 8);\n  if (param_2 != iVar1) {\n    if (param_2 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = g_object_ref(param_2);\n      iVar3 = *(int *)(param_1 + 0xc);\n      iVar1 = *(int *)(iVar3 + 8);\n    }\n    if (iVar1 != 0) {\n      g_object_unref();\n      iVar3 = *(int *)(param_1 + 0xc);\n      *(undefined4 *)(iVar3 + 8) = 0;\n    }\n    *(undefined4 *)(iVar3 + 8) = uVar2;\n    g_signal_emit(param_1,DAT_0003d05c,0,param_2);\n  }\n  g_object_notify_by_pspec(param_1,DAT_0003d050);\n  return;\n}\n\n Revised code:\nvoid user_list_set_current_user (UserList* self, LoginOption* value) {\n\tLoginOption* _tmp0_;\n\tLoginOption* _tmp1_;\n\tLoginOption* _tmp2_;\n\tg_return_if_fail (self != NULL);\n\t_tmp0_ = value;\n\t_tmp1_ = user_list_get_current_user (self);\n\t_tmp2_ = _tmp1_;\n\tif (_tmp0_ != _tmp2_) {\n\t\tLoginOption* _tmp3_;\n\t\tLoginOption* _tmp4_;\n\t\tLoginOption* _tmp5_;\n\t\t_tmp3_ = value;\n\t\t_tmp4_ = _g_object_ref0 (_tmp3_);\n\t\t_g_object_unref0 (self->priv->_current_user);\n\t\tself->priv->_current_user = _tmp4_;\n\t\t_tmp5_ = value;\n\t\tg_signal_emit (self, user_list_signals[USER_LIST_CURRENT_USER_CHANGED_SIGNAL], 0, _tmp5_);\n\t}\n\tg_object_notify_by_pspec ((GObject *) self, user_list_properties[USER_LIST_CURRENT_USER]);\n}\n\n## Example:\n\n Input code:\nvoid FUN_000221a0(int param_1,undefined4 param_2)\n{\n  int iVar1;\n  undefined4 uVar2;\n  if (param_1 == 0) {\n    g_return_if_fail_warning(0,\"audience_objects_video_set_title\",\"self != NULL\");\n    return;\n  }\n  iVar1 = g_strcmp0(param_2,*(undefined4 *)(*(int *)(param_1 + 0xc) + 0x10));\n  if (iVar1 == 0) {\n    return;\n  }\n  uVar2 = g_strdup(param_2);\n  g_free(*(undefined4 *)(*(int *)(param_1 + 0xc) + 0x10));\n  *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x10) = uVar2;\n  g_object_notify_by_pspec(param_1,DAT_000520ec);\n  return;\n}\n\n Revised code:\nstatic void\naudience_objects_video_set_title (AudienceObjectsVideo* self,\n                                  const gchar* value)\n{\n#line 34 \"../src/Objects/Video.vala\"\n\tg_return_if_fail (self != NULL);\n#line 34 \"../src/Objects/Video.vala\"\n\tif (g_strcmp0 (value, audience_objects_video_get_title (self)) != 0) {\n#line 1981 \"Video.c\"\n\t\tgchar* _tmp0_;\n#line 34 \"../src/Objects/Video.vala\"\n\t\t_tmp0_ = g_strdup (value);\n#line 34 \"../src/Objects/Video.vala\"\n\t\t_g_free0 (self->priv->_title);\n#line 34 \"../src/Objects/Video.vala\"\n\t\tself->priv->_title = _tmp0_;\n#line 34 \"../src/Objects/Video.vala\"\n\t\tg_object_notify_by_pspec ((GObject *) self, audience_objects_video_properties[AUDIENCE_OBJECTS_VIDEO_TITLE_PROPERTY]);\n#line 1991 \"Video.c\"\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid dino_entities_call_set_id(int param_1,int param_2)\n{\n  undefined4 uVar1;\n  int iVar2;\n  if (param_1 == 0) {\n    g_return_if_fail_warning(\"libdino\",\"dino_entities_call_set_id\",\"self != NULL\");\n    return;\n  }\n  iVar2 = dino_entities_call_get_id();\n  uVar1 = DAT_00104078;\n  if (iVar2 == param_2) {\n    return;\n  }\n  **(int **)(param_1 + 0xc) = param_2;\n  g_object_notify_by_pspec(param_1,uVar1);\n  return;\n}",
        "output": "```c\nstatic void\ndino_entities_call_set_id (DinoEntitiesCall* self,\n                           gint value)\n{\n\tg_return_if_fail (self != NULL);\n\tif (dino_entities_call_get_id (self) != value) {\n\t\tself->priv->_id = value;\n\t\tg_object_notify_by_pspec ((GObject *) self, dino_entities_call_properties[DINO_ENTITIES_CALL_ID_PROPERTY]);\n\t}\n}\n```",
        "source_code": "void\ndino_entities_call_set_id (DinoEntitiesCall* self,\n                           gint value)\n{\n\tgint old_value;\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\tg_return_if_fail (self != NULL);\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\told_value = dino_entities_call_get_id (self);\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\tif (old_value != value) {\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\t\tself->priv->_id = value;\n#line 21 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git18.20220517.f25bfb0/libdino/src/entity/call.vala\"\n\t\tg_object_notify_by_pspec ((GObject *) self, dino_entities_call_properties[DINO_ENTITIES_CALL_ID_PROPERTY]);\n#line 1849 \"call.c\"\n\t}\n}",
        "parsed_output": "static void\ndino_entities_call_set_id (DinoEntitiesCall* self,\n                           gint value)\n{\n\tg_return_if_fail (self != NULL);\n\tif (dino_entities_call_get_id (self) != value) {\n\t\tself->priv->_id = value;\n\t\tg_object_notify_by_pspec ((GObject *) self, dino_entities_call_properties[DINO_ENTITIES_CALL_ID_PROPERTY]);\n\t}\n}",
        "baseline_code_stripped": "void dino_entities_call_set_id(int param_1,int param_2)\n{\n  undefined4 uVar1;\n  int iVar2;\n  if (param_1 == 0) {\n    g_return_if_fail_warning(\"libdino\",\"dino_entities_call_set_id\",\"self != NULL\");\n    return;\n  }\n  iVar2 = dino_entities_call_get_id();\n  uVar1 = DAT_00104078;\n  if (iVar2 == param_2) {\n    return;\n  }\n  **(int **)(param_1 + 0xc) = param_2;\n  g_object_notify_by_pspec(param_1,uVar1);\n  return;\n}",
        "similarity_score_unixcoder": 0.8178899884223938,
        "similarity_score_baseline_stripped": 0.7299197912216187
    },
    {
        "func_name": "pattern1200",
        "normed_func_sha256": "cb1a269f014b9c94858235ab51b55d30b45163cd1841f98f0ebfd8cb93647c70",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint FUN_011f9080(long param_1,uint param_2)\n{\n  char cVar1;\n  byte bVar2;\n  cVar1 = FUN_00884d60(DAT_01e8e380);\n  if (cVar1 != '\\0') {\n    cVar1 = FUN_011d23e0(DAT_01e8e388,param_2);\n    if (cVar1 != '\\0') {\n      bVar2 = *(byte *)(param_1 + 2);\n      if ((bVar2 == param_2) &&\n         ((uint)bVar2 == (uint)*(byte *)(*(long *)(*(long *)(param_1 + 8) + 8) + 2))) {\n        cVar1 = FUN_011d17d0(DAT_01e8e390,bVar2);\n        if (cVar1 != '\\0') {\n          bVar2 = FUN_00884de0(DAT_01e8e3a0,bVar2);\n          return bVar2 - 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n\n Revised code:\nstatic int\npattern893 (rtx x1, machine_mode i1)\n{\n  rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\n  rtx x2;\n  int res ATTRIBUTE_UNUSED;\n  if (!register_operand (operands[0], i1)\n      || !aarch64_sync_memory_operand (operands[1], i1)\n      || GET_MODE (x1) != i1)\n    return -1;\n  x2 = XVECEXP (x1, 0, 0);\n  if (GET_MODE (x2) != i1\n      || !aarch64_plus_operand (operands[2], i1)\n      || !scratch_operand (operands[4], i1))\n    return -1;\n  return 0;\n}\n\n## Example:\n\n Input code:\nint FUN_00930b94(long param_1,uint param_2)\n{\n  byte bVar1;\n  char cVar2;\n  uint uVar3;\n  cVar2 = FUN_00c406f0(DAT_01d1a630);\n  if (cVar2 != '\\0') {\n    bVar1 = *(byte *)(param_1 + 2);\n    if (((bVar1 == param_2) && (cVar2 = FUN_00c406f0(DAT_01d1a638,(uint)bVar1), cVar2 != '\\0')) &&\n       (cVar2 = FUN_00c406f0(DAT_01d1a640,bVar1), cVar2 != '\\0')) {\n      uVar3 = FUN_00903aa4(DAT_01d1a648,0xf);\n      return (uVar3 & 0xff) - 1;\n    }\n  }\n  return -1;\n}\n\n Revised code:\nstatic int\npattern210 (rtx x1, machine_mode i1)\n{\n  rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\n  int res ATTRIBUTE_UNUSED;\n  if (!register_operand (operands[0], i1)\n      || GET_MODE (x1) != i1\n      || !register_operand (operands[1], i1)\n      || !register_operand (operands[2], i1)\n      || !aarch64_simd_shift_imm_offset_qi (operands[3], E_SImode))\n    return -1;\n  return 0;\n}\n\n## Example:\n\n Input code:\nint FUN_00df4112(long param_1,uint param_2,uint param_3)\n{\n  char cVar1;\n  byte bVar2;\n  cVar1 = FUN_01114a50(DAT_01f4f7a0);\n  if (cVar1 != '\\0') {\n    bVar2 = *(byte *)(param_1 + 2);\n    if ((((bVar2 == param_2) && ((uint)bVar2 == (uint)*(byte *)(*(long *)(param_1 + 8) + 2))) &&\n        (*(byte *)(*(long *)(*(long *)(param_1 + 8) + 8) + 2) == param_3)) &&\n       ((cVar1 = FUN_01114fc0(DAT_01f4f7a8,bVar2), cVar1 != '\\0' &&\n        (cVar1 = FUN_01114fc0(DAT_01f4f7b0,bVar2), cVar1 != '\\0')))) {\n      bVar2 = FUN_01309860(DAT_01f4f7b8,bVar2);\n      return bVar2 - 1;\n    }\n  }\n  return -1;\n}\n\n Revised code:\nstatic int\npattern1360 (rtx x1, machine_mode i1, machine_mode i2)\n{\n  rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\n  rtx x2, x3;\n  int res ATTRIBUTE_UNUSED;\n  if (!register_operand (operands[0], i1)\n      || GET_MODE (x1) != i1)\n    return -1;\n  x2 = XEXP (x1, 0);\n  if (GET_MODE (x2) != i1)\n    return -1;\n  x3 = XEXP (x2, 0);\n  if (GET_MODE (x3) != i2\n      || !nonimmediate_operand (operands[1], i1)\n      || !nonimmediate_operand (operands[2], i1)\n      || !nonimm_or_0_operand (operands[3], i1))\n    return -1;\n  return 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_00e9f69c(long param_1,uint param_2)\n{\n  char cVar1;\n  byte bVar2;\n  cVar1 = FUN_01175500(DAT_01f6e6a0);\n  if (cVar1 != '\\0') {\n    bVar2 = *(byte *)(param_1 + 2);\n    if ((((bVar2 == param_2) && (cVar1 = FUN_01568900(DAT_01f6e6a8,(uint)bVar2), cVar1 != '\\0')) &&\n        (cVar1 = FUN_012fad90(DAT_01f6e6b0,bVar2), cVar1 != '\\0')) &&\n       (cVar1 = FUN_01175500(DAT_01f6e6b8,bVar2), cVar1 != '\\0')) {\n      bVar2 = FUN_01175a40(DAT_01f6e6c0,bVar2);\n      return bVar2 - 1;\n    }\n  }\n  return -1;\n}",
        "output": "```c\nstatic int\npattern1740 (rtx x1, machine_mode i1)\n{\n  rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\n  int res ATTRIBUTE_UNUSED;\n  if (!register_operand (operands[0], i1)\n      || GET_MODE (x1) != i1\n      || !register_operand (operands[1], i1)\n      || !aarch64_simd_struct_operand (operands[2], i1)\n      || !aarch64_simd_struct_operand (operands[3], i1))\n    return -1;\n  return 0;\n}\n```",
        "source_code": "static int\npattern1200 (rtx x1, machine_mode i1)\n{\n  rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\n  int res ATTRIBUTE_UNUSED;\n  if (!register_operand (operands[0], i1)\n      || GET_MODE (x1) != i1\n      || !float_vector_all_ones_operand (operands[1], i1)\n      || !const0_operand (operands[2], i1)\n      || !register_operand (operands[3], i1)\n      || !nonimmediate_operand (operands[4], i1))\n    return -1;\n  return 0;\n}",
        "parsed_output": "static int\npattern1740 (rtx x1, machine_mode i1)\n{\n  rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\n  int res ATTRIBUTE_UNUSED;\n  if (!register_operand (operands[0], i1)\n      || GET_MODE (x1) != i1\n      || !register_operand (operands[1], i1)\n      || !aarch64_simd_struct_operand (operands[2], i1)\n      || !aarch64_simd_struct_operand (operands[3], i1))\n    return -1;\n  return 0;\n}",
        "baseline_code_stripped": "int FUN_00e9f69c(long param_1,uint param_2)\n{\n  char cVar1;\n  byte bVar2;\n  cVar1 = FUN_01175500(DAT_01f6e6a0);\n  if (cVar1 != '\\0') {\n    bVar2 = *(byte *)(param_1 + 2);\n    if ((((bVar2 == param_2) && (cVar1 = FUN_01568900(DAT_01f6e6a8,(uint)bVar2), cVar1 != '\\0')) &&\n        (cVar1 = FUN_012fad90(DAT_01f6e6b0,bVar2), cVar1 != '\\0')) &&\n       (cVar1 = FUN_01175500(DAT_01f6e6b8,bVar2), cVar1 != '\\0')) {\n      bVar2 = FUN_01175a40(DAT_01f6e6c0,bVar2);\n      return bVar2 - 1;\n    }\n  }\n  return -1;\n}",
        "similarity_score_unixcoder": 0.9441142082214355,
        "similarity_score_baseline_stripped": 0.422084778547287
    },
    {
        "func_name": "soap_PATCH__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes",
        "normed_func_sha256": "39820e1ced6d0c6b58d860554c52e53553b6efdb70d792e512a65c71fc8766f9",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_01266252(undefined8 param_1,undefined8 param_2,long *param_3)\n{\n  code *pcVar1;\n  bool bVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  FUN_01826b70(param_1);\n  iVar3 = FUN_01839be0(param_1,param_2,0,\"text/xml; charset=utf-8\");\n  if (iVar3 == 0) {\n    (**(code **)(*param_3 + 0x10))(param_3,param_1);\n    pcVar1 = *(code **)(*param_3 + 0x18);\n    lVar4 = (**(code **)*param_3)(param_3);\n    if (lVar4 == 0x357) {\n      puVar6 = &DAT_019647c8;\n    }\n    else {\n      puVar6 = (undefined *)0x0;\n    }\n    iVar3 = (*pcVar1)(param_3,param_1,\"vbox:IRecordingScreenSettings_getAudioHzResponse\",puVar6);\n    if (iVar3 == 0) {\n      iVar3 = FUN_018373f0(param_1);\n      if (iVar3 == 0) {\n        iVar3 = FUN_01841070(param_1);\n        if (iVar3 == 0) {\n          bVar2 = false;\n          goto LAB_01266344;\n        }\n      }\n    }\n  }\n  bVar2 = true;\nLAB_01266344:\n  if (bVar2) {\n    uVar5 = FUN_018222f0(param_1);\n  }\n  else {\n    uVar5 = 0;\n  }\n  return uVar5;\n}\n\n Revised code:\nint soap_PUT__vbox__IRecordingScreenSettings_USCOREgetAudioHzResponse(struct soap *soap, const char *URL, _vbox__IRecordingScreenSettings_USCOREgetAudioHzResponse const*p)\n{\n\tsoap_free_temp(soap);\n\tif (soap_PUT(soap, URL, NULL, \"text/xml; charset=utf-8\") || (p->soap_serialize(soap), 0) || p->soap_put(soap, \"vbox:IRecordingScreenSettings_getAudioHzResponse\", p->soap_type() == SOAP_TYPE__vbox__IRecordingScreenSettings_USCOREgetAudioHzResponse ? \"\" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))\n\t\treturn soap_closesock(soap);\n\treturn SOAP_OK;\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_016a3951(undefined8 param_1,undefined8 param_2,long *param_3)\n{\n  code *pcVar1;\n  bool bVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  FUN_01aca350(param_1);\n  iVar3 = FUN_01add460(param_1,param_2,0,\"text/xml; charset=utf-8\");\n  if (iVar3 == 0) {\n    (**(code **)(*param_3 + 0x10))(param_3,param_1);\n    pcVar1 = *(code **)(*param_3 + 0x18);\n    lVar4 = (**(code **)*param_3)(param_3);\n    if (lVar4 == 0xe50) {\n      puVar6 = &DAT_01fe53c0;\n    }\n    else {\n      puVar6 = (undefined *)0x0;\n    }\n    iVar3 = (*pcVar1)(param_3,param_1,\"vbox:IBooleanFormValue_setSelectedResponse\",puVar6);\n    if (iVar3 == 0) {\n      iVar3 = FUN_01adabd0(param_1);\n      if (iVar3 == 0) {\n        iVar3 = FUN_01ae4850(param_1);\n        if (iVar3 == 0) {\n          bVar2 = false;\n          goto LAB_016a3a43;\n        }\n      }\n    }\n  }\n  bVar2 = true;\nLAB_016a3a43:\n  if (bVar2) {\n    uVar5 = FUN_01ac5ad0(param_1);\n  }\n  else {\n    uVar5 = 0;\n  }\n  return uVar5;\n}\n\n Revised code:\nint soap_PATCH__vbox__IBooleanFormValue_USCOREsetSelectedResponse(struct soap *soap, const char *URL, _vbox__IBooleanFormValue_USCOREsetSelectedResponse const*p)\n{\n\tsoap_free_temp(soap);\n\tif (soap_PATCH(soap, URL, NULL, \"text/xml; charset=utf-8\") || (p->soap_serialize(soap), 0) || p->soap_put(soap, \"vbox:IBooleanFormValue_setSelectedResponse\", p->soap_type() == SOAP_TYPE__vbox__IBooleanFormValue_USCOREsetSelectedResponse ? \"\" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))\n\t\treturn soap_closesock(soap);\n\treturn SOAP_OK;\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_011f0442(undefined8 param_1,undefined8 param_2,long *param_3)\n{\n  code *pcVar1;\n  bool bVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  FUN_01826b70(param_1);\n  iVar3 = FUN_01839c80(param_1,param_2,0,\"text/xml; charset=utf-8\");\n  if (iVar3 == 0) {\n    (**(code **)(*param_3 + 0x10))(param_3,param_1);\n    pcVar1 = *(code **)(*param_3 + 0x18);\n    lVar4 = (**(code **)*param_3)(param_3);\n    if (lVar4 == 0xc2) {\n      puVar6 = &DAT_0195fd48;\n    }\n    else {\n      puVar6 = (undefined *)0x0;\n    }\n    iVar3 = (*pcVar1)(param_3,param_1,\"vbox:INATNetwork_setIPv6EnabledResponse\",puVar6);\n    if (iVar3 == 0) {\n      iVar3 = FUN_018373f0(param_1);\n      if (iVar3 == 0) {\n        iVar3 = FUN_01841070(param_1);\n        if (iVar3 == 0) {\n          bVar2 = false;\n          goto LAB_011f0534;\n        }\n      }\n    }\n  }\n  bVar2 = true;\nLAB_011f0534:\n  if (bVar2) {\n    uVar5 = FUN_018222f0(param_1);\n  }\n  else {\n    uVar5 = 0;\n  }\n  return uVar5;\n}\n\n Revised code:\nint soap_PATCH__vbox__INATNetwork_USCOREsetIPv6EnabledResponse(struct soap *soap, const char *URL, _vbox__INATNetwork_USCOREsetIPv6EnabledResponse const*p)\n{\n\tsoap_free_temp(soap);\n\tif (soap_PATCH(soap, URL, NULL, \"text/xml; charset=utf-8\") || (p->soap_serialize(soap), 0) || p->soap_put(soap, \"vbox:INATNetwork_setIPv6EnabledResponse\", p->soap_type() == SOAP_TYPE__vbox__INATNetwork_USCOREsetIPv6EnabledResponse ? \"\" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))\n\t\treturn soap_closesock(soap);\n\treturn SOAP_OK;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_016adba6(undefined8 param_1,undefined8 param_2,long *param_3)\n{\n  code *pcVar1;\n  bool bVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  FUN_01aca350(param_1);\n  iVar3 = FUN_01add460(param_1,param_2,0,\"text/xml; charset=utf-8\");\n  if (iVar3 == 0) {\n    (**(code **)(*param_3 + 0x10))(param_3,param_1);\n    pcVar1 = *(code **)(*param_3 + 0x18);\n    lVar4 = (**(code **)*param_3)(param_3);\n    if (lVar4 == 0xe37) {\n      puVar6 = &DAT_01fe53c0;\n    }\n    else {\n      puVar6 = (undefined *)0x0;\n    }\n    iVar3 = (*pcVar1)(param_3,param_1,\"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\",puVar6);\n    if (iVar3 == 0) {\n      iVar3 = FUN_01adabd0(param_1);\n      if (iVar3 == 0) {\n        iVar3 = FUN_01ae4850(param_1);\n        if (iVar3 == 0) {\n          bVar2 = false;\n          goto LAB_016adc98;\n        }\n      }\n    }\n  }\n  bVar2 = true;\nLAB_016adc98:\n  if (bVar2) {\n    uVar5 = FUN_01ac5ad0(param_1);\n  }\n  else {\n    uVar5 = 0;\n  }\n  return uVar5;\n}",
        "output": "```c\nint soap_GET__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes(struct soap *soap, const char *URL, _vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes const*p)\n{\n\tsoap_free_temp(soap);\n\tif (soap_GET(soap, URL, NULL, \"text/xml; charset=utf-8\") || (p->soap_serialize(soap), 0) || p->soap_put(soap, \"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\", p->soap_type() == SOAP_TYPE__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes ? \"\" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))\n\t\treturn soap_closesock(soap);\n\treturn SOAP_OK;\n}\n```",
        "source_code": "int soap_PATCH__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes(struct soap *soap, const char *URL, _vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes const*p)\n{\n\tsoap_free_temp(soap);\n\tif (soap_PATCH(soap, URL, NULL, \"text/xml; charset=utf-8\") || (p->soap_serialize(soap), 0) || p->soap_put(soap, \"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\", p->soap_type() == SOAP_TYPE__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes ? \"\" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))\n\t\treturn soap_closesock(soap);\n\treturn SOAP_OK;\n}",
        "parsed_output": "int soap_GET__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes(struct soap *soap, const char *URL, _vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes const*p)\n{\n\tsoap_free_temp(soap);\n\tif (soap_GET(soap, URL, NULL, \"text/xml; charset=utf-8\") || (p->soap_serialize(soap), 0) || p->soap_put(soap, \"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\", p->soap_type() == SOAP_TYPE__vbox__IUpdateAgentAvailableEvent_USCOREgetReleaseNotes ? \"\" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))\n\t\treturn soap_closesock(soap);\n\treturn SOAP_OK;\n}",
        "baseline_code_stripped": "undefined8 FUN_016adba6(undefined8 param_1,undefined8 param_2,long *param_3)\n{\n  code *pcVar1;\n  bool bVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  FUN_01aca350(param_1);\n  iVar3 = FUN_01add460(param_1,param_2,0,\"text/xml; charset=utf-8\");\n  if (iVar3 == 0) {\n    (**(code **)(*param_3 + 0x10))(param_3,param_1);\n    pcVar1 = *(code **)(*param_3 + 0x18);\n    lVar4 = (**(code **)*param_3)(param_3);\n    if (lVar4 == 0xe37) {\n      puVar6 = &DAT_01fe53c0;\n    }\n    else {\n      puVar6 = (undefined *)0x0;\n    }\n    iVar3 = (*pcVar1)(param_3,param_1,\"vbox:IUpdateAgentAvailableEvent_getReleaseNotes\",puVar6);\n    if (iVar3 == 0) {\n      iVar3 = FUN_01adabd0(param_1);\n      if (iVar3 == 0) {\n        iVar3 = FUN_01ae4850(param_1);\n        if (iVar3 == 0) {\n          bVar2 = false;\n          goto LAB_016adc98;\n        }\n      }\n    }\n  }\n  bVar2 = true;\nLAB_016adc98:\n  if (bVar2) {\n    uVar5 = FUN_01ac5ad0(param_1);\n  }\n  else {\n    uVar5 = 0;\n  }\n  return uVar5;\n}",
        "similarity_score_unixcoder": 0.9671962261199951,
        "similarity_score_baseline_stripped": 0.4740559458732605
    },
    {
        "func_name": "mono_test_marshal_bool_ref_as_I1_U1",
        "normed_func_sha256": "883222a1f9789eb5ed2f3567257066381e091ed36407d9a1c3ccdee575d45922",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool FUN_002c9a30(XDR *param_1,long param_2)\n{\n  int iVar1;\n  bool_t bVar2;\n  bool bVar3;\n  iVar1 = FUN_002c4d40();\n  bVar3 = false;\n  if (iVar1 != 0) {\n    bVar2 = xdr_u_int(param_1,(u_int *)(param_2 + 0x18));\n    bVar3 = bVar2 != 0;\n  }\n  return bVar3;\n}\n\n Revised code:\nbool_t\nxdr_remote_storage_vol_delete_args (XDR *xdrs, remote_storage_vol_delete_args *objp)\n{\n\n         if (!xdr_remote_nonnull_storage_vol (xdrs, &objp->vol))\n                 return FALSE;\n         if (!xdr_u_int (xdrs, &objp->flags))\n                 return FALSE;\n        return TRUE;\n}\n\n## Example:\n\n Input code:\nbool FUN_00278650(int *param_1,int *param_2)\n{\n  bool bVar1;\n  int iVar2;\n  iVar2 = memcmp(param_1 + 2,param_2 + 2,8);\n  if (iVar2 != 0) {\n    return false;\n  }\n  if (((*(byte *)(param_1 + 5) ^ *(byte *)(param_2 + 5)) & 0x1f) == 0) {\n    bVar1 = false;\n    if (*(char *)(param_1 + 6) == *(char *)(param_2 + 6)) {\n      bVar1 = *param_1 == *param_2;\n    }\n    return bVar1;\n  }\n  return false;\n}\n\n Revised code:\nstatic int\npsymbol_compare (const void *addr1, const void *addr2, int length)\n{\n  struct partial_symbol *sym1 = (struct partial_symbol *) addr1;\n  struct partial_symbol *sym2 = (struct partial_symbol *) addr2;\n  return (memcmp (&sym1->ginfo.value, &sym2->ginfo.value,\n                  sizeof (sym1->ginfo.value)) == 0\n\t  && sym1->ginfo.language == sym2->ginfo.language\n          && sym1->domain == sym2->domain\n          && sym1->aclass == sym2->aclass\n          && sym1->ginfo.name == sym2->ginfo.name);\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_0010731a(XDR *param_1,bool_t *param_2)\n{\n  bool_t bVar1;\n  int iVar2;\n  bVar1 = xdr_bool(param_1,param_2);\n  if (bVar1 == 0) {\n    return 0;\n  }\n  if (*param_2 != 0) {\n    if (*param_2 != 1) {\n      return 0;\n    }\n    iVar2 = FUN_001069c0(param_1,param_2 + 1);\n    if (iVar2 == 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\n Revised code:\nbool_t\nxdr_sattrguard3(XDR *xdrs, sattrguard3 *objp)\n{\n    if (!xdr_bool(xdrs, &objp->check))\n        return FALSE;\n    switch (objp->check) {\n        case TRUE:\n            if (!xdr_nfstime3(xdrs, &objp->sattrguard3_u.obj_ctime))\n                return FALSE;\n            break;\n        case FALSE:\n            break;\n        default:\n            return FALSE;\n    }\n    return TRUE;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint mono_test_marshal_bool_ref_as_I1_U1(char *bTrue,char *bFalse)\n{\n  int iVar1;\n  if ((bTrue == (char *)0x0) || (bFalse == (char *)0x0)) {\n    iVar1 = 4;\n  }\n  else {\n    iVar1 = 5;\n    if ((*bTrue != '\\0') && (iVar1 = 6, *bFalse == '\\0')) {\n      *bFalse = '\\x01';\n      *bTrue = '\\0';\n      return 0;\n    }\n  }\n  return iVar1;\n}",
        "output": "```c\nint\nmono_test_marshal_bool_ref_as_I1_U1 (char *bTrue, char *bFalse)\n{\n    if (bTrue == NULL || bFalse == NULL)\n        return ERROR_INVALID_PARAMETER;\n\n    if (*bTrue && !*bFalse) {\n        *bFalse = 1;\n        *bTrue = 0;\n        return SUCCESS;\n    }\n\n    return ERROR_UNEXPECTED;\n}\n```",
        "source_code": "STDCALL \nmono_test_marshal_bool_ref_as_I1_U1 (char* bTrue, char* bFalse)\n{\n\tif (!bTrue || !bFalse)\n                return 4;\n\tif (!(*bTrue))\n                return 5;\n        if (*bFalse)\n                return 6;\n\t*bFalse = 1;\n        *bTrue = 0;\n\treturn 0;\n}",
        "parsed_output": "int\nmono_test_marshal_bool_ref_as_I1_U1 (char *bTrue, char *bFalse)\n{\n    if (bTrue == NULL || bFalse == NULL)\n        return ERROR_INVALID_PARAMETER;\n\n    if (*bTrue && !*bFalse) {\n        *bFalse = 1;\n        *bTrue = 0;\n        return SUCCESS;\n    }\n\n    return ERROR_UNEXPECTED;\n}",
        "baseline_code_stripped": "int mono_test_marshal_bool_ref_as_I1_U1(char *bTrue,char *bFalse)\n{\n  int iVar1;\n  if ((bTrue == (char *)0x0) || (bFalse == (char *)0x0)) {\n    iVar1 = 4;\n  }\n  else {\n    iVar1 = 5;\n    if ((*bTrue != '\\0') && (iVar1 = 6, *bFalse == '\\0')) {\n      *bFalse = '\\x01';\n      *bTrue = '\\0';\n      return 0;\n    }\n  }\n  return iVar1;\n}",
        "similarity_score_unixcoder": 0.8961489200592041,
        "similarity_score_baseline_stripped": 0.8568769097328186
    },
    {
        "func_name": "PitchPreset::write",
        "normed_func_sha256": "a93c4aeae8a726e70df61e9a3cf7185a80af0769cafb0c375a5bf6680280a660",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_0030a6e0(long param_1,int param_2)\n{\n  long *local_28 [2];\n  long local_18 [2];\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  if (param_2 == 0) {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_replace\n              (param_1 + 0x340U,0,*(char **)(param_1 + 0x348),(ulong)&DAT_005099e0);\n  }\n  else {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_replace\n              (param_1 + 0x340U,0,*(char **)(param_1 + 0x348),(ulong)&DAT_005099d8);\n  }\n  if (1 < DAT_00600010) {\n    FUN_0046f680(2,\"set_preamp\",\"rigs/kenwood/TS480SAT.cxx\",0x308,\"%s\",\n                 *(undefined8 *)(param_1 + 0x340));\n  }\n  FUN_004a1570(1,\"set preamp\");\n  local_28[0] = local_18;\n  FUN_005074e0(local_28,*(long *)(param_1 + 0x340),\n               *(long *)(param_1 + 0x340) + *(long *)(param_1 + 0x348));\n  FUN_0047f9e0(local_28,0,0);\n  if (local_28[0] != local_18) {\n    operator_delete(local_28[0],local_18[0] + 1);\n  }\n  FUN_004a1570(5,\"\",&DAT_00509720,*(undefined8 *)(param_1 + 0x340),&DAT_00509718,\n               *(undefined8 *)(param_1 + 800));\n  *(int *)(param_1 + 0x400) = param_2;\n  if (local_8 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);\n}\n\n Revised code:\nvoid RIG_TS480SAT::set_preamp(int val)\n{\n\tif (val)\tcmd = \"PA1;\";\n\telse\t\tcmd = \"PA0;\";\n\tLOG_WARN(\"%s\", cmd.c_str());\n\tset_trace(1, \"set preamp\");\n\tsendCommand(cmd);\n\tsett(\"\");\n\tpreamp_level = val;\n}\n\n## Example:\n\n Input code:\nSmartPointer * __thiscall\notb::Wrapper::InputVectorDataListParameter::FromVectorData\n          (InputVectorDataListParameter *this,SmartPointer *param_1,VectorData *param_2)\n{\n  long *plVar1;\n  long local_30;\n  long *local_28;\n  long local_20;\n  long local_18 [2];\n  long local_8;\n  local_28 = local_18;\n  local_8 = ___stack_chk_guard;\n  local_30 = 0x14;\n  local_28 = (long *)std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n                     _M_create((ulong *)&local_28,(ulong)&local_30);\n  local_18[0] = local_30;\n  *local_28 = 0x642d726f74636556;\n  local_28[1] = 0x656c696620617461;\n  *(undefined4 *)(local_28 + 2) = 0x656d616e;\n  local_20 = local_30;\n  *(undefined *)((long)local_28 + local_30) = 0;\n  plVar1 = *(long **)param_1;\n  if (plVar1 != (long *)0x0) {\n    (**(code **)(*plVar1 + 0x18))(plVar1);\n  }\n  InputVectorDataParameter::SetVectorData((InputVectorDataParameter *)plVar1,param_2);\n  if (plVar1 != (long *)0x0) {\n    (**(code **)(*plVar1 + 0x20))(plVar1);\n  }\n  plVar1 = *(long **)param_1;\n  if (*(code **)(*plVar1 + 0xb8) == Parameter::SetDescription) {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_assign\n              ((basic_string *)(plVar1 + 0xd));\n    (**(code **)(*plVar1 + 0x88))(plVar1);\n  }\n  else {\n    (**(code **)(*plVar1 + 0xb8))(plVar1,&local_28);\n  }\n  if (local_28 != local_18) {\n    operator_delete(local_28);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return param_1;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nInputVectorDataParameter::Pointer& InputVectorDataListParameter::FromVectorData(InputVectorDataParameter::Pointer& parameter, VectorDataType* data)\n{\n  return FromData(parameter, data,\n                  [](auto p, auto d) -> void {\n                    assert(p);\n\n                    p->SetVectorData(d);\n                  },\n                  \"Vector-data filename\");\n}\n\n## Example:\n\n Input code:\nvoid __thiscall\ngu::RecordSetOutBase::post_alloc(RecordSetOutBase *this,bool param_1,uchar *param_2,long param_3)\n{\n  uchar **ppuVar1;\n  long in_FS_OFFSET;\n  uchar *local_38;\n  long local_30;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1) {\n    ppuVar1 = *(uchar ***)(this + 0x140);\n    local_38 = param_2;\n    local_30 = param_3;\n    if (ppuVar1 == *(uchar ***)(this + 0x148)) {\n      std::vector<gu_buf,gu::ReservedAllocator<gu_buf,4,false>>::_M_insert_aux\n                ((vector_gu_buf_gu__ReservedAllocator_gu_buf_4_false__ *)(this + 0x128),\n                 (__normal_iterator)ppuVar1,(gu_buf *)&local_38);\n    }\n    else {\n      if (ppuVar1 != (uchar **)0x0) {\n        *ppuVar1 = param_2;\n        ppuVar1[1] = (uchar *)param_3;\n      }\n      *(uchar ***)(this + 0x140) = ppuVar1 + 2;\n    }\n  }\n  else {\n    *(long *)(*(long *)(this + 0x140) + -8) = *(long *)(*(long *)(this + 0x140) + -8) + param_3;\n  }\n  *(long *)this = *(long *)this + param_3;\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid\nRecordSetOutBase::post_alloc (bool const          new_page,\n                              const byte_t* const ptr,\n                              ssize_t const       size)\n{\n    if (new_page)\n    {\n        Buf b = { ptr, size };\n        bufs_->push_back (b);\n    }\n    else\n    {\n        bufs_->back().size += size;\n    }\n    size_ += size;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall PitchPreset::write(PitchPreset *this,PresetType param_1,basic_ptree *param_2)\n{\n  code *pcVar1;\n  long *local_28 [2];\n  long local_18 [2];\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  pcVar1 = *(code **)(*(long *)this + 0x20);\n  local_28[0] = local_18;\n  if (param_1 == 1) {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"output\",0x29a93e);\n    (*pcVar1)(this,param_2,local_28,this + 0x10);\n  }\n  else {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"input\",0x29a945);\n    (*pcVar1)(this,param_2,local_28,this + 8);\n  }\n  if (local_28[0] != local_18) {\n    operator_delete(local_28[0],local_18[0] + 1);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```cpp\nvoid PitchPreset::write(PresetType type, basic_ptree* tree)\n{\n    std::string key = (type == PresetType::Output) ? \"output\" : \"input\";\n    auto write_func = reinterpret_cast<void(*)(PitchPreset*, basic_ptree*, const std::string&, void*)>(\n        *reinterpret_cast<void**>(this) + 0x20);\n    void* data = (type == PresetType::Output) ? this + 0x10 : this + 8;\n    write_func(this, tree, key, data);\n}\n```",
        "source_code": "void PitchPreset::write(PresetType preset_type, boost::property_tree::ptree& root) {\n  if (preset_type == PresetType::output) {\n    save(root, \"output\", output_settings);\n  } else {\n    save(root, \"input\", input_settings);\n  }\n}",
        "parsed_output": "pp\nvoid PitchPreset::write(PresetType type, basic_ptree* tree)\n{\n    std::string key = (type == PresetType::Output) ? \"output\" : \"input\";\n    auto write_func = reinterpret_cast<void(*)(PitchPreset*, basic_ptree*, const std::string&, void*)>(\n        *reinterpret_cast<void**>(this) + 0x20);\n    void* data = (type == PresetType::Output) ? this + 0x10 : this + 8;\n    write_func(this, tree, key, data);\n}",
        "baseline_code_stripped": "void __thiscall PitchPreset::write(PitchPreset *this,PresetType param_1,basic_ptree *param_2)\n{\n  code *pcVar1;\n  long *local_28 [2];\n  long local_18 [2];\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  pcVar1 = *(code **)(*(long *)this + 0x20);\n  local_28[0] = local_18;\n  if (param_1 == 1) {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"output\",0x29a93e);\n    (*pcVar1)(this,param_2,local_28,this + 0x10);\n  }\n  else {\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n    _M_construct_char_const__((char *)local_28,\"input\",0x29a945);\n    (*pcVar1)(this,param_2,local_28,this + 8);\n  }\n  if (local_28[0] != local_18) {\n    operator_delete(local_28[0],local_18[0] + 1);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.7815552949905396,
        "similarity_score_baseline_stripped": 0.595273494720459
    },
    {
        "func_name": "meth_wxRichTextBuffer_ClearStyleStack",
        "normed_func_sha256": "a840ac8c9b53f94fde4a54c9b47e2c197818531eb2b738acb1f4b3db4ca79508",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_002d9e50(undefined8 param_1,undefined8 param_2)\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  bool bVar5;\n  long *local_40;\n  int *local_38;\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar2 = (int *)(**(code **)(sipAPI__richtext + 0x2b8))\n                            (param_1,PTR_sipTypeDef__richtext_wxTextAttrDimension_0037c3f0);\n  if (piVar2 == (int *)0x0) {\nLAB_002d9f90:\n    uVar3 = 0;\n  }\n  else {\n    local_40 = (long *)0x0;\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_40,param_2,&DAT_002fcc17,\n                       PTR_sipTypeDef__richtext_wxTextAttrDimension_0037c3f0,&local_38);\n    if (iVar1 != 0) {\n      PyErr_Clear();\n      bVar5 = true;\n      uVar3 = PyEval_SaveThread();\n      if (*piVar2 == *local_38) {\n        bVar5 = *(short *)(piVar2 + 1) != *(short *)(local_38 + 1);\n      }\n      PyEval_RestoreThread(uVar3);\n      lVar4 = PyErr_Occurred();\n      uVar3 = 0;\n      if (lVar4 == 0) {\n        uVar3 = PyBool_FromLong(bVar5);\n      }\n      goto LAB_002d9f16;\n    }\n    if (local_40 != (long *)0x0) {\n      *local_40 = *local_40 + -1;\n      if (*local_40 == 0) {\n        _Py_Dealloc();\n      }\n      if (local_40 == (long *)&_Py_NoneStruct) goto LAB_002d9f90;\n    }\n    uVar3 = (**(code **)(sipAPI__richtext + 0x300))\n                      (sipModuleAPI__richtext,0x29,\n                       PTR_sipTypeDef__richtext_wxTextAttrDimension_0037c3f0,param_1,param_2);\n  }\nLAB_002d9f16:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic PyObject *slot_wxTextAttrDimension___ne__(PyObject *sipSelf,PyObject *sipArg)\n{\n     ::wxTextAttrDimension *sipCpp = reinterpret_cast< ::wxTextAttrDimension *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_wxTextAttrDimension));\n\n    if (!sipCpp)\n        return SIP_NULLPTR;\n\n    PyObject *sipParseErr = SIP_NULLPTR;\n\n    {\n        const  ::wxTextAttrDimension* dim;\n\n        if (sipParseArgs(&sipParseErr, sipArg, \"1J9\", sipType_wxTextAttrDimension, &dim))\n        {\n            bool sipRes;\n\n            PyErr_Clear();\n\n            Py_BEGIN_ALLOW_THREADS\n            sipRes = !sipCpp-> ::wxTextAttrDimension::operator==(*dim);\n            Py_END_ALLOW_THREADS\n\n            if (PyErr_Occurred())\n                return 0;\n\n            return PyBool_FromLong(sipRes);\n        }\n    }\n\n    Py_XDECREF(sipParseErr);\n\n    if (sipParseErr == Py_None)\n        return SIP_NULLPTR;\n\n    return sipPySlotExtend(&sipModuleAPI__richtext, ne_slot, sipType_wxTextAttrDimension, sipSelf, sipArg);\n}\n\n## Example:\n\n Input code:\nlong * FUN_003ba1e0(long *param_1,undefined8 param_2)\n{\n  int iVar1;\n  uint *puVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  uint local_3c;\n  long *local_38;\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((*(long *)(PTR_sipTypeDef_kdeui_KRichTextWidget_RichTextSupport_006777c0 + 0x20) == param_1[1]\n      ) || (iVar1 = PyType_IsSubtype(param_1[1],\n                                     *(long *)(\n                                              PTR_sipTypeDef_kdeui_KRichTextWidget_RichTextSupport_006777c0\n                                              + 0x20)), iVar1 != 0)) {\n    puVar2 = (uint *)(**(code **)(sipAPI_kdeui + 0x2b8))\n                               (param_1,\n                                PTR_sipTypeDef_kdeui_KRichTextWidget_RichTextSupport_006777c0);\n    if (puVar2 == (uint *)0x0) {\nLAB_003ba300:\n      param_1 = (long *)0x0;\n      goto LAB_003ba232;\n    }\n    local_38 = (long *)0x0;\n    iVar1 = (**(code **)(sipAPI_kdeui + 0x280))(&local_38,param_2,&DAT_0055e1f5,&local_3c);\n    if (iVar1 != 0) {\n      uVar3 = PyEval_SaveThread();\n      *puVar2 = *puVar2 & local_3c;\n      PyEval_RestoreThread(uVar3);\n      *param_1 = *param_1 + 1;\n      goto LAB_003ba232;\n    }\n    if (local_38 != (long *)0x0) {\n      *local_38 = *local_38 + -1;\n      if (*local_38 == 0) {\n        _Py_Dealloc();\n      }\n      if (local_38 == (long *)&_Py_NoneStruct) goto LAB_003ba300;\n    }\n    PyErr_Clear();\n  }\n  param_1 = (long *)&_Py_NotImplementedStruct;\n  __Py_NotImplementedStruct = __Py_NotImplementedStruct + 1;\nLAB_003ba232:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return param_1;\n}\n\n Revised code:\nstatic PyObject *slot_KRichTextWidget_RichTextSupport___iand__(PyObject *sipSelf,PyObject *sipArg)\n{\n    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_KRichTextWidget_RichTextSupport)))\n    {\n        Py_INCREF(Py_NotImplemented);\n        return Py_NotImplemented;\n    }\n\n     ::KRichTextWidget::RichTextSupport *sipCpp = reinterpret_cast< ::KRichTextWidget::RichTextSupport *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_KRichTextWidget_RichTextSupport));\n\n    if (!sipCpp)\n        return SIP_NULLPTR;\n\n    PyObject *sipParseErr = SIP_NULLPTR;\n\n    {\n        int a0;\n\n        if (sipParseArgs(&sipParseErr, sipArg, \"1i\", &a0))\n        {\n            Py_BEGIN_ALLOW_THREADS\n            sipCpp-> ::KRichTextWidget::RichTextSupport::operator&=(a0);\n            Py_END_ALLOW_THREADS\n\n            Py_INCREF(sipSelf);\n            return sipSelf;\n        }\n    }\n\n    Py_XDECREF(sipParseErr);\n\n    if (sipParseErr == Py_None)\n        return SIP_NULLPTR;\n\n    PyErr_Clear();\n\n    Py_INCREF(Py_NotImplemented);\n    return Py_NotImplemented;\n}\n\n## Example:\n\n Input code:\nundefined * FUN_004d9d10(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  long local_40 [2];\n  undefined8 local_30;\n  long *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  local_40[0] = param_1;\n  if ((param_1 == 0) || (iVar1 = (**(code **)(sipAPI__core + 0x3a8))(param_1,param_2,0), iVar1 != 0)\n     ) {\n    iVar1 = (**(code **)(sipAPI__core + 0x280))\n                      (&local_30,param_2,&DAT_00900015,local_40,\n                       PTR_sipTypeDef__core_wxChoicebook_00ad8e08,&local_28);\n    if (iVar1 == 0) goto LAB_004d9e07;\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    wxWindowBase::InitDialog();\n  }\n  else {\n    iVar1 = (**(code **)(sipAPI__core + 0x280))\n                      (&local_30,param_2,&DAT_00900015,local_40,\n                       PTR_sipTypeDef__core_wxChoicebook_00ad8e08,&local_28);\n    if (iVar1 == 0) {\nLAB_004d9e07:\n      (**(code **)(sipAPI__core + 0x2a0))\n                (local_30,\"Choicebook\",\"InitDialog\",s_InitDialog_self__00af7dd0);\n      puVar4 = (undefined *)0x0;\n      goto LAB_004d9e34;\n    }\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    (**(code **)(*local_28 + 0x2b8))();\n  }\n  PyEval_RestoreThread(uVar2);\n  lVar3 = PyErr_Occurred();\n  puVar4 = (undefined *)0x0;\n  if (lVar3 == 0) {\n    puVar4 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\nLAB_004d9e34:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return puVar4;\n}\n\n Revised code:\nstatic PyObject *meth_wxChoicebook_InitDialog(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));\n\n    {\n         ::wxChoicebook *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_wxChoicebook, &sipCpp))\n        {\n            PyErr_Clear();\n\n            Py_BEGIN_ALLOW_THREADS\n            (sipSelfWasArg ? sipCpp-> ::wxChoicebook::InitDialog() : sipCpp->InitDialog());\n            Py_END_ALLOW_THREADS\n\n            if (PyErr_Occurred())\n                return 0;\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_Choicebook, sipName_InitDialog, doc_wxChoicebook_InitDialog);\n\n    return NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined * FUN_001e1f20(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  long local_40 [2];\n  undefined8 local_30;\n  long *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  local_40[0] = param_1;\n  if ((param_1 == 0) ||\n     (iVar1 = (**(code **)(sipAPI__richtext + 0x3a8))(param_1,param_2,0), iVar1 != 0)) {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) goto LAB_001e2014;\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    wxRichTextBuffer::ClearStyleStack();\n  }\n  else {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) {\nLAB_001e2014:\n      (**(code **)(sipAPI__richtext + 0x2a0))(local_30,\"RichTextBuffer\",\"ClearStyleStack\",0);\n      puVar4 = (undefined *)0x0;\n      goto LAB_001e203c;\n    }\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    (**(code **)(*local_28 + 0x458))();\n  }\n  PyEval_RestoreThread(uVar2);\n  lVar3 = PyErr_Occurred();\n  puVar4 = (undefined *)0x0;\n  if (lVar3 == 0) {\n    puVar4 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\nLAB_001e203c:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return puVar4;\n}",
        "output": "```c\nstatic PyObject *meth_wxRichTextBuffer_ClearStyleStack(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));\n\n    {\n         ::wxRichTextBuffer *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_wxRichTextBuffer, &sipCpp))\n        {\n            PyErr_Clear();\n\n            Py_BEGIN_ALLOW_THREADS\n            (sipSelfWasArg ? sipCpp-> ::wxRichTextBuffer::ClearStyleStack() : sipCpp->ClearStyleStack());\n            Py_END_ALLOW_THREADS\n\n            if (PyErr_Occurred())\n                return 0;\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_RichTextBuffer, sipName_ClearStyleStack, doc_wxRichTextBuffer_ClearStyleStack);\n\n    return NULL;\n}\n```",
        "source_code": "static PyObject *meth_wxRichTextBuffer_ClearStyleStack(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));\n\n    {\n         ::wxRichTextBuffer *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_wxRichTextBuffer, &sipCpp))\n        {\n            PyErr_Clear();\n\n            Py_BEGIN_ALLOW_THREADS\n            (sipSelfWasArg ? sipCpp-> ::wxRichTextBuffer::ClearStyleStack() : sipCpp->ClearStyleStack());\n            Py_END_ALLOW_THREADS\n\n            if (PyErr_Occurred())\n                return 0;\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    sipNoMethod(sipParseErr, sipName_RichTextBuffer, sipName_ClearStyleStack, SIP_NULLPTR);\n\n    return SIP_NULLPTR;\n}",
        "parsed_output": "static PyObject *meth_wxRichTextBuffer_ClearStyleStack(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));\n\n    {\n         ::wxRichTextBuffer *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_wxRichTextBuffer, &sipCpp))\n        {\n            PyErr_Clear();\n\n            Py_BEGIN_ALLOW_THREADS\n            (sipSelfWasArg ? sipCpp-> ::wxRichTextBuffer::ClearStyleStack() : sipCpp->ClearStyleStack());\n            Py_END_ALLOW_THREADS\n\n            if (PyErr_Occurred())\n                return 0;\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_RichTextBuffer, sipName_ClearStyleStack, doc_wxRichTextBuffer_ClearStyleStack);\n\n    return NULL;\n}",
        "baseline_code_stripped": "undefined * FUN_001e1f20(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  long local_40 [2];\n  undefined8 local_30;\n  long *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  local_40[0] = param_1;\n  if ((param_1 == 0) ||\n     (iVar1 = (**(code **)(sipAPI__richtext + 0x3a8))(param_1,param_2,0), iVar1 != 0)) {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) goto LAB_001e2014;\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    wxRichTextBuffer::ClearStyleStack();\n  }\n  else {\n    iVar1 = (**(code **)(sipAPI__richtext + 0x280))\n                      (&local_30,param_2,&DAT_002f29ba,local_40,\n                       PTR_sipTypeDef__richtext_wxRichTextBuffer_0034e550,&local_28);\n    if (iVar1 == 0) {\nLAB_001e2014:\n      (**(code **)(sipAPI__richtext + 0x2a0))(local_30,\"RichTextBuffer\",\"ClearStyleStack\",0);\n      puVar4 = (undefined *)0x0;\n      goto LAB_001e203c;\n    }\n    PyErr_Clear();\n    uVar2 = PyEval_SaveThread();\n    (**(code **)(*local_28 + 0x458))();\n  }\n  PyEval_RestoreThread(uVar2);\n  lVar3 = PyErr_Occurred();\n  puVar4 = (undefined *)0x0;\n  if (lVar3 == 0) {\n    puVar4 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\nLAB_001e203c:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return puVar4;\n}",
        "similarity_score_unixcoder": 0.976956307888031,
        "similarity_score_baseline_stripped": 0.6001149415969849
    },
    {
        "func_name": "message_new_empty",
        "normed_func_sha256": "0be0f08bab1e2ad99d5ddfb69ba8a99572936aceb896597fa4c99c45b642a592",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined4 FUN_000db20c(int param_1,undefined4 param_2,uint param_3,int param_4)\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  if (param_1 != 0) {\n    if (*(char *)(*(int *)(param_1 + 0x10c) + 3) == '\\x02') {\n      puVar2 = (undefined4 *)FUN_000dadc0(param_1,8,0x12,1);\n      if (puVar2 == (undefined4 *)0x0) {\n        uVar1 = 0xfffffff4;\n      }\n      else {\n        uVar1 = 0;\n        puVar2[2] = param_3;\n        puVar2[3] = param_4;\n        *puVar2 = 5;\n        puVar2[1] = 0;\n        *(undefined *)(puVar2 + 4) = 0;\n        *(undefined *)((int)puVar2 + 0x11) = 0x74;\n      }\n    }\n    else if ((param_4 != 0 || 0xfffffffe < param_3) && (param_4 != 0 || param_3 != 0xffffffff)) {\n      uVar1 = 0xffffffa1;\n    }\n    else {\n      uVar1 = FUN_000db11c(param_1,param_1,5,0,param_3);\n    }\n    return uVar1;\n  }\n  log_assert_failed_realm\n            (0,\"m\",\"src/libsystemd/sd-bus/bus-message.c\",0x196,\"message_append_reply_cookie\");\n}\n\n Revised code:\nstatic int message_append_field_signature(\n                sd_bus_message *m,\n                uint64_t h,\n                const char *s,\n                const char **ret) {\n        size_t l;\n        uint8_t *p;\n        assert(m);\n        if (h > 0xFF)\n                return -EINVAL;\n        l = strlen(s);\n        if (l > SD_BUS_MAXIMUM_SIGNATURE_LENGTH)\n                return -EINVAL;\n        if (BUS_MESSAGE_IS_GVARIANT(m))\n                return message_append_field_string(m, h, 'g', s, ret);\n        else {\n                p = message_extend_fields(m, 8, 4 + 1 + l + 1, false);\n                if (!p)\n                        return -ENOMEM;\n                p[0] = (uint8_t) h;\n                p[1] = 1;\n                p[2] = SD_BUS_TYPE_SIGNATURE;\n                p[3] = 0;\n                p[4] = l;\n                memcpy(p + 5, s, l + 1);\n                if (ret)\n                        *ret = (const char*) p + 5;\n        }\n        return 0;\n}\n\n## Example:\n\n Input code:\nvoid FUN_002ad748(undefined8 param_1,ulonglong param_2,int param_3,undefined8 *param_4)\n{\n  undefined8 *puVar1;\n  undefined4 uVar2;\n  if (param_2 == 0) {\n    if (param_3 == 1) {\n      FUN_00179d00();\n      return;\n    }\n    if (param_3 < 2) {\n      if (param_3 == 0) {\n        FUN_001810a0();\n        return;\n      }\n    }\n    else {\n      if (param_3 == 2) {\n        FUN_0017b4c0(param_1,*(undefined *)param_4[1]);\n        return;\n      }\n      if (param_3 == 3) {\n        FUN_00180360(param_1,*(undefined *)param_4[1]);\n      }\n    }\n  }\n  else if ((param_2 & 0xffffffff) == 10) {\n    puVar1 = (undefined8 *)param_4[1];\n    if ((undefined *)*puVar1 == (undefined *)0x0) {\n      if (puVar1[1] != 0) {\n        return;\n      }\n      uVar2 = 0;\n    }\n    else {\n      if ((undefined *)*puVar1 != (undefined *)0x0) {\n        return;\n      }\n      if (puVar1[1] != 0) {\n        return;\n      }\n      uVar2 = 1;\n    }\n    *(undefined4 *)*param_4 = uVar2;\n  }\n  return;\n}\n\n Revised code:\nvoid pqPropertyLinksConnection::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<pqPropertyLinksConnection *>(_o);\n        Q_UNUSED(_t)\n        switch (_id) {\n        case 0: _t->qtpropertyModified(); break;\n        case 1: _t->smpropertyModified(); break;\n        case 2: _t->copyValuesFromServerManagerToQt((*reinterpret_cast< bool(*)>(_a[1]))); break;\n        case 3: _t->copyValuesFromQtToServerManager((*reinterpret_cast< bool(*)>(_a[1]))); break;\n        default: ;\n        }\n    } else if (_c == QMetaObject::IndexOfMethod) {\n        int *result = reinterpret_cast<int *>(_a[0]);\n        {\n            using _t = void (pqPropertyLinksConnection::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&pqPropertyLinksConnection::qtpropertyModified)) {\n                *result = 0;\n                return;\n            }\n        }\n        {\n            using _t = void (pqPropertyLinksConnection::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&pqPropertyLinksConnection::smpropertyModified)) {\n                *result = 1;\n                return;\n            }\n        }\n    }\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_0027eab0(long param_1,undefined4 *param_2)\n{\n  undefined8 uVar1;\n  if (*(int *)(*(long *)(*(long *)(param_1 + 0x40) + 8) + 0x60) == 2) {\n    uVar1 = 0;\n    **(undefined4 **)(param_1 + 0x20) = *param_2;\n    *(undefined2 *)(param_1 + 0x28) = 0x101;\n  }\n  else {\n    uVar1 = 0xfffffed0;\n  }\n  return uVar1;\n}\n\n Revised code:\nstatic inline uint32_t buf_get_u32(const uint8_t *_buffer,\n\tunsigned first, unsigned num)\n{\n\tconst uint8_t *buffer = _buffer;\n\n\tif ((num == 32) && (first == 0)) {\n\t\treturn (((uint32_t)buffer[3]) << 24) |\n\t\t\t\t(((uint32_t)buffer[2]) << 16) |\n\t\t\t\t(((uint32_t)buffer[1]) << 8) |\n\t\t\t\t(((uint32_t)buffer[0]) << 0);\n\t} else {\n\t\tuint32_t result = 0;\n\t\tfor (unsigned i = first; i < first + num; i++) {\n\t\t\tif (((buffer[i / 8] >> (i % 8)) & 1) == 1)\n\t\t\t\tresult |= 1 << (i - first);\n\t\t}\n\t\treturn result;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_00172170(long param_1,undefined8 *param_2)\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  undefined8 uVar3;\n  if (param_2 != (undefined8 *)0x0) {\n    puVar2 = (undefined4 *)calloc(1,0x430);\n    if (puVar2 == (undefined4 *)0x0) {\n      uVar3 = 0xfffffff4;\n    }\n    else {\n      uVar1 = *(undefined4 *)(param_1 + 0x18);\n      *(byte *)(puVar2 + 0x109) = *(byte *)(puVar2 + 0x109) & 0xfe;\n      *puVar2 = 1;\n      puVar2[4] = uVar1;\n      *param_2 = puVar2;\n      uVar3 = 0;\n    }\n    return uVar3;\n  }\n  FUN_00148060(0,&DAT_001bfb62,\"../src/libsystemd/sd-netlink/netlink-message.c\",0x1b,\n               \"message_new_empty\");\n  return 0xffffffea;\n}",
        "output": "```c\nstatic int message_new_empty(sd_netlink_message **msg, int fd) {\n    sd_netlink_message *m;\n\n    if (!msg) {\n        log_error(\"message_new_empty\", \"../src/libsystemd/sd-netlink/netlink-message.c\", 27);\n        return -EINVAL;\n    }\n\n    m = calloc(1, sizeof(sd_netlink_message));\n    if (!m)\n        return -ENOMEM;\n\n    m->type = 1;\n    m->fd = fd;\n    m->flags &= ~0x01;\n\n    *msg = m;\n    return 0;\n}\n```",
        "source_code": "int message_new_empty(sd_netlink *rtnl, sd_netlink_message **ret) {\n        sd_netlink_message *m;\n        assert_return(ret, -EINVAL);\n        m = new0(sd_netlink_message, 1);\n        if (!m)\n                return -ENOMEM;\n        m->n_ref = 1;\n        m->protocol = rtnl->protocol;\n        m->sealed = false;\n        *ret = m;\n        return 0;\n}",
        "parsed_output": "static int message_new_empty(sd_netlink_message **msg, int fd) {\n    sd_netlink_message *m;\n\n    if (!msg) {\n        log_error(\"message_new_empty\", \"../src/libsystemd/sd-netlink/netlink-message.c\", 27);\n        return -EINVAL;\n    }\n\n    m = calloc(1, sizeof(sd_netlink_message));\n    if (!m)\n        return -ENOMEM;\n\n    m->type = 1;\n    m->fd = fd;\n    m->flags &= ~0x01;\n\n    *msg = m;\n    return 0;\n}",
        "baseline_code_stripped": "undefined8 FUN_00172170(long param_1,undefined8 *param_2)\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  undefined8 uVar3;\n  if (param_2 != (undefined8 *)0x0) {\n    puVar2 = (undefined4 *)calloc(1,0x430);\n    if (puVar2 == (undefined4 *)0x0) {\n      uVar3 = 0xfffffff4;\n    }\n    else {\n      uVar1 = *(undefined4 *)(param_1 + 0x18);\n      *(byte *)(puVar2 + 0x109) = *(byte *)(puVar2 + 0x109) & 0xfe;\n      *puVar2 = 1;\n      puVar2[4] = uVar1;\n      *param_2 = puVar2;\n      uVar3 = 0;\n    }\n    return uVar3;\n  }\n  FUN_00148060(0,&DAT_001bfb62,\"../src/libsystemd/sd-netlink/netlink-message.c\",0x1b,\n               \"message_new_empty\");\n  return 0xffffffea;\n}",
        "similarity_score_unixcoder": 0.861474335193634,
        "similarity_score_baseline_stripped": 0.5321404933929443
    },
    {
        "func_name": "send_CharSet",
        "normed_func_sha256": "f2b2d298b3cf7e51637cf5484e6481f38c14bce7a51afba8d2e58f36203a60e0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_00166e53(ulong *param_1,undefined4 param_2,undefined8 param_3)\n{\n  code *pcVar1;\n  ulong local_10;\n  local_10 = *param_1;\n  if ((local_10 < 0xf) || (0x14 < local_10)) {\n    DAT_0052a010 = 0;\n  }\n  else {\n    DAT_0052a010 = 1;\n    local_10 = local_10 - 6;\n  }\n  if (local_10 < 0x17) {\n    pcVar1 = *(code **)(&DAT_003a3400 + local_10 * 8);\n  }\n  else {\n    pcVar1 = FUN_00166f6d;\n  }\n  (*pcVar1)(param_1,param_2,param_3);\n  return;\n}\n\n Revised code:\nstatic Bool\nLoad_Bool_Into_Word(WamWord *exp, int result, WamWord *load_word)\n{\n  PlULong op = *exp;\n\n  if (op >= EQ_F && op <= LTE_F)\n    {\n      pl_full_ac = 1;\n      op = op - EQ_F + EQ;\n    }\n  else\n    pl_full_ac = 0;\n\n  return (*((op <= ONE) ? func_tbl[op] : Set_Var)) (exp, result, load_word);\n}\n\n## Example:\n\n Input code:\nint FUN_0043c288(undefined8 param_1,long param_2,ulong param_3,uint param_4)\n{\n  bool bVar1;\n  int iVar2;\n  int local_10;\n  uint local_c;\n  if (param_2 == 0) {\n    FUN_004318e4(&DAT_00581326);\n    local_10 = -1;\n  }\n  else {\n    if (DAT_007d1f08 == 0) {\n      iVar2 = DAT_007c9108 * 4;\n      DAT_007d1f08 = FUN_004408fd(DAT_007c9108 + 1);\n      DAT_007d1f10 = FUN_004408fd(iVar2 + 3);\n    }\n    local_c = DAT_007c9108 + 1;\n    if (param_3 < local_c) {\n      local_c = (uint)param_3;\n    }\n    if ((param_4 & 1) == 0) {\n      local_10 = FUN_004395f7(param_1,param_2,local_c,DAT_007d1f08);\n    }\n    else {\n      local_10 = FUN_00439882(param_1,param_2,local_c,DAT_007d1f08);\n    }\n    if (local_10 < 0) {\n      FUN_0043b265(param_2);\n    }\n    else {\n      if (DAT_007c9108 < local_c) {\n        local_c = DAT_007c9108;\n      }\n      else {\n        *(undefined *)((ulong)local_c + DAT_007d1f08) = 0xff;\n      }\n      iVar2 = FUN_0043bb55(DAT_007d1f08,DAT_007d1f10,local_c,param_4);\n      if (((iVar2 == 0) || (param_3 == 0)) || (((param_4 & 1) == 0 && (param_3 <= DAT_007c9108)))) {\n        bVar1 = false;\n      }\n      else {\n        bVar1 = true;\n      }\n      FUN_004318e4(DAT_007d1f10);\n      if (bVar1) {\n        FUN_004318e4(&DAT_005813e3);\n      }\n    }\n  }\n  return local_10;\n}\n\n Revised code:\nint\nprintstr_ex(struct tcb *const tcp, const kernel_ulong_t addr,\n\t    const kernel_ulong_t len, const unsigned int user_style)\n{\n\tstatic char *str;\n\tstatic char *outstr;\n\tunsigned int size;\n\tunsigned int style = user_style;\n\tint rc;\n\tint ellipsis;\n\tif (!addr) {\n\t\ttprints(\"NULL\");\n\t\treturn -1;\n\t}\n\tif (!str) {\n\t\tconst unsigned int outstr_size =\n\t\t\t4 * max_strlen +  3;\n\t\tstr = xmalloc(max_strlen + 1);\n\t\toutstr = xmalloc(outstr_size);\n\t}\n\tsize = max_strlen + 1;\n\tif (size > len)\n\t\tsize = len;\n\tif (style & QUOTE_0_TERMINATED)\n\t\trc = umovestr(tcp, addr, size, str);\n\telse\n\t\trc = umoven(tcp, addr, size, str);\n\tif (rc < 0) {\n\t\tprintaddr(addr);\n\t\treturn rc;\n\t}\n\tif (size > max_strlen)\n\t\tsize = max_strlen;\n\telse\n\t\tstr[size] = '\\xff';\n\tellipsis = string_quote(str, outstr, size, style)\n\t\t   && len\n\t\t   && ((style & QUOTE_0_TERMINATED)\n\t\t       || len > max_strlen);\n\ttprints(outstr);\n\tif (ellipsis)\n\t\ttprints(\"...\");\n\treturn rc;\n}\n\n## Example:\n\n Input code:\nundefined1 * FUN_0034e82c(long param_1,long param_2)\n{\n  short sVar1;\n  int iVar2;\n  short local_14;\n  undefined1 *local_10;\n  if (*(short *)(param_1 + 0x1e) != 0) {\n    iVar2 = FUN_0031d7b4(100);\n    if (*(short *)(param_1 + 0x1e) <= iVar2) {\n      sVar1 = 0;\n      goto LAB_0034e876;\n    }\n  }\n  sVar1 = *(short *)(param_1 + 0x1c);\nLAB_0034e876:\n  if (param_2 == 0) {\n    local_10 = &DAT_004a82a0 + (long)DAT_004a6788 * 0xd8;\n    local_14 = FUN_00349b99((int)*(short *)(param_1 + 0x10),(int)*(short *)(param_1 + 0x12),\n                            (int)*(short *)(param_1 + 0x14),(int)*(short *)(param_1 + 0x16),\n                            (int)*(short *)(param_1 + 0x18),(int)*(short *)(param_1 + 0x1a),\n                            (int)sVar1,(int)*(short *)(param_1 + 0x20));\n  }\n  else {\n    local_10 = PTR_DAT_0049a2c8 + (long)DAT_004a678c * 0xd8;\n    local_14 = FUN_0034a370(param_2,(int)*(short *)(param_1 + 0x10),(int)*(short *)(param_1 + 0x12),\n                            (int)*(short *)(param_1 + 0x14),(int)*(short *)(param_1 + 0x16),\n                            (int)sVar1,(int)*(short *)(param_1 + 0x20));\n  }\n  if (local_14 == 0) {\n    local_10 = (undefined1 *)0x0;\n  }\n  else {\n    FUN_0025462d(local_10);\n    local_10[7] = (char)*(undefined2 *)(param_1 + 0x22);\n    local_10[8] = (char)*(undefined2 *)(param_1 + 0x24);\n  }\n  return local_10;\n}\n\n Revised code:\nstatic struct mkroom *\nbuild_room(room *r, struct mkroom *mkr)\n{\n    boolean okroom;\n    struct mkroom   *aroom;\n    xint16 rtype = (!r->chance || rn2(100) < r->chance) ? r->rtype : OROOM;\n\n    if(mkr) {\n        aroom = &subrooms[nsubroom];\n        okroom = create_subroom(mkr, r->x, r->y, r->w, r->h,\n                                rtype, r->rlit);\n    } else {\n        aroom = &rooms[nroom];\n        okroom = create_room(r->x, r->y, r->w, r->h, r->xalign,\n                             r->yalign, rtype, r->rlit);\n    }\n\n    if (okroom) {\n#ifdef SPECIALIZATION\n        topologize(aroom, FALSE);        /* set roomno */\n#else\n        topologize(aroom);          /* set roomno */\n#endif\n        aroom->needfill = r->filled;\n        aroom->needjoining = r->joined;\n        return aroom;\n    }\n    return (struct mkroom *)0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00186aab(undefined8 param_1,long param_2)\n{\n  byte bVar1;\n  undefined *local_10;\n  local_10 = (undefined *)0x0;\n  bVar1 = *(byte *)(param_2 + 2) >> 4;\n  if (bVar1 == 3) {\n    local_10 = &DAT_001cffac;\n  }\n  else if (bVar1 < 4) {\n    if (bVar1 == 2) {\n      local_10 = &DAT_001cffa8;\n    }\n    else if (bVar1 < 3) {\n      if (bVar1 == 0) {\n        local_10 = &DAT_001cffa0;\n      }\n      else if (bVar1 == 1) {\n        local_10 = &DAT_001cffa4;\n      }\n    }\n  }\n  if (local_10 != (undefined *)0x0) {\n    FUN_00186fdd(param_1,local_10);\n  }\n  return;\n}",
        "output": "```c\nvoid process_data(uint64_t param_1, int64_t param_2)\n{\n    const uint8_t type = (*(uint8_t *)(param_2 + 2)) >> 4;\n    const uint8_t *data_ptr = NULL;\n\n    switch (type) {\n        case 0:\n            data_ptr = &DAT_001cffa0;\n            break;\n        case 1:\n            data_ptr = &DAT_001cffa4;\n            break;\n        case 2:\n            data_ptr = &DAT_001cffa8;\n            break;\n        case 3:\n            data_ptr = &DAT_001cffac;\n            break;\n        default:\n            break;\n    }\n\n    if (data_ptr != NULL) {\n        FUN_00186fdd(param_1, data_ptr);\n    }\n}\n```",
        "source_code": "static void\nsend_CharSet(XtermWidget xw, LineData *ld)\n{\n#if OPT_DEC_CHRSET\n    const char *msg = 0;\n\n    switch (GetLineDblCS(ld)) {\n    case CSET_SWL:\n\tmsg = \"\\033#5\";\n\tbreak;\n    case CSET_DHL_TOP:\n\tmsg = \"\\033#3\";\n\tbreak;\n    case CSET_DHL_BOT:\n\tmsg = \"\\033#4\";\n\tbreak;\n    case CSET_DWL:\n\tmsg = \"\\033#6\";\n\tbreak;\n    }\n    if (msg != 0)\n\tstringToPrinter(xw, msg);\n#else\n    (void) xw;\n    (void) ld;\n#endif /* OPT_DEC_CHRSET */\n}",
        "parsed_output": "void process_data(uint64_t param_1, int64_t param_2)\n{\n    const uint8_t type = (*(uint8_t *)(param_2 + 2)) >> 4;\n    const uint8_t *data_ptr = NULL;\n\n    switch (type) {\n        case 0:\n            data_ptr = &DAT_001cffa0;\n            break;\n        case 1:\n            data_ptr = &DAT_001cffa4;\n            break;\n        case 2:\n            data_ptr = &DAT_001cffa8;\n            break;\n        case 3:\n            data_ptr = &DAT_001cffac;\n            break;\n        default:\n            break;\n    }\n\n    if (data_ptr != NULL) {\n        FUN_00186fdd(param_1, data_ptr);\n    }\n}",
        "baseline_code_stripped": "void FUN_00186aab(undefined8 param_1,long param_2)\n{\n  byte bVar1;\n  undefined *local_10;\n  local_10 = (undefined *)0x0;\n  bVar1 = *(byte *)(param_2 + 2) >> 4;\n  if (bVar1 == 3) {\n    local_10 = &DAT_001cffac;\n  }\n  else if (bVar1 < 4) {\n    if (bVar1 == 2) {\n      local_10 = &DAT_001cffa8;\n    }\n    else if (bVar1 < 3) {\n      if (bVar1 == 0) {\n        local_10 = &DAT_001cffa0;\n      }\n      else if (bVar1 == 1) {\n        local_10 = &DAT_001cffa4;\n      }\n    }\n  }\n  if (local_10 != (undefined *)0x0) {\n    FUN_00186fdd(param_1,local_10);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.5111730098724365,
        "similarity_score_baseline_stripped": 0.494633287191391
    },
    {
        "func_name": "meth_QQuickItem_grabToImage",
        "normed_func_sha256": "415a100168782cf8af63c903dee54b2c1005845202e4086a5dc13ab1ea1d8c36",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_004a94c0(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  long local_28 [2];\n  undefined8 local_18;\n  long *local_10;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  local_18 = 0;\n  local_28[0] = param_1;\n  if (((*(long *)(PTR_DAT_00659610 + 0x10) == *(long *)(param_1 + 8)) ||\n      (iVar1 = PyType_IsSubtype(*(long *)(param_1 + 8),*(long *)(PTR_DAT_00659610 + 0x10)),\n      iVar1 != 0)) && (iVar1 = (**(code **)(DAT_00698c98 + 0x448))(local_28[0]), iVar1 == 0)) {\n    iVar1 = (**(code **)(DAT_00698c98 + 0x330))\n                      (&local_18,param_2,&DAT_0052b3b8,local_28,PTR_DAT_00659610,&local_10);\n    if (iVar1 != 0) {\n      puVar3 = (undefined8 *)operator_new(8);\n      uVar2 = (**(code **)(*local_10 + 0x78))(local_10);\n      *puVar3 = uVar2;\n      goto LAB_004a9630;\n    }\n  }\n  else {\n    iVar1 = (**(code **)(DAT_00698c98 + 0x330))\n                      (&local_18,param_2,&DAT_0052b3b8,local_28,PTR_DAT_00659610,&local_10);\n    if (iVar1 != 0) {\n      puVar3 = (undefined8 *)operator_new(8);\n      uVar2 = QPushButton::minimumSizeHint();\n      *puVar3 = uVar2;\nLAB_004a9630:\n      uVar2 = (**(code **)(DAT_00698c98 + 0x98))(puVar3,PTR_s_QSize_0065a170,0);\n      goto LAB_004a9590;\n    }\n  }\n  (**(code **)(DAT_00698c98 + 0x348))\n            (local_18,\"QPushButton\",\"minimumSizeHint\",\"minimumSizeHint(self) -> QSize\");\n  uVar2 = 0;\nLAB_004a9590:\n  if (local_8 - ___stack_chk_guard != 0) {\n    __stack_chk_fail(uVar2,&__stack_chk_guard,local_8 - ___stack_chk_guard,0);\n  }\n  return;\n}\n\n Revised code:\nstatic PyObject *meth_QPushButton_minimumSizeHint(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n    bool sipSelfWasArg = (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_QPushButton)) || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));\n\n    {\n        const ::QPushButton *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_QPushButton, &sipCpp))\n        {\n            ::QSize*sipRes;\n\n            sipRes = new ::QSize((sipSelfWasArg ? sipCpp->::QPushButton::minimumSizeHint() : sipCpp->minimumSizeHint()));\n\n            return sipConvertFromNewType(sipRes, sipType_QSize, SIP_NULLPTR);\n        }\n    }\n\n    sipNoMethod(sipParseErr, sipName_QPushButton, sipName_minimumSizeHint, doc_QPushButton_minimumSizeHint);\n\n    return SIP_NULLPTR;\n}\n\n## Example:\n\n Input code:\nvoid FUN_00627ec0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined (*pauVar3) [16];\n  undefined auVar4 [16];\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined4 local_18 [2];\n  QPoint *local_10;\n  long local_8;\n  local_20 = 0;\n  local_18[0] = 0xffffffff;\n  local_8 = ___stack_chk_guard;\n  local_28 = param_1;\n  iVar1 = (**(code **)(DAT_0092d288 + 0x370))\n                    (&local_20,param_2,param_3,&PTR_s_screen_009081f8,0,&DAT_007066a0,&local_28,\n                     PTR_DAT_008612c8,&local_10,local_18);\n  if (iVar1 == 0) {\n    iVar1 = (**(code **)(DAT_0092d288 + 0x370))\n                      (&local_20,param_2,param_3,0,0,&DAT_00705248,&local_28,PTR_DAT_008612c8,\n                       &local_10,PTR_DAT_008627d0,local_18);\n    if (iVar1 == 0) {\n      iVar1 = (**(code **)(DAT_0092d288 + 0x370))\n                        (&local_20,param_2,param_3,0,0,&DAT_007055a8,&local_28,PTR_DAT_008612c8,\n                         &local_10,PTR_s_QPoint_00862aa0,local_18);\n      if (iVar1 == 0) {\n        (**(code **)(DAT_0092d288 + 0x2a0))\n                  (local_20,\"QDesktopWidget\",\"availableGeometry\",\n                   s_availableGeometry_self__screen__i_00908118);\n        uVar2 = 0;\n      }\n      else {\n        uVar2 = PyEval_SaveThread();\n        pauVar3 = (undefined (*) [16])operator_new(0x10);\n        QDesktopWidget::screenNumber(local_10);\n        auVar4 = QDesktopWidget::availableGeometry((int)local_10);\n        *pauVar3 = auVar4;\n        PyEval_RestoreThread(uVar2);\n        uVar2 = (**(code **)(DAT_0092d288 + 0x90))(pauVar3,PTR_s_QRect_00862ab0,0);\n      }\n      goto LAB_00628048;\n    }\n    uVar2 = PyEval_SaveThread();\n    pauVar3 = (undefined (*) [16])operator_new(0x10);\n    auVar4 = QDesktopWidget::availableGeometry((QWidget *)local_10);\n  }\n  else {\n    uVar2 = PyEval_SaveThread();\n    pauVar3 = (undefined (*) [16])operator_new(0x10);\n    auVar4 = QDesktopWidget::availableGeometry((int)local_10);\n  }\n  *pauVar3 = auVar4;\n  PyEval_RestoreThread(uVar2);\n  uVar2 = (**(code **)(DAT_0092d288 + 0x90))(pauVar3,PTR_s_QRect_00862ab0,0);\nLAB_00628048:\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(uVar2);\n}\n\n Revised code:\nstatic PyObject *meth_QDesktopWidget_availableGeometry(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        int a0 = -1;\n        const  ::QDesktopWidget *sipCpp;\n\n        static const char *sipKwdList[] = {\n            sipName_screen,\n        };\n\n        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, \"B|i\", &sipSelf, sipType_QDesktopWidget, &sipCpp, &a0))\n        {\n             ::QRect*sipRes;\n\n            Py_BEGIN_ALLOW_THREADS\n            sipRes = new  ::QRect(sipCpp->availableGeometry(a0));\n            Py_END_ALLOW_THREADS\n\n            return sipConvertFromNewType(sipRes,sipType_QRect,NULL);\n        }\n    }\n\n    {\n        const  ::QWidget* a0;\n        const  ::QDesktopWidget *sipCpp;\n\n        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, \"BJ8\", &sipSelf, sipType_QDesktopWidget, &sipCpp, sipType_QWidget, &a0))\n        {\n             ::QRect*sipRes;\n\n            Py_BEGIN_ALLOW_THREADS\n            sipRes = new  ::QRect(sipCpp->availableGeometry(a0));\n            Py_END_ALLOW_THREADS\n\n            return sipConvertFromNewType(sipRes,sipType_QRect,NULL);\n        }\n    }\n\n    {\n        const  ::QPoint* a0;\n        const  ::QDesktopWidget *sipCpp;\n\n        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, \"BJ9\", &sipSelf, sipType_QDesktopWidget, &sipCpp, sipType_QPoint, &a0))\n        {\n             ::QRect*sipRes;\n\n            Py_BEGIN_ALLOW_THREADS\n            sipRes = new  ::QRect(sipCpp->availableGeometry(*a0));\n            Py_END_ALLOW_THREADS\n\n            return sipConvertFromNewType(sipRes,sipType_QRect,NULL);\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QDesktopWidget, sipName_availableGeometry, doc_QDesktopWidget_availableGeometry);\n\n    return NULL;\n}\n\n## Example:\n\n Input code:\nvoid FUN_00298728(int param_1,undefined4 param_2)\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *pvVar3;\n  int local_2c [2];\n  undefined4 local_24;\n  int *local_20;\n  int local_1c;\n  local_1c = __stack_chk_guard;\n  local_24 = 0;\n  local_2c[0] = param_1;\n  if ((param_1 == 0) || (iVar1 = (**(code **)(DAT_006f22e0 + 0x1d4))(), iVar1 != 0)) {\n    iVar1 = (**(code **)(DAT_006f22e0 + 0x140))\n                      (&local_24,param_2,&DAT_00603a18,local_2c,DAT_006613a0,&local_20);\n    if (iVar1 == 0) goto LAB_00298854;\n    uVar2 = PyEval_SaveThread();\n    pvVar3 = operator_new(8);\n    QScrollBar::sizeHint();\n  }\n  else {\n    iVar1 = (**(code **)(DAT_006f22e0 + 0x140))\n                      (&local_24,param_2,&DAT_00603a18,local_2c,DAT_006613a0,&local_20);\n    if (iVar1 == 0) {\nLAB_00298854:\n      (**(code **)(DAT_006f22e0 + 0x150))\n                (local_24,\"QScrollBar\",\"sizeHint\",s_sizeHint_self_____QSize_0068f0ac);\n      uVar2 = 0;\n      goto LAB_00298890;\n    }\n    uVar2 = PyEval_SaveThread();\n    pvVar3 = operator_new(8);\n    (**(code **)(*local_20 + 0x38))();\n  }\n  PyEval_RestoreThread(uVar2);\n  uVar2 = (**(code **)(DAT_006f22e0 + 0x48))(pvVar3,DAT_006619d0,0);\nLAB_00298890:\n  if (local_1c != __stack_chk_guard) {\n    __stack_chk_fail(uVar2);\n  }\n  return;\n}\n\n Revised code:\nstatic PyObject *meth_QScrollBar_sizeHint(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));\n\n    {\n        const  ::QScrollBar *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_QScrollBar, &sipCpp))\n        {\n             ::QSize*sipRes;\n\n            Py_BEGIN_ALLOW_THREADS\n            sipRes = new  ::QSize((sipSelfWasArg ? sipCpp-> ::QScrollBar::sizeHint() : sipCpp->sizeHint()));\n            Py_END_ALLOW_THREADS\n\n            return sipConvertFromNewType(sipRes,sipType_QSize,NULL);\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QScrollBar, sipName_sizeHint, doc_QScrollBar_sizeHint);\n\n    return NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0018aef0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  undefined8 local_38 [2];\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 *local_18;\n  QSize *pQStack_10;\n  long local_8;\n  local_18 = &local_20;\n  local_28 = 0;\n  local_20 = 0xffffffffffffffff;\n  local_8 = ___stack_chk_guard;\n  local_38[0] = param_1;\n  iVar1 = (**(code **)(DAT_00273618 + 0x370))\n                    (&local_28,param_2,param_3,&PTR_s_targetSize_002626c0,0,&DAT_001f6098,local_38,\n                     PTR_DAT_00272258,&pQStack_10,PTR_s_QSize_00272728,&local_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_00273618 + 0x2a0))\n              (local_28,\"QQuickItem\",\"grabToImage\",s_grabToImage_self__targetSize__QS_00261ed8);\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = PyEval_SaveThread();\n    puVar3 = (undefined8 *)operator_new(0x10);\n    QQuickItem::grabToImage(pQStack_10);\n    PyEval_RestoreThread(uVar2);\n    uVar2 = (**(code **)(DAT_00273618 + 0x90))(*puVar3,PTR_DAT_00272290,0);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(uVar2);\n}",
        "output": "```c\nstatic PyObject *meth_QQuickItem_grabToImage(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        const ::QQuickItem *sipCpp;\n        const ::QSize *a0 = NULL;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B|J8\", &sipSelf, sipType_QQuickItem, &sipCpp, sipType_QSize, &a0))\n        {\n            ::QImage *sipRes;\n\n            Py_BEGIN_ALLOW_THREADS\n            sipRes = new ::QImage(sipCpp->grabToImage(a0));\n            Py_END_ALLOW_THREADS\n\n            return sipConvertFromNewType(sipRes, sipType_QImage, NULL);\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QQuickItem, sipName_grabToImage, doc_QQuickItem_grabToImage);\n\n    return NULL;\n}\n```",
        "source_code": "static PyObject *meth_QQuickItem_grabToImage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        const  ::QSize& a0def = QSize();\n        const  ::QSize* a0 = &a0def;\n         ::QQuickItem *sipCpp;\n\n        static const char *sipKwdList[] = {\n            sipName_targetSize,\n        };\n\n        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, \"B|J9\", &sipSelf, sipType_QQuickItem, &sipCpp, sipType_QSize, &a0))\n        {\n             ::QQuickItemGrabResult*sipRes = 0;\n\n#line 282 \"/builddir/build/BUILD/PyQt5_gpl-5.11.3/aarch64-redhat-linux-gnu/sip/QtQuick/qquickitem.sip\"\n        QSharedPointer<QQuickItemGrabResult> *grab;\n        \n        Py_BEGIN_ALLOW_THREADS\n        // This will leak but there seems to be no way to detach the object.\n        grab = new QSharedPointer<QQuickItemGrabResult>(sipCpp->grabToImage(*a0));\n        Py_END_ALLOW_THREADS\n        \n        sipRes = grab->data();\n#line 4464 \"/builddir/build/BUILD/PyQt5_gpl-5.11.3/aarch64-redhat-linux-gnu/QtQuick/sipQtQuickQQuickItem.cpp\"\n\n            return sipConvertFromNewType(sipRes,sipType_QQuickItemGrabResult,NULL);\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QQuickItem, sipName_grabToImage, doc_QQuickItem_grabToImage);\n\n    return NULL;\n}",
        "parsed_output": "static PyObject *meth_QQuickItem_grabToImage(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        const ::QQuickItem *sipCpp;\n        const ::QSize *a0 = NULL;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B|J8\", &sipSelf, sipType_QQuickItem, &sipCpp, sipType_QSize, &a0))\n        {\n            ::QImage *sipRes;\n\n            Py_BEGIN_ALLOW_THREADS\n            sipRes = new ::QImage(sipCpp->grabToImage(a0));\n            Py_END_ALLOW_THREADS\n\n            return sipConvertFromNewType(sipRes, sipType_QImage, NULL);\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QQuickItem, sipName_grabToImage, doc_QQuickItem_grabToImage);\n\n    return NULL;\n}",
        "baseline_code_stripped": "void FUN_0018aef0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  undefined8 local_38 [2];\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 *local_18;\n  QSize *pQStack_10;\n  long local_8;\n  local_18 = &local_20;\n  local_28 = 0;\n  local_20 = 0xffffffffffffffff;\n  local_8 = ___stack_chk_guard;\n  local_38[0] = param_1;\n  iVar1 = (**(code **)(DAT_00273618 + 0x370))\n                    (&local_28,param_2,param_3,&PTR_s_targetSize_002626c0,0,&DAT_001f6098,local_38,\n                     PTR_DAT_00272258,&pQStack_10,PTR_s_QSize_00272728,&local_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_00273618 + 0x2a0))\n              (local_28,\"QQuickItem\",\"grabToImage\",s_grabToImage_self__targetSize__QS_00261ed8);\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = PyEval_SaveThread();\n    puVar3 = (undefined8 *)operator_new(0x10);\n    QQuickItem::grabToImage(pQStack_10);\n    PyEval_RestoreThread(uVar2);\n    uVar2 = (**(code **)(DAT_00273618 + 0x90))(*puVar3,PTR_DAT_00272290,0);\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(uVar2);\n}",
        "similarity_score_unixcoder": 0.9430551528930664,
        "similarity_score_baseline_stripped": 0.632226288318634
    },
    {
        "func_name": "game_hub_data_compat_tool_real_run_data_free",
        "normed_func_sha256": "438821cb6448faf6abb4221552c9c43641d71545bf24150f264e7e3ad33332b0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid applications_plug_real_search_data_free(int param_1)\n{\n  g_free(*(undefined4 *)(param_1 + 0x14));\n  *(undefined4 *)(param_1 + 0x14) = 0;\n  if (*(int *)(param_1 + 0x18) != 0) {\n    g_object_unref();\n    *(undefined4 *)(param_1 + 0x18) = 0;\n  }\n  if (*(int *)(param_1 + 0x10) != 0) {\n    g_object_unref();\n    *(undefined4 *)(param_1 + 0x10) = 0;\n  }\n  g_slice_free1(0xf4,param_1);\n  return;\n}\n\n Revised code:\nstatic void applications_plug_real_search_data_free (gpointer _data) {\n\tApplicationsPlugSearchData* _data_;\n\t_data_ = _data;\n#line 22 \"/builddir/build/BUILD/switchboard-plug-applications-0.1.2/src/Plug.vala\"\n\t_g_free0 (_data_->search);\n#line 22 \"/builddir/build/BUILD/switchboard-plug-applications-0.1.2/src/Plug.vala\"\n\t_g_object_unref0 (_data_->result);\n#line 22 \"/builddir/build/BUILD/switchboard-plug-applications-0.1.2/src/Plug.vala\"\n\t_g_object_unref0 (_data_->self);\n#line 22 \"/builddir/build/BUILD/switchboard-plug-applications-0.1.2/src/Plug.vala\"\n\tg_slice_free (ApplicationsPlugSearchData, _data_);\n#line 494 \"Plug.c\"\n}\n\n## Example:\n\n Input code:\nvoid applications_plug_real_search_data_free(int param_1)\n{\n  g_free(*(undefined4 *)(param_1 + 0x14));\n  *(undefined4 *)(param_1 + 0x14) = 0;\n  if (*(int *)(param_1 + 0x18) != 0) {\n    g_object_unref();\n    *(undefined4 *)(param_1 + 0x18) = 0;\n  }\n  if (*(int *)(param_1 + 0x10) != 0) {\n    g_object_unref();\n    *(undefined4 *)(param_1 + 0x10) = 0;\n  }\n  g_slice_free1(0xcc,param_1);\n  return;\n}\n\n Revised code:\nstatic void applications_plug_real_search_data_free (gpointer _data) {\n\tApplicationsPlugSearchData* _data_;\n\t_data_ = _data;\n#line 22 \"/builddir/build/BUILD/switchboard-plug-applications-0.1.2/src/Plug.vala\"\n\t_g_free0 (_data_->search);\n#line 22 \"/builddir/build/BUILD/switchboard-plug-applications-0.1.2/src/Plug.vala\"\n\t_g_object_unref0 (_data_->result);\n#line 22 \"/builddir/build/BUILD/switchboard-plug-applications-0.1.2/src/Plug.vala\"\n\t_g_object_unref0 (_data_->self);\n#line 22 \"/builddir/build/BUILD/switchboard-plug-applications-0.1.2/src/Plug.vala\"\n\tg_slice_free (ApplicationsPlugSearchData, _data_);\n#line 472 \"Plug.c\"\n}\n\n## Example:\n\n Input code:\nvoid game_hub_data_sources_steam_steam_game_real_update_game_info_data_free(int param_1)\n{\n  if (*(int *)(param_1 + 0x10) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x10));\n    *(undefined4 *)(param_1 + 0x10) = 0;\n  }\n  g_slice_free1(0x2d8,param_1);\n  return;\n}\n\n Revised code:\nstatic void\ngame_hub_data_sources_steam_steam_game_real_update_game_info_data_free (gpointer _data)\n{\n\tGameHubDataSourcesSteamSteamGameUpdateGameInfoData* _data_;\n\t_data_ = _data;\n#line 26 \"../src/data/sources/steam/SteamGame.vala\"\n\t_g_object_unref0 (_data_->self);\n#line 26 \"../src/data/sources/steam/SteamGame.vala\"\n\tg_slice_free (GameHubDataSourcesSteamSteamGameUpdateGameInfoData, _data_);\n#line 2004 \"SteamGame.c\"\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid game_hub_data_compat_tool_real_run_data_free(int param_1)\n{\n  if (*(int *)(param_1 + 0x14) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x14));\n    *(undefined4 *)(param_1 + 0x14) = 0;\n  }\n  if (*(int *)(param_1 + 0x10) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x10));\n    *(undefined4 *)(param_1 + 0x10) = 0;\n  }\n  g_slice_free1(0x18,param_1);\n  return;\n}",
        "output": "```c\nstatic void\ngame_hub_data_compat_tool_real_run_data_free (gpointer _data)\n{\n\tGameHubDataCompatToolRunData* _data_;\n\t_data_ = _data;\n#line 30 \"../src/data/compat/CompatTool.vala\"\n\t_g_object_unref0 (_data_->tool);\n#line 30 \"../src/data/compat/CompatTool.vala\"\n\t_g_object_unref0 (_data_->self);\n#line 30 \"../src/data/compat/CompatTool.vala\"\n\tg_slice_free (GameHubDataCompatToolRunData, _data_);\n#line 1024 \"CompatTool.c\"\n}\n```",
        "source_code": "static void\ngame_hub_data_compat_tool_real_run_data_free (gpointer _data)\n{\n\tGameHubDataCompatToolRunData* _data_;\n\t_data_ = _data;\n#line 25 \"../src/data/CompatTool.vala\"\n\t_g_object_unref0 (_data_->game);\n#line 25 \"../src/data/CompatTool.vala\"\n\t_g_object_unref0 (_data_->self);\n#line 25 \"../src/data/CompatTool.vala\"\n\tg_slice_free (GameHubDataCompatToolRunData, _data_);\n#line 1016 \"CompatTool.c\"\n}",
        "parsed_output": "static void\ngame_hub_data_compat_tool_real_run_data_free (gpointer _data)\n{\n\tGameHubDataCompatToolRunData* _data_;\n\t_data_ = _data;\n#line 30 \"../src/data/compat/CompatTool.vala\"\n\t_g_object_unref0 (_data_->tool);\n#line 30 \"../src/data/compat/CompatTool.vala\"\n\t_g_object_unref0 (_data_->self);\n#line 30 \"../src/data/compat/CompatTool.vala\"\n\tg_slice_free (GameHubDataCompatToolRunData, _data_);\n#line 1024 \"CompatTool.c\"\n}",
        "baseline_code_stripped": "void game_hub_data_compat_tool_real_run_data_free(int param_1)\n{\n  if (*(int *)(param_1 + 0x14) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x14));\n    *(undefined4 *)(param_1 + 0x14) = 0;\n  }\n  if (*(int *)(param_1 + 0x10) != 0) {\n    g_object_unref(*(undefined4 *)(param_1 + 0x10));\n    *(undefined4 *)(param_1 + 0x10) = 0;\n  }\n  g_slice_free1(0x18,param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.9781305193901062,
        "similarity_score_baseline_stripped": 0.7293176651000977
    },
    {
        "func_name": "sipQtCharts_QScatterSeries::connectNotify",
        "normed_func_sha256": "cf635fe8270631b3f5917c72303734da6dc28985b7e711e2912fbcd3abc33de3",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __thiscall\nsipQgsTemporalNavigationObject::connectNotify\n          (sipQgsTemporalNavigationObject *this,QMetaMethod *param_1)\n{\n  _object *p_Var1;\n  long in_FS_OFFSET;\n  PyGILState_STATE local_24;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__core + 0x4c0))(&local_24,this + 0x92,this + 0x88,0,\"connectNotify\");\n  if (p_Var1 == (_object *)0x0) {\n    QObject::connectNotify((QMetaMethod *)this);\n  }\n  else {\n    sipVH__core_3(local_24,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)\n                           sipImportedVirtErrorHandlers__core_QtCore,\n                  *(_sipSimpleWrapper **)(this + 0x88),p_Var1,param_1);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid sipQgsTemporalNavigationObject::connectNotify(const ::QMetaMethod& a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[2], &sipPySelf, SIP_NULLPTR, sipName_connectNotify);\n\n    if (!sipMeth)\n    {\n        ::QgsTemporalNavigationObject::connectNotify(a0);\n        return;\n    }\n\n    extern void sipVH__core_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const ::QMetaMethod&);\n\n    sipVH__core_3(sipGILState, sipImportedVirtErrorHandlers__core_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);\n}\n\n## Example:\n\n Input code:\nvoid __thiscall sipQgsColorButton::connectNotify(sipQgsColorButton *this,QMetaMethod *param_1)\n{\n  _object *p_Var1;\n  PyGILState_STATE local_20;\n  int local_1c;\n  local_1c = __stack_chk_guard;\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__gui + 0x164))\n                     (&local_20,this + 0x98,*(undefined4 *)(this + 0x90),0,\"connectNotify\");\n  if (p_Var1 == (_object *)0x0) {\n    QObject::connectNotify((QMetaMethod *)this);\n  }\n  else {\n    sipVH__gui_0(local_20,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)\n                          sipImportedVirtErrorHandlers__gui_QtCore,\n                 *(_sipSimpleWrapper **)(this + 0x90),p_Var1,param_1);\n  }\n  if (local_1c == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\n::QVariant sipQgsColorButton::inputMethodQuery( ::Qt::InputMethodQuery a0) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[43]),sipPySelf,SIP_NULLPTR,sipName_inputMethodQuery);\n\n    if (!sipMeth)\n        return  ::QgsColorButton::inputMethodQuery(a0);\n\n    extern  ::QVariant sipVH__gui_79(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::Qt::InputMethodQuery);\n\n    return sipVH__gui_79(sipGILState, sipImportedVirtErrorHandlers__gui_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);\n}\n\n## Example:\n\n Input code:\nvoid __thiscall sipQgsPlotToolZoom::disconnectNotify(sipQgsPlotToolZoom *this,QMetaMethod *param_1)\n{\n  _object *p_Var1;\n  long in_FS_OFFSET;\n  PyGILState_STATE local_24;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__gui + 0x4c0))\n                     (&local_24,this + 0x68,this + 0x60,0,\"disconnectNotify\");\n  if (p_Var1 == (_object *)0x0) {\n    QObject::disconnectNotify((QMetaMethod *)this);\n  }\n  else {\n    sipVH__gui_0(local_24,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)\n                          sipImportedVirtErrorHandlers__gui_QtCore,\n                 *(_sipSimpleWrapper **)(this + 0x60),p_Var1,param_1);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid sipQgsPlotToolZoom::disconnectNotify(const ::QMetaMethod& a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[0], &sipPySelf, SIP_NULLPTR, sipName_disconnectNotify);\n\n    if (!sipMeth)\n    {\n        ::QgsPlotToolZoom::disconnectNotify(a0);\n        return;\n    }\n\n    extern void sipVH__gui_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const ::QMetaMethod&);\n\n    sipVH__gui_0(sipGILState, sipImportedVirtErrorHandlers__gui_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall\nsipQtCharts_QScatterSeries::connectNotify(sipQtCharts_QScatterSeries *this,QMetaMethod *param_1)\n{\n  _object *p_Var1;\n  int in_GS_OFFSET;\n  PyGILState_STATE local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  p_Var1 = (_object *)\n           (**(code **)(DAT_000d2940 + 0x164))\n                     (&local_14,this + 0x16,*(undefined4 *)(this + 0xc),0,\"connectNotify\");\n  if (p_Var1 == (_object *)0x0) {\n    FUN_00035fa0(this,param_1);\n  }\n  else {\n    sipVH_QtChart_0(local_14,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)\n                             PTR_s_PyQt5_000cc22c,*(_sipSimpleWrapper **)(this + 0xc),p_Var1,param_1\n                   );\n  }\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  __stack_chk_fail_local();\n}",
        "output": "```cpp\nvoid sipQtCharts_QScatterSeries::connectNotify(const ::QMetaMethod& a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[22], &sipPySelf, SIP_NULLPTR, sipName_connectNotify);\n\n    if (!sipMeth)\n    {\n        ::QScatterSeries::connectNotify(a0);\n        return;\n    }\n\n    extern void sipVH_QtChart_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const ::QMetaMethod&);\n\n    sipVH_QtChart_0(sipGILState, sipImportedVirtErrorHandlers_QtChart[0].iveh_handler, sipPySelf, sipMeth, a0);\n}\n```",
        "source_code": "void sipQtCharts_QScatterSeries::connectNotify(const  ::QMetaMethod& a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_connectNotify);\n\n    if (!sipMeth)\n    {\n         ::QtCharts::QScatterSeries::connectNotify(a0);\n        return;\n    }\n\n    extern void sipVH_QtChart_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);\n\n    sipVH_QtChart_0(sipGILState, sipImportedVirtErrorHandlers_QtChart_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);\n}",
        "parsed_output": "pp\nvoid sipQtCharts_QScatterSeries::connectNotify(const ::QMetaMethod& a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[22], &sipPySelf, SIP_NULLPTR, sipName_connectNotify);\n\n    if (!sipMeth)\n    {\n        ::QScatterSeries::connectNotify(a0);\n        return;\n    }\n\n    extern void sipVH_QtChart_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const ::QMetaMethod&);\n\n    sipVH_QtChart_0(sipGILState, sipImportedVirtErrorHandlers_QtChart[0].iveh_handler, sipPySelf, sipMeth, a0);\n}",
        "baseline_code_stripped": "void __thiscall\nsipQtCharts_QScatterSeries::connectNotify(sipQtCharts_QScatterSeries *this,QMetaMethod *param_1)\n{\n  _object *p_Var1;\n  int in_GS_OFFSET;\n  PyGILState_STATE local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  p_Var1 = (_object *)\n           (**(code **)(DAT_000d2940 + 0x164))\n                     (&local_14,this + 0x16,*(undefined4 *)(this + 0xc),0,\"connectNotify\");\n  if (p_Var1 == (_object *)0x0) {\n    FUN_00035fa0(this,param_1);\n  }\n  else {\n    sipVH_QtChart_0(local_14,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)\n                             PTR_s_PyQt5_000cc22c,*(_sipSimpleWrapper **)(this + 0xc),p_Var1,param_1\n                   );\n  }\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  __stack_chk_fail_local();\n}",
        "similarity_score_unixcoder": 0.9585019946098328,
        "similarity_score_baseline_stripped": 0.7519751191139221
    },
    {
        "func_name": "RemoveObstacle::apply",
        "normed_func_sha256": "477d534fa11340a99a8fca21f0af40048992ce748121a484385fdc070fa07878",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_00439c60(long *param_1)\n{\n  char cVar1;\n  long *plVar2;\n  long lVar3;\n  undefined *in_x8;\n  undefined local_71;\n  void *local_70 [3];\n  void *local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  void **ppvStack_38;\n  undefined8 local_30;\n  undefined *local_28;\n  undefined8 local_20;\n  undefined local_18;\n  undefined7 uStack_17;\n  undefined8 uStack_10;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  local_20 = 0;\n  local_18 = 0;\n  lVar3 = *(long *)(*param_1 + -0x18);\n  local_71 = 0x15;\n  local_28 = &local_18;\n  FUN_001ba180(&local_71);\n  plVar2 = *(long **)((long)param_1 + lVar3 + 8);\n  local_58 = (void *)0x0;\n  uStack_50 = 0;\n  local_48 = 0;\n  cVar1 = (**(code **)(*plVar2 + 0x28))(plVar2,local_70,&local_58);\n  if (cVar1 != '\\0') {\n    local_40 = 0x1efa1400000002;\n    local_30 = 0;\n    ppvStack_38 = &local_58;\n    FUN_0024a970(&local_40,&local_28);\n  }\n  if (local_58 != (void *)0x0) {\n    operator_delete(local_58);\n  }\n  if (local_70[0] != (void *)0x0) {\n    operator_delete(local_70[0]);\n  }\n  if (cVar1 == '\\0') {\n    *in_x8 = 0;\n    if (local_28 != &local_18) {\n      operator_delete(local_28);\n    }\n  }\n  else {\n    *in_x8 = 0;\n    *(undefined **)(in_x8 + 8) = in_x8 + 0x18;\n    if (local_28 == &local_18) {\n      *(ulong *)(in_x8 + 0x18) = CONCAT71(uStack_17,local_18);\n      *(undefined8 *)(in_x8 + 0x20) = uStack_10;\n    }\n    else {\n      *(undefined **)(in_x8 + 8) = local_28;\n      *(ulong *)(in_x8 + 0x18) = CONCAT71(uStack_17,local_18);\n    }\n    *(undefined8 *)(in_x8 + 0x10) = local_20;\n    *in_x8 = 1;\n  }\n  if (local_8 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);\n}\n\n Revised code:\nboost::optional<std::string> CLoanView::GetDefaultLoanScheme()\n{\n    std::string loanSchemeID;\n    if (Read(DefaultLoanSchemeKey::prefix(), loanSchemeID)) {\n        return loanSchemeID;\n    }\n\n    return {};\n}\n\n## Example:\n\n Input code:\nvoid FUN_0019cd78(long param_1,short param_2,char *param_3)\n{\n  size_t sVar1;\n  long *local_90;\n  undefined *local_88;\n  long lStack_80;\n  undefined auStack_78 [16];\n  undefined **local_68;\n  undefined4 local_60;\n  undefined8 local_5c;\n  undefined4 local_54;\n  undefined auStack_50 [16];\n  code *local_40;\n  undefined2 local_30;\n  undefined *local_28 [2];\n  undefined auStack_18 [16];\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  if (param_3 != (char *)0x0 && param_2 == 4) {\n    local_88 = auStack_78;\n    local_30 = *(undefined2 *)(param_1 + 0x4c);\n    sVar1 = strlen(param_3);\n    FUN_001c4ee8(&local_88,param_3,param_3 + sVar1);\n    local_28[0] = auStack_18;\n    local_68 = &PTR_FUN_00259c08;\n    local_60 = 0x3b;\n    local_5c = 0xffffffff;\n    local_54 = 0;\n    local_40 = (code *)0x0;\n    FUN_001c4ee8(local_28,local_88,local_88 + lStack_80);\n    if (local_88 != auStack_78) {\n      operator_delete(local_88);\n    }\n    GameActions::Execute((GameAction *)&local_68);\n    if (local_90 != (long *)0x0) {\n      (**(code **)(*local_90 + 8))();\n    }\n    local_68 = &PTR_FUN_00259c08;\n    if (local_28[0] != auStack_18) {\n      operator_delete(local_28[0]);\n    }\n    local_68 = (undefined **)&DAT_0025c358;\n    if (local_40 != (code *)0x0) {\n      (*local_40)(auStack_50,auStack_50,3);\n    }\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic void window_banner_textinput(rct_window* w, rct_widgetindex widgetIndex, char* text)\n{\n    if (widgetIndex == WIDX_BANNER_TEXT && text != nullptr)\n    {\n        auto bannerSetNameAction = BannerSetNameAction(w->number, text);\n        GameActions::Execute(&bannerSetNameAction);\n    }\n}\n\n## Example:\n\n Input code:\nvoid FUN_00659890(undefined8 param_1,undefined2 *param_2)\n{\n  long lVar1;\n  char *__s;\n  size_t sVar2;\n  undefined4 *local_68 [2];\n  undefined auStack_58 [24];\n  undefined8 *local_40;\n  ulong local_38;\n  undefined8 local_30;\n  undefined8 uStack_28;\n  undefined8 local_20;\n  ulong local_18;\n  undefined8 local_10;\n  undefined8 uStack_8;\n  FUN_0070f2c0(local_68,auStack_58);\n  *(undefined2 *)local_68[0] = *param_2;\n  FUN_0070f370(local_68,2);\n  *(undefined2 *)local_68[0] = param_2[1];\n  FUN_0070f370(local_68,2);\n  FUN_0070f330(local_68,0xc);\n  *local_68[0] = *(undefined4 *)(param_2 + 8);\n  FUN_0070f370(local_68,4);\n  FUN_0070f330(local_68,4);\n  lVar1 = FUN_0070f380(local_68);\n  local_40 = &local_30;\n  local_38 = 0;\n  local_30 = 0;\n  uStack_28 = 0;\n  FUN_0028a440(&local_40,\"\",0,2);\n  local_20 = &local_10;\n  local_18 = 0;\n  local_10 = 0;\n  uStack_8 = 0;\n  FUN_0028a440(&local_20,\n               \"/home/abuild/rpmbuild/BUILD/ja2-stracciatella-0.20.0/src/game/TileEngine/LoadSaveLightSprite.cc\"\n               ,0x5f,2);\n  FUN_00337640(lVar1 == 0x18,&local_40,&local_20,0x46);\n  if ((0xf < local_18) && (local_20 != (undefined8 *)0x0)) {\n    operator_delete__(local_20);\n  }\n  if ((0xf < local_38) && (local_40 != (undefined8 *)0x0)) {\n    operator_delete__(local_40);\n  }\n  FUN_00714e40(param_1,auStack_58,0x18);\n  __s = (char *)FUN_006541c0(param_2);\n  sVar2 = strlen(__s);\n  local_20 = (undefined8 *)CONCAT71(local_20._1_7_,(char)sVar2 + '\\x01');\n  FUN_00714e40(param_1,&local_20,1);\n  FUN_00714e40(param_1,__s,(ulong)local_20 & 0xff);\n  return;\n}\n\n Revised code:\nvoid InjectLightSpriteIntoFile(HWFILE const file, LIGHT_SPRITE const* const l)\n{\n\tBYTE data[24];\n\n\tDataWriter d{data};\n\tINJ_I16(d, l->iX)\n\tINJ_I16(d, l->iY)\n\tINJ_SKIP(d, 12)\n\tINJ_U32(d, l->uiFlags)\n\tINJ_SKIP(d, 4)\n\tAssert(d.getConsumed() == lengthof(data));\n\n\tfile->write(data, sizeof(data));\n\n\tconst char* const light_name = LightSpriteGetTypeName(l);\n\tconst UINT8       str_len    = static_cast<UINT8>(strlen(light_name) + 1);\n\tfile->write(&str_len,   sizeof(str_len));\n\tfile->write(light_name, str_len);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_005a0ee0(undefined8 param_1,long *param_2,long *param_3,undefined8 param_4)\n{\n  undefined4 uVar1;\n  long *plVar2;\n  JsonNode *pJVar3;\n  CObstacleInstance *this;\n  undefined local_d1;\n  undefined auStack_d0 [8];\n  _Rb_tree_node_base a_Stack_c8 [8];\n  undefined8 local_c0;\n  _Rb_tree_node_base *local_b8;\n  undefined **local_a0;\n  undefined8 uStack_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  JsonNode *local_80;\n  JsonNode *local_78;\n  JsonNode *local_70;\n  long local_68;\n  local_88 = 0xffffffff;\n  local_68 = ___stack_chk_guard;\n  local_a0 = &PTR_FUN_007f7050;\n  uStack_98 = 0;\n  local_90 = 0;\n  local_80 = (JsonNode *)0x0;\n  local_78 = (JsonNode *)0x0;\n  local_70 = (JsonNode *)0x0;\n  if (*(code **)(*param_3 + 0x148) == spells::BaseMechanics::battle) {\n    plVar2 = (long *)param_3[10];\n  }\n  else {\n    plVar2 = (long *)(**(code **)(*param_3 + 0x148))(param_3);\n  }\n  plVar2 = (long *)(**(code **)(*(long *)((long)plVar2 + *(long *)(*plVar2 + -0x98)) + 0x18))\n                             ((long)plVar2 + *(long *)(*plVar2 + -0x98));\n  if (*(code **)(*plVar2 + 0x18) == BattleInfo::getBattleID) {\n    local_88 = *(undefined4 *)(plVar2 + 1);\n  }\n  else {\n    local_88 = (**(code **)(*plVar2 + 0x18))();\n  }\n  FUN_0059c0f4(param_1,param_3,param_4,0);\n  pJVar3 = local_78;\n  while (local_78 = pJVar3, local_b8 != a_Stack_c8) {\n    local_d1 = 3;\n    this = *(CObstacleInstance **)(local_b8 + 0x20);\n    if (pJVar3 == local_70) {\n      FUN_002d3b60(&local_80,pJVar3,this + 0xc,&local_d1);\n      pJVar3 = local_78 + -0x78;\n    }\n    else {\n      uVar1 = *(undefined4 *)(this + 0xc);\n      JsonNode::JsonNode(pJVar3,0);\n      pJVar3[0x70] = (JsonNode)0x3;\n      *(undefined4 *)(pJVar3 + 0x74) = uVar1;\n      pJVar3 = local_78;\n      local_78 = local_78 + 0x78;\n    }\n    CObstacleInstance::toInfo(this,(ObstacleChanges *)pJVar3,3);\n    local_b8 = (_Rb_tree_node_base *)std::_Rb_tree_increment(local_b8);\n    pJVar3 = local_78;\n  }\n  FUN_002b8b20(auStack_d0,local_c0);\n  if (local_80 != local_78) {\n    (**(code **)(*param_2 + 0x58))(param_2,&local_a0);\n  }\n  FUN_002bf270(&local_a0);\n  if (local_68 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_68 - ___stack_chk_guard);\n}",
        "output": "```cpp\nvoid ProcessBattleObstacles(GameContext* context, BattleInstance* battle, ObstacleList* obstacles, JsonNode* jsonNode)\n{\n    uint32_t battleID = 0xFFFFFFFF;\n    JsonNode* currentNode = nullptr;\n    JsonNode* obstacleNode = nullptr;\n    JsonNode* tempNode = nullptr;\n\n    // Determine battle ID\n    if (battle->GetMechanics() == spells::BaseMechanics::battle)\n    {\n        battleID = battle->GetBattleID();\n    }\n    else\n    {\n        battleID = battle->ComputeBattleID();\n    }\n\n    // Initialize JSON node for obstacles\n    InitializeJsonNode(context, battle, jsonNode, 0);\n\n    // Process each obstacle in the list\n    for (auto it = obstacles->Begin(); it != obstacles->End(); ++it)\n    {\n        CObstacleInstance* obstacle = it->GetObstacleInstance();\n        uint32_t obstacleData = obstacle->GetData();\n\n        if (currentNode == tempNode)\n        {\n            AddObstacleToJson(&currentNode, tempNode, obstacle, 3);\n            currentNode -= 0x78;\n        }\n        else\n        {\n            JsonNode::Initialize(currentNode, 0);\n            currentNode->SetType(3);\n            currentNode->SetData(obstacleData);\n            currentNode += 0x78;\n        }\n\n        obstacle->ToInfo(currentNode, 3);\n    }\n\n    // Finalize JSON node\n    FinalizeJsonNode(context, jsonNode);\n\n    // If there are remaining obstacles, process them\n    if (currentNode != tempNode)\n    {\n        obstacles->ProcessRemaining(context);\n    }\n\n    CleanupJsonNode(context);\n}\n```",
        "source_code": "void RemoveObstacle::apply(ServerCallback * server, const Mechanics * m, const EffectTarget & target) const\n{\n\tBattleObstaclesChanged pack;\n\tpack.battleID = m->battle()->getBattle()->getBattleID();\n\n\tfor(const auto & obstacle : getTargets(m, target, false))\n\t{\n\t\tauto * serializable = const_cast<CObstacleInstance*>(obstacle); //Workaround\n\t\tpack.changes.emplace_back(obstacle->uniqueID, BattleChanges::EOperation::REMOVE);\n\t\tserializable->toInfo(pack.changes.back(), BattleChanges::EOperation::REMOVE);\n\t}\n\n\tif(!pack.changes.empty())\n\t\tserver->apply(&pack);\n}",
        "parsed_output": "pp\nvoid ProcessBattleObstacles(GameContext* context, BattleInstance* battle, ObstacleList* obstacles, JsonNode* jsonNode)\n{\n    uint32_t battleID = 0xFFFFFFFF;\n    JsonNode* currentNode = nullptr;\n    JsonNode* obstacleNode = nullptr;\n    JsonNode* tempNode = nullptr;\n\n    // Determine battle ID\n    if (battle->GetMechanics() == spells::BaseMechanics::battle)\n    {\n        battleID = battle->GetBattleID();\n    }\n    else\n    {\n        battleID = battle->ComputeBattleID();\n    }\n\n    // Initialize JSON node for obstacles\n    InitializeJsonNode(context, battle, jsonNode, 0);\n\n    // Process each obstacle in the list\n    for (auto it = obstacles->Begin(); it != obstacles->End(); ++it)\n    {\n        CObstacleInstance* obstacle = it->GetObstacleInstance();\n        uint32_t obstacleData = obstacle->GetData();\n\n        if (currentNode == tempNode)\n        {\n            AddObstacleToJson(&currentNode, tempNode, obstacle, 3);\n            currentNode -= 0x78;\n        }\n        else\n        {\n            JsonNode::Initialize(currentNode, 0);\n            currentNode->SetType(3);\n            currentNode->SetData(obstacleData);\n            currentNode += 0x78;\n        }\n\n        obstacle->ToInfo(currentNode, 3);\n    }\n\n    // Finalize JSON node\n    FinalizeJsonNode(context, jsonNode);\n\n    // If there are remaining obstacles, process them\n    if (currentNode != tempNode)\n    {\n        obstacles->ProcessRemaining(context);\n    }\n\n    CleanupJsonNode(context);\n}",
        "baseline_code_stripped": "void FUN_005a0ee0(undefined8 param_1,long *param_2,long *param_3,undefined8 param_4)\n{\n  undefined4 uVar1;\n  long *plVar2;\n  JsonNode *pJVar3;\n  CObstacleInstance *this;\n  undefined local_d1;\n  undefined auStack_d0 [8];\n  _Rb_tree_node_base a_Stack_c8 [8];\n  undefined8 local_c0;\n  _Rb_tree_node_base *local_b8;\n  undefined **local_a0;\n  undefined8 uStack_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  JsonNode *local_80;\n  JsonNode *local_78;\n  JsonNode *local_70;\n  long local_68;\n  local_88 = 0xffffffff;\n  local_68 = ___stack_chk_guard;\n  local_a0 = &PTR_FUN_007f7050;\n  uStack_98 = 0;\n  local_90 = 0;\n  local_80 = (JsonNode *)0x0;\n  local_78 = (JsonNode *)0x0;\n  local_70 = (JsonNode *)0x0;\n  if (*(code **)(*param_3 + 0x148) == spells::BaseMechanics::battle) {\n    plVar2 = (long *)param_3[10];\n  }\n  else {\n    plVar2 = (long *)(**(code **)(*param_3 + 0x148))(param_3);\n  }\n  plVar2 = (long *)(**(code **)(*(long *)((long)plVar2 + *(long *)(*plVar2 + -0x98)) + 0x18))\n                             ((long)plVar2 + *(long *)(*plVar2 + -0x98));\n  if (*(code **)(*plVar2 + 0x18) == BattleInfo::getBattleID) {\n    local_88 = *(undefined4 *)(plVar2 + 1);\n  }\n  else {\n    local_88 = (**(code **)(*plVar2 + 0x18))();\n  }\n  FUN_0059c0f4(param_1,param_3,param_4,0);\n  pJVar3 = local_78;\n  while (local_78 = pJVar3, local_b8 != a_Stack_c8) {\n    local_d1 = 3;\n    this = *(CObstacleInstance **)(local_b8 + 0x20);\n    if (pJVar3 == local_70) {\n      FUN_002d3b60(&local_80,pJVar3,this + 0xc,&local_d1);\n      pJVar3 = local_78 + -0x78;\n    }\n    else {\n      uVar1 = *(undefined4 *)(this + 0xc);\n      JsonNode::JsonNode(pJVar3,0);\n      pJVar3[0x70] = (JsonNode)0x3;\n      *(undefined4 *)(pJVar3 + 0x74) = uVar1;\n      pJVar3 = local_78;\n      local_78 = local_78 + 0x78;\n    }\n    CObstacleInstance::toInfo(this,(ObstacleChanges *)pJVar3,3);\n    local_b8 = (_Rb_tree_node_base *)std::_Rb_tree_increment(local_b8);\n    pJVar3 = local_78;\n  }\n  FUN_002b8b20(auStack_d0,local_c0);\n  if (local_80 != local_78) {\n    (**(code **)(*param_2 + 0x58))(param_2,&local_a0);\n  }\n  FUN_002bf270(&local_a0);\n  if (local_68 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_68 - ___stack_chk_guard);\n}",
        "similarity_score_unixcoder": 0.6803569793701172,
        "similarity_score_baseline_stripped": 0.37734994292259216
    },
    {
        "func_name": "sipQTransposeProxyModel::headerData",
        "normed_func_sha256": "558b272a016bf8d4cdce8dcd4e1fee402fbe8b8de5f2dbc1b95f26e7a679853c",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nQModelIndex * FUN_001a21e0(QModelIndex *param_1,int param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined *puVar2;\n  int unaff_EDI;\n  int in_GS_OFFSET;\n  undefined auStack_30 [4];\n  undefined auStack_2c [8];\n  undefined local_24 [4];\n  undefined4 local_20;\n  FUN_00080b72();\n  local_20 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  iVar1 = (**(code **)(*(int *)(unaff_EDI + 0x16cfa1) + 0x260))\n                    (local_24,param_2 + 0x27,param_2 + 8,0,unaff_EDI + 0x7e1d5);\n  if (iVar1 == 0) {\n    QAbstractTableModel::flags(param_1);\n    puVar2 = auStack_30;\n  }\n  else {\n    FUN_001d9160(iVar1,param_3);\n    puVar2 = auStack_2c;\n  }\n  if (*(int *)(puVar2 + 0xc) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return param_1;\n  }\n  *(undefined4 *)(puVar2 + -4) = 0x1a227f;\n  FUN_001df220();\n}\n\n Revised code:\n::Qt::ItemFlags sipQAbstractTableModel::flags(const ::QModelIndex& a0) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[27]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_flags);\n\n    if (!sipMeth)\n        return ::QAbstractTableModel::flags(a0);\n\n    extern ::Qt::ItemFlags sipVH_QtCore_35(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const ::QModelIndex&);\n\n    return sipVH_QtCore_35(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_00184390(undefined4 param_1)\n{\n  int *piVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  int unaff_EBX;\n  undefined4 *puVar5;\n  int in_GS_OFFSET;\n  undefined4 uStack_44;\n  undefined auStack_40 [12];\n  undefined local_34 [8];\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined4 uStack_14;\n  uStack_14 = 0x18439d;\n  entry();\n  piVar1 = *(int **)(unaff_EBX + 0x145a87);\n  local_24 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  local_2c = 0;\n  iVar2 = (**(code **)(*piVar1 + 0x140))\n                    (&local_2c,param_1,\n                     \"_ZNK19QAbstractProxyModel8itemDataERK11QModelIndex\" + unaff_EBX + 0x12,\n                     local_34,*(undefined4 *)(*(int *)(unaff_EBX + 0x145a6f) + 200),&local_28);\n  if (iVar2 == 0) {\n    uStack_44 = 0;\n    (**(code **)(*piVar1 + 0x150))\n              (local_2c,*(int *)(unaff_EBX + 0x145b7f) + 0x53f7,\n               *(int *)(unaff_EBX + 0x145b7f) + 0x68c3);\n    uVar3 = 0;\n    puVar5 = (undefined4 *)auStack_40;\n  }\n  else {\n    uStack_44 = 0x184402;\n    uVar3 = FUN_000bece0();\n    uVar4 = FUN_000bb4d0(4);\n    FUN_000b9300(uVar4,local_28);\n    FUN_000b7dd0(uVar3);\n    uVar3 = (**(code **)(*piVar1 + 0x48))\n                      (uVar4,*(undefined4 *)(*(int *)(unaff_EBX + 0x145a5f) + 0x60),0);\n    puVar5 = &uStack_44;\n  }\n  if (*(int *)((int)puVar5 + 0x1c) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return uVar3;\n  }\n  *(undefined **)((int)puVar5 + -4) = &UNK_0018447d;\n  FUN_001f9be0();\n}\n\n Revised code:\nstatic PyObject *meth_KDirOperator_nameFilter(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        const  ::KDirOperator *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"B\", &sipSelf, sipType_KDirOperator, &sipCpp))\n        {\n             ::QString*sipRes;\n\n            Py_BEGIN_ALLOW_THREADS\n            sipRes = new  ::QString(sipCpp->nameFilter());\n            Py_END_ALLOW_THREADS\n\n            return sipConvertFromNewType(sipRes,sipType_QString,NULL);\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_KDirOperator, sipName_nameFilter, NULL);\n\n    return NULL;\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_003055e0(undefined4 param_1,int param_2)\n{\n  int iVar1;\n  undefined *puVar2;\n  int unaff_EDI;\n  int in_GS_OFFSET;\n  undefined auStack_20 [4];\n  undefined auStack_1c [8];\n  undefined local_14 [4];\n  undefined4 local_10;\n  FUN_000d1dd4();\n  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  iVar1 = (**(code **)(*(int *)(unaff_EDI + 0x24cb6e) + 0x260))\n                    (local_14,param_2 + 0x1a,param_2 + 0x10,0,unaff_EDI + 0x93e49);\n  if (iVar1 == 0) {\n    QBoxLayout::minimumSize();\n    puVar2 = auStack_20;\n  }\n  else {\n    FUN_000d0de0(*(undefined4 *)(param_2 + 0x10),iVar1);\n    puVar2 = auStack_1c;\n  }\n  if (*(int *)(puVar2 + 0xc) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return param_1;\n  }\n  *(undefined4 *)(puVar2 + -4) = 0x30567e;\n  FUN_0034c180();\n}\n\n Revised code:\n::QSize sipQVBoxLayout::minimumSize() const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n#if SIP_ABI_MAJOR_VERSION >= 12 && SIP_ABI_MINOR_VERSION >= 8\n    sipMeth = sipIsPyMethod_12_8(&sipGILState, const_cast<char *>(&sipPyMethods[6]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_minimumSize);\n\n#else\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[6]), sipPySelf, SIP_NULLPTR, sipName_minimumSize);\n#endif\n\n    if (!sipMeth)\n        return  ::QVBoxLayout::minimumSize();\n\n    extern  ::QSize sipVH_QtWidgets_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);\n\n    return sipVH_QtWidgets_10(sipGILState, sipImportedVirtErrorHandlers_QtWidgets_QtCore[0].iveh_handler, sipPySelf, sipMeth);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_000aeb40(int param_1,Orientation param_2,int param_3,undefined4 param_4,undefined4 param_5)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  int unaff_EDI;\n  int in_GS_OFFSET;\n  undefined4 uStack_20;\n  undefined auStack_1c [8];\n  undefined local_14 [4];\n  undefined4 local_10;\n  FUN_00089011();\n  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  iVar1 = (**(code **)(*(int *)((int)&fde_0024eb90 + unaff_EDI + 2) + 0x260))\n                    (local_14,param_2 + 0x25,param_2 + 8,0,unaff_EDI + 0x161867);\n  if (iVar1 == 0) {\n    QTransposeProxyModel::headerData(param_1,param_2,param_3);\n    puVar2 = &uStack_20;\n  }\n  else {\n    uStack_20 = param_5;\n    FUN_001d4e90(iVar1,param_3,param_4);\n    puVar2 = (undefined4 *)auStack_1c;\n  }\n  if (*(int *)((int)puVar2 + 0xc) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return param_1;\n  }\n  *(undefined **)((int)puVar2 + -4) = &UNK_000aebea;\n  FUN_001da030();\n}",
        "output": "```cpp\nint QTransposeProxyModel::headerData(int section, Qt::Orientation orientation, int role) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[5]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_headerData);\n\n    if (!sipMeth)\n        return QTransposeProxyModel::headerData(section, orientation, role);\n\n    extern int sipVH_QtCore_42(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int, Qt::Orientation, int);\n\n    return sipVH_QtCore_42(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, section, orientation, role);\n}\n```",
        "source_code": "::QVariant sipQTransposeProxyModel::headerData(int a0, ::Qt::Orientation a1,int a2) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n#if SIP_ABI_MAJOR_VERSION >= 12 && SIP_ABI_MINOR_VERSION >= 8\n    sipMeth = sipIsPyMethod_12_8(&sipGILState, const_cast<char *>(&sipPyMethods[25]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_headerData);\n\n#else\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[25]), sipPySelf, SIP_NULLPTR, sipName_headerData);\n#endif\n\n    if (!sipMeth)\n        return  ::QTransposeProxyModel::headerData(a0,a1,a2);\n\n    extern  ::QVariant sipVH_QtCore_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int, ::Qt::Orientation,int);\n\n    return sipVH_QtCore_25(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0, a1, a2);\n}",
        "parsed_output": "pp\nint QTransposeProxyModel::headerData(int section, Qt::Orientation orientation, int role) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[5]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_headerData);\n\n    if (!sipMeth)\n        return QTransposeProxyModel::headerData(section, orientation, role);\n\n    extern int sipVH_QtCore_42(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int, Qt::Orientation, int);\n\n    return sipVH_QtCore_42(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, section, orientation, role);\n}",
        "baseline_code_stripped": "int FUN_000aeb40(int param_1,Orientation param_2,int param_3,undefined4 param_4,undefined4 param_5)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  int unaff_EDI;\n  int in_GS_OFFSET;\n  undefined4 uStack_20;\n  undefined auStack_1c [8];\n  undefined local_14 [4];\n  undefined4 local_10;\n  FUN_00089011();\n  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  iVar1 = (**(code **)(*(int *)((int)&fde_0024eb90 + unaff_EDI + 2) + 0x260))\n                    (local_14,param_2 + 0x25,param_2 + 8,0,unaff_EDI + 0x161867);\n  if (iVar1 == 0) {\n    QTransposeProxyModel::headerData(param_1,param_2,param_3);\n    puVar2 = &uStack_20;\n  }\n  else {\n    uStack_20 = param_5;\n    FUN_001d4e90(iVar1,param_3,param_4);\n    puVar2 = (undefined4 *)auStack_1c;\n  }\n  if (*(int *)((int)puVar2 + 0xc) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return param_1;\n  }\n  *(undefined **)((int)puVar2 + -4) = &UNK_000aebea;\n  FUN_001da030();\n}",
        "similarity_score_unixcoder": 0.9293530583381653,
        "similarity_score_baseline_stripped": 0.6006065607070923
    },
    {
        "func_name": "ServicePage::onCurrentServerChanged",
        "normed_func_sha256": "7a286658067c6031477184439dab50eec06e0f427fdf391692752e761748097e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __thiscall TtRssAccountDetails::onUrlChanged(TtRssAccountDetails *this)\n{\n  undefined8 uVar1;\n  char cVar2;\n  StatusType SVar3;\n  long in_FS_OFFSET;\n  int *local_40;\n  QString local_38 [8];\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  QLineEdit::text();\n  if (local_40[1] == 0) {\n    uVar1 = *(undefined8 *)(this + 0x48);\n    QMetaObject::tr((char *)local_38,staticMetaObject,0x433c4e);\n    WidgetWithStatus::setStatus((StatusType)uVar1,(QString *)0x2);\n  }\n  else {\n    cVar2 = QString::endsWith((QLatin1String)&local_40,5);\n    if (cVar2 == '\\0') {\n      cVar2 = QString::endsWith((QLatin1String)&local_40,4);\n      SVar3 = (StatusType)*(undefined8 *)(this + 0x48);\n      if (cVar2 == '\\0') {\n        QMetaObject::tr((char *)local_38,staticMetaObject,0x433c63);\n        WidgetWithStatus::setStatus(SVar3,(QString *)0x3);\n        goto LAB_0039814d;\n      }\n    }\n    else {\n      SVar3 = (StatusType)*(undefined8 *)(this + 0x48);\n    }\n    QMetaObject::tr((char *)local_38,staticMetaObject,0x43a990);\n    WidgetWithStatus::setStatus(SVar3,(QString *)0x1);\n  }\nLAB_0039814d:\n  QString::_QString(local_38);\n  if (*local_40 != 0) {\n    if (*local_40 == -1) goto LAB_00398170;\n    LOCK();\n    *local_40 = *local_40 + -1;\n    UNLOCK();\n    if (*local_40 != 0) goto LAB_00398170;\n  }\n  QArrayData::deallocate((QArrayData *)local_40,2,8);\nLAB_00398170:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid TtRssAccountDetails::onUrlChanged() {\r\n  const QString url = m_ui.m_txtUrl->lineEdit()->text();\r\n\r\n  if (url.isEmpty()) {\r\n    m_ui.m_txtUrl->setStatus(WidgetWithStatus::StatusType::Error, tr(\"URL cannot be empty.\"));\r\n  }\r\n  else if (url.endsWith(QL1S(\"/api/\")) || url.endsWith(QL1S(\"/api\"))) {\r\n    m_ui.m_txtUrl->setStatus(WidgetWithStatus::StatusType::Warning, tr(\"URL should NOT end with \\\"/api/\\\".\"));\r\n  }\r\n  else {\r\n    m_ui.m_txtUrl->setStatus(WidgetWithStatus::StatusType::Ok, tr(\"URL is okay.\"));\r\n  }\r\n}\n\n## Example:\n\n Input code:\nvoid FUN_001d1e90(QWidget *param_1)\n{\n  char cVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  long lVar5;\n  QMovie *this;\n  long *plVar6;\n  QFlags QVar7;\n  long in_FS_OFFSET;\n  undefined *local_70;\n  KUrl local_68 [16];\n  undefined8 *local_58 [3];\n  long local_40;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  QObject::sender();\n  lVar5 = QMetaObject::cast((QObject *)&PTR_staticMetaObject_00264e00);\n  if (lVar5 != 0) {\n    uVar2 = QTabWidget::indexOf(param_1);\n    if (uVar2 != 0xffffffff) {\n      QTabWidget::tabBar();\n      iVar3 = QMetaObject::cast((QObject *)&PTR_staticMetaObject_00260360);\n      QTabBar::tabButton(iVar3,uVar2);\n      this = (QMovie *)QMetaObject::cast((QObject *)&QLabel::staticMetaObject);\n      QVar7 = (QFlags)local_58;\n      if (this == (QMovie *)0x0) {\n        local_58[0] = (undefined8 *)((ulong)local_58[0] & 0xffffffff00000000);\n        this = (QMovie *)operator_new(0x28);\n        QLabel::QLabel((QLabel *)this,param_1,QVar7);\n        QTabWidget::tabBar();\n        iVar3 = QMetaObject::cast((QObject *)&PTR_staticMetaObject_00260360);\n        QTabBar::setTabButton(iVar3,uVar2,(QWidget *)0x0);\n        QTabWidget::tabBar();\n        iVar3 = QMetaObject::cast((QObject *)&PTR_staticMetaObject_00260360);\n        QTabBar::setTabButton(iVar3,uVar2,(QWidget *)0x0);\n      }\n      plVar6 = (long *)QLabel::movie();\n      if (plVar6 != (long *)0x0) {\n        QMovie::stop();\n        (**(code **)(*plVar6 + 0x20))(plVar6);\n      }\n      QLabel::setMovie(this);\n      IconManager::self();\n      FUN_002136f0(local_58,lVar5);\n      IconManager::iconForUrl(local_68);\n      KUrl::_KUrl((KUrl *)local_58);\n      local_70 = &DAT_1000000010;\n      QIcon::pixmap((QSize *)local_58,(Mode)local_68,(State)&local_70);\n      QLabel::setPixmap((QPixmap *)this);\n      QPixmap::_QPixmap((QPixmap *)local_58);\n      QTabWidget::tabBar();\n      QMetaObject::cast((QObject *)&PTR_staticMetaObject_00260360);\n      QTabBar::tabData(QVar7);\n      cVar1 = QVariant::toBool();\n      QVariant::_QVariant((QVariant *)local_58);\n      if (cVar1 == '\\0') {\n        FUN_00213730(local_58,lVar5);\n      }\n      else {\n        local_58[0] = &QString::shared_null;\n        LOCK();\n        QString::shared_null._0_4_ = (int)QString::shared_null + 1;\n        UNLOCK();\n      }\n      KTabWidget::setTabText((int)param_1,(QString *)(ulong)uVar2);\n      LOCK();\n      *(int *)local_58[0] = *(int *)local_58[0] + -1;\n      UNLOCK();\n      if (*(int *)local_58[0] == 0) {\n        QString::free((Data *)local_58[0]);\n      }\n      uVar4 = QTabWidget::currentIndex();\n      if (uVar4 == uVar2) {\n        FUN_00213d50(lVar5);\n      }\n      KIcon::_KIcon((KIcon *)local_68);\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid TabWidget::tabLoadFinished(bool ok)\n{\n    Q_UNUSED(ok);\n\n    WebWindow *tab = qobject_cast<WebWindow *>(sender());\n    if (!tab)\n        return;\n\n    int index = indexOf(tab);\n\n    if (-1 == index)\n        return;\n\n    QLabel *label = qobject_cast<QLabel* >(tabBar()->tabButton(index, QTabBar::LeftSide));\n    if (!label)\n    {\n        label = new QLabel(this);\n        tabBar()->setTabButton(index, QTabBar::LeftSide, 0);\n        tabBar()->setTabButton(index, QTabBar::LeftSide, label);\n    }\n\n    QMovie *movie = label->movie();\n    if (movie)\n    {\n        movie->stop();\n        delete movie;\n    }\n\n    label->setMovie(0);\n\n    KIcon ic = IconManager::self()->iconForUrl(tab->url());\n    label->setPixmap(ic.pixmap(16, 16));\n\n    if (!tabBar()->tabData(index).toBool())\n    {\n        setTabText(index, tab->title());\n    }\n    else\n    {\n        setTabText(index, QString());\n    }\n\n    if (index == currentIndex())\n        tab->checkFocus();\n}\n\n## Example:\n\n Input code:\nvoid FUN_00105070(long param_1)\n{\n  QTextStream *this;\n  long lVar1;\n  long in_FS_OFFSET;\n  QTextStream *local_80;\n  QUrl local_78 [8];\n  int *local_70;\n  int *local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  long local_40;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = FUN_0010c1b0();\n  if (*(char *)(lVar1 + 0x10) != '\\0') {\n    lVar1 = FUN_0010c1b0();\n    local_50 = *(undefined8 *)(lVar1 + 8);\n    local_68 = (int *)0x2;\n    local_60 = 0;\n    local_58 = 0;\n    QMessageLogger::debug();\n    this = local_80;\n    QString::fromUtf8_helper((char *)&local_70,0x10c2d3);\n    QTextStream::operator__(this,(QString *)&local_70);\n    if (*local_70 == 0) {\nLAB_001051b0:\n      QArrayData::deallocate((QArrayData *)local_70,2,8);\n    }\n    else if (*local_70 != -1) {\n      LOCK();\n      *local_70 = *local_70 + -1;\n      UNLOCK();\n      if (*local_70 == 0) goto LAB_001051b0;\n    }\n    if (local_80[0x20] != (QTextStream)0x0) {\n      QTextStream::operator__(local_80,' ');\n    }\n    *(int *)(local_80 + 0x18) = *(int *)(local_80 + 0x18) + 1;\n    operator__(SUB81(&local_70,0),local_78);\n    QDebug::_QDebug((QDebug *)&local_70);\n    QDebug::_QDebug((QDebug *)local_78);\n    QDebug::_QDebug((QDebug *)&local_80);\n  }\n  local_68 = (int *)QString::fromLatin1_helper(\"\",0);\n  KIO::SlaveBase::mimeType((QString *)(param_1 + 0x10));\n  if (*local_68 != 0) {\n    if (*local_68 == -1) goto LAB_001050e7;\n    LOCK();\n    *local_68 = *local_68 + -1;\n    UNLOCK();\n    if (*local_68 != 0) goto LAB_001050e7;\n  }\n  QArrayData::deallocate((QArrayData *)local_68,2,8);\nLAB_001050e7:\n  KIO::SlaveBase::finished();\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid KioKdeconnect::get(const QUrl& url)\n{\n    qCDebug(KDECONNECT_KIO) << \"Get: \" << url;\n    mimeType(QLatin1String(\"\"));\n    finished();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall ServicePage::onCurrentServerChanged(ServicePage *this)\n{\n  QString *pQVar1;\n  code *pcVar2;\n  char cVar3;\n  int iVar4;\n  long *plVar5;\n  long in_FS_OFFSET;\n  QString local_68 [8];\n  QString local_60 [8];\n  Jid local_58 [8];\n  undefined8 local_50;\n  undefined8 *local_48;\n  long local_40;\n  local_50 = *(undefined8 *)(this + 0x70);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  *(undefined8 **)(this + 0x70) = &QListData::shared_null;\n  local_48 = &QListData::shared_null;\n  QList<Jid>::_QList((QList_Jid_ *)&local_50);\n  QList<Jid>::_QList((QList_Jid_ *)&local_48);\n  QComboBox::clear();\n  local_48 = &QArrayData::shared_null;\n  QLabel::setText(*(QString **)(this + 0x30));\n  QString::_QString((QString *)&local_48);\n  iVar4 = QComboBox::count();\n  if (0 < iVar4) {\n    iVar4 = QComboBox::count();\n    if (0 < iVar4) {\n      plVar5 = (long *)PluginHelper::pluginInstance_IServiceDiscovery_();\n      if (plVar5 != (long *)0x0) {\n        pcVar2 = *(code **)(*plVar5 + 0xd0);\n        local_48 = &QArrayData::shared_null;\n        serverJid();\n        Jid::Jid((Jid *)&local_50,local_60);\n        streamJid();\n        Jid::Jid(local_58,local_68);\n        cVar3 = (*pcVar2)(plVar5,local_58,&local_50,&local_48);\n        Jid::_Jid(local_58);\n        QString::_QString(local_68);\n        Jid::_Jid((Jid *)&local_50);\n        QString::_QString(local_60);\n        QString::_QString((QString *)&local_48);\n        if (cVar3 != '\\0') {\n          this[0x68] = (ServicePage)0x1;\n          pQVar1 = *(QString **)(this + 0x30);\n          QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae20);\n          QLabel::setText(pQVar1);\n          goto LAB_001d5fc8;\n        }\n      }\n      pQVar1 = *(QString **)(this + 0x30);\n      QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae48);\n      QLabel::setText(pQVar1);\n      goto LAB_001d5fc8;\n    }\n  }\n  pQVar1 = *(QString **)(this + 0x30);\n  QMetaObject::tr((char *)&local_48,staticMetaObject,0x20adf8);\n  QLabel::setText(pQVar1);\nLAB_001d5fc8:\n  QString::_QString((QString *)&local_48);\n  QWizardPage::completeChanged();\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```cpp\nvoid ServicePage::onCurrentServerChanged() {\n    m_ui.m_lblStatus->setText(tr(\"No servers available.\"));\n    m_ui.m_cmbServers->clear();\n\n    if (m_ui.m_cmbServers->count() > 0) {\n        auto serviceDiscovery = PluginHelper::pluginInstance<IServiceDiscovery>();\n        if (serviceDiscovery) {\n            Jid serverJid(m_ui.m_cmbServers->currentText());\n            Jid streamJid(m_ui.m_cmbServers->currentText());\n\n            if (serviceDiscovery->isServerCompatible(streamJid, serverJid)) {\n                m_ui.m_lblStatus->setText(tr(\"Server is compatible.\"));\n                m_isServerCompatible = true;\n            } else {\n                m_ui.m_lblStatus->setText(tr(\"Server is not compatible.\"));\n            }\n        } else {\n            m_ui.m_lblStatus->setText(tr(\"Service discovery plugin not available.\"));\n        }\n    }\n\n    emit completeChanged();\n}\n```",
        "source_code": "void ServicePage::onCurrentServerChanged()\r\n{\r\n\tFWaitInfo.clear();\r\n\tcmbService->clear();\r\n\tlblInfo->setText(QString::null);\r\n\r\n\tif (cmbAccount->count()>0 && cmbServer->count()>0)\r\n\t{\r\n\t\tIServiceDiscovery *discovery = PluginHelper::pluginInstance<IServiceDiscovery>();\r\n\t\tif (discovery && discovery->requestDiscoItems(streamJid(),serverJid()))\r\n\t\t{\r\n\t\t\tFWaitItems = true;\r\n\t\t\tlblInfo->setText(tr(\"Loading list of available services...\"));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlblInfo->setText(tr(\"Failed to load list of services\"));\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlblInfo->setText(tr(\"Account or server is not selected\"));\r\n\t}\r\n\r\n\temit completeChanged();\r\n}",
        "parsed_output": "pp\nvoid ServicePage::onCurrentServerChanged() {\n    m_ui.m_lblStatus->setText(tr(\"No servers available.\"));\n    m_ui.m_cmbServers->clear();\n\n    if (m_ui.m_cmbServers->count() > 0) {\n        auto serviceDiscovery = PluginHelper::pluginInstance<IServiceDiscovery>();\n        if (serviceDiscovery) {\n            Jid serverJid(m_ui.m_cmbServers->currentText());\n            Jid streamJid(m_ui.m_cmbServers->currentText());\n\n            if (serviceDiscovery->isServerCompatible(streamJid, serverJid)) {\n                m_ui.m_lblStatus->setText(tr(\"Server is compatible.\"));\n                m_isServerCompatible = true;\n            } else {\n                m_ui.m_lblStatus->setText(tr(\"Server is not compatible.\"));\n            }\n        } else {\n            m_ui.m_lblStatus->setText(tr(\"Service discovery plugin not available.\"));\n        }\n    }\n\n    emit completeChanged();\n}",
        "baseline_code_stripped": "void __thiscall ServicePage::onCurrentServerChanged(ServicePage *this)\n{\n  QString *pQVar1;\n  code *pcVar2;\n  char cVar3;\n  int iVar4;\n  long *plVar5;\n  long in_FS_OFFSET;\n  QString local_68 [8];\n  QString local_60 [8];\n  Jid local_58 [8];\n  undefined8 local_50;\n  undefined8 *local_48;\n  long local_40;\n  local_50 = *(undefined8 *)(this + 0x70);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  *(undefined8 **)(this + 0x70) = &QListData::shared_null;\n  local_48 = &QListData::shared_null;\n  QList<Jid>::_QList((QList_Jid_ *)&local_50);\n  QList<Jid>::_QList((QList_Jid_ *)&local_48);\n  QComboBox::clear();\n  local_48 = &QArrayData::shared_null;\n  QLabel::setText(*(QString **)(this + 0x30));\n  QString::_QString((QString *)&local_48);\n  iVar4 = QComboBox::count();\n  if (0 < iVar4) {\n    iVar4 = QComboBox::count();\n    if (0 < iVar4) {\n      plVar5 = (long *)PluginHelper::pluginInstance_IServiceDiscovery_();\n      if (plVar5 != (long *)0x0) {\n        pcVar2 = *(code **)(*plVar5 + 0xd0);\n        local_48 = &QArrayData::shared_null;\n        serverJid();\n        Jid::Jid((Jid *)&local_50,local_60);\n        streamJid();\n        Jid::Jid(local_58,local_68);\n        cVar3 = (*pcVar2)(plVar5,local_58,&local_50,&local_48);\n        Jid::_Jid(local_58);\n        QString::_QString(local_68);\n        Jid::_Jid((Jid *)&local_50);\n        QString::_QString(local_60);\n        QString::_QString((QString *)&local_48);\n        if (cVar3 != '\\0') {\n          this[0x68] = (ServicePage)0x1;\n          pQVar1 = *(QString **)(this + 0x30);\n          QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae20);\n          QLabel::setText(pQVar1);\n          goto LAB_001d5fc8;\n        }\n      }\n      pQVar1 = *(QString **)(this + 0x30);\n      QMetaObject::tr((char *)&local_48,staticMetaObject,0x20ae48);\n      QLabel::setText(pQVar1);\n      goto LAB_001d5fc8;\n    }\n  }\n  pQVar1 = *(QString **)(this + 0x30);\n  QMetaObject::tr((char *)&local_48,staticMetaObject,0x20adf8);\n  QLabel::setText(pQVar1);\nLAB_001d5fc8:\n  QString::_QString((QString *)&local_48);\n  QWizardPage::completeChanged();\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.7988903522491455,
        "similarity_score_baseline_stripped": 0.6262897849082947
    },
    {
        "func_name": "botlink_resolve_success",
        "normed_func_sha256": "515d28efdd2e4c7a363a30b26e9ac714b550cba85844ae7e085d90156e2bc1ad",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_1002ddf0(int param_1)\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined4 *puVar5;\n  iVar1 = *(int *)(param_1 + 0xf0);\n  FUN_100cd820(param_1);\n  iVar2 = *(int *)(param_1 + 0x144);\n  if (iVar2 != 0) {\n    iVar3 = *(int *)(iVar2 + 4);\n    *(undefined4 *)(iVar2 + 4) = 0;\n    if (iVar3 != 0) {\n      *(int *)(param_1 + 0x40) = *(int *)(param_1 + 0x40) + 4000;\n      (*DAT_102c2c68)(0x3554,DAT_102c2c6c,iVar3);\n    }\n  }\n  iVar2 = *(int *)(param_1 + 0x144);\n  if (iVar2 != 0) {\n    puVar4 = *(undefined4 **)(iVar2 + 0xc);\n    *(undefined4 *)(iVar2 + 0xc) = 0;\n    while (puVar4 != (undefined4 *)0x0) {\n      puVar5 = (undefined4 *)*puVar4;\n      (*DAT_102c2c68)(0x35e4,DAT_102c2c6c,puVar4);\n      puVar4 = puVar5;\n    }\n  }\n  iVar2 = *(int *)(param_1 + 0x144);\n  if (iVar2 != 0) {\n    puVar4 = *(undefined4 **)(iVar2 + 0x24);\n    *(undefined4 *)(iVar2 + 0x24) = 0;\n    while (puVar4 != (undefined4 *)0x0) {\n      puVar5 = (undefined4 *)*puVar4;\n      (*DAT_102c2c68)(0x35e4,DAT_102c2c6c,puVar4);\n      puVar4 = puVar5;\n    }\n  }\n  FUN_10195780(param_1);\n  iVar2 = *(int *)(param_1 + 0x144);\n  if (iVar2 != 0) {\n    *(undefined4 *)(param_1 + 0x144) = 0;\n    (*DAT_102c2c68)(0x3954,DAT_102c2c6c,iVar2);\n  }\n  FUN_100c4730((undefined4 *)(param_1 + 0x120));\n  FUN_100c4630(*(undefined4 *)(param_1 + 0x130));\n  *(undefined4 *)(param_1 + 0x120) = 0x8deffacd;\n  if (*(int *)(param_1 + 0x50) != param_1 + 0x54) {\n    (*DAT_102c2c68)(0x3454,DAT_102c2c6c,*(int *)(param_1 + 0x50));\n  }\n  FUN_10138140(param_1);\n  if (*(int *)(param_1 + 0x118) != 0) {\n    (*DAT_102c2c88)(0x5e56,DAT_102c2c8c,*(int *)(param_1 + 0x118));\n  }\n  FUN_100d4710(param_1);\n  *(undefined4 *)(param_1 + 0x3c) = 0x3b;\n  if (iVar1 != 0) {\n    FUN_10035230(iVar1);\n  }\n  return;\n}\n\n Revised code:\nstatic void\ndelete_process(Process* p)\n{\n    ErtsPSD *psd;\n    struct saved_calls *scb;\n    process_breakpoint_trace_t *pbt;\n    Uint32 block_rla_ref = (Uint32) (Uint) p->u.terminate;\n\n    VERBOSE(DEBUG_PROCESSES, (\"Removing process: %T\\n\",p->common.id));\n    VERBOSE(DEBUG_SHCOPY, (\"[pid=%T] delete process: %p %p %p %p\\n\", p->common.id,\n                           HEAP_START(p), HEAP_END(p), OLD_HEAP(p), OLD_HEND(p)));\n\n    /* free all pending messages */\n    erts_proc_sig_cleanup_queues(p);\n\n    scb = ERTS_PROC_SET_SAVED_CALLS_BUF(p, NULL);\n\n    if (scb) {\n#ifndef BEAMASM\n\tp->fcalls += CONTEXT_REDS; /* Reduction counting depends on this... */\n#endif\n\n        erts_free(ERTS_ALC_T_CALLS_BUF, (void *) scb);\n    }\n\n    pbt = ERTS_PROC_SET_CALL_TIME(p, NULL);\n    if (pbt)\n        erts_free(ERTS_ALC_T_BPD, (void *) pbt);\n    pbt = ERTS_PROC_SET_CALL_MEMORY(p, NULL);\n    if (pbt)\n        erts_free(ERTS_ALC_T_BPD, (void *) pbt);\n\n    erts_destroy_nfunc(p);\n\n    /* Cleanup psd */\n\n    psd = (ErtsPSD *) erts_atomic_read_nob(&p->psd);\n\n    if (psd) {\n\terts_atomic_set_nob(&p->psd, (erts_aint_t) NULL); /* Reduction counting depends on this... */\n\terts_free(ERTS_ALC_T_PSD, psd);\n    }\n\n    /* Clean binaries and funs */\n    erts_cleanup_offheap(&p->off_heap);\n    erts_cleanup_offheap_list(p->wrt_bins);\n\n    /*\n     * The mso list should not be used anymore, but if it is, make sure that\n     * we'll notice.\n     */\n    p->off_heap.first = (void*)(UWord)0x8DEFFACD;\n\n    if (p->arg_reg != p->def_arg_reg) {\n\terts_free(ERTS_ALC_T_ARG_REG, p->arg_reg);\n    }\n\n    /*\n     * Release heaps. Clobber contents in DEBUG build.\n     */\n\n    erts_deallocate_young_generation(p);\n\n    if (p->old_heap != NULL) {\n\n#ifdef DEBUG\n\tsys_memset(p->old_heap, DEBUG_BAD_BYTE,\n                   (p->old_hend-p->old_heap)*sizeof(Eterm));\n#endif\n\tERTS_HEAP_FREE(ERTS_ALC_T_OLD_HEAP,\n\t\t       p->old_heap,\n\t\t       (p->old_hend-p->old_heap)*sizeof(Eterm));\n    }\n\n    erts_erase_dicts(p);\n\n    p->fvalue = NIL;\n\n    if (block_rla_ref)\n        erts_unblock_release_literal_area(block_rla_ref);\n}\n\n## Example:\n\n Input code:\nvoid FUN_10066e88(undefined4 param_1,int param_2)\n{\n  int *piVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  int iVar5;\n  piVar1 = *(int **)(param_2 + 0x10);\n  iVar5 = *(int *)(param_2 + 0xc);\n  if (*piVar1 == 0) {\n    iVar2 = piVar1[1];\n    if (_DAT_102184fc == 0) {\n      iVar3 = *(int *)(param_2 + 4);\n    }\n    else {\n      iVar3 = *(int *)(param_2 + 0x20) * 0xf8 + _DAT_100ea2a8 + 0xd;\n    }\n  }\n  else {\n    iVar2 = piVar1[1];\n    iVar3 = *(int *)(*piVar1 + 4);\n  }\n  FUN_10004bf8(iVar5 + 0x200,iVar2,iVar3);\n  FUN_10027d10(param_1);\n  iVar5 = FUN_10030334(6,0x1f7,iVar5);\n  puVar4 = *(undefined4 **)(param_2 + 0x30);\n  *(int *)(iVar5 + 0x30) = param_2;\n  *puVar4 = 0x1f7;\n  *(undefined4 *)(iVar5 + 0x18) = 0x6e;\n  *(code **)(iVar5 + 0x2c) = FUN_10065ec0;\n  FUN_1002ffe4(*(undefined4 *)(param_2 + 0x14),iVar5);\n  return;\n}\n\n Revised code:\nstatic void\nsslConnectTimeout(int fd, void *data)\n{\n    SslStateData *sslState = data;\n    request_t *request = sslState->request;\n    ErrorState *err = NULL;\n    if (sslState->servers->peer)\n\thierarchyNote(&sslState->request->hier, sslState->servers->code,\n\t    sslState->servers->peer->host);\n    else if (Config.onoff.log_ip_on_direct)\n\thierarchyNote(&sslState->request->hier, sslState->servers->code,\n\t    fd_table[sslState->server.fd].ipaddr);\n    else\n\thierarchyNote(&sslState->request->hier, sslState->servers->code,\n\t    sslState->host);\n    comm_close(fd);\n    err = errorCon(ERR_CONNECT_FAIL, HTTP_SERVICE_UNAVAILABLE, request);\n    *sslState->status_ptr = HTTP_SERVICE_UNAVAILABLE;\n    err->xerrno = ETIMEDOUT;\n    err->callback = sslErrorComplete;\n    err->callback_data = sslState;\n    errorSend(sslState->client.fd, err);\n}\n\n## Example:\n\n Input code:\nvoid FUN_001a1070(long param_1)\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  int iVar4;\n  undefined8 *puVar5;\n  undefined8 uVar6;\n  undefined8 *puVar7;\n  int iVar8;\n  iVar4 = *(int *)(param_1 + 0x120) + -1;\n  *(int *)(param_1 + 0x120) = iVar4;\n  if (iVar4 == 10) {\n    FUN_002503f0(param_1,0x3e,0);\n    iVar4 = *(int *)(param_1 + 0x30);\n    iVar1 = *(int *)(param_1 + 0x2c);\n    iVar2 = *(int *)(param_1 + 0xa0);\n    iVar8 = 0x100;\n    if (*(int *)(param_1 + 0x1c) == -1) {\n      iVar8 = -0x100;\n    }\n    puVar5 = (undefined8 *)operator_new(0x120);\n    uVar3 = *(undefined4 *)(param_1 + 0x1c);\n    FUN_001bef10(puVar5,*(undefined8 *)(param_1 + 0x88),0,iVar8 + (iVar4 - iVar1) / 2 + iVar2,\n                 (*(int *)(param_1 + 0x38) - *(int *)(param_1 + 0x34)) / 2 +\n                 *(int *)(param_1 + 0xa4) + -0x100,0);\n    *(undefined *)(puVar5 + 0x23) = 0;\n    *puVar5 = &PTR_FUN_00487bb0;\n    puVar5[0x22] = 0x42c80000;\n    FUN_001bf150(puVar5,0x3818,0);\n    *(undefined4 *)((long)puVar5 + 0x1c) = uVar3;\n    *(undefined4 *)(puVar5 + 4) = 0;\n    uVar6 = FUN_00169f90();\n    puVar7 = (undefined8 *)operator_new(0x10);\n    *puVar7 = &PTR_FUN_00485328;\n    puVar7[1] = puVar5;\n    FUN_0027d550(uVar6);\n    iVar4 = *(int *)(param_1 + 0x120);\n  }\n  if (0 < iVar4) {\n    return;\n  }\n  *(undefined4 *)(param_1 + 0x120) = 0x3c;\n  FUN_001bdf50(param_1,0);\n  *(undefined8 *)(param_1 + 0x118) = 0;\n  *(code **)(param_1 + 0x110) = FUN_0019ff50;\n  return;\n}\n\n Revised code:\nvoid CDevilSprite::processShoot()\n{\n\tm_timer--;\n\n\tif( m_timer == SPRITE_SHOOT_DELAY/2 )\n\t{\n        playSound(GameSound::SPRITE_SHOT);\n\t\tint x_coord = getXMidPos();\n\t\tx_coord += (xDirection == LEFT) ? -(8<<STC) : +(8<<STC);\n\t\tCEnemyShot *Spark = new CEnemyShot(mpMap, 0, x_coord, getYMidPos()-(8<<STC),\n                                            0x3818, xDirection, 0,  100, 0);\n\t\tgEventManager.add( new EventSpawnObject( Spark ) );\n\t}\n\n\tif( m_timer <= 0 )\n\t{\n\t\tm_timer = SPRITE_MOVE_DELAY;\n\t\tsetAction(A_SPRITE_MOVE);\n\t\tmp_processState = &CDevilSprite::processMove;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_10011df0(int param_1)\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined4 uVar5;\n  char *__src;\n  iVar1 = param_1 * 0x188;\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc + 0x184);\n  uVar5 = *(undefined4 *)(iVar3 + 0x18);\n  *(undefined4 *)(iVar1 + _DAT_10077ffc + 4) = *(undefined4 *)(iVar3 + 0x14);\n  __src = *(char **)(iVar3 + 0x10);\n  FUN_10027460(param_1,&PTR_s_FORK_BOT_10075e48,0x9c);\n  iVar3 = iVar1 + _DAT_10077ffc;\n  *(undefined4 *)(iVar3 + 0x17c) = _DAT_100780c4;\n  strcpy((char *)(*(int *)(iVar3 + 0x184) + 0x79),__src);\n  iVar3 = _DAT_10077ffc;\n  iVar2 = iVar1 + _DAT_10077ffc;\n  puVar4 = *(undefined4 **)(iVar2 + 0x184);\n  puVar4[2] = 0x76652062;\n  puVar4[3] = 0x6f742900;\n  puVar4[1] = 0x6d697469;\n  *puVar4 = 0x28707269;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x90) = uVar5;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x94) = *(undefined4 *)(iVar2 + 8);\n  uVar5 = FUN_10039320(0x20);\n  *(undefined4 *)(iVar1 + iVar3) = uVar5;\n  FUN_100319f0(__src,\"botnet.c\",0x42b);\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc);\n  if (-1 < iVar3) {\n    uVar5 = FUN_10038c20(*(undefined4 *)(iVar1 + _DAT_10077ffc + 4));\n    iVar1 = FUN_1003a5d0(iVar3,uVar5,*(undefined4 *)(iVar1 + _DAT_10077ffc + 8));\n    if (-1 < iVar1) {\n      return;\n    }\n  }\n  FUN_10024db0(param_1);\n  return;\n}",
        "output": "```c\nvoid initializeBot(int botIndex)\n{\n    int botOffset = botIndex * 0x188;\n    int botData = *(int *)(botOffset + _DAT_10077ffc + 0x184);\n    undefined4 botValue = *(undefined4 *)(botData + 0x18);\n    *(undefined4 *)(botOffset + _DAT_10077ffc + 4) = *(undefined4 *)(botData + 0x14);\n    char *botName = *(char **)(botData + 0x10);\n\n    setupBot(botIndex, &PTR_s_FORK_BOT_10075e48, 0x9c);\n\n    int botBase = botOffset + _DAT_10077ffc;\n    *(undefined4 *)(botBase + 0x17c) = _DAT_100780c4;\n    strcpy((char *)(*(int *)(botBase + 0x184) + 0x79), botName);\n\n    undefined4 *botAttributes = *(undefined4 **)(botBase + 0x184);\n    botAttributes[0] = 0x28707269; // \"rip(\"\n    botAttributes[1] = 0x6d697469; // \"itim\"\n    botAttributes[2] = 0x76652062; // \"e b\"\n    botAttributes[3] = 0x6f742900; // \"ot)\"\n\n    *(undefined4 *)(*(int *)(botBase + 0x184) + 0x90) = botValue;\n    *(undefined4 *)(*(int *)(botBase + 0x184) + 0x94) = *(undefined4 *)(botBase + 8);\n\n    undefined4 botID = allocateMemory(0x20);\n    *(undefined4 *)(botOffset + _DAT_10077ffc) = botID;\n\n    logBotInitialization(botName, \"botnet.c\", 0x42b);\n\n    int botHandle = *(int *)(botOffset + _DAT_10077ffc);\n    if (botHandle >= 0) {\n        undefined4 botConfig = getBotConfig(*(undefined4 *)(botOffset + _DAT_10077ffc + 4));\n        int result = configureBot(botHandle, botConfig, *(undefined4 *)(botOffset + _DAT_10077ffc + 8));\n        if (result >= 0) {\n            return;\n        }\n    }\n\n    cleanupBot(botIndex);\n}\n```",
        "source_code": "static void botlink_resolve_success(int i)\n{\n  int idx = dcc[i].u.dns->ibuf;\n  char *linker = dcc[i].u.dns->cptr;\n\n  dcc[i].addr = dcc[i].u.dns->ip;\n  changeover_dcc(i, &DCC_FORK_BOT, sizeof(struct bot_info));\n  dcc[i].timeval = now;\n  strcpy(dcc[i].u.bot->linker, linker);\n  strcpy(dcc[i].u.bot->version, \"(primitive bot)\");\n  dcc[i].u.bot->numver = idx;\n  dcc[i].u.bot->port = dcc[i].port;     /* Remember where i started */\n  dcc[i].sock = getsock(SOCK_STRONGCONN);\n  nfree(linker);\n  if (dcc[i].sock < 0 ||\n      open_telnet_raw(dcc[i].sock, iptostr(htonl(dcc[i].addr)),\n                      dcc[i].port) < 0)\n    failed_link(i);\n}",
        "parsed_output": "void initializeBot(int botIndex)\n{\n    int botOffset = botIndex * 0x188;\n    int botData = *(int *)(botOffset + _DAT_10077ffc + 0x184);\n    undefined4 botValue = *(undefined4 *)(botData + 0x18);\n    *(undefined4 *)(botOffset + _DAT_10077ffc + 4) = *(undefined4 *)(botData + 0x14);\n    char *botName = *(char **)(botData + 0x10);\n\n    setupBot(botIndex, &PTR_s_FORK_BOT_10075e48, 0x9c);\n\n    int botBase = botOffset + _DAT_10077ffc;\n    *(undefined4 *)(botBase + 0x17c) = _DAT_100780c4;\n    strcpy((char *)(*(int *)(botBase + 0x184) + 0x79), botName);\n\n    undefined4 *botAttributes = *(undefined4 **)(botBase + 0x184);\n    botAttributes[0] = 0x28707269; // \"rip(\"\n    botAttributes[1] = 0x6d697469; // \"itim\"\n    botAttributes[2] = 0x76652062; // \"e b\"\n    botAttributes[3] = 0x6f742900; // \"ot)\"\n\n    *(undefined4 *)(*(int *)(botBase + 0x184) + 0x90) = botValue;\n    *(undefined4 *)(*(int *)(botBase + 0x184) + 0x94) = *(undefined4 *)(botBase + 8);\n\n    undefined4 botID = allocateMemory(0x20);\n    *(undefined4 *)(botOffset + _DAT_10077ffc) = botID;\n\n    logBotInitialization(botName, \"botnet.c\", 0x42b);\n\n    int botHandle = *(int *)(botOffset + _DAT_10077ffc);\n    if (botHandle >= 0) {\n        undefined4 botConfig = getBotConfig(*(undefined4 *)(botOffset + _DAT_10077ffc + 4));\n        int result = configureBot(botHandle, botConfig, *(undefined4 *)(botOffset + _DAT_10077ffc + 8));\n        if (result >= 0) {\n            return;\n        }\n    }\n\n    cleanupBot(botIndex);\n}",
        "baseline_code_stripped": "void FUN_10011df0(int param_1)\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined4 uVar5;\n  char *__src;\n  iVar1 = param_1 * 0x188;\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc + 0x184);\n  uVar5 = *(undefined4 *)(iVar3 + 0x18);\n  *(undefined4 *)(iVar1 + _DAT_10077ffc + 4) = *(undefined4 *)(iVar3 + 0x14);\n  __src = *(char **)(iVar3 + 0x10);\n  FUN_10027460(param_1,&PTR_s_FORK_BOT_10075e48,0x9c);\n  iVar3 = iVar1 + _DAT_10077ffc;\n  *(undefined4 *)(iVar3 + 0x17c) = _DAT_100780c4;\n  strcpy((char *)(*(int *)(iVar3 + 0x184) + 0x79),__src);\n  iVar3 = _DAT_10077ffc;\n  iVar2 = iVar1 + _DAT_10077ffc;\n  puVar4 = *(undefined4 **)(iVar2 + 0x184);\n  puVar4[2] = 0x76652062;\n  puVar4[3] = 0x6f742900;\n  puVar4[1] = 0x6d697469;\n  *puVar4 = 0x28707269;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x90) = uVar5;\n  *(undefined4 *)(*(int *)(iVar2 + 0x184) + 0x94) = *(undefined4 *)(iVar2 + 8);\n  uVar5 = FUN_10039320(0x20);\n  *(undefined4 *)(iVar1 + iVar3) = uVar5;\n  FUN_100319f0(__src,\"botnet.c\",0x42b);\n  iVar3 = *(int *)(iVar1 + _DAT_10077ffc);\n  if (-1 < iVar3) {\n    uVar5 = FUN_10038c20(*(undefined4 *)(iVar1 + _DAT_10077ffc + 4));\n    iVar1 = FUN_1003a5d0(iVar3,uVar5,*(undefined4 *)(iVar1 + _DAT_10077ffc + 8));\n    if (-1 < iVar1) {\n      return;\n    }\n  }\n  FUN_10024db0(param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.5784487724304199,
        "similarity_score_baseline_stripped": 0.4765426218509674
    },
    {
        "func_name": "truncate64",
        "normed_func_sha256": "ef59824173e1837ee91fe70d42957dccc71cf4f253c65ae334e63dda8115f708",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nulong FUN_005318e0(void)\n{\n  ulong uVar1;\n  long in_x3;\n  uVar1 = (**(code **)**(undefined8 **)(*(long *)(in_x3 + 8) + 0x28))();\n  if (uVar1 < 0x20000000) {\n    return uVar1 << 2 | 1;\n  }\n  uVar1 = KJS::jsNumberCell((double)(unkuint9)uVar1);\n  return uVar1;\n}\n\n Revised code:\nJSValue *HTMLCollection::lengthGetter(ExecState *, JSObject *, const Identifier &, const PropertySlot &slot)\n{\n    HTMLCollection *thisObj = static_cast<HTMLCollection *>(slot.slotBase());\n    return jsNumber(thisObj->m_impl->length());\n}\n\n## Example:\n\n Input code:\nulong FUN_00633820(void)\n{\n  ulong uVar1;\n  long in_FS_OFFSET;\n  uint local_14;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = (*(code *)PTR_FUN_00a7ba80)(&local_14,0,0);\n  if (uVar1 == 0) {\n    uVar1 = (ulong)local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar1;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nABSL_ATTRIBUTE_NO_SANITIZE_MEMORY\nint GetCPU() {\n  unsigned cpu;\n  long ret_code =  // NOLINT(runtime/int)\n      (*VDSOSupport::getcpu_fn_)(&cpu, nullptr, nullptr);\n  return ret_code == 0 ? static_cast<int>(cpu) : static_cast<int>(ret_code);\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_01ef29d0(void)\n{\n  undefined8 uVar1;\n  ulonglong in_r7;\n  longlong in_r12;\n  longlong in_r13;\n  if (in_r7 < 0xb) {\n    uVar1 = (*(code *)((longlong)*(int *)(in_r12 + 0x6c) + (longlong)(int *)(in_r12 + 0x6c)))();\n    return uVar1;\n  }\n  if (*(longlong *)(in_r13 + -0x7010) == *(longlong *)(in_r13 + -0x7010)) {\n    return 0;\n  }\n  FUN_010b0be0();\n}\n\n Revised code:\nint yaksuri_seqi_unpack_blkhindx_resized_double(const void *inbuf, void *outbuf, uintptr_t count, yaksi_type_s * type, yaksa_op_t op)\n{\n    int rc = YAKSA_SUCCESS;\n    const char *restrict sbuf = (const char *) inbuf;\n    char *restrict dbuf = (char *) outbuf;\n    uintptr_t extent ATTRIBUTE((unused)) = type->extent;\n    \n    intptr_t count1 = type->u.blkhindx.count;\n    intptr_t blocklength1 ATTRIBUTE((unused)) = type->u.blkhindx.blocklength;\n    intptr_t *restrict array_of_displs1 = type->u.blkhindx.array_of_displs;\n    uintptr_t extent1 ATTRIBUTE((unused)) = type->extent;\n    \n    uintptr_t extent2 ATTRIBUTE((unused)) = type->u.blkhindx.child->extent;\n    \n    uintptr_t idx = 0;\n    switch (op) {\n        case YAKSA_OP__PROD:\n        {\n            for (intptr_t i = 0; i < count; i++) {\n                for (intptr_t j1 = 0; j1 < count1; j1++) {\n                    for (intptr_t k1 = 0; k1 < blocklength1; k1++) {\n                        YAKSURI_SEQI_OP_PROD(*((const double *) (const void *) (sbuf + idx)), *((double *) (void *) (dbuf + i * extent + array_of_displs1[j1] + k1 * extent2)));\n                        idx += sizeof(double);\n                    }\n                }\n            }\n            break;\n        }\n        \n        case YAKSA_OP__SUM:\n        {\n            for (intptr_t i = 0; i < count; i++) {\n                for (intptr_t j1 = 0; j1 < count1; j1++) {\n                    for (intptr_t k1 = 0; k1 < blocklength1; k1++) {\n                        YAKSURI_SEQI_OP_SUM(*((const double *) (const void *) (sbuf + idx)), *((double *) (void *) (dbuf + i * extent + array_of_displs1[j1] + k1 * extent2)));\n                        idx += sizeof(double);\n                    }\n                }\n            }\n            break;\n        }\n        \n        case YAKSA_OP__MIN:\n        {\n            for (intptr_t i = 0; i < count; i++) {\n                for (intptr_t j1 = 0; j1 < count1; j1++) {\n                    for (intptr_t k1 = 0; k1 < blocklength1; k1++) {\n                        YAKSURI_SEQI_OP_MIN_FLOAT(double, *((const double *) (const void *) (sbuf + idx)), *((double *) (void *) (dbuf + i * extent + array_of_displs1[j1] + k1 * extent2)));\n                        idx += sizeof(double);\n                    }\n                }\n            }\n            break;\n        }\n        \n        case YAKSA_OP__MAX:\n        {\n            for (intptr_t i = 0; i < count; i++) {\n                for (intptr_t j1 = 0; j1 < count1; j1++) {\n                    for (intptr_t k1 = 0; k1 < blocklength1; k1++) {\n                        YAKSURI_SEQI_OP_MAX_FLOAT(double, *((const double *) (const void *) (sbuf + idx)), *((double *) (void *) (dbuf + i * extent + array_of_displs1[j1] + k1 * extent2)));\n                        idx += sizeof(double);\n                    }\n                }\n            }\n            break;\n        }\n        \n        case YAKSA_OP__REPLACE:\n        {\n            for (intptr_t i = 0; i < count; i++) {\n                for (intptr_t j1 = 0; j1 < count1; j1++) {\n                    for (intptr_t k1 = 0; k1 < blocklength1; k1++) {\n                        YAKSURI_SEQI_OP_REPLACE(*((const double *) (const void *) (sbuf + idx)), *((double *) (void *) (dbuf + i * extent + array_of_displs1[j1] + k1 * extent2)));\n                        idx += sizeof(double);\n                    }\n                }\n            }\n            break;\n        }\n        \n        default:\n            break;\n    }\n    \n    return rc;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint truncate64(char *__file,__off64_t __length)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  uVar1 = (**(code **)(in_GS_OFFSET + 0x10))();\n  if (0xfffff000 < uVar1) {\n    *(uint *)((undefined *)0x8 + in_GS_OFFSET) = -uVar1;\n    uVar1 = 0xffffffff;\n  }\n  return uVar1;\n}",
        "output": "int truncate64(const char *file, off64_t length) {\n    unsigned int result;\n    int gs_offset;\n    \n    result = (*reinterpret_cast<unsigned int (*)(void)>(*(void **)(gs_offset + 0x10)))();\n    \n    if (result > 0xfffff000) {\n        *reinterpret_cast<unsigned int *>(reinterpret_cast<char *>(gs_offset) + 0x8) = -static_cast<int>(result);\n        result = 0xffffffff;\n    }\n    \n    return static_cast<int>(result);\n}",
        "source_code": "int\ntruncate64 (const char *path, off64_t length)\n{\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n  if (! __have_no_truncate64)\n#endif\n    {\n      unsigned int low = length & 0xffffffff;\n      unsigned int high = length >> 32;\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n      int saved_errno = errno;\n#endif\n      int result = INLINE_SYSCALL (truncate64, 3, CHECK_STRING (path),\n\t\t\t\t   __LONG_LONG_PAIR (high, low));\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n      if (result != -1 || errno != ENOSYS)\n#endif\n\treturn result;\n\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n      __set_errno (saved_errno);\n      __have_no_truncate64 = 1;\n#endif\n    }\n\n#ifndef __ASSUME_TRUNCATE64_SYSCALL\n  if ((off_t) length != length)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  return __truncate (path, (off_t) length);\n#endif\n}",
        "parsed_output": "int truncate64(const char *file, off64_t length) {\n    unsigned int result;\n    int gs_offset;\n    \n    result = (*reinterpret_cast<unsigned int (*)(void)>(*(void **)(gs_offset + 0x10)))();\n    \n    if (result > 0xfffff000) {\n        *reinterpret_cast<unsigned int *>(reinterpret_cast<char *>(gs_offset) + 0x8) = -static_cast<int>(result);\n        result = 0xffffffff;\n    }\n    \n    return static_cast<int>(result);\n}",
        "baseline_code_stripped": "int truncate64(char *__file,__off64_t __length)\n{\n  uint uVar1;\n  int in_GS_OFFSET;\n  uVar1 = (**(code **)(in_GS_OFFSET + 0x10))();\n  if (0xfffff000 < uVar1) {\n    *(uint *)((undefined *)0x8 + in_GS_OFFSET) = -uVar1;\n    uVar1 = 0xffffffff;\n  }\n  return uVar1;\n}",
        "similarity_score_unixcoder": 0.6287442445755005,
        "similarity_score_baseline_stripped": 0.6443058848381042
    },
    {
        "func_name": "ByteString_CreateFromInt32",
        "normed_func_sha256": "7d289aa6ea103094a0f31a150ef7fafefe5fa908bfa7516227bace0055418cd4",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nulong Java_org_sbml_libsbml_libsbmlJNI_DefaultValues_1setTextAnchor_1_1SWIG_12\n                (long *param_1,undefined8 param_2,DefaultValues *param_3,undefined8 param_4,\n                long param_5)\n{\n  size_t sVar1;\n  char *__s;\n  ulong uVar2;\n  undefined8 *puVar3;\n  long in_FS_OFFSET;\n  size_t local_70;\n  undefined8 *local_68;\n  size_t local_60;\n  undefined8 local_58;\n  long local_40;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_5 == 0) {\n    FUN_0059c610(param_1,7,\"null string\");\n    uVar2 = 0;\n    goto LAB_0060cbd7;\n  }\n  __s = (char *)(**(code **)(*param_1 + 0x548))(param_1,param_5,0);\n  if (__s == (char *)0x0) {\n    uVar2 = 0;\n    goto LAB_0060cbd7;\n  }\n  local_68 = &local_58;\n  local_60 = strlen(__s);\n  local_70 = local_60;\n  if (local_60 < 0x10) {\n    puVar3 = &local_58;\n    if (local_60 == 1) {\n      local_58 = CONCAT71(local_58._1_7_,*__s);\n    }\n    else if (local_60 != 0) goto LAB_0060cc2b;\n  }\n  else {\n    local_68 = (undefined8 *)\n               std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::\n               _M_create((basic_string_char_std__char_traits_char__std__allocator_char__ *)&local_68\n                         ,&local_70,0);\n    local_58 = local_70;\n    puVar3 = local_68;\nLAB_0060cc2b:\n    sVar1 = local_70;\n    memcpy(puVar3,__s,local_60);\n    local_60 = sVar1;\n    puVar3 = local_68;\n  }\n  *(undefined *)((long)puVar3 + local_60) = 0;\n  (**(code **)(*param_1 + 0x550))(param_1,param_5,__s);\n  uVar2 = DefaultValues::setTextAnchor(param_3,(basic_string *)&local_68);\n  if (local_68 != &local_58) {\n    operator_delete(local_68);\n    uVar2 = uVar2 & 0xffffffff;\n  }\nLAB_0060cbd7:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n Revised code:\nSWIGEXPORT jint JNICALL Java_org_sbml_libsbml_libsbmlJNI_DefaultValues_1setTextAnchor_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {\n  jint jresult = 0 ;\n  DefaultValues *arg1 = (DefaultValues *) 0 ;\n  std::string *arg2 = 0 ;\n  int result;\n  \n  (void)jenv;\n  (void)jcls;\n  (void)jarg1_;\n  arg1 = *(DefaultValues **)&jarg1; \n  if(!jarg2) {\n    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, \"null string\");\n    return 0;\n  }\n  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); \n  if (!arg2_pstr) return 0;\n  std::string arg2_str(arg2_pstr);\n  arg2 = &arg2_str;\n  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); \n  result = (int)(arg1)->setTextAnchor((std::string const &)*arg2);\n  jresult = (jint)result; \n  return jresult;\n}\n\n## Example:\n\n Input code:\nulong FUN_00d95146(long param_1,long *param_2,ushort *param_3,undefined8 param_4)\n{\n  code *pcVar1;\n  uint uVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_98 [4];\n  char local_78 [72];\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*param_3 == 0x47) {\n    uVar3 = (**(code **)(*param_2 + 0x18))\n                      (param_2,*(undefined4 *)(param_1 + 0x8c),*(undefined8 *)(param_1 + 0x80));\n  }\n  else if ((*param_3 == 0x5f) && (param_3[1] == 0x50)) {\n    uVar3 = (**(code **)(*param_2 + 0xd0))(param_2,1,param_4);\n  }\n  else {\n    pcVar1 = *(code **)(*param_2 + 0x30);\n    nsFixedCString::nsFixedCString((nsFixedCString *)local_98,local_78,0x40,0);\n    AppendUTF16toUTF8(param_3,(nsACString_internal *)local_98);\n    uVar2 = (*pcVar1)(param_2,local_98[0],param_4);\n    nsACString_internal::_nsACString_internal((nsACString_internal *)local_98);\n    uVar3 = (ulong)uVar2;\n    if (uVar2 == 0x80040111) {\n      nsAString_internal::SetLength((uint)param_4);\n      uVar3 = 0;\n    }\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n Revised code:\nnsresult nsAbView::GetCardValue(nsIAbCard *card, const PRUnichar *colID,\n                                nsAString &_retval)\n{\n  // \"G\" == \"GeneratedName\", \"_P\" == \"_PhoneticName\"\n  // else, standard column (like PrimaryEmail and _AimScreenName)\n  if (colID[0] == PRUnichar('G'))\n    return card->GenerateName(mGeneratedNameFormat, mABBundle, _retval);\n\n  if (colID[0] == PRUnichar('_') && colID[1] == PRUnichar('P'))\n    // Use LN/FN order for the phonetic name\n    return card->GeneratePhoneticName(PR_TRUE, _retval);\n\n  nsresult rv = card->GetPropertyAsAString(NS_ConvertUTF16toUTF8(colID).get(), _retval);\n  if (rv == NS_ERROR_NOT_AVAILABLE) {\n    rv = NS_OK;\n    _retval.Truncate();\n  }\n  return rv;\n}\n\n## Example:\n\n Input code:\nint per_read_integer(int *param_1,uint *param_2)\n{\n  byte *pbVar1;\n  int iVar2;\n  uint uVar3;\n  int in_GS_OFFSET;\n  ushort local_12;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  iVar2 = per_read_length(param_1,&local_12);\n  if (iVar2 != 0) {\n    pbVar1 = (byte *)param_1[1];\n    uVar3 = (uint)local_12;\n    if ((uint)(param_1[2] - ((int)pbVar1 - *param_1)) < uVar3) {\n      iVar2 = 0;\n    }\n    else if (uVar3 == 0) {\n      *param_2 = 0;\n      iVar2 = 1;\n    }\n    else if (uVar3 == 1) {\n      *param_2 = (uint)*pbVar1;\n      iVar2 = 1;\n      param_1[1] = (int)(pbVar1 + 1);\n    }\n    else {\n      iVar2 = 0;\n      if (uVar3 == 2) {\n        *param_2 = (uint)*pbVar1 * 0x100 + (uint)pbVar1[1];\n        iVar2 = 1;\n        param_1[1] = (int)(pbVar1 + 2);\n      }\n    }\n  }\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return iVar2;\n  }\n  FUN_00117f30();\n}\n\n Revised code:\nBOOL per_read_integer(STREAM* s, UINT32* integer)\n{\n\tUINT16 length;\n\tif (!per_read_length(s, &length))\n\t\treturn FALSE;\n\tif (stream_get_left(s) < length)\n\t\treturn FALSE;\n\tif (length == 1)\n\t\tstream_read_BYTE(s, *integer);\n\telse if (length == 2)\n\t\tstream_read_UINT16_be(s, *integer);\n\telse\n\t\treturn FALSE;\n\treturn TRUE;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nbinfilter * __thiscall\nbinfilter::ByteString_CreateFromInt32(binfilter *this,long param_1,short param_2)\n{\n  ushort uVar1;\n  int in_GS_OFFSET;\n  char local_31 [33];\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar1 = rtl_str_valueOfInt32(local_31,param_1,(int)param_2);\n  ByteString::ByteString((ByteString *)this,local_31,uVar1);\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return this;\n  }\n  FUN_0019b1f0();\n}",
        "output": "binfilter* binfilter::ByteString_CreateFromInt32(binfilter* this, int32_t value, int16_t radix) {\n    char buffer[33];\n    uint16_t length = rtl_str_valueOfInt32(buffer, value, static_cast<int>(radix));\n    ByteString::ByteString(reinterpret_cast<ByteString*>(this), buffer, length);\n    return this;\n}",
        "source_code": "ByteString ByteString_CreateFromInt32(sal_Int32 n, sal_Int16 nRadix)\n    {\n        sal_Char aBuf[RTL_STR_MAX_VALUEOFINT32];\n        BOOST_STATIC_ASSERT(RTL_STR_MAX_VALUEOFINT32 <= STRING_MAXLEN);\n        return ByteString(\n            aBuf,\n            static_cast< xub_StrLen >(rtl_str_valueOfInt32( aBuf, n, nRadix )) );\n    }",
        "parsed_output": "binfilter* binfilter::ByteString_CreateFromInt32(binfilter* this, int32_t value, int16_t radix) {\n    char buffer[33];\n    uint16_t length = rtl_str_valueOfInt32(buffer, value, static_cast<int>(radix));\n    ByteString::ByteString(reinterpret_cast<ByteString*>(this), buffer, length);\n    return this;\n}",
        "baseline_code_stripped": "binfilter * __thiscall\nbinfilter::ByteString_CreateFromInt32(binfilter *this,long param_1,short param_2)\n{\n  ushort uVar1;\n  int in_GS_OFFSET;\n  char local_31 [33];\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar1 = rtl_str_valueOfInt32(local_31,param_1,(int)param_2);\n  ByteString::ByteString((ByteString *)this,local_31,uVar1);\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return this;\n  }\n  FUN_0019b1f0();\n}",
        "similarity_score_unixcoder": 0.7419131398200989,
        "similarity_score_baseline_stripped": 0.5975655913352966
    },
    {
        "func_name": "save_as_application_proceed",
        "normed_func_sha256": "f14a16a1ca5b344a98cdf047dc65aaa0e72eec918d30dd77d74214e31d86ccfc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_001d22f0(undefined8 param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  longlong in_r13;\n  longlong local_98;\n  int local_38;\n  int local_34;\n  int local_30;\n  longlong local_28;\n  local_28 = *(longlong *)(in_r13 + -0x7010);\n  FUN_00175920(param_1,&local_38);\n  uVar2 = FUN_00178f20(param_1);\n  uVar3 = FUN_00172a00(param_1);\n  uVar4 = FUN_00178260(param_1);\n  FUN_00172ee0(uVar2,param_2,uVar3,uVar4,param_1,0,(longlong)(local_38 + 3),(longlong)(local_34 + 3)\n              );\n  iVar1 = FUN_00174700(param_1);\n  if (iVar1 == 0) {\n    uVar2 = FUN_00178f20(param_1);\n    FUN_00170520(uVar2,param_2,0,1,param_1,local_98 + -0xdba008,(longlong)local_38,\n                 (longlong)local_34);\n  }\n  else {\n    uVar2 = FUN_00178f20(param_1);\n    FUN_001700c0(uVar2,param_2,1,param_1,local_98 + -0xdba008,(longlong)local_38,(longlong)local_34,\n                 (longlong)(local_30 + -1));\n  }\n  if (local_28 == *(longlong *)(in_r13 + -0x7010)) {\n    return 0;\n  }\n  FUN_00177d40();\n}\n\n Revised code:\ngboolean selectable_frame_draw_cb(GtkWidget *widget, cairo_t *cr, gpointer UNUSED(data))\n{\n\tGtkAllocation allocation;\n\tgtk_widget_get_allocation(widget, &allocation);\n\tgtk_paint_flat_box(gtk_widget_get_style(widget),\n\t\t\t   cr,\n\t\t\t   gtk_widget_get_state(widget),\n\t\t\t   gtk_frame_get_shadow_type(GTK_FRAME(widget)),\n\t\t\t   widget,\n\t\t\t   NULL,\n\t\t\t   allocation.x + 3, allocation.y + 3,\n\t\t\t   allocation.width - 6, allocation.height - 6);\n\n\tif (gtk_widget_has_focus(widget))\n\t\t{\n\t\tgtk_paint_focus(gtk_widget_get_style(widget), cr, GTK_STATE_ACTIVE,\n\t\t\t\twidget, \"image_window\",\n\t\t\t\tallocation.x, allocation.y,\n\t\t\t\tallocation.width - 1, allocation.height - 1);\n\t\t}\n\telse\n\t\t{\n\t\tgtk_paint_shadow(gtk_widget_get_style(widget), cr, GTK_STATE_NORMAL, GTK_SHADOW_IN,\n\t\t\t\t widget, \"image_window\",\n\t\t\t\t allocation.x, allocation.y,\n\t\t\t\t allocation.width - 1, allocation.height - 1);\n\t\t}\n\treturn FALSE;\n}\n\n## Example:\n\n Input code:\nvoid FUN_001246a8(longlong param_1,longlong **param_2)\n{\n  longlong lVar1;\n  undefined8 uVar2;\n  longlong in_r13;\n  undefined8 uVar3;\n  longlong local_68;\n  longlong local_20;\n  longlong local_18;\n  local_18 = *(longlong *)(in_r13 + -0x7010);\n  *(undefined *)(param_1 + 0x2e) = 1;\n  local_20 = 0;\n  lVar1 = FUN_00109700();\n  if (param_2 == (longlong **)0x0) {\nLAB_001247e0:\n    uVar2 = FUN_00109d60();\n    uVar2 = FUN_0010b0e0(param_2,uVar2);\n    uVar2 = FUN_0010a360(uVar2,0,&local_20);\n    *(undefined8 *)(param_1 + 0x30) = uVar2;\n  }\n  else {\n    if ((*param_2 == (longlong *)0x0) || (**param_2 != lVar1)) {\n      lVar1 = FUN_0010b1c0(param_2,lVar1);\n      if (lVar1 == 0) goto LAB_001247e0;\n    }\n    uVar2 = FUN_00109700();\n    uVar2 = FUN_0010b0e0(param_2,uVar2);\n    uVar2 = FUN_0010b2e0(uVar2,0,param_1 + 0x40,&local_20);\n    *(undefined8 *)(param_1 + 0x30) = uVar2;\n  }\n  if (*(longlong *)(param_1 + 0x40) != 0) {\n    *(undefined4 *)(param_1 + 0x18) = 1;\n    FUN_001245c8(param_1);\n  }\n  if (*(longlong *)(param_1 + 0x30) == 0) {\n    lVar1 = local_68 + -0x27e88;\n    if (local_20 != 0) {\n      lVar1 = *(longlong *)(local_20 + 8);\n    }\n    FUN_001099e0(**(undefined8 **)(local_68 + -0x7ee0),1,local_68 + -0x27e68,lVar1);\n  }\n  else {\n    FUN_00124638(param_1);\n  }\n  if (local_20 != 0) {\n    FUN_00108a00();\n  }\n  lVar1 = FUN_00129228(*(undefined8 *)(*(longlong *)(param_1 + 0x38) + 0x18),\n                       *(undefined8 *)(param_1 + 0x30));\n  if (lVar1 != 0) {\n    uVar3 = **(undefined8 **)(local_68 + -0x7ee0);\n    uVar2 = FUN_00109b20();\n    FUN_001099e0(uVar3,1,local_68 + -0x27e40,uVar2);\n  }\n  if (local_18 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  FUN_0010a660();\n}\n\n Revised code:\nstatic void\nnode_verify (mime_node_t *node, GMimeObject *part)\n{\n    GError *err = NULL;\n    notmuch_status_t status;\n    node->verify_attempted = true;\n    if (GMIME_IS_APPLICATION_PKCS7_MIME (part))\n\tnode->sig_list = g_mime_application_pkcs7_mime_verify (\n\t    GMIME_APPLICATION_PKCS7_MIME (part), GMIME_VERIFY_NONE, &node->unwrapped_child, &err);\n    else\n\tnode->sig_list = g_mime_multipart_signed_verify (\n\t    GMIME_MULTIPART_SIGNED (part), GMIME_VERIFY_NONE, &err);\n    if (node->unwrapped_child) {\n\tnode->nchildren = 1;\n\tset_unwrapped_child_destructor (node);\n    }\n    if (node->sig_list)\n\tset_signature_list_destructor (node);\n    else\n\tfprintf (stderr, \"Failed to verify signed part: %s\\n\",\n\t\t err ? err->message : \"no error explanation given\");\n    if (err)\n\tg_error_free (err);\n    status = _notmuch_message_crypto_potential_sig_list (node->ctx->msg_crypto, node->sig_list);\n    if (status) \n\tfprintf (stderr, \"Warning: failed to note signature status: %s.\\n\", notmuch_status_to_string (\n\t\t     status));\n}\n\n## Example:\n\n Input code:\nvoid FUN_00295d00(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  longlong in_r13;\n  undefined4 uVar4;\n  longlong local_178;\n  undefined local_129 [257];\n  longlong local_28;\n  local_28 = *(longlong *)(in_r13 + -0x7010);\n  uVar2 = FUN_0014da00();\n  uVar2 = FUN_00144dc0(param_1,uVar2);\n  FUN_00150f60(local_129,0,0x101);\n  local_129[0] = 2;\n  uVar3 = FUN_0014a120();\n  uVar3 = FUN_00144dc0(param_1,uVar3);\n  iVar1 = FUN_00150fc0(uVar3,0x2000);\n  if (iVar1 == 0) {\n    FUN_00148920(local_178 + -0x59ea0,0x80,local_178 + -0x7f6c0);\n  }\n  else {\n    iVar1 = FUN_0014cc40(uVar2,local_129,0x101,param_3);\n    if (iVar1 == 0) {\n      FUN_00149980(param_3,local_178 + -0x59e60);\n      uVar4 = 0;\n      goto LAB_00295dfc;\n    }\n    FUN_00150200(500000);\n    uVar3 = FUN_0014f780();\n    uVar2 = FUN_00144dc0(uVar2,uVar3);\n    FUN_00148980(uVar2,0x2000);\n  }\n  uVar4 = 1;\nLAB_00295dfc:\n  if (local_28 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  FUN_00145e40(uVar4);\n}\n\n Revised code:\nstatic gboolean\nfu_wacom_aes_device_attach(FuDevice *device, FuProgress *progress, GError **error)\n{\n\tFuWacomDevice *self = FU_WACOM_DEVICE(device);\n\tFuWacomRawRequest req = {.report_id = FU_WACOM_RAW_BL_REPORT_ID_TYPE,\n\t\t\t\t .cmd = FU_WACOM_RAW_BL_TYPE_FINALIZER,\n\t\t\t\t 0x00};\n\n\tif (!fu_device_has_flag(device, FWUPD_DEVICE_FLAG_IS_BOOTLOADER)) {\n\t\tg_debug(\"already in runtime mode, skipping\");\n\t\treturn TRUE;\n\t}\n\tif (!fu_wacom_device_set_feature(self, (const guint8 *)&req, sizeof(req), error)) {\n\t\tg_prefix_error(error, \"failed to finalize the device: \");\n\t\treturn FALSE;\n\t}\n\n\t/* wait for device back to runtime mode */\n\tg_usleep(500 * 1000);\n\tfu_device_remove_flag(FU_DEVICE(self), FWUPD_DEVICE_FLAG_IS_BOOTLOADER);\n\treturn TRUE;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_001b07d8(longlong param_1)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 in_r8;\n  longlong in_r13;\n  longlong local_88;\n  longlong local_40;\n  longlong local_38;\n  local_38 = *(longlong *)(in_r13 + -0x7010);\n  local_40 = 0;\n  iVar1 = FUN_00148400(*(undefined8 *)(param_1 + 0x30),*(undefined8 *)(param_1 + 0x10),\n                       *(undefined8 *)(param_1 + 0x38),*(undefined4 *)(param_1 + 0x68),&local_40,\n                       in_r8,0,0);\n  if (iVar1 == 0) {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d48,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(local_40 + 8));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n  }\n  else {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d78,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n    uVar4 = FUN_00152220(0,local_88 + -0x47d10,5);\n    FUN_00143f80(uVar3,uVar4,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30)\n                );\n    FUN_001452c0(uVar3,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30));\n    uVar4 = FUN_00149ec0(*(undefined8 *)(param_1 + 0x30));\n    FUN_0014d740(2,0,local_88 + -0xa76b0,uVar4);\n    FUN_00144ac0(0);\n  }\n  FUN_001459a0(uVar3,1);\n  uVar4 = FUN_001479c0();\n  FUN_001508a0(uVar4,*(undefined8 *)(param_1 + 0x28),uVar3);\n  FUN_001b06a8(param_1);\n  if (local_40 != 0) {\n    FUN_00151b40();\n  }\n  FUN_00144ac0(uVar2);\n  if (local_38 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  FUN_0014f3a0();\n}",
        "output": "```c\nstatic void\nprocess_data(DataContext *ctx)\n{\n    gboolean result;\n    DataHandler *handler;\n    DataProcessor *processor;\n    DataVerifier *verifier;\n    DataLogger *logger;\n\n    result = data_handler_initialize(ctx->input, ctx->config, ctx->output, ctx->flags, &handler);\n    if (!result) {\n        processor = data_processor_create(0, ctx->log_path, 5);\n        processor = data_processor_configure(processor, ctx->settings, handler->extra_data);\n        verifier = data_verifier_create();\n        if (ctx->cache != NULL) {\n            data_cache_clear(ctx->cache);\n        }\n    } else {\n        processor = data_processor_create(0, ctx->log_path_alt, 5);\n        processor = data_processor_configure(processor, ctx->settings);\n        verifier = data_verifier_create();\n        if (ctx->cache != NULL) {\n            data_cache_clear(ctx->cache);\n        }\n        logger = data_logger_create(0, ctx->log_path_error, 5);\n        data_logger_log(logger, verifier, ctx->log_path_error, ctx->log_path_backup, ctx->input);\n        data_logger_finalize(logger, ctx->log_path_error, ctx->log_path_backup, ctx->input);\n        verifier = data_verifier_finalize(ctx->input);\n        data_logger_write(2, 0, ctx->log_path_final, verifier);\n        data_cleanup(0);\n    }\n    data_verifier_process(verifier, TRUE);\n    logger = data_logger_initialize();\n    data_logger_execute(logger, ctx->settings, verifier);\n    data_context_finalize(ctx);\n    if (handler != NULL) {\n        data_handler_cleanup(handler);\n    }\n    data_cleanup(processor);\n    if (ctx->state == ctx->initial_state) {\n        return;\n    }\n    data_error_handler();\n}\n```",
        "source_code": "static void\nsave_as_application_proceed (EphyApplicationDialogData *data)\n{\n  g_autofree char *message = NULL;\n  GNotification *notification;\n  gboolean success;\n  g_autoptr (GError) error = NULL;\n\n  /* Create Web Application, including a new profile and .desktop file. */\n  success = ephy_web_application_create (data->app_id,\n                                         data->url,\n                                         data->token,\n                                         data->webapp_options,\n                                         &error);\n\n  if (success)\n    message = g_strdup_printf (_(\"The application \u201c%s\u201d is ready to be used\"),\n                               data->chosen_name);\n  else\n    message = g_strdup_printf (_(\"The application \u201c%s\u201d could not be created: %s\"),\n                               data->chosen_name, error->message);\n\n  notification = g_notification_new (message);\n\n  if (data->framed_pixbuf)\n    g_notification_set_icon (notification, G_ICON (data->framed_pixbuf));\n\n  if (success) {\n    /* Translators: Desktop notification when a new web app is created. */\n    g_notification_add_button_with_target (notification, _(\"Launch\"), \"app.launch-app\", \"s\", data->app_id);\n    g_notification_set_default_action_and_target (notification, \"app.launch-app\", \"s\", data->app_id);\n\n    ephy_focus_desktop_app (data->app_id);\n  }\n\n  g_notification_set_priority (notification, G_NOTIFICATION_PRIORITY_LOW);\n\n  g_application_send_notification (G_APPLICATION (g_application_get_default ()), data->chosen_name, notification);\n\n  ephy_application_dialog_data_free (data);\n}",
        "parsed_output": "static void\nprocess_data(DataContext *ctx)\n{\n    gboolean result;\n    DataHandler *handler;\n    DataProcessor *processor;\n    DataVerifier *verifier;\n    DataLogger *logger;\n\n    result = data_handler_initialize(ctx->input, ctx->config, ctx->output, ctx->flags, &handler);\n    if (!result) {\n        processor = data_processor_create(0, ctx->log_path, 5);\n        processor = data_processor_configure(processor, ctx->settings, handler->extra_data);\n        verifier = data_verifier_create();\n        if (ctx->cache != NULL) {\n            data_cache_clear(ctx->cache);\n        }\n    } else {\n        processor = data_processor_create(0, ctx->log_path_alt, 5);\n        processor = data_processor_configure(processor, ctx->settings);\n        verifier = data_verifier_create();\n        if (ctx->cache != NULL) {\n            data_cache_clear(ctx->cache);\n        }\n        logger = data_logger_create(0, ctx->log_path_error, 5);\n        data_logger_log(logger, verifier, ctx->log_path_error, ctx->log_path_backup, ctx->input);\n        data_logger_finalize(logger, ctx->log_path_error, ctx->log_path_backup, ctx->input);\n        verifier = data_verifier_finalize(ctx->input);\n        data_logger_write(2, 0, ctx->log_path_final, verifier);\n        data_cleanup(0);\n    }\n    data_verifier_process(verifier, TRUE);\n    logger = data_logger_initialize();\n    data_logger_execute(logger, ctx->settings, verifier);\n    data_context_finalize(ctx);\n    if (handler != NULL) {\n        data_handler_cleanup(handler);\n    }\n    data_cleanup(processor);\n    if (ctx->state == ctx->initial_state) {\n        return;\n    }\n    data_error_handler();\n}",
        "baseline_code_stripped": "void FUN_001b07d8(longlong param_1)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 in_r8;\n  longlong in_r13;\n  longlong local_88;\n  longlong local_40;\n  longlong local_38;\n  local_38 = *(longlong *)(in_r13 + -0x7010);\n  local_40 = 0;\n  iVar1 = FUN_00148400(*(undefined8 *)(param_1 + 0x30),*(undefined8 *)(param_1 + 0x10),\n                       *(undefined8 *)(param_1 + 0x38),*(undefined4 *)(param_1 + 0x68),&local_40,\n                       in_r8,0,0);\n  if (iVar1 == 0) {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d48,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(local_40 + 8));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n  }\n  else {\n    uVar2 = FUN_00152220(0,local_88 + -0x47d78,5);\n    uVar2 = FUN_001536e0(uVar2,*(undefined8 *)(param_1 + 0x28));\n    uVar3 = FUN_0014b9a0();\n    if (*(longlong *)(param_1 + 0x58) != 0) {\n      FUN_0014d380();\n    }\n    uVar4 = FUN_00152220(0,local_88 + -0x47d10,5);\n    FUN_00143f80(uVar3,uVar4,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30)\n                );\n    FUN_001452c0(uVar3,local_88 + -0x47d08,local_88 + -0x4bd08,*(undefined8 *)(param_1 + 0x30));\n    uVar4 = FUN_00149ec0(*(undefined8 *)(param_1 + 0x30));\n    FUN_0014d740(2,0,local_88 + -0xa76b0,uVar4);\n    FUN_00144ac0(0);\n  }\n  FUN_001459a0(uVar3,1);\n  uVar4 = FUN_001479c0();\n  FUN_001508a0(uVar4,*(undefined8 *)(param_1 + 0x28),uVar3);\n  FUN_001b06a8(param_1);\n  if (local_40 != 0) {\n    FUN_00151b40();\n  }\n  FUN_00144ac0(uVar2);\n  if (local_38 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  FUN_0014f3a0();\n}",
        "similarity_score_unixcoder": 0.5430002212524414,
        "similarity_score_baseline_stripped": 0.40226635336875916
    },
    {
        "func_name": "_wrap_meep_grid_volume_icenter",
        "normed_func_sha256": "5f2c1e968960a76781eb3f969cc9f4071c3bb34c2b8642b6058203432a8b905b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_001a7b98(undefined4 *param_1,undefined4 param_2,void **param_3,void **param_4)\n{\n  undefined4 *puVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  int local_2c;\n  int local_28;\n  int local_24;\n  local_24 = __stack_chk_guard;\n  *param_4 = (void *)0x0;\n  *param_3 = (void *)0x0;\n  FUN_00237fe8(0x3dcccccd,param_1[5],param_2,&local_2c,&local_28);\n  if (local_2c != 0) {\n    puVar1 = (undefined4 *)operator_new(0x30);\n    *param_3 = puVar1;\n    uVar2 = param_1[1];\n    uVar3 = param_1[2];\n    uVar4 = param_1[3];\n    uVar5 = param_1[4];\n    *puVar1 = *param_1;\n    puVar1[1] = uVar2;\n    uVar2 = param_1[10];\n    puVar1[2] = uVar3;\n    puVar1[3] = uVar4;\n    puVar1[4] = uVar5;\n    puVar1[5] = local_2c;\n    puVar1[6] = 0;\n    puVar1[7] = 0;\n    puVar1[8] = 0;\n    puVar1[9] = 0;\n    puVar1[10] = uVar2;\n    puVar1[0xb] = 0;\n  }\n  if (local_28 != 0) {\n    puVar1 = (undefined4 *)operator_new(0x30);\n    *param_4 = puVar1;\n    uVar2 = param_1[1];\n    uVar4 = param_1[2];\n    uVar5 = param_1[3];\n    uVar3 = param_1[4];\n    uVar6 = param_1[10];\n    *puVar1 = *param_1;\n    puVar1[1] = uVar2;\n    puVar1[2] = uVar4;\n    puVar1[3] = uVar5;\n    puVar1[4] = uVar3;\n    puVar1[5] = local_28;\n    puVar1[6] = 0;\n    puVar1[7] = 0;\n    puVar1[8] = 0;\n    puVar1[9] = 0;\n    puVar1[10] = uVar6;\n    puVar1[0xb] = 0;\n  }\n  if (local_2c == 0) {\n    uVar2 = 1;\n  }\n  else if (local_28 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 3;\n  }\n  if (local_24 != __stack_chk_guard) {\n    __stack_chk_fail(uVar2);\n  }\n  return;\n}\n\n Revised code:\nint idBrushBSPPortal::Split( const idPlane &splitPlane, idBrushBSPPortal **front, idBrushBSPPortal **back ) {\n\tidWinding *frontWinding, *backWinding;\n\n\t(*front) = (*back) = NULL;\n\twinding->Split( splitPlane, 0.1f, &frontWinding, &backWinding );\n\tif ( frontWinding ) {\n\t\t(*front) = new idBrushBSPPortal();\n\t\t(*front)->plane = plane;\n\t\t(*front)->planeNum = planeNum;\n\t\t(*front)->flags = flags;\n\t\t(*front)->winding = frontWinding;\n\t}\n\tif ( backWinding ) {\n\t\t(*back) = new idBrushBSPPortal();\n\t\t(*back)->plane = plane;\n\t\t(*back)->planeNum = planeNum;\n\t\t(*back)->flags = flags;\n\t\t(*back)->winding = backWinding;\n\t}\n\n\tif ( frontWinding && backWinding ) {\n\t\treturn PLANESIDE_CROSS;\n\t}\n\telse if ( frontWinding ) {\n\t\treturn PLANESIDE_FRONT;\n\t}\n\telse {\n\t\treturn PLANESIDE_BACK;\n\t}\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_0008e230(undefined4 param_1,undefined2 *param_2)\n{\n  undefined4 uVar1;\n  undefined4 local_24;\n  undefined4 uStack_20;\n  undefined4 uStack_1c;\n  undefined4 local_18;\n  undefined4 uStack_14;\n  undefined4 uStack_10;\n  uint local_c;\n  local_c = __stack_chk_guard;\n  FUN_0002411c(&local_24,*param_2,0x8e7);\n  uVar1 = FUN_0005d9c4(param_1,local_24,uStack_20,uStack_1c,local_18,uStack_14,uStack_10);\n  if ((local_c ^ __stack_chk_guard) != 0) {\n    __stack_chk_fail(uVar1,local_c ^ __stack_chk_guard,0);\n  }\n  return uVar1;\n}\n\n Revised code:\nstatic UA_StatusCode function_namespace0_generated_159_finish(UA_Server *server, UA_UInt16* ns) {\nreturn UA_Server_addNode_finish(server, \nUA_NODEID_NUMERIC(ns[0], 2279)\n);\n}\n\n## Example:\n\n Input code:\nundefined4 * f_4696(undefined4 *param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 *puVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  int in_GS_OFFSET;\n  undefined local_3c [4];\n  undefined4 local_38;\n  undefined4 **local_34;\n  undefined4 *local_30 [4];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x815ff0c;\n  local_30[0] = param_1;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  if (((_C_disable_overflow_check == 0) && (local_3c < _C_stack_hard_limit)) &&\n     (0x10000 < (int)_C_stack_hard_limit - (int)local_3c)) {\n    C_stack_overflow();\n  }\n  puVar4 = local_30[0];\n  *local_30[0] = 0x3000002;\n  local_30[0][1] = 0x16;\n  local_30[0][2] = 0xe;\n  local_34 = local_30;\n  local_30[0] = local_30[0] + 3;\n  uVar5 = C_a_i_list2_isra_1();\n  uVar6 = DAT_0820fb7c;\n  uVar3 = DAT_0820f698;\n  uVar2 = DAT_0820f68c;\n  local_38 = DAT_0820fb7c;\n  *local_30[0] = 0x8000004;\n  local_30[0][4] = uVar5;\n  local_30[0][1] = uVar2;\n  local_30[0][2] = uVar3;\n  local_30[0][3] = uVar6;\n  local_30[0] = local_30[0] + 5;\n  uVar6 = C_a_i_list2_isra_1();\n  uVar3 = DAT_0820f694;\n  uVar2 = DAT_0820f68c;\n  local_30[0][3] = puVar4;\n  local_30[0][4] = uVar6;\n  iVar1 = *(int *)(in_GS_OFFSET + 0x14);\n  *local_30[0] = 0x8000004;\n  local_30[0][1] = uVar2;\n  local_30[0][2] = uVar3;\n  if (local_20 != iVar1) {\n    local_30[0] = (undefined4 *)__stack_chk_fail_local();\n  }\n  return local_30[0];\n}\n\n Revised code:\nstatic C_word C_fcall f_4696(C_word *a,C_word t0,C_word t1,C_word t2){\nC_word tmp;\nC_word t3;\nC_word t4;\nC_word t5;\nC_word t6;\nC_word t7;\nC_stack_overflow_check;{}\nt3=C_a_i_list1(&a,1,C_SCHEME_TRUE);\nt4=C_a_i_list2(&a,2,t1,t2);\nt5=C_a_i_record4(&a,4,lf[35],lf[38],lf[351],t4);\nt6=C_a_i_list2(&a,2,((C_word*)t0)[2],t5);\nreturn(C_a_i_record4(&a,4,lf[35],lf[37],t3,t6));}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00058de0(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined local_48 [4];\n  undefined4 local_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  undefined4 uStack_38;\n  undefined4 local_34;\n  undefined4 uStack_30;\n  undefined4 local_2c;\n  undefined4 uStack_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 local_1c;\n  undefined4 uStack_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  iVar1 = FUN_0002aef4(param_1,local_48,DAT_000e6ce8,0);\n  if (iVar1 < 0) {\n    scm_wrong_type_arg(\"meep-grid-volume-icenter\",1,param_1);\n  }\n  meep::grid_volume::icenter();\n  local_44 = local_2c;\n  uStack_40 = uStack_28;\n  uStack_3c = uStack_24;\n  uStack_38 = uStack_20;\n  local_34 = local_1c;\n  uStack_30 = uStack_18;\n  puVar2 = (undefined4 *)operator_new(0x18);\n  local_44 = local_2c;\n  *puVar2 = local_2c;\n  puVar2[1] = uStack_40;\n  puVar2[2] = uStack_3c;\n  puVar2[3] = uStack_38;\n  puVar2[4] = local_34;\n  puVar2[5] = uStack_30;\n  FUN_0002b164(puVar2,DAT_000e6d00,1);\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "static void meep_grid_volume_icenter_wrapper(meep::grid_volume &gv) {\n    int result;\n    meep::vec icenter;\n\n    result = validate_grid_volume(\"meep-grid-volume-icenter\", 1, gv);\n    if (result < 0) {\n        scm_wrong_type_arg(\"meep-grid-volume-icenter\", 1, gv);\n    }\n\n    icenter = gv.icenter();\n\n    meep::vec *icenter_ptr = new meep::vec(icenter);\n    process_icenter(icenter_ptr, DAT_000e6d00, 1);\n}",
        "source_code": "static SCM\n_wrap_meep_grid_volume_icenter (SCM s_0)\n{\n#define FUNC_NAME \"meep-grid-volume-icenter\"\n  meep::grid_volume *arg1 = (meep::grid_volume *) 0 ;\n  SCM gswig_result;\n  SWIGUNUSED int gswig_list_p = 0;\n  meep::ivec result;\n  \n  {\n    arg1 = (meep::grid_volume *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_meep__grid_volume, 1, 0);\n  }\n  result = ((meep::grid_volume const *)arg1)->icenter();\n  {\n    meep::ivec * resultptr;\n    resultptr = new meep::ivec((const meep::ivec &) result);\n    gswig_result =  SWIG_NewPointerObj (resultptr, SWIGTYPE_p_meep__ivec, 1);\n  }\n  \n  \n  return gswig_result;\n#undef FUNC_NAME\n}",
        "parsed_output": "static void meep_grid_volume_icenter_wrapper(meep::grid_volume &gv) {\n    int result;\n    meep::vec icenter;\n\n    result = validate_grid_volume(\"meep-grid-volume-icenter\", 1, gv);\n    if (result < 0) {\n        scm_wrong_type_arg(\"meep-grid-volume-icenter\", 1, gv);\n    }\n\n    icenter = gv.icenter();\n\n    meep::vec *icenter_ptr = new meep::vec(icenter);\n    process_icenter(icenter_ptr, DAT_000e6d00, 1);\n}",
        "baseline_code_stripped": "void FUN_00058de0(undefined4 param_1)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined local_48 [4];\n  undefined4 local_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  undefined4 uStack_38;\n  undefined4 local_34;\n  undefined4 uStack_30;\n  undefined4 local_2c;\n  undefined4 uStack_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 local_1c;\n  undefined4 uStack_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  iVar1 = FUN_0002aef4(param_1,local_48,DAT_000e6ce8,0);\n  if (iVar1 < 0) {\n    scm_wrong_type_arg(\"meep-grid-volume-icenter\",1,param_1);\n  }\n  meep::grid_volume::icenter();\n  local_44 = local_2c;\n  uStack_40 = uStack_28;\n  uStack_3c = uStack_24;\n  uStack_38 = uStack_20;\n  local_34 = local_1c;\n  uStack_30 = uStack_18;\n  puVar2 = (undefined4 *)operator_new(0x18);\n  local_44 = local_2c;\n  *puVar2 = local_2c;\n  puVar2[1] = uStack_40;\n  puVar2[2] = uStack_3c;\n  puVar2[3] = uStack_38;\n  puVar2[4] = local_34;\n  puVar2[5] = uStack_30;\n  FUN_0002b164(puVar2,DAT_000e6d00,1);\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.672439694404602,
        "similarity_score_baseline_stripped": 0.6443890333175659
    },
    {
        "func_name": "remoteDomainGetGuestInfo",
        "normed_func_sha256": "11ac12fba50d67b18e05e56afecdba6c7683af36674a47348feb748fc8fbad20",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint remoteDomainGetSchedulerParametersFlags\n              (long param_1,undefined8 param_2,undefined4 *param_3,undefined4 param_4)\n{\n  undefined8 uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  ulong local_78;\n  undefined8 local_70;\n  undefined local_68 [32];\n  undefined4 local_48;\n  undefined4 local_44;\n  long local_40;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = *(undefined8 *)(*(long *)(param_1 + 8) + 0x48);\n  virMutexLock(uVar1);\n  make_nonnull_domain(local_68,param_1);\n  local_48 = *param_3;\n  local_78 = 0;\n  local_70 = 0;\n  local_44 = param_4;\n  iVar2 = call_isra_3(uVar1,0,0xdf,&xdr_remote_domain_get_scheduler_parameters_flags_args,local_68,\n                      &xdr_remote_domain_get_scheduler_parameters_flags_ret,&local_78);\n  if (iVar2 != -1) {\n    iVar2 = remoteDeserializeTypedParameters_constprop_12\n                      (local_70,local_78 & 0xffffffff,param_2,param_3);\n    iVar2 = iVar2 >> 0x1f;\n    xdr_free((xdrproc_t)&xdr_remote_domain_get_scheduler_parameters_flags_ret,(char *)&local_78);\n  }\n  virMutexUnlock(uVar1);\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic int\nremoteDomainGetNumaParameters (virDomainPtr domain,\n                               virTypedParameterPtr params, int *nparams,\n                               unsigned int flags)\n{\n    int rv = -1;\n    remote_domain_get_numa_parameters_args args;\n    remote_domain_get_numa_parameters_ret ret;\n    struct private_data *priv = domain->conn->privateData;\n    remoteDriverLock(priv);\n    make_nonnull_domain (&args.dom, domain);\n    args.nparams = *nparams;\n    args.flags = flags;\n    memset (&ret, 0, sizeof ret);\n    if (call (domain->conn, priv, 0, REMOTE_PROC_DOMAIN_GET_NUMA_PARAMETERS,\n              (xdrproc_t) xdr_remote_domain_get_numa_parameters_args, (char *) &args,\n              (xdrproc_t) xdr_remote_domain_get_numa_parameters_ret, (char *) &ret) == -1)\n        goto done;\n    if (*nparams == 0) {\n        *nparams = ret.nparams;\n        rv = 0;\n        goto cleanup;\n    }\n    if (remoteDeserializeTypedParameters(ret.params.params_val,\n                                         ret.params.params_len,\n                                         REMOTE_DOMAIN_NUMA_PARAMETERS_MAX,\n                                         params,\n                                         nparams) < 0)\n        goto cleanup;\n    rv = 0;\ncleanup:\n    xdr_free ((xdrproc_t) xdr_remote_domain_get_numa_parameters_ret,\n              (char *) &ret);\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_00338310(long param_1,long param_2,undefined4 param_3,int param_4)\n{\n  int iVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined local_48 [24];\n  long local_30;\n  uVar2 = *(undefined8 *)(param_1 + 0x88);\n  local_50 = 0;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48._0_16_ = (undefined  [16])0x0;\n  local_58 = virLockGuardLock(uVar2);\n  if (param_4 < 0x401) {\n    local_50 = CONCAT44(param_4,param_3);\n    iVar1 = FUN_003299c0(uVar2,0,0,0,0,0,0x65,xdr_remote_node_get_cells_free_memory_args,&local_50,\n                         xdr_remote_node_get_cells_free_memory_ret,local_48);\n    if (iVar1 != -1) {\n      if ((ulong)(uint)local_48._0_4_ != 0) {\n        uVar3 = 0;\n        do {\n          *(undefined8 *)(param_2 + uVar3 * 8) = *(undefined8 *)(local_48._8_8_ + uVar3 * 8);\n          uVar3 = uVar3 + 1;\n        } while (uVar3 != (uint)local_48._0_4_);\n      }\n      xdr_free(xdr_remote_node_get_cells_free_memory_ret,local_48);\n      uVar4 = local_48._0_4_;\n      goto LAB_003383b1;\n    }\n  }\n  else {\n    uVar2 = dcgettext(\"libvirt\",\"too many NUMA cells: %1$d > %2$d\",5);\n    virReportErrorHelper\n              (0xd,0x27,\"../src/remote/remote_driver.c\",\"remoteNodeGetCellsFreeMemory\",0x636,uVar2,\n               param_4,0x400);\n  }\n  uVar4 = 0xffffffff;\nLAB_003383b1:\n  virLockGuardUnlock(&local_58);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic int\nremoteNodeGetCellsFreeMemory(virConnectPtr conn,\n                             unsigned long long *freeMems,\n                             int startCell,\n                             int maxCells)\n{\n    remote_node_get_cells_free_memory_args args = {0};\n    remote_node_get_cells_free_memory_ret ret = {0};\n    size_t i;\n    struct private_data *priv = conn->privateData;\n    VIR_LOCK_GUARD lock = remoteDriverLock(priv);\n\n    if (maxCells > REMOTE_NODE_MAX_CELLS) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many NUMA cells: %1$d > %2$d\"),\n                       maxCells, REMOTE_NODE_MAX_CELLS);\n        return -1;\n    }\n\n    args.startCell = startCell;\n    args.maxcells = maxCells;\n\n    if (call(conn, priv, 0, REMOTE_PROC_NODE_GET_CELLS_FREE_MEMORY,\n             (xdrproc_t) xdr_remote_node_get_cells_free_memory_args, (char *)&args,\n             (xdrproc_t) xdr_remote_node_get_cells_free_memory_ret, (char *)&ret) == -1)\n        return -1;\n\n    for (i = 0; i < ret.cells.cells_len; i++)\n        freeMems[i] = ret.cells.cells_val[i];\n\n    xdr_free((xdrproc_t) xdr_remote_node_get_cells_free_memory_ret, (char *) &ret);\n\n    return ret.cells.cells_len;\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_003358b0(long param_1,long param_2,undefined4 param_3,int param_4)\n{\n  int iVar1;\n  ulong uVar2;\n  undefined8 uVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined local_48 [24];\n  long local_30;\n  uVar3 = *(undefined8 *)(param_1 + 0x88);\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50 = 0;\n  local_48._0_16_ = (undefined  [16])0x0;\n  local_58 = virLockGuardLock(uVar3);\n  if (param_4 < 0x401) {\n    local_50 = CONCAT44(param_4,param_3);\n    iVar1 = FUN_00424140(uVar3,0,0x65,xdr_remote_node_get_cells_free_memory_args,&local_50,\n                         xdr_remote_node_get_cells_free_memory_ret,local_48);\n    if (iVar1 != -1) {\n      if (local_48._0_4_ != 0) {\n        uVar2 = 0;\n        do {\n          *(undefined8 *)(param_2 + uVar2 * 8) = *(undefined8 *)(local_48._8_8_ + uVar2 * 8);\n          uVar2 = uVar2 + 1;\n        } while (uVar2 != (uint)local_48._0_4_);\n      }\n      xdr_free(xdr_remote_node_get_cells_free_memory_ret,local_48);\n      uVar4 = local_48._0_4_;\n      goto LAB_0033597b;\n    }\n  }\n  else {\n    uVar3 = dcgettext(\"libvirt\",\"too many NUMA cells: %d > %d\",5);\n    virReportErrorHelper\n              (0xd,0x27,\"../src/remote/remote_driver.c\",\"remoteNodeGetCellsFreeMemory\",0x634,uVar3,\n               param_4,0x400);\n  }\n  uVar4 = 0xffffffff;\nLAB_0033597b:\n  virLockGuardUnlock(&local_58);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic int\nremoteNodeGetCellsFreeMemory(virConnectPtr conn,\n                             unsigned long long *freeMems,\n                             int startCell,\n                             int maxCells)\n{\n    remote_node_get_cells_free_memory_args args = {0};\n    remote_node_get_cells_free_memory_ret ret = {0};\n    size_t i;\n    struct private_data *priv = conn->privateData;\n    VIR_LOCK_GUARD lock = remoteDriverLock(priv);\n\n    if (maxCells > REMOTE_NODE_MAX_CELLS) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many NUMA cells: %d > %d\"),\n                       maxCells, REMOTE_NODE_MAX_CELLS);\n        return -1;\n    }\n\n    args.startCell = startCell;\n    args.maxcells = maxCells;\n\n    if (call(conn, priv, 0, REMOTE_PROC_NODE_GET_CELLS_FREE_MEMORY,\n             (xdrproc_t) xdr_remote_node_get_cells_free_memory_args, (char *)&args,\n             (xdrproc_t) xdr_remote_node_get_cells_free_memory_ret, (char *)&ret) == -1)\n        return -1;\n\n    for (i = 0; i < ret.cells.cells_len; i++)\n        freeMems[i] = ret.cells.cells_val[i];\n\n    xdr_free((xdrproc_t) xdr_remote_node_get_cells_free_memory_ret, (char *) &ret);\n\n    return ret.cells.cells_len;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4\nFUN_003f3652(long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,\n            undefined4 param_5)\n{\n  undefined8 uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  undefined4 local_54;\n  undefined4 local_48 [2];\n  undefined8 local_40;\n  undefined local_38 [32];\n  undefined4 local_18;\n  undefined4 local_14;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_54 = 0xffffffff;\n  uVar1 = *(undefined8 *)(*(long *)(param_1 + 0x18) + 0x88);\n  FUN_003ca6fa(uVar1);\n  FUN_003f3f4c(local_38,param_1);\n  local_18 = param_2;\n  local_14 = param_5;\n  memset(local_48,0,0x10);\n  iVar2 = FUN_003efead(*(undefined8 *)(param_1 + 0x18),uVar1,0,0x1a2,\n                       xdr_remote_domain_get_guest_info_args,local_38,\n                       xdr_remote_domain_get_guest_info_ret,local_48,param_4,param_3,param_5);\n  if (iVar2 != -1) {\n    iVar2 = virTypedParamsDeserialize(local_40,local_48[0],0x800,param_3,param_4);\n    if (-1 < iVar2) {\n      local_54 = 0;\n    }\n    xdr_free(xdr_remote_domain_get_guest_info_ret,(char *)local_48);\n  }\n  FUN_003ca71a(uVar1);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return local_54;\n}",
        "output": "```c\nstatic int\nremoteDomainGetGuestInfo(virDomainPtr domain,\n                         virTypedParameterPtr params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    int rv = -1;\n    remote_domain_get_guest_info_args args;\n    remote_domain_get_guest_info_ret ret = {0};\n    struct private_data *priv = domain->conn->privateData;\n\n    remoteDriverLock(priv);\n    make_nonnull_domain(&args.dom, domain);\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n\n    if (call(domain->conn, priv, 0, REMOTE_PROC_DOMAIN_GET_GUEST_INFO,\n             (xdrproc_t)xdr_remote_domain_get_guest_info_args, (char *)&args,\n             (xdrproc_t)xdr_remote_domain_get_guest_info_ret, (char *)&ret) == -1)\n        goto cleanup;\n\n    if (virTypedParamsDeserialize(ret.params.params_val,\n                                  ret.params.params_len,\n                                  REMOTE_DOMAIN_GUEST_INFO_MAX,\n                                  params, nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n\ncleanup:\n    xdr_free((xdrproc_t)xdr_remote_domain_get_guest_info_ret, (char *)&ret);\n    remoteDriverUnlock(priv);\n    return rv;\n}\n```",
        "source_code": "static int\nremoteDomainGetGuestInfo(virDomainPtr dom,\n                         unsigned int types,\n                         virTypedParameterPtr *params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    int rv = -1;\n    struct private_data *priv = dom->conn->privateData;\n    remote_domain_get_guest_info_args args;\n    remote_domain_get_guest_info_ret ret;\n\n    remoteDriverLock(priv);\n\n    make_nonnull_domain(&args.dom, dom);\n\n    args.types = types;\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n\n    if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_GET_GUEST_INFO,\n             (xdrproc_t)xdr_remote_domain_get_guest_info_args, (char *)&args,\n             (xdrproc_t)xdr_remote_domain_get_guest_info_ret, (char *)&ret) == -1)\n        goto done;\n\n    if (virTypedParamsDeserialize((struct _virTypedParameterRemote *) ret.params.params_val,\n                                  ret.params.params_len,\n                                  REMOTE_DOMAIN_GUEST_INFO_PARAMS_MAX,\n                                  params,\n                                  nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_remote_domain_get_guest_info_ret,\n             (char *) &ret);\n\n done:\n    remoteDriverUnlock(priv);\n    return rv;\n}",
        "parsed_output": "static int\nremoteDomainGetGuestInfo(virDomainPtr domain,\n                         virTypedParameterPtr params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    int rv = -1;\n    remote_domain_get_guest_info_args args;\n    remote_domain_get_guest_info_ret ret = {0};\n    struct private_data *priv = domain->conn->privateData;\n\n    remoteDriverLock(priv);\n    make_nonnull_domain(&args.dom, domain);\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n\n    if (call(domain->conn, priv, 0, REMOTE_PROC_DOMAIN_GET_GUEST_INFO,\n             (xdrproc_t)xdr_remote_domain_get_guest_info_args, (char *)&args,\n             (xdrproc_t)xdr_remote_domain_get_guest_info_ret, (char *)&ret) == -1)\n        goto cleanup;\n\n    if (virTypedParamsDeserialize(ret.params.params_val,\n                                  ret.params.params_len,\n                                  REMOTE_DOMAIN_GUEST_INFO_MAX,\n                                  params, nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n\ncleanup:\n    xdr_free((xdrproc_t)xdr_remote_domain_get_guest_info_ret, (char *)&ret);\n    remoteDriverUnlock(priv);\n    return rv;\n}",
        "baseline_code_stripped": "undefined4\nFUN_003f3652(long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,\n            undefined4 param_5)\n{\n  undefined8 uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  undefined4 local_54;\n  undefined4 local_48 [2];\n  undefined8 local_40;\n  undefined local_38 [32];\n  undefined4 local_18;\n  undefined4 local_14;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_54 = 0xffffffff;\n  uVar1 = *(undefined8 *)(*(long *)(param_1 + 0x18) + 0x88);\n  FUN_003ca6fa(uVar1);\n  FUN_003f3f4c(local_38,param_1);\n  local_18 = param_2;\n  local_14 = param_5;\n  memset(local_48,0,0x10);\n  iVar2 = FUN_003efead(*(undefined8 *)(param_1 + 0x18),uVar1,0,0x1a2,\n                       xdr_remote_domain_get_guest_info_args,local_38,\n                       xdr_remote_domain_get_guest_info_ret,local_48,param_4,param_3,param_5);\n  if (iVar2 != -1) {\n    iVar2 = virTypedParamsDeserialize(local_40,local_48[0],0x800,param_3,param_4);\n    if (-1 < iVar2) {\n      local_54 = 0;\n    }\n    xdr_free(xdr_remote_domain_get_guest_info_ret,(char *)local_48);\n  }\n  FUN_003ca71a(uVar1);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return local_54;\n}",
        "similarity_score_unixcoder": 0.9821880459785461,
        "similarity_score_baseline_stripped": 0.6256576776504517
    },
    {
        "func_name": "dino_entities_message_get_real_jid",
        "normed_func_sha256": "c6b9c1e0af59c12795773ec2273afdbaacf73d0a8b10047eab11045269403fc3",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 dino_entities_message_get_real_jid(long param_1)\n{\n  if (param_1 != 0) {\n    return *(undefined8 *)(*(long *)(param_1 + 0x18) + 0x28);\n  }\n  g_return_if_fail_warning(\"libdino\",\"dino_entities_message_get_real_jid\",\"self != NULL\");\n  return 0;\n}\n\n Revised code:\nXmppJid*\ndino_entities_message_get_real_jid (DinoEntitiesMessage* self)\n{\n\tXmppJid* result;\n\tXmppJid* _tmp0_;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\tg_return_val_if_fail (self != NULL, NULL);\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\t_tmp0_ = self->priv->_real_jid;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\tresult = _tmp0_;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\treturn result;\n#line 2820 \"message.c\"\n}\n\n## Example:\n\n Input code:\nundefined4 dino_entities_message_get_server_id(int param_1)\n{\n  if (param_1 != 0) {\n    return *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x24);\n  }\n  g_return_if_fail_warning(\"libdino\",\"dino_entities_message_get_server_id\",\"self != NULL\");\n  return 0;\n}\n\n Revised code:\nconst gchar*\ndino_entities_message_get_server_id (DinoEntitiesMessage* self)\n{\n\tconst gchar* result;\n\tconst gchar* _tmp0_;\n#line 56 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\tg_return_val_if_fail (self != NULL, NULL);\n#line 56 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\t_tmp0_ = self->priv->_server_id;\n#line 56 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\tresult = _tmp0_;\n#line 56 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\treturn result;\n#line 3295 \"message.c\"\n}\n\n## Example:\n\n Input code:\nundefined4 dino_entities_conversation_get_id(int param_1)\n{\n  if (param_1 != 0) {\n    return **(undefined4 **)(param_1 + 0xc);\n  }\n  g_return_if_fail_warning(\"libdino\",\"dino_entities_conversation_get_id\",\"self != NULL\");\n  return 0;\n}\n\n Revised code:\ngint\ndino_entities_conversation_get_id (DinoEntitiesConversation* self)\n{\n\tgint result;\n#line 15 \"/builddir/build/BUILD/dino-330649a5372880d14a12ea37af948c7acbbc6a3d/libdino/src/entity/conversation.vala\"\n\tg_return_val_if_fail (self != NULL, 0);\n#line 15 \"/builddir/build/BUILD/dino-330649a5372880d14a12ea37af948c7acbbc6a3d/libdino/src/entity/conversation.vala\"\n\tresult = self->priv->_id;\n#line 15 \"/builddir/build/BUILD/dino-330649a5372880d14a12ea37af948c7acbbc6a3d/libdino/src/entity/conversation.vala\"\n\treturn result;\n#line 2089 \"conversation.c\"\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 dino_entities_message_get_real_jid(int param_1)\n{\n  if (param_1 != 0) {\n    return *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x14);\n  }\n  g_return_if_fail_warning(\"libdino\",\"dino_entities_message_get_real_jid\",\"self != NULL\");\n  return 0;\n}",
        "output": "```c\nconst gchar*\ndino_entities_message_get_real_jid (DinoEntitiesMessage* self)\n{\n\tconst gchar* result;\n\tconst gchar* _tmp0_;\n#line 52 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\tg_return_val_if_fail (self != NULL, NULL);\n#line 52 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\t_tmp0_ = self->priv->_real_jid;\n#line 52 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\tresult = _tmp0_;\n#line 52 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\treturn result;\n#line 2845 \"message.c\"\n}\n```",
        "source_code": "XmppJid*\ndino_entities_message_get_real_jid (DinoEntitiesMessage* self)\n{\n\tXmppJid* result;\n\tXmppJid* _tmp0_;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\tg_return_val_if_fail (self != NULL, NULL);\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\t_tmp0_ = self->priv->_real_jid;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\tresult = _tmp0_;\n#line 48 \"/home/abuild/rpmbuild/BUILD/dino-0.3.0~git71.20230117.7e0d1db/libdino/src/entity/message.vala\"\n\treturn result;\n#line 2816 \"message.c\"\n}",
        "parsed_output": "const gchar*\ndino_entities_message_get_real_jid (DinoEntitiesMessage* self)\n{\n\tconst gchar* result;\n\tconst gchar* _tmp0_;\n#line 52 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\tg_return_val_if_fail (self != NULL, NULL);\n#line 52 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\t_tmp0_ = self->priv->_real_jid;\n#line 52 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\tresult = _tmp0_;\n#line 52 \"/home/abuild/rpmbuild/BUILD/dino-0.4.1~git75.20231210.384ef1d/libdino/src/entity/message.vala\"\n\treturn result;\n#line 2845 \"message.c\"\n}",
        "baseline_code_stripped": "undefined4 dino_entities_message_get_real_jid(int param_1)\n{\n  if (param_1 != 0) {\n    return *(undefined4 *)(*(int *)(param_1 + 0xc) + 0x14);\n  }\n  g_return_if_fail_warning(\"libdino\",\"dino_entities_message_get_real_jid\",\"self != NULL\");\n  return 0;\n}",
        "similarity_score_unixcoder": 0.9495006203651428,
        "similarity_score_baseline_stripped": 0.7007763981819153
    },
    {
        "func_name": "sipQgsLayoutView::showEvent",
        "normed_func_sha256": "1a6bc7810dbed627cc7cf033d7c2b28cc099ff9edde8c0816daeccba084dfb7b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_001b66d0(long *param_1)\n{\n  undefined8 uVar1;\n  uVar1 = PyEval_SaveThread();\n  if (param_1 != (long *)0x0) {\n    (**(code **)(*param_1 + 8))(param_1);\n  }\n  PyEval_RestoreThread(uVar1);\n  return;\n}\n\n Revised code:\nstatic void release_KSystemTimeZoneBackend(void *sipCppV,int sipState)\n{\n    Py_BEGIN_ALLOW_THREADS\n\n    if (sipState & SIP_DERIVED_CLASS)\n        delete reinterpret_cast<sipKSystemTimeZoneBackend *>(sipCppV);\n    else\n        delete reinterpret_cast<KSystemTimeZoneBackend *>(sipCppV);\n\n    Py_END_ALLOW_THREADS\n}\n\n## Example:\n\n Input code:\nvoid FUN_0040cc8c(void *param_1)\n{\n  undefined4 uVar1;\n  uVar1 = PyEval_SaveThread();\n  if (param_1 != (void *)0x0) {\n    operator_delete(param_1,4);\n  }\n  PyEval_RestoreThread(uVar1);\n  return;\n}\n\n Revised code:\nstatic void release_KCharSelect_Controls(void *sipCppV, int)\n{\n    Py_BEGIN_ALLOW_THREADS\n\n    delete reinterpret_cast< ::KCharSelect::Controls *>(sipCppV);\n\n    Py_END_ALLOW_THREADS\n}\n\n## Example:\n\n Input code:\nvoid FUN_004a4fb6(void *param_1)\n{\n  undefined8 uVar1;\n  uVar1 = PyEval_SaveThread();\n  if (param_1 != (void *)0x0) {\n    FUN_004a550c(param_1);\n    operator_delete(param_1);\n  }\n  PyEval_RestoreThread(uVar1);\n  return;\n}\n\n Revised code:\nstatic void release_QList_0101QTextFrame(void *ptr, int)\n{\n    Py_BEGIN_ALLOW_THREADS\n    delete reinterpret_cast<QList< ::QTextFrame*> *>(ptr);\n    Py_END_ALLOW_THREADS\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_004dc6c4(int *param_1)\n{\n  undefined4 uVar1;\n  uVar1 = PyEval_SaveThread();\n  if (param_1 != (int *)0x0) {\n    (**(code **)(*param_1 + 4))(param_1);\n  }\n  PyEval_RestoreThread(uVar1);\n  return;\n}",
        "output": "static void release_CustomObject(void *sipCppV, int)\n{\n    Py_BEGIN_ALLOW_THREADS\n\n    delete reinterpret_cast<CustomObject *>(sipCppV);\n\n    Py_END_ALLOW_THREADS\n}",
        "source_code": "void sipQgsLayoutView::showEvent( ::QShowEvent*a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[13],sipPySelf,NULL,sipName_showEvent);\n\n    if (!sipMeth)\n    {\n         ::QgsLayoutView::showEvent(a0);\n        return;\n    }\n\n    extern void sipVH__gui_30(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QShowEvent*);\n\n    sipVH__gui_30(sipGILState, sipImportedVirtErrorHandlers__gui_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);\n}",
        "parsed_output": "static void release_CustomObject(void *sipCppV, int)\n{\n    Py_BEGIN_ALLOW_THREADS\n\n    delete reinterpret_cast<CustomObject *>(sipCppV);\n\n    Py_END_ALLOW_THREADS\n}",
        "baseline_code_stripped": "void FUN_004dc6c4(int *param_1)\n{\n  undefined4 uVar1;\n  uVar1 = PyEval_SaveThread();\n  if (param_1 != (int *)0x0) {\n    (**(code **)(*param_1 + 4))(param_1);\n  }\n  PyEval_RestoreThread(uVar1);\n  return;\n}",
        "similarity_score_unixcoder": 0.40789762139320374,
        "similarity_score_baseline_stripped": 0.4899625778198242
    },
    {
        "func_name": "_wrap_ephy_password_manager_add_password",
        "normed_func_sha256": "21440c1d75f502c6675c600c42168ee588884369e11133af9cf9f1a84c0e0961",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined * FUN_001405c0(undefined8 param_1,undefined8 param_2)\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  undefined *puVar4;\n  iVar1 = PyArg_ParseTuple(param_2,&DAT_0014bd29);\n  if (iVar1 == 0) {\n    return (undefined *)0x0;\n  }\n  lVar2 = lasso_saml2_key_info_confirmation_data_type_new();\n  if (lVar2 != 0) {\n    uVar3 = g_type_check_instance_cast(lVar2,0x50);\n    puVar4 = (undefined *)FUN_001397a0(uVar3);\n    g_object_unref(lVar2);\n    return puVar4;\n  }\n  __Py_NoneStruct = __Py_NoneStruct + 1;\n  return &_Py_NoneStruct;\n}\n\n Revised code:\nstatic PyObject*\nsaml2_key_info_confirmation_data_type_new(G_GNUC_UNUSED PyObject *self, PyObject *args)\n{\n    LassoNode* return_value;\n    PyObject* return_pyvalue = NULL;\n\n    if (! PyArg_ParseTuple(args, \"\")) return NULL;\n    return_value =\n(LassoNode*)\nlasso_saml2_key_info_confirmation_data_type_new();\n    if (return_value) {\n        return_pyvalue = PyGObjectPtr_New(G_OBJECT(return_value));\n    } else {\n        return_pyvalue = noneRef();\n    }\n\n    if (return_value) g_object_unref(return_value);\n    return return_pyvalue;\n}\n\n## Example:\n\n Input code:\nvoid FUN_00028414(undefined4 param_1,undefined4 param_2)\n{\n  void **ppvVar1;\n  undefined4 *puVar2;\n  int iVar3;\n  char *__s;\n  size_t sVar4;\n  void *pvVar5;\n  undefined4 uVar6;\n  void **local_20;\n  undefined4 local_1c;\n  undefined4 *local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  local_20 = (void **)0x0;\n  local_1c = 0;\n  local_18 = (undefined4 *)0x0;\n  puVar2 = (undefined4 *)PyArg_ParseTuple(param_2,\"OO:dpns_filereg_lfn_set\",&local_1c,&local_18);\n  if (puVar2 == (undefined4 *)0x0) goto LAB_00028508;\n  iVar3 = FUN_0001ef2c(local_1c,&local_20,DAT_0008eb28,0);\n  ppvVar1 = local_20;\n  if (iVar3 < 0) {\n    if (iVar3 == -1) {\n      iVar3 = -5;\n    }\n    uVar6 = FUN_0001796c(iVar3);\n    PyErr_SetString(uVar6,\n                    \"in method \\'dpns_filereg_lfn_set\\', argument 1 of type \\'struct dpns_filereg *\\'\"\n                   );\n    puVar2 = (undefined4 *)0x0;\n    goto LAB_00028508;\n  }\n  puVar2 = &_Py_NoneStruct;\n  if (local_18 == &_Py_NoneStruct) {\n    if (*local_20 != (void *)0x0) {\n      free(*local_20);\n    }\nLAB_00028540:\n    *ppvVar1 = (void *)0x0;\n  }\n  else {\n    __s = (char *)PyString_AsString();\n    if (*ppvVar1 != (void *)0x0) {\n      free(*ppvVar1);\n    }\n    if (__s == (char *)0x0) goto LAB_00028540;\n    sVar4 = strlen(__s);\n    pvVar5 = malloc(sVar4 + 1);\n    pvVar5 = memcpy(pvVar5,__s,sVar4 + 1);\n    *ppvVar1 = pvVar5;\n  }\n  _Py_NoneStruct = _Py_NoneStruct + 1;\nLAB_00028508:\n  if (local_14 == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(puVar2);\n}\n\n Revised code:\nSWIGINTERN PyObject *_wrap_dpns_filereg_lfn_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {\n  PyObject *resultobj = 0;\n  struct dpns_filereg *arg1 = (struct dpns_filereg *) 0 ;\n  char *arg2 = (char *) 0 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  PyObject * obj0 = 0 ;\n  PyObject * obj1 = 0 ;\n  \n  if (!PyArg_ParseTuple(args,(char *)\"OO:dpns_filereg_lfn_set\",&obj0,&obj1)) SWIG_fail;\n  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_dpns_filereg, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), \"in method '\" \"dpns_filereg_lfn_set\" \"', argument \" \"1\"\" of type '\" \"struct dpns_filereg *\"\"'\"); \n  }\n  arg1 = (struct dpns_filereg *)(argp1);\n  {\n    if (obj1 == Py_None) {\n      arg2 = NULL;\n    } else {\n      arg2 = PyString_AsString (obj1);\n    }\n  }\n  if (arg1->lfn) free((char*)arg1->lfn);\n  if (arg2) {\n    size_t size = strlen((const char *)(arg2)) + 1;\n    arg1->lfn = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));\n  } else {\n    arg1->lfn = 0;\n  }\n  resultobj = SWIG_Py_Void();\n  return resultobj;\nfail:\n  return NULL;\n}\n\n## Example:\n\n Input code:\nundefined8 *\nFUN_005ab9b0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  long *plVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  __uid_t local_50;\n  __gid_t _Stack_4c;\n  char *local_48;\n  undefined *puStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  char *local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long *local_10;\n  long *local_8;\n  puVar5 = (undefined8 *)0x0;\n  local_48 = \"lchown\";\n  puStack_40 = &DAT_0063cfb8;\n  local_38 = 0;\n  uStack_30 = 0;\n  local_28 = (char *)0x0;\n  uStack_20 = 0xffffffff;\n  local_18 = 0;\n  local_10 = (long *)0x0;\n  local_8 = (long *)0x0;\n  iVar2 = _PyArg_ParseStackAndKeywords_SizeT\n                    (param_2,param_3,param_4,&PTR_DAT_0084b920,FUN_005a3220,&local_48,\n                     _Py_Uid_Converter,&local_50,_Py_Gid_Converter,&_Stack_4c);\n  if (iVar2 != 0) {\n    uVar3 = PyEval_SaveThread();\n    iVar2 = lchown(local_28,local_50,_Stack_4c);\n    PyEval_RestoreThread(uVar3);\n    if (iVar2 < 0) {\n      puVar5 = (undefined8 *)PyErr_SetFromErrnoWithFilenameObject(PyExc_OSError,local_10);\n    }\n    else {\n      puVar5 = &_Py_NoneStruct;\n      _Py_NoneStruct = _Py_NoneStruct + 1;\n    }\n  }\n  plVar1 = local_10;\n  if (local_10 != (long *)0x0) {\n    lVar4 = *local_10;\n    local_10 = (long *)0x0;\n    *plVar1 = lVar4 + -1;\n    if (lVar4 + -1 == 0) {\n      (**(code **)(plVar1[1] + 0x30))();\n    }\n  }\n  plVar1 = local_8;\n  if (local_8 != (long *)0x0) {\n    lVar4 = *local_8;\n    local_8 = (long *)0x0;\n    *plVar1 = lVar4 + -1;\n    if (lVar4 + -1 == 0) {\n      (**(code **)(plVar1[1] + 0x30))();\n      return puVar5;\n    }\n  }\n  return puVar5;\n}\n\n Revised code:\nstatic PyObject *\nos_lchown(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    static const char * const _keywords[] = {\"path\", \"uid\", \"gid\", NULL};\n    static _PyArg_Parser _parser = {\"O&O&O&:lchown\", _keywords, 0};\n    path_t path = PATH_T_INITIALIZE(\"lchown\", \"path\", 0, 0);\n    uid_t uid;\n    gid_t gid;\n\n    if (!_PyArg_ParseStackAndKeywords(args, nargs, kwnames, &_parser,\n        path_converter, &path, _Py_Uid_Converter, &uid, _Py_Gid_Converter, &gid)) {\n        goto exit;\n    }\n    return_value = os_lchown_impl(module, &path, uid, gid);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined1 * FUN_004ca070(long param_1,undefined8 param_2,undefined8 param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined1 *puVar6;\n  long local_18;\n  iVar3 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"O:EphyPasswordManager.add_password\",&PTR_s_info_00620a90,\n                     &local_18);\n  puVar6 = (undefined1 *)0x0;\n  if (iVar3 != 0) {\n    if (((*(long *)(local_18 + 8) == *(long *)(_PyGObject_API + 0x80)) ||\n        (iVar3 = PyType_IsSubtype(), iVar3 != 0)) &&\n       (lVar1 = *(long *)(local_18 + 0x18), lVar4 = ephy_password_info_get_type(), lVar1 == lVar4))\n    {\n      uVar2 = *(undefined8 *)(local_18 + 0x10);\n      uVar5 = ephy_password_manager_get_type();\n      uVar5 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 0x10),uVar5);\n      ephy_password_manager_add_password(uVar5,uVar2);\n      _Py_NoneStruct._0_4_ = _Py_NoneStruct._0_4_ + 1;\n      puVar6 = _Py_NoneStruct;\n    }\n    else {\n      PyErr_SetString(PyExc_TypeError,\"info should be a EphyPasswordInfo\");\n      puVar6 = (undefined1 *)0x0;\n    }\n  }\n  return puVar6;\n}",
        "output": "```c\nstatic PyObject *\nephy_password_manager_add_password(PyObject *self, PyObject *args, PyObject *kwargs)\n{\n    static char *kwlist[] = {\"info\", NULL};\n    PyObject *info = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs, \"O:EphyPasswordManager.add_password\", kwlist, &info)) {\n        return NULL;\n    }\n\n    if ((Py_TYPE(info) == (PyTypeObject *)_PyGObject_API[20] || PyType_IsSubtype(Py_TYPE(info), (PyTypeObject *)_PyGObject_API[20])) &&\n        (G_TYPE_FROM_INSTANCE(info) == ephy_password_info_get_type())) {\n        EphyPasswordInfo *password_info = (EphyPasswordInfo *)G_TYPE_INSTANCE_GET_PRIVATE(info, ephy_password_info_get_type(), EphyPasswordInfo);\n        EphyPasswordManager *password_manager = (EphyPasswordManager *)g_type_check_instance_cast((GTypeInstance *)self, ephy_password_manager_get_type());\n        ephy_password_manager_add_password(password_manager, password_info);\n        Py_RETURN_NONE;\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"info should be a EphyPasswordInfo\");\n        return NULL;\n    }\n}\n```",
        "source_code": "static PyObject *\n_wrap_ephy_password_manager_add_password(PyGObject *self, PyObject *args, PyObject *kwargs)\n{\n    static char *kwlist[] = { \"info\", NULL };\n    PyObject *py_info;\n    EphyPasswordInfo *info = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs, \"O:EphyPasswordManager.add_password\", kwlist, &py_info))\n        return NULL;\n    if (pyg_boxed_check(py_info, EPHY_TYPE_PASSWORD_INFO))\n        info = pyg_boxed_get(py_info, EphyPasswordInfo);\n    else {\n        PyErr_SetString(PyExc_TypeError, \"info should be a EphyPasswordInfo\");\n        return NULL;\n    }\n    ephy_password_manager_add_password(EPHY_PASSWORD_MANAGER(self->obj), info);\n    Py_INCREF(Py_None);\n    return Py_None;\n}",
        "parsed_output": "static PyObject *\nephy_password_manager_add_password(PyObject *self, PyObject *args, PyObject *kwargs)\n{\n    static char *kwlist[] = {\"info\", NULL};\n    PyObject *info = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs, \"O:EphyPasswordManager.add_password\", kwlist, &info)) {\n        return NULL;\n    }\n\n    if ((Py_TYPE(info) == (PyTypeObject *)_PyGObject_API[20] || PyType_IsSubtype(Py_TYPE(info), (PyTypeObject *)_PyGObject_API[20])) &&\n        (G_TYPE_FROM_INSTANCE(info) == ephy_password_info_get_type())) {\n        EphyPasswordInfo *password_info = (EphyPasswordInfo *)G_TYPE_INSTANCE_GET_PRIVATE(info, ephy_password_info_get_type(), EphyPasswordInfo);\n        EphyPasswordManager *password_manager = (EphyPasswordManager *)g_type_check_instance_cast((GTypeInstance *)self, ephy_password_manager_get_type());\n        ephy_password_manager_add_password(password_manager, password_info);\n        Py_RETURN_NONE;\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"info should be a EphyPasswordInfo\");\n        return NULL;\n    }\n}",
        "baseline_code_stripped": "undefined1 * FUN_004ca070(long param_1,undefined8 param_2,undefined8 param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined1 *puVar6;\n  long local_18;\n  iVar3 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"O:EphyPasswordManager.add_password\",&PTR_s_info_00620a90,\n                     &local_18);\n  puVar6 = (undefined1 *)0x0;\n  if (iVar3 != 0) {\n    if (((*(long *)(local_18 + 8) == *(long *)(_PyGObject_API + 0x80)) ||\n        (iVar3 = PyType_IsSubtype(), iVar3 != 0)) &&\n       (lVar1 = *(long *)(local_18 + 0x18), lVar4 = ephy_password_info_get_type(), lVar1 == lVar4))\n    {\n      uVar2 = *(undefined8 *)(local_18 + 0x10);\n      uVar5 = ephy_password_manager_get_type();\n      uVar5 = g_type_check_instance_cast(*(undefined8 *)(param_1 + 0x10),uVar5);\n      ephy_password_manager_add_password(uVar5,uVar2);\n      _Py_NoneStruct._0_4_ = _Py_NoneStruct._0_4_ + 1;\n      puVar6 = _Py_NoneStruct;\n    }\n    else {\n      PyErr_SetString(PyExc_TypeError,\"info should be a EphyPasswordInfo\");\n      puVar6 = (undefined1 *)0x0;\n    }\n  }\n  return puVar6;\n}",
        "similarity_score_unixcoder": 0.8907310366630554,
        "similarity_score_baseline_stripped": 0.7029593586921692
    },
    {
        "func_name": "getGuard",
        "normed_func_sha256": "fa9da67e45a6fef8f712a6823fd4cf79fee510cdf38aecc82547cbe7e235f190",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_00017ce8(undefined4 param_1,undefined4 param_2,int *param_3,int param_4)\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  char acStack_e4 [200];\n  int local_1c;\n  local_1c = __stack_chk_guard;\n  if (param_3 != (int *)0x0) {\n    if ((*param_3 == 0) && (param_3[1] == 0)) {\n      iVar1 = FUN_0001afc4(param_2,param_3[3]);\n      uVar3 = *(undefined4 *)(iVar1 + 0xc);\n      param_3 = (int *)FUN_0001a504(*(undefined4 *)(iVar1 + 8));\n      if (param_3 != (int *)0x0) {\n        __sprintf_chk(acStack_e4,1,200,&DAT_00030518,param_1,uVar3);\n        if ((param_3[2] == 0) && (param_4 != 0 && param_3[8] != 0)) {\n          __strcat_chk(acStack_e4,&DAT_00030004,200);\n          param_3 = (int *)FUN_00017ce8(acStack_e4,param_3,param_3[8],param_4);\n        }\n        else {\n          param_3 = (int *)strlen(acStack_e4);\n        }\n      }\n    }\n    else {\n      iVar1 = FUN_00017ce8(param_1,param_2,*param_3,param_4);\n      iVar2 = FUN_00017ce8(param_1,param_2,param_3[1],param_4);\n      param_3 = (int *)(iVar1 + 4 + iVar2);\n    }\n  }\n  if (local_1c == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(param_3);\n}\n\n Revised code:\nint LenEmbed(char *prefix, struct nlist *np, struct embed *E, int flatten)\n/* return the number of characters required to print element E */\n{\n  char longstr[200];\n\n  if (E == NULL) return(0);\n  if (E->left == NULL && E->right == NULL) {\n    /* this is a root in our cell's embedding heirarchy */\n    struct objlist *ob;\n    char *instancename;\n    char *classname;\n    struct nlist *np2;\n\n    ob = InstanceNumber(np,E->instancenumber);\n    instancename = ob->instance;\n    classname = ob->classname;\n    np2 = LookupCell(classname);\n    if (np2 == NULL) return(0);\n    sprintf(longstr, \"%s%s\", prefix, instancename);\n    if (np2->primitive || np2->embedding == NULL || !flatten) \n      return(strlen(longstr));\n    /* else, prepend classname */\n    strcat(longstr,SEPARATOR);\n    return(LenEmbed(longstr, np2, (struct embed *)np2->embedding, flatten));\n  }\n\n  /* else it is a compound element (with 2 parentheses) */\n  return(PRINT_INDENT + 2 + LenEmbed(prefix, np, E->left, flatten) + \n\t LenEmbed(prefix, np, E->right, flatten));\n}\n\n## Example:\n\n Input code:\nvoid FUN_0002b4e0(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  char *pcVar4;\n  char acStack_3c [32];\n  int local_1c;\n  local_1c = __stack_chk_guard;\n  if ((DAT_000dbb58 & 1) != 0) {\n    if ((param_1 == 0) || (iVar1 = FUN_00025084(), param_1 == iVar1)) {\n      pcVar4 = \"platform\";\n    }\n    else {\n      pcVar4 = acStack_3c;\n      g_snprintf(pcVar4,0x20,\"%s[%p]\",\"platform\",param_1);\n    }\n    uVar2 = FUN_0002b1dc(param_5);\n    uVar3 = FUN_000299b0(param_4,0);\n    FUN_000222fc(\"src/platform/nm-platform.c\",0x1111,0,1,1,0,0,\"%s: signal: address 6 %7s: %s\",\n                 pcVar4,uVar2,uVar3);\n  }\n  if (local_1c == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid\n_free_signal (const char *file, int line, const char *func, SignalData *data)\n{\n\tdebug (\"NMPlatformSignalAssert: %s:%d, %s(): free signal: \"SIGNAL_DATA_FMT, file, line, func, SIGNAL_DATA_ARG (data));\n\tif (data->received_count != 0)\n\t\tg_error (\"NMPlatformSignalAssert: %s:%d, %s(): failure to free non-accepted signal: \"SIGNAL_DATA_FMT, file, line, func, SIGNAL_DATA_ARG (data));\n\tg_signal_handler_disconnect (nm_platform_get (), data->handler_id);\n\tg_free (data);\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_001de3a0(int param_1,int param_2,undefined8 param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  lVar1 = FUN_001de048();\n  if (lVar1 == 0 || param_1 == 0) {\n    uVar2 = FUN_00194788(param_3);\n    return uVar2;\n  }\n  uVar2 = FUN_00194788(*(undefined8 *)(lVar1 + 8));\n  if ((param_2 != 0) && (lVar1 = FUN_001de0f0(param_1,param_2), lVar1 != 0)) {\n    uVar2 = g_strconcat(uVar2,\" : \",*(undefined8 *)(lVar1 + 8),0);\n    return uVar2;\n  }\n  return uVar2;\n}\n\n Revised code:\ngchar *gsb_data_budget_get_name ( gint no_budget,\n                    gint no_sub_budget,\n                    const gchar *return_value_error )\n{\n    struct_budget *budget;\n    gchar *return_value;\n\n    budget = gsb_data_budget_get_structure ( no_budget );\n\n    if (!budget || !no_budget)\n\treturn my_strdup (return_value_error);\n\n    return_value = my_strdup ( budget -> budget_name );\n\n    if ( no_sub_budget )\n    {\n\tstruct_sub_budget *sub_budget;\n\n\tsub_budget = gsb_data_budget_get_sub_budget_structure ( no_budget,\n\t\t\t\t\t\t\t\tno_sub_budget );\n\n\tif (sub_budget)\n\t{\n\t    return_value = g_strconcat ( return_value,\n\t\t\t\t\t \" : \",\n\t\t\t\t\t sub_budget -> sub_budget_name,\n\t\t\t\t\t NULL );\n\t}\n    }\n    return return_value;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar * getGuard(int param_1)\n{\n  undefined8 uVar1;\n  undefined4 in_ESI;\n  undefined4 in_register_0000003c;\n  char *pcVar2;\n  cString acStack_28 [24];\n  pcVar2 = (char *)CONCAT44(in_register_0000003c,param_1);\n  switch(in_ESI) {\n  case 0:\n    cString::sprintf(pcVar2,&DAT_0012d554);\n    break;\n  case 1:\n    cString::sprintf(pcVar2,&DAT_0012d559);\n    break;\n  case 2:\n    cString::sprintf(pcVar2,&DAT_0012d55e);\n    break;\n  case 3:\n    cString::sprintf(pcVar2,&DAT_0012d562);\n    break;\n  case 4:\n    uVar1 = I18nTranslate(\"Auto\",\"femon\");\n    cString::sprintf((char *)acStack_28,\"%s\",uVar1);\n    cString::_cString(acStack_28);\n  default:\n    cString::sprintf(pcVar2,&DAT_00128586);\n  }\n  return pcVar2;\n}",
        "output": "```c\nchar *getGuard(int guardType)\n{\n    char *result;\n    cString tempString[24];\n\n    switch (guardType) {\n        case 0:\n            result = cString::sprintf(\"%s\", \"Guard Type 0\");\n            break;\n        case 1:\n            result = cString::sprintf(\"%s\", \"Guard Type 1\");\n            break;\n        case 2:\n            result = cString::sprintf(\"%s\", \"Guard Type 2\");\n            break;\n        case 3:\n            result = cString::sprintf(\"%s\", \"Guard Type 3\");\n            break;\n        case 4: {\n            const char *translatedText = I18nTranslate(\"Auto\", \"femon\");\n            cString::sprintf((char *)tempString, \"%s\", translatedText);\n            cString::_cString(tempString);\n            result = cString::sprintf(\"%s\", tempString);\n            break;\n        }\n        default:\n            result = cString::sprintf(\"%s\", \"Unknown Guard Type\");\n            break;\n    }\n\n    return result;\n}\n```",
        "source_code": "cString getGuard(int value)\n{\n  switch (value) {\n    case GUARD_INTERVAL_1_32: return cString::sprintf(\"1/32\");\n    case GUARD_INTERVAL_1_16: return cString::sprintf(\"1/16\");\n    case GUARD_INTERVAL_1_8:  return cString::sprintf(\"1/8\");\n    case GUARD_INTERVAL_1_4:  return cString::sprintf(\"1/4\");\n    case GUARD_INTERVAL_AUTO: cString::sprintf(\"%s\", tr(\"Auto\"));\n    }\n  return cString::sprintf(\"---\");\n}",
        "parsed_output": "char *getGuard(int guardType)\n{\n    char *result;\n    cString tempString[24];\n\n    switch (guardType) {\n        case 0:\n            result = cString::sprintf(\"%s\", \"Guard Type 0\");\n            break;\n        case 1:\n            result = cString::sprintf(\"%s\", \"Guard Type 1\");\n            break;\n        case 2:\n            result = cString::sprintf(\"%s\", \"Guard Type 2\");\n            break;\n        case 3:\n            result = cString::sprintf(\"%s\", \"Guard Type 3\");\n            break;\n        case 4: {\n            const char *translatedText = I18nTranslate(\"Auto\", \"femon\");\n            cString::sprintf((char *)tempString, \"%s\", translatedText);\n            cString::_cString(tempString);\n            result = cString::sprintf(\"%s\", tempString);\n            break;\n        }\n        default:\n            result = cString::sprintf(\"%s\", \"Unknown Guard Type\");\n            break;\n    }\n\n    return result;\n}",
        "baseline_code_stripped": "char * getGuard(int param_1)\n{\n  undefined8 uVar1;\n  undefined4 in_ESI;\n  undefined4 in_register_0000003c;\n  char *pcVar2;\n  cString acStack_28 [24];\n  pcVar2 = (char *)CONCAT44(in_register_0000003c,param_1);\n  switch(in_ESI) {\n  case 0:\n    cString::sprintf(pcVar2,&DAT_0012d554);\n    break;\n  case 1:\n    cString::sprintf(pcVar2,&DAT_0012d559);\n    break;\n  case 2:\n    cString::sprintf(pcVar2,&DAT_0012d55e);\n    break;\n  case 3:\n    cString::sprintf(pcVar2,&DAT_0012d562);\n    break;\n  case 4:\n    uVar1 = I18nTranslate(\"Auto\",\"femon\");\n    cString::sprintf((char *)acStack_28,\"%s\",uVar1);\n    cString::_cString(acStack_28);\n  default:\n    cString::sprintf(pcVar2,&DAT_00128586);\n  }\n  return pcVar2;\n}",
        "similarity_score_unixcoder": 0.7702319622039795,
        "similarity_score_baseline_stripped": 0.5830280184745789
    },
    {
        "func_name": "_wrap_ColorShift_SetJsonValue",
        "normed_func_sha256": "cee1148d3ea61c3c3baf1ef9ea29a39f11cac582360540b57e55f906871652fd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_002c6170(int param_1,undefined4 *param_2,undefined4 param_3)\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 extraout_ECX;\n  int in_GS_OFFSET;\n  undefined8 uVar5;\n  iVar1 = *(int *)(in_GS_OFFSET + 0x14);\n  if (param_1 != 2) {\n    rb_raise(_rb_eArgError,\"wrong # of arguments(%d for 2)\",param_1,param_2);\n  }\n  iVar2 = FUN_003ef980(0);\n  if (iVar2 < 0) {\n    uVar3 = FUN_000c5cd0(1,param_3,extraout_ECX,extraout_ECX);\n  }\n  else {\n    iVar2 = FUN_000c65c0();\n    if (iVar2 < 0) {\n      uVar3 = FUN_000c5cd0(2,*param_2,iVar2,iVar2);\n    }\n    else {\n      uVar5 = FUN_000c65c0();\n      uVar3 = (undefined4)((ulonglong)uVar5 >> 0x20);\n      if (-1 < (int)uVar5) {\n        FUN_000d9ce0();\n        if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {\n          FUN_003f2a20();\n        }\n        return;\n      }\n      uVar3 = FUN_000c5cd0(3,param_2[1],uVar3,uVar3);\n    }\n  }\n  uVar4 = FUN_000c5b60();\n  rb_raise(uVar4,&DAT_003f3181,uVar3);\n}\n\n Revised code:\nSWIGINTERN VALUE\n_wrap_VectorConstTmpfsPtr_slice(int argc, VALUE *argv, VALUE self) {\n  std::vector< storage::Tmpfs const * > *arg1 = (std::vector< storage::Tmpfs const * > *) 0 ;\n  std::vector< storage::Tmpfs const * >::difference_type arg2 ;\n  std::vector< storage::Tmpfs const * >::difference_type arg3 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  ptrdiff_t val2 ;\n  int ecode2 = 0 ;\n  ptrdiff_t val3 ;\n  int ecode3 = 0 ;\n  VALUE result;\n  VALUE vresult = Qnil;\n  \n  if ((argc < 2) || (argc > 2)) {\n    rb_raise(rb_eArgError, \"wrong # of arguments(%d for 2)\",argc); SWIG_fail;\n  }\n  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_storage__Tmpfs_const_p_std__allocatorT_storage__Tmpfs_const_p_t_t, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( \"\", \"std::vector< storage::Tmpfs const * > *\",\"slice\", 1, self )); \n  }\n  arg1 = reinterpret_cast< std::vector< storage::Tmpfs const * > * >(argp1);\n  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( \"\", \"std::vector< storage::Tmpfs const * >::difference_type\",\"slice\", 2, argv[0] ));\n  } \n  arg2 = static_cast< std::vector< storage::Tmpfs const * >::difference_type >(val2);\n  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);\n  if (!SWIG_IsOK(ecode3)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( \"\", \"std::vector< storage::Tmpfs const * >::difference_type\",\"slice\", 3, argv[1] ));\n  } \n  arg3 = static_cast< std::vector< storage::Tmpfs const * >::difference_type >(val3);\n  try {\n    result = (VALUE)std_vector_Sl_storage_Tmpfs_SS_const_Sm__Sg__slice(arg1,arg2,arg3);\n  } catch(std::invalid_argument &_e) {\n    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());\n  }\n  vresult = result;\n  return vresult;\nfail:\n  return Qnil;\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_00255000(int param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 extraout_ECX;\n  int in_GS_OFFSET;\n  undefined8 uVar3;\n  int *local_38;\n  int local_30 [4];\n  int local_20;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  if (param_1 != 0) {\n    rb_raise(_rb_eArgError,\"wrong # of arguments(%d for 0)\",param_1);\n  }\n  iVar1 = FUN_004053d0(0);\n  if (-1 < iVar1) {\n    if (_DAT_00000004 == iRam00000000) {\n      if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n        return 4;\n      }\n    }\n    else {\n      _DAT_00000004 = _DAT_00000004 + -4;\n      if ((swig::traits_info<storage::Luks>::type_info()::info == '\\0') &&\n         (iVar1 = __cxa_guard_acquire(&swig::traits_info<storage::Luks>::type_info()::info),\n         iVar1 != 0)) {\n        FUN_00405920();\n        swig::traits_info<storage::Luks>::type_info()::info = FUN_0038bec0();\n        __cxa_guard_release(&swig::traits_info<storage::Luks>::type_info()::info);\n        if (local_38 != local_30) {\n          operator_delete(local_38,local_30[0] + 1);\n        }\n      }\n      if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n        uVar2 = FUN_000cb1c0();\n        return uVar2;\n      }\n    }\n    FUN_004087f0();\n  }\n  uVar2 = FUN_000caf90(1,param_3,extraout_ECX,extraout_ECX);\n  uVar3 = FUN_000cae20();\n  rb_raise((int)uVar3,&DAT_0040918d,uVar2,(int)((ulonglong)uVar3 >> 0x20));\n}\n\n Revised code:\nSWIGINTERN VALUE\n_wrap_new_IndexOutOfRangeException__SWIG_1(int argc, VALUE *argv, VALUE self) {\n  int arg1 ;\n  int arg2 ;\n  int arg3 ;\n  int val1 ;\n  int ecode1 = 0 ;\n  int val2 ;\n  int ecode2 = 0 ;\n  int val3 ;\n  int ecode3 = 0 ;\n  const char *classname SWIGUNUSED = \"Storage::IndexOutOfRangeException\";\n  storage::IndexOutOfRangeException *result = 0 ;\n  \n  if ((argc < 3) || (argc > 3)) {\n    rb_raise(rb_eArgError, \"wrong # of arguments(%d for 3)\",argc); SWIG_fail;\n  }\n  ecode1 = SWIG_AsVal_int(argv[0], &val1);\n  if (!SWIG_IsOK(ecode1)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( \"\", \"int\",\"IndexOutOfRangeException\", 1, argv[0] ));\n  } \n  arg1 = static_cast< int >(val1);\n  ecode2 = SWIG_AsVal_int(argv[1], &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( \"\", \"int\",\"IndexOutOfRangeException\", 2, argv[1] ));\n  } \n  arg2 = static_cast< int >(val2);\n  ecode3 = SWIG_AsVal_int(argv[2], &val3);\n  if (!SWIG_IsOK(ecode3)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( \"\", \"int\",\"IndexOutOfRangeException\", 3, argv[2] ));\n  } \n  arg3 = static_cast< int >(val3);\n  result = (storage::IndexOutOfRangeException *)new storage::IndexOutOfRangeException(arg1,arg2,arg3);\n  DATA_PTR(self) = result;\n  return self;\nfail:\n  return Qnil;\n}\n\n## Example:\n\n Input code:\nvoid FUN_00eb7bd0(undefined8 *param_1,undefined4 param_2)\n{\n  undefined8 uVar1;\n  undefined4 uVar2;\n  int *piVar3;\n  int iVar4;\n  int in_GS_OFFSET;\n  undefined local_5c [4];\n  undefined local_58 [8];\n  int local_50;\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0xeb7bd9;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  FUN_04a1b140(local_5c,0x6052b6c9,(-(uint)(*(char *)((int)param_1 + 0xc) == '\\0') & 0xfffffffc) + 6\n               ,0,0,0);\n  iVar4 = FUN_04a180e0(local_58,0x10);\n  FUN_00c83d00(iVar4 + local_50);\n  uVar1 = *param_1;\n  *(undefined4 *)(local_50 + 8 + iVar4) = param_2;\n  uVar2 = *(undefined4 *)(param_1 + 1);\n  *(undefined8 *)(local_50 + 0x18) = uVar1;\n  *(undefined4 *)(local_50 + 0x14) = uVar2;\n  FUN_04a1ef00(*(undefined4 *)(param_1 + 2),local_5c);\n  piVar3 = *(int **)(param_1 + 2);\n  *(undefined4 *)(param_1 + 2) = 0;\n  if (piVar3 != (int *)0x0) {\n    (**(code **)(*piVar3 + 4))(piVar3);\n  }\n  FUN_04a18e30(local_5c);\n  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  FUN_09e60090();\n}\n\n Revised code:\nvoid CookieManager_DeleteSessionOnlyCookies_ProxyToResponder::Run(\n    uint32_t in_num_deleted) {\n#if BUILDFLAG(MOJO_TRACE_ENABLED)\n  TRACE_EVENT1(\n    \"mojom\", \"Send reply network::mojom::CookieManager::DeleteSessionOnlyCookies\", \"async_response_parameters\",\n    [&](perfetto::TracedValue context){\n      auto dict = std::move(context).WriteDictionary();\n      perfetto::WriteIntoTracedValueWithFallback(\n           dict.AddItem(\"num_deleted\"), in_num_deleted,\n                        \"<value of type uint32_t>\");\n   });\n#endif\n  \n  const uint32_t kFlags = mojo::Message::kFlagIsResponse |\n      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |\n      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);\n  \n  mojo::Message message(\n      internal::kCookieManager_DeleteSessionOnlyCookies_Name, kFlags, 0, 0, nullptr);\n  mojo::internal::MessageFragment<\n      ::network::mojom::internal::CookieManager_DeleteSessionOnlyCookies_ResponseParams_Data> params(\n          message);\n  params.Allocate();\n  params->num_deleted = in_num_deleted;\n\n#if defined(ENABLE_IPC_FUZZER)\n  message.set_interface_name(CookieManager::Name_);\n  message.set_method_name(\"DeleteSessionOnlyCookies\");\n#endif\n\n  message.set_request_id(request_id_);\n  message.set_trace_nonce(trace_nonce_);\n  ::mojo::internal::SendMojoMessage(*responder_, message);\n  // SendMojoMessage() fails silently if the responder connection is closed,\n  // or if the message is malformed.\n  //\n  // TODO(darin): If Accept() returns false due to a malformed message, that\n  // may be good reason to close the connection. However, we don't have a\n  // way to do that from here. We should add a way.\n  responder_ = nullptr;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_00058cd0(int param_1,undefined4 *param_2,undefined4 param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 extraout_ECX;\n  int in_GS_OFFSET;\n  undefined8 uVar5;\n  Value *local_54;\n  Value local_50 [24];\n  Value local_38 [24];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x58cdb;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar2 = Json::Value::Value(local_50,0);\n  if (param_1 != 1) {\n    rb_raise(_rb_eArgError,\"wrong # of arguments(%d for 1)\",param_1,uVar2);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(1,param_3,param_2,param_2);\n    if (iVar3 == -1) {\n      iVar3 = -5;\n    }\n    uVar4 = FUN_0003948e();\n    rb_raise(uVar4,&DAT_0013fdc3,uVar2,iVar3);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(2,*param_2,extraout_ECX,extraout_ECX);\n    uVar5 = FUN_0003948e();\n    rb_raise((int)uVar5,&DAT_0013fdc3,uVar2,(int)((ulonglong)uVar5 >> 0x20));\n  }\n  if (local_54 != (Value *)0x0) {\n    Json::Value::Value(local_38,local_54);\n    Json::Value::operator_(local_50,SUB41(local_38,0));\n    Json::Value::_Value(local_38);\n    pcVar1 = *(code **)(iRam00000000 + 0x24);\n    Json::Value::Value(local_38,local_50);\n    (*pcVar1)(0,local_38);\n    Json::Value::_Value(local_38);\n    Json::Value::_Value(local_50);\n    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n      return 4;\n    }\n    FUN_0013fce0();\n  }\n  uVar2 = FUN_000392b0(2,*param_2,0,0);\n  rb_raise(_rb_eArgError,&DAT_0013fdc3,uVar2);\n}",
        "output": "```c\nSWIGINTERN VALUE\n_wrap_JsonValue_Operator(int argc, VALUE *argv, VALUE self) {\n  Json::Value *arg1 = nullptr;\n  Json::Value arg2;\n  Json::Value temp_value1;\n  Json::Value temp_value2;\n  void *argp1 = nullptr;\n  int res1 = 0;\n  VALUE result = Qnil;\n\n  if (argc != 1) {\n    rb_raise(rb_eArgError, \"wrong # of arguments(%d for 1)\", argc);\n    return Qnil;\n  }\n\n  res1 = SWIG_ConvertPtr(self, &argp1, SWIGTYPE_p_Json__Value, 0 | 0);\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError(\"\", \"Json::Value *\", \"operator\", 1, self));\n  }\n  arg1 = reinterpret_cast<Json::Value *>(argp1);\n\n  try {\n    SWIG_AsVal_JsonValue(argv[0], &arg2);\n\n    Json::Value::Value(temp_value1, *arg1);\n    Json::Value::operator_(temp_value1, arg2);\n    Json::Value::Value(temp_value2, temp_value1);\n\n    result = SWIG_NewPointerObj(new Json::Value(temp_value2), SWIGTYPE_p_Json__Value, SWIG_POINTER_OWN);\n  } catch (const std::exception &e) {\n    rb_raise(rb_eRuntimeError, \"%s\", e.what());\n  }\n\n  Json::Value::_Value(temp_value1);\n  Json::Value::_Value(temp_value2);\n\n  return result;\n\nfail:\n  return Qnil;\n}\n```",
        "source_code": "SWIGINTERN VALUE\n_wrap_ColorShift_SetJsonValue(int argc, VALUE *argv, VALUE self) {\n  openshot::ColorShift *arg1 = (openshot::ColorShift *) 0 ;\n  Json::Value arg2 ;\n  void *argp1 = 0 ;\n  int res1 = 0 ;\n  void *argp2 ;\n  int res2 = 0 ;\n  \n  if ((argc < 1) || (argc > 1)) {\n    rb_raise(rb_eArgError, \"wrong # of arguments(%d for 1)\",argc); SWIG_fail;\n  }\n  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_openshot__ColorShift, 0 |  0 );\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( \"\", \"openshot::ColorShift *\",\"SetJsonValue\", 1, self )); \n  }\n  arg1 = reinterpret_cast< openshot::ColorShift * >(argp1);\n  {\n    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_Json__Value,  0 );\n    if (!SWIG_IsOK(res2)) {\n      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( \"\", \"Json::Value const\",\"SetJsonValue\", 2, argv[0] )); \n    }  \n    if (!argp2) {\n      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError(\"invalid null reference \", \"Json::Value const\",\"SetJsonValue\", 2, argv[0]));\n    } else {\n      arg2 = *(reinterpret_cast< Json::Value * >(argp2));\n    }\n  }\n  (arg1)->SetJsonValue(arg2);\n  return Qnil;\nfail:\n  return Qnil;\n}",
        "parsed_output": "SWIGINTERN VALUE\n_wrap_JsonValue_Operator(int argc, VALUE *argv, VALUE self) {\n  Json::Value *arg1 = nullptr;\n  Json::Value arg2;\n  Json::Value temp_value1;\n  Json::Value temp_value2;\n  void *argp1 = nullptr;\n  int res1 = 0;\n  VALUE result = Qnil;\n\n  if (argc != 1) {\n    rb_raise(rb_eArgError, \"wrong # of arguments(%d for 1)\", argc);\n    return Qnil;\n  }\n\n  res1 = SWIG_ConvertPtr(self, &argp1, SWIGTYPE_p_Json__Value, 0 | 0);\n  if (!SWIG_IsOK(res1)) {\n    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError(\"\", \"Json::Value *\", \"operator\", 1, self));\n  }\n  arg1 = reinterpret_cast<Json::Value *>(argp1);\n\n  try {\n    SWIG_AsVal_JsonValue(argv[0], &arg2);\n\n    Json::Value::Value(temp_value1, *arg1);\n    Json::Value::operator_(temp_value1, arg2);\n    Json::Value::Value(temp_value2, temp_value1);\n\n    result = SWIG_NewPointerObj(new Json::Value(temp_value2), SWIGTYPE_p_Json__Value, SWIG_POINTER_OWN);\n  } catch (const std::exception &e) {\n    rb_raise(rb_eRuntimeError, \"%s\", e.what());\n  }\n\n  Json::Value::_Value(temp_value1);\n  Json::Value::_Value(temp_value2);\n\n  return result;\n\nfail:\n  return Qnil;\n}",
        "baseline_code_stripped": "undefined4 FUN_00058cd0(int param_1,undefined4 *param_2,undefined4 param_3)\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 extraout_ECX;\n  int in_GS_OFFSET;\n  undefined8 uVar5;\n  Value *local_54;\n  Value local_50 [24];\n  Value local_38 [24];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x58cdb;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  uVar2 = Json::Value::Value(local_50,0);\n  if (param_1 != 1) {\n    rb_raise(_rb_eArgError,\"wrong # of arguments(%d for 1)\",param_1,uVar2);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(1,param_3,param_2,param_2);\n    if (iVar3 == -1) {\n      iVar3 = -5;\n    }\n    uVar4 = FUN_0003948e();\n    rb_raise(uVar4,&DAT_0013fdc3,uVar2,iVar3);\n  }\n  iVar3 = FUN_0003e770(0,0);\n  if (iVar3 < 0) {\n    uVar2 = FUN_000392b0(2,*param_2,extraout_ECX,extraout_ECX);\n    uVar5 = FUN_0003948e();\n    rb_raise((int)uVar5,&DAT_0013fdc3,uVar2,(int)((ulonglong)uVar5 >> 0x20));\n  }\n  if (local_54 != (Value *)0x0) {\n    Json::Value::Value(local_38,local_54);\n    Json::Value::operator_(local_50,SUB41(local_38,0));\n    Json::Value::_Value(local_38);\n    pcVar1 = *(code **)(iRam00000000 + 0x24);\n    Json::Value::Value(local_38,local_50);\n    (*pcVar1)(0,local_38);\n    Json::Value::_Value(local_38);\n    Json::Value::_Value(local_50);\n    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {\n      return 4;\n    }\n    FUN_0013fce0();\n  }\n  uVar2 = FUN_000392b0(2,*param_2,0,0);\n  rb_raise(_rb_eArgError,&DAT_0013fdc3,uVar2);\n}",
        "similarity_score_unixcoder": 0.8469511866569519,
        "similarity_score_baseline_stripped": 0.5859085917472839
    },
    {
        "func_name": "lu_shadow_uses_elevated_privileges",
        "normed_func_sha256": "52320d3b6a1ca684d2aefa145f40839fcc9dfb973bc0a2677aec0765513bb45d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined4 * FUN_00019764(int param_1,undefined4 param_2)\n{\n  undefined4 *puVar1;\n  int iVar2;\n  undefined4 uVar3;\n  if (param_1 == 0) {\n    g_return_if_fail_warning(0,\"fcontents_read\",\"fname\");\n  }\n  else {\n    puVar1 = (undefined4 *)g_malloc0(0x3c);\n    puVar1[2] = 0;\n    puVar1[3] = &LAB_0001cf9c;\n    puVar1[4] = &LAB_0001cfcc;\n    puVar1[5] = &LAB_0001d040;\n    puVar1[6] = &LAB_0001d0ac;\n    puVar1[7] = &LAB_0001d070;\n    puVar1[8] = &LAB_0001d0e8;\n    puVar1[9] = &LAB_0001d124;\n    puVar1[10] = &LAB_0001d19c;\n    puVar1[0xb] = &LAB_0001d210;\n    puVar1[0xc] = &LAB_0001d1d0;\n    iVar2 = g_file_get_contents(param_1,puVar1 + 1,puVar1 + 0xd,param_2);\n    if (iVar2 != 0) {\n      uVar3 = g_strdup(param_1);\n      *puVar1 = uVar3;\n      return puVar1;\n    }\n    g_free(puVar1);\n  }\n  return (undefined4 *)0x0;\n}\n\n Revised code:\nstatic FContents *fcontents_read (const gchar *fname, GError **error)\n{\n    FContents *cts;\n\n    g_return_val_if_fail (fname, NULL);\n\n    cts = g_new0 (FContents, 1);\n    fcontents_set_reversed (cts, FALSE);\n\n    if (g_file_get_contents (fname, &cts->contents, &cts->length, error))\n    {\n\tcts->filename = g_strdup (fname);\n    }\n    else\n    {\n\tg_free (cts);\n\tcts = NULL;\n    }\n    return cts;\n}\n\n## Example:\n\n Input code:\nbool FUN_00016210(undefined4 param_1,int param_2)\n{\n  undefined4 uVar1;\n  uint uVar2;\n  uint uVar3;\n  if (*(int *)(param_2 + 4) != 1) {\n    return false;\n  }\n  uVar1 = g_build_filename(*(undefined4 *)(param_2 + 0xc),\"mail\",0);\n  uVar2 = g_file_test(uVar1,4);\n  g_free(uVar1);\n  uVar1 = g_build_filename(*(undefined4 *)(param_2 + 0xc),\".addressbook\",0);\n  uVar3 = g_file_test(uVar1,1);\n  g_free(uVar1);\n  return (uVar3 | uVar2) != 0;\n}\n\n Revised code:\nstatic gboolean\npine_supported(EImport *ei, EImportTarget *target, EImportImporter *im)\n{\n\tEImportTargetHome *s;\n\tchar *maildir, *addrfile;\n\tgboolean md_exists, addr_exists;\n\n\tif (target->type != E_IMPORT_TARGET_HOME)\n\t\treturn FALSE;\n\n\ts = (EImportTargetHome *)target;\n\n\tmaildir = g_build_filename(s->homedir, \"mail\", NULL);\n\tmd_exists = g_file_test(maildir, G_FILE_TEST_IS_DIR);\n\tg_free(maildir);\n\n\taddrfile = g_build_filename(s->homedir, \".addressbook\", NULL);\n\taddr_exists = g_file_test(addrfile, G_FILE_TEST_IS_REGULAR);\n\tg_free (addrfile);\n\n\treturn md_exists || addr_exists;\n}\n\n## Example:\n\n Input code:\nint FUN_00072990(void)\n{\n  char *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  int iVar4;\n  int param_5;\n  iVar4 = 0;\n  pcVar1 = *(char **)(param_5 + 8);\n  if (pcVar1 != (char *)0x0) {\n    uVar2 = g_strchug(pcVar1);\n    g_strchomp(uVar2);\n    if (*pcVar1 == '\\0') {\n      g_free(*(undefined4 *)(param_5 + 8));\n      *(undefined4 *)(param_5 + 8) = 0;\n      return 0;\n    }\n    iVar4 = 1;\n    iVar3 = FUN_0006d4a0(0,3,0,1,0,0,1);\n    if (iVar3 != 0) {\n      iVar4 = FUN_00110cd0(iVar3,pcVar1);\n      if (iVar4 != 0) {\n        FUN_00072710(*(undefined4 *)(param_5 + 4),iVar4);\n      }\n      FUN_00110e70(iVar3);\n    }\n  }\n  return iVar4;\n}\n\n Revised code:\nstatic int \nfit_put_weight_func(struct objlist *obj,N_VALUE *inst,N_VALUE *rval,\n           int argc,char **argv)\n{\n  char *math;\n  MathEquation *code;\n  int rcode;\n  math = argv[2];\n  if (math == NULL) {\n    return 0;\n  }\n  g_strstrip(math);\n  if (math[0] == '\\0') {\n    g_free(argv[2]);\n    argv[2] = NULL;\n    return 0;\n  }\n  code = ofile_create_math_equation(NULL, TRUE, FALSE, TRUE, FALSE, FALSE);\n  if (code == NULL)\n    return 1;\n  rcode = math_equation_parse(code, math);\n  if (rcode) {\n    show_eqn_error(obj, code, math, argv[1], rcode);\n  }\n  math_equation_free(code);\n  return rcode;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nbool FUN_00013089(int param_1)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  char *pcVar3;\n  int iVar4;\n  int iVar5;\n  uVar1 = g_strconcat(*(undefined4 *)(param_1 + 0xc),\"/directory\",0);\n  uVar2 = lu_cfg_read_single(*(undefined4 *)(param_1 + 0x10),uVar1,&DAT_00018a38);\n  g_free(uVar1);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/shadow\",0);\n  iVar4 = access(pcVar3,6);\n  g_free(pcVar3);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/gshadow\",0);\n  iVar5 = access(pcVar3,6);\n  g_free(pcVar3);\n  return iVar5 != 0 || iVar4 != 0;\n}",
        "output": "```c\nstatic gboolean\ncheck_shadow_files(Config *config)\n{\n    char *directory_path;\n    char *shadow_path;\n    char *gshadow_path;\n    gboolean shadow_exists, gshadow_exists;\n\n    directory_path = g_strconcat(config->base_path, \"/directory\", NULL);\n    char *resolved_path = lu_cfg_read_single(config->cfg, directory_path, &DAT_00018a38);\n    g_free(directory_path);\n\n    shadow_path = g_strdup_printf(\"%s/%s/shadow\", resolved_path, resolved_path);\n    shadow_exists = (access(shadow_path, R_OK | W_OK) == 0);\n    g_free(shadow_path);\n\n    gshadow_path = g_strdup_printf(\"%s/%s/gshadow\", resolved_path, resolved_path);\n    gshadow_exists = (access(gshadow_path, R_OK | W_OK) == 0);\n    g_free(gshadow_path);\n\n    return shadow_exists || gshadow_exists;\n}\n```",
        "source_code": "static gboolean\nlu_shadow_uses_elevated_privileges(struct lu_module *module)\n{\n\tconst char *directory;\n\tchar *path, *key;\n\tgboolean ret = FALSE;\n\t/* Get the directory the files are in. */\n\tkey = g_strconcat(module->name, \"/directory\", NULL);\n\tdirectory = lu_cfg_read_single(module->lu_context, key, SYSCONFDIR);\n\tg_free(key);\n\t/* If we can't access the shadow file as a normal user, then the\n\t * answer is \"yes\". */\n\tpath = g_strconcat(\"%s/%s\", directory, \"/shadow\", NULL);\n\tif (access(path, R_OK | W_OK) != 0) {\n\t\tret = TRUE;\n\t}\n\tg_free(path);\n\t/* If we can't access the gshadow file as a normal user, then the\n\t * answer is \"yes\". */\n\tpath = g_strconcat(\"%s/%s\", directory, \"/gshadow\", NULL);\n\tif (access(path, R_OK | W_OK) != 0) {\n\t\tret = TRUE;\n\t}\n\tg_free(path);\n\treturn ret;\n}",
        "parsed_output": "static gboolean\ncheck_shadow_files(Config *config)\n{\n    char *directory_path;\n    char *shadow_path;\n    char *gshadow_path;\n    gboolean shadow_exists, gshadow_exists;\n\n    directory_path = g_strconcat(config->base_path, \"/directory\", NULL);\n    char *resolved_path = lu_cfg_read_single(config->cfg, directory_path, &DAT_00018a38);\n    g_free(directory_path);\n\n    shadow_path = g_strdup_printf(\"%s/%s/shadow\", resolved_path, resolved_path);\n    shadow_exists = (access(shadow_path, R_OK | W_OK) == 0);\n    g_free(shadow_path);\n\n    gshadow_path = g_strdup_printf(\"%s/%s/gshadow\", resolved_path, resolved_path);\n    gshadow_exists = (access(gshadow_path, R_OK | W_OK) == 0);\n    g_free(gshadow_path);\n\n    return shadow_exists || gshadow_exists;\n}",
        "baseline_code_stripped": "bool FUN_00013089(int param_1)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  char *pcVar3;\n  int iVar4;\n  int iVar5;\n  uVar1 = g_strconcat(*(undefined4 *)(param_1 + 0xc),\"/directory\",0);\n  uVar2 = lu_cfg_read_single(*(undefined4 *)(param_1 + 0x10),uVar1,&DAT_00018a38);\n  g_free(uVar1);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/shadow\",0);\n  iVar4 = access(pcVar3,6);\n  g_free(pcVar3);\n  pcVar3 = (char *)g_strconcat(\"%s/%s\",uVar2,\"/gshadow\",0);\n  iVar5 = access(pcVar3,6);\n  g_free(pcVar3);\n  return iVar5 != 0 || iVar4 != 0;\n}",
        "similarity_score_unixcoder": 0.679590106010437,
        "similarity_score_baseline_stripped": 0.5106364488601685
    },
    {
        "func_name": "sequeler_widgets_connection_dialog_class_init",
        "normed_func_sha256": "ddc6034aff01cf7ce7461601663446e999c5617d85f93f43f9ca537883a8840b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid pomodoro_accelerator_class_init(long param_1)\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  DAT_0033b078 = g_type_class_peek_parent();\n  g_type_class_add_private(param_1,8);\n  *(code **)(param_1 + 0x88) = pomodoro_accelerator_real_changed;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x20) = _vala_pomodoro_accelerator_get_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x18) = _vala_pomodoro_accelerator_set_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x30) = pomodoro_accelerator_finalize;\n  uVar2 = g_param_spec_string(\"name\",\"name\",\"name\",0,0xe3);\n  DAT_0033b098 = uVar2;\n  uVar3 = g_type_check_class_cast(param_1,0x50);\n  g_object_class_install_property(uVar3,1,uVar2);\n  uVar2 = g_param_spec_string(\"display-name\",\"display-name\",\"display-name\",0,0xe1);\n  _DAT_0033b0a0 = uVar2;\n  uVar3 = g_type_check_class_cast(param_1,0x50);\n  g_object_class_install_property(uVar3,2,uVar2);\n  uVar2 = pomodoro_accelerator_get_type();\n  DAT_0033b080 = g_signal_new(\"changed\",uVar2,2,0x88,0,0,g_cclosure_marshal_VOID__VOID,4,0);\n  return;\n}\n\n Revised code:\nstatic void pomodoro_accelerator_class_init (PomodoroAcceleratorClass * klass) {\n\tpomodoro_accelerator_parent_class = g_type_class_peek_parent (klass);\n\tg_type_class_add_private (klass, sizeof (PomodoroAcceleratorPrivate));\n\t((PomodoroAcceleratorClass *) klass)->changed = pomodoro_accelerator_real_changed;\n\tG_OBJECT_CLASS (klass)->get_property = _vala_pomodoro_accelerator_get_property;\n\tG_OBJECT_CLASS (klass)->set_property = _vala_pomodoro_accelerator_set_property;\n\tG_OBJECT_CLASS (klass)->finalize = pomodoro_accelerator_finalize;\n\tg_object_class_install_property (G_OBJECT_CLASS (klass), POMODORO_ACCELERATOR_NAME_PROPERTY, pomodoro_accelerator_properties[POMODORO_ACCELERATOR_NAME_PROPERTY] = g_param_spec_string (\"name\", \"name\", \"name\", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));\n\tg_object_class_install_property (G_OBJECT_CLASS (klass), POMODORO_ACCELERATOR_DISPLAY_NAME_PROPERTY, pomodoro_accelerator_properties[POMODORO_ACCELERATOR_DISPLAY_NAME_PROPERTY] = g_param_spec_string (\"display-name\", \"display-name\", \"display-name\", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));\n\tpomodoro_accelerator_signals[POMODORO_ACCELERATOR_CHANGED_SIGNAL] = g_signal_new (\"changed\", POMODORO_TYPE_ACCELERATOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (PomodoroAcceleratorClass, changed), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);\n}\n\n## Example:\n\n Input code:\nvoid FUN_00115bc0(undefined8 param_1)\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  DAT_0012f140 = g_type_class_peek_parent();\n  g_type_class_adjust_private_offset(param_1,&DAT_0012f148);\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x20) = FUN_00117430;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x18) = FUN_00117360;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x10) = FUN_001170e0;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x30) = FUN_00117080;\n  uVar2 = gtk_style_context_get_type();\n  uVar2 = g_param_spec_object(\"context\",\"context\",\"context\",uVar2,0xe7);\n  DAT_0012f158 = uVar2;\n  uVar3 = g_type_check_class_cast(param_1,0x50);\n  g_object_class_install_property(uVar3,1,uVar2);\n  uVar2 = g_param_spec_int(\"scale\",\"scale\",\"scale\",0x80000000,0x7fffffff,0,0xe3);\n  DAT_0012f160 = uVar2;\n  uVar3 = g_type_check_class_cast(param_1,0x50);\n  g_object_class_install_property(uVar3,2,uVar2);\n  return;\n}\n\n Revised code:\nstatic void\nmarlin_view_chrome_breadcrumb_icon_list_class_init (MarlinViewChromeBreadcrumbIconListClass * klass,\n                                                    gpointer klass_data)\n{\n\tmarlin_view_chrome_breadcrumb_icon_list_parent_class = g_type_class_peek_parent (klass);\n\tg_type_class_adjust_private_offset (klass, &MarlinViewChromeBreadcrumbIconList_private_offset);\n\tG_OBJECT_CLASS (klass)->get_property = _vala_marlin_view_chrome_breadcrumb_icon_list_get_property;\n\tG_OBJECT_CLASS (klass)->set_property = _vala_marlin_view_chrome_breadcrumb_icon_list_set_property;\n\tG_OBJECT_CLASS (klass)->constructor = marlin_view_chrome_breadcrumb_icon_list_constructor;\n\tG_OBJECT_CLASS (klass)->finalize = marlin_view_chrome_breadcrumb_icon_list_finalize;\n\tg_object_class_install_property (G_OBJECT_CLASS (klass), MARLIN_VIEW_CHROME_BREADCRUMB_ICON_LIST_CONTEXT_PROPERTY, marlin_view_chrome_breadcrumb_icon_list_properties[MARLIN_VIEW_CHROME_BREADCRUMB_ICON_LIST_CONTEXT_PROPERTY] = g_param_spec_object (\"context\", \"context\", \"context\", gtk_style_context_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));\n\tg_object_class_install_property (G_OBJECT_CLASS (klass), MARLIN_VIEW_CHROME_BREADCRUMB_ICON_LIST_SCALE_PROPERTY, marlin_view_chrome_breadcrumb_icon_list_properties[MARLIN_VIEW_CHROME_BREADCRUMB_ICON_LIST_SCALE_PROPERTY] = g_param_spec_int (\"scale\", \"scale\", \"scale\", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));\n}\n\n## Example:\n\n Input code:\nvoid FUN_00445d80(undefined8 param_1)\n{\n  long lVar1;\n  undefined8 uVar2;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  DAT_005e2eb8 = g_type_class_peek_parent(param_1);\n  *(code **)(lVar1 + 0x30) = FUN_00446140;\n  *(code **)(lVar1 + 0x18) = FUN_00445e10;\n  *(code **)(lVar1 + 0x20) = FUN_00445e80;\n  uVar2 = ephy_window_get_type();\n  uVar2 = g_param_spec_object(\"EphyWindow\",\"EphyWindow\",\"Parent window\",uVar2,3);\n  g_object_class_install_property(lVar1,1,uVar2);\n  return;\n}\n\n Revised code:\nstatic void\nppview_toolbar_class_init (PPViewToolbarClass *klass)\n{\n        GObjectClass *object_class = G_OBJECT_CLASS (klass);\n\n        parent_class = g_type_class_peek_parent (klass);\n\n        object_class->finalize = ppview_toolbar_finalize;\n\n\tobject_class->set_property = ppview_toolbar_set_property;\n\tobject_class->get_property = ppview_toolbar_get_property;\n\n\tg_object_class_install_property (object_class,\n                                         PROP_EPHY_WINDOW,\n                                         g_param_spec_object (\"EphyWindow\",\n                                                              \"EphyWindow\",\n                                                              \"Parent window\",\n                                                              EPHY_WINDOW_TYPE,\n                                                              G_PARAM_READWRITE));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sequeler_widgets_connection_dialog_class_init(undefined8 param_1)\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  DAT_00160530 = g_type_class_peek_parent();\n  g_type_class_adjust_private_offset(param_1,&DAT_00160528);\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x20) = _vala_sequeler_widgets_connection_dialog_get_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x18) = _vala_sequeler_widgets_connection_dialog_set_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x10) = sequeler_widgets_connection_dialog_constructor;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x30) = sequeler_widgets_connection_dialog_finalize;\n  uVar2 = g_type_check_class_cast(param_1,0x50);\n  uVar3 = sequeler_window_get_type();\n  DAT_00160540 = g_param_spec_object(\"window\",\"window\",\"window\",uVar3,0xeb);\n  g_object_class_install_property(uVar2,1);\n  return;\n}",
        "output": "```c\nstatic void\nsequeler_widgets_connection_dialog_class_init (SequelerWidgetsConnectionDialogClass *klass)\n{\n    GObjectClass *object_class = G_OBJECT_CLASS (klass);\n\n    sequeler_widgets_connection_dialog_parent_class = g_type_class_peek_parent (klass);\n    g_type_class_adjust_private_offset (klass, &SequelerWidgetsConnectionDialog_private_offset);\n\n    object_class->get_property = _vala_sequeler_widgets_connection_dialog_get_property;\n    object_class->set_property = _vala_sequeler_widgets_connection_dialog_set_property;\n    object_class->constructor = sequeler_widgets_connection_dialog_constructor;\n    object_class->finalize = sequeler_widgets_connection_dialog_finalize;\n\n    g_object_class_install_property (object_class,\n                                     PROP_WINDOW,\n                                     g_param_spec_object (\"window\",\n                                                          \"window\",\n                                                          \"window\",\n                                                          SEQUELER_WINDOW_TYPE,\n                                                          G_PARAM_READWRITE));\n}\n```",
        "source_code": "static void\nsequeler_widgets_connection_dialog_class_init (SequelerWidgetsConnectionDialogClass * klass,\n                                               gpointer klass_data)\n{\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tsequeler_widgets_connection_dialog_parent_class = g_type_class_peek_parent (klass);\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tg_type_class_adjust_private_offset (klass, &SequelerWidgetsConnectionDialog_private_offset);\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->get_property = _vala_sequeler_widgets_connection_dialog_get_property;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->set_property = _vala_sequeler_widgets_connection_dialog_set_property;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->constructor = sequeler_widgets_connection_dialog_constructor;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tG_OBJECT_CLASS (klass)->finalize = sequeler_widgets_connection_dialog_finalize;\n#line 22 \"../src/Widgets/ConnectionDialog.vala\"\n\tg_object_class_install_property (G_OBJECT_CLASS (klass), SEQUELER_WIDGETS_CONNECTION_DIALOG_WINDOW_PROPERTY, sequeler_widgets_connection_dialog_properties[SEQUELER_WIDGETS_CONNECTION_DIALOG_WINDOW_PROPERTY] = g_param_spec_object (\"window\", \"window\", \"window\", SEQUELER_TYPE_WINDOW, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));\n#line 5302 \"ConnectionDialog.c\"\n}",
        "parsed_output": "static void\nsequeler_widgets_connection_dialog_class_init (SequelerWidgetsConnectionDialogClass *klass)\n{\n    GObjectClass *object_class = G_OBJECT_CLASS (klass);\n\n    sequeler_widgets_connection_dialog_parent_class = g_type_class_peek_parent (klass);\n    g_type_class_adjust_private_offset (klass, &SequelerWidgetsConnectionDialog_private_offset);\n\n    object_class->get_property = _vala_sequeler_widgets_connection_dialog_get_property;\n    object_class->set_property = _vala_sequeler_widgets_connection_dialog_set_property;\n    object_class->constructor = sequeler_widgets_connection_dialog_constructor;\n    object_class->finalize = sequeler_widgets_connection_dialog_finalize;\n\n    g_object_class_install_property (object_class,\n                                     PROP_WINDOW,\n                                     g_param_spec_object (\"window\",\n                                                          \"window\",\n                                                          \"window\",\n                                                          SEQUELER_WINDOW_TYPE,\n                                                          G_PARAM_READWRITE));\n}",
        "baseline_code_stripped": "void sequeler_widgets_connection_dialog_class_init(undefined8 param_1)\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  DAT_00160530 = g_type_class_peek_parent();\n  g_type_class_adjust_private_offset(param_1,&DAT_00160528);\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x20) = _vala_sequeler_widgets_connection_dialog_get_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x18) = _vala_sequeler_widgets_connection_dialog_set_property;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x10) = sequeler_widgets_connection_dialog_constructor;\n  lVar1 = g_type_check_class_cast(param_1,0x50);\n  *(code **)(lVar1 + 0x30) = sequeler_widgets_connection_dialog_finalize;\n  uVar2 = g_type_check_class_cast(param_1,0x50);\n  uVar3 = sequeler_window_get_type();\n  DAT_00160540 = g_param_spec_object(\"window\",\"window\",\"window\",uVar3,0xeb);\n  g_object_class_install_property(uVar2,1);\n  return;\n}",
        "similarity_score_unixcoder": 0.9425575733184814,
        "similarity_score_baseline_stripped": 0.8177669644355774
    },
    {
        "func_name": "BotTree::serialize",
        "normed_func_sha256": "76fe8713c2d7998c190a0e815fd24283ab97f4c85ccb45333e160b7124920fb9",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined4 __regparm3 FUN_082c29a0(uint param_1)\n{\n  ushort *puVar1;\n  DAT_0a86c290 = DAT_0a86c290 + 2;\n  FUN_0823ff60(0x14,(param_1 & 7) + 8);\n  puVar1 = (ushort *)(DAT_0a86c294 + DAT_0a86c290);\n  DAT_0a86c290 = DAT_0a86c290 + 2;\n  FUN_0823feb0(0x14,0x14,(int)(short)(*puVar1 << 8 | *puVar1 >> 8));\n  thunk_FUN_08237d20();\n  FUN_0823be40(0x15,5);\n  FUN_08240fd0(0x15,1);\n  FUN_08249e10(0x14,0x15,0x16);\n  if (100 < DAT_0a86c290) {\n    FUN_08249420();\n  }\n  return 0;\n}\n\n Revised code:\nunsigned long REGPARAM2 op_57e8_0_comp_nf(uae_u32 opcode) /* Scc */\n{\n\tuae_s32 srcreg = (opcode & 7);\n\tuae_u32 dodgy=0;\n\tuae_u32 m68k_pc_offset_thisinst=m68k_pc_offset;\n\tm68k_pc_offset+=2;\n{\tuae_u8 scratchie=S1;\n{\tint srca=scratchie++;\n\tmov_l_rr(srca,8+srcreg);\n\tlea_l_brr(srca,srca,(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2));\n{\tint val = scratchie++;\n\tmake_flags_live();\n\tsetcc(val,5);\n\tsub_b_ri(val,1);\n\twritebyte(srca,val,scratchie);\n}}}\t if (m68k_pc_offset>100) sync_m68k_pc();\nreturn 0;\n}\n\n## Example:\n\n Input code:\nvoid FUN_000d3560(int param_1)\n{\n  DAT_00228634 = FUN_0003a4a0(param_1);\n  *(code **)(param_1 + 4) = FUN_000d3a10;\n  FUN_00039450(param_1,&DAT_00228638);\n  *(code **)(param_1 + 8) = FUN_000d3650;\n  *(code **)(param_1 + 0xc) = FUN_000d37b0;\n  *(code **)(param_1 + 0x10) = FUN_000d36f0;\n  *(code **)(param_1 + 0x14) = FUN_000d3600;\n  return;\n}\n\n Revised code:\nstatic void\nvala_loop_class_init (ValaLoopClass * klass)\n{\n\tvala_loop_parent_class = g_type_class_peek_parent (klass);\n\t((ValaCodeNodeClass *) klass)->finalize = vala_loop_finalize;\n\tg_type_class_adjust_private_offset (klass, &ValaLoop_private_offset);\n\t((ValaCodeNodeClass *) klass)->accept = (void (*) (ValaCodeNode *, ValaCodeVisitor*)) vala_loop_real_accept;\n\t((ValaCodeNodeClass *) klass)->accept_children = (void (*) (ValaCodeNode *, ValaCodeVisitor*)) vala_loop_real_accept_children;\n\t((ValaCodeNodeClass *) klass)->check = (gboolean (*) (ValaCodeNode *, ValaCodeContext*)) vala_loop_real_check;\n\t((ValaCodeNodeClass *) klass)->emit = (void (*) (ValaCodeNode *, ValaCodeGenerator*)) vala_loop_real_emit;\n}\n\n## Example:\n\n Input code:\nundefined4 __regparm3 FUN_08291410(uint param_1)\n{\n  DAT_0a86c2b0 = DAT_0a86c2b0 + 2;\n  FUN_08239b40();\n  FUN_08239ba0();\n  FUN_08241210(param_1 >> 9 & 7,(param_1 & 7) + 8);\n  FUN_08239b20();\n  FUN_08239bb0();\n  if ((DAT_0a86bd9c & 1) != 0) {\n    FUN_08239b50();\n  }\n  if ((DAT_0a86bd9c & 0x1e) == 0) {\n    FUN_08239b40();\n  }\n  if (100 < DAT_0a86c2b0) {\n    FUN_082494c0();\n  }\n  return 0;\n}\n\n Revised code:\nunsigned long REGPARAM2 op_d088_0_comp_ff(uae_u32 opcode) /* ADD */\n{\n\tuae_s32 srcreg = (opcode & 7);\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n\tuae_u32 dodgy=0;\n\tuae_u32 m68k_pc_offset_thisinst=m68k_pc_offset;\n\tm68k_pc_offset+=2;\n{\tuae_u8 scratchie=S1;\n{\tint src=dodgy?scratchie++:srcreg+8;\n\tif (dodgy) \n\t\tmov_l_rr(src,srcreg+8);\n{\tint dst=dstreg;\n\tdont_care_flags();\n\tstart_needflags();\n\tadd_l(dst,src);\n\tlive_flags();\n\tend_needflags();\n\tif (needed_flags&FLAG_X) duplicate_carry();\nif (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n\tif((uae_u32)dstreg!=(uae_u32)dst)\n\t\tmov_l_rr(dstreg,dst);\n}}}\t if (m68k_pc_offset>100) sync_m68k_pc();\nreturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 __fastcall FUN_10002610(int param_1)\n{\n  undefined4 unaff_retaddr;\n  FUN_1004a620(param_1 + 0x21d8,64000,0);\n  if ((_DAT_10840e5c & 1) == 0) {\n    _DAT_10840e5c = _DAT_10840e5c | 1;\n    DAT_10840e58 = FUN_1004a640(1);\n  }\n  FUN_1004a7b0(DAT_10840e58);\n  (**(code **)(**(int **)(param_1 + 0x21d4) + 0x10))(DAT_10840e58);\n  FUN_1004a730(DAT_10840e58,param_1 + 0x1b0c,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 4,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 5,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 6,1,0);\n  DAT_10840e54 = FUN_1004a7c0(DAT_10840e58);\n  FUN_1004a7b0(DAT_10840e58);\n  FUN_1004a6b0(DAT_10840e58,unaff_retaddr,DAT_10840e54,0);\n  return 1;\n}",
        "output": "```c\nint initialize_and_process(int param_1) {\n    int ret_value = 1;\n\n    // Initialize some data structure with specific parameters\n    initialize_structure(param_1 + 0x21d8, 64000, 0);\n\n    // Check and set a flag, and initialize a global resource if not already done\n    if ((_DAT_10840e5c & 1) == 0) {\n        _DAT_10840e5c |= 1;\n        DAT_10840e58 = allocate_resource(1);\n    }\n\n    // Perform operations using the global resource\n    prepare_resource(DAT_10840e58);\n    invoke_callback((**(int **)(param_1 + 0x21d4) + 0x10), DAT_10840e58);\n\n    // Process various offsets of the input parameter\n    process_data(DAT_10840e58, param_1 + 0x1b0c, 1, 0);\n    process_data(DAT_10840e58, param_1 + 4, 1, 0);\n    process_data(DAT_10840e58, param_1 + 5, 1, 0);\n    process_data(DAT_10840e58, param_1 + 6, 1, 0);\n\n    // Finalize and clean up\n    DAT_10840e54 = finalize_resource(DAT_10840e58);\n    prepare_resource(DAT_10840e58);\n    complete_processing(DAT_10840e58, ret_value, DAT_10840e54, 0);\n\n    return ret_value;\n}\n```",
        "source_code": "bool BotTree::serialize(void *data_)\n{\n   memstream_set_buffer(buffer, MEM_STREAM_BUFFER_SIZE);\n   static memstream_t *stream = memstream_open(1);\n   assert(stream != NULL);\n   memstream_rewind(stream);\n   assert(tree != NULL);\n   tree->serialize(stream);                                                                            // write to the stream\n   memstream_write(stream, &calculatedBestCellToPickUpBonus, sizeof(calculatedBestCellToPickUpBonus)); // write to the stream\n   memstream_write(stream, &_direction1FrameAgo, sizeof(_direction1FrameAgo));                         // write to the stream\n   memstream_write(stream, &_direction2FramesAgo, sizeof(_direction2FramesAgo));                       // write to the stream\n   memstream_write(stream, &_shiveringCounter, sizeof(_shiveringCounter));                             // write to the stream\n   serializeSize = memstream_pos(stream);\n   memstream_rewind(stream);\n   memstream_read(stream, data_, serializeSize);     // read from the stream\n   return(true);\n}",
        "parsed_output": "int initialize_and_process(int param_1) {\n    int ret_value = 1;\n\n    // Initialize some data structure with specific parameters\n    initialize_structure(param_1 + 0x21d8, 64000, 0);\n\n    // Check and set a flag, and initialize a global resource if not already done\n    if ((_DAT_10840e5c & 1) == 0) {\n        _DAT_10840e5c |= 1;\n        DAT_10840e58 = allocate_resource(1);\n    }\n\n    // Perform operations using the global resource\n    prepare_resource(DAT_10840e58);\n    invoke_callback((**(int **)(param_1 + 0x21d4) + 0x10), DAT_10840e58);\n\n    // Process various offsets of the input parameter\n    process_data(DAT_10840e58, param_1 + 0x1b0c, 1, 0);\n    process_data(DAT_10840e58, param_1 + 4, 1, 0);\n    process_data(DAT_10840e58, param_1 + 5, 1, 0);\n    process_data(DAT_10840e58, param_1 + 6, 1, 0);\n\n    // Finalize and clean up\n    DAT_10840e54 = finalize_resource(DAT_10840e58);\n    prepare_resource(DAT_10840e58);\n    complete_processing(DAT_10840e58, ret_value, DAT_10840e54, 0);\n\n    return ret_value;\n}",
        "baseline_code_stripped": "undefined4 __fastcall FUN_10002610(int param_1)\n{\n  undefined4 unaff_retaddr;\n  FUN_1004a620(param_1 + 0x21d8,64000,0);\n  if ((_DAT_10840e5c & 1) == 0) {\n    _DAT_10840e5c = _DAT_10840e5c | 1;\n    DAT_10840e58 = FUN_1004a640(1);\n  }\n  FUN_1004a7b0(DAT_10840e58);\n  (**(code **)(**(int **)(param_1 + 0x21d4) + 0x10))(DAT_10840e58);\n  FUN_1004a730(DAT_10840e58,param_1 + 0x1b0c,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 4,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 5,1,0);\n  FUN_1004a730(DAT_10840e58,param_1 + 6,1,0);\n  DAT_10840e54 = FUN_1004a7c0(DAT_10840e58);\n  FUN_1004a7b0(DAT_10840e58);\n  FUN_1004a6b0(DAT_10840e58,unaff_retaddr,DAT_10840e54,0);\n  return 1;\n}",
        "similarity_score_unixcoder": 0.4713475704193115,
        "similarity_score_baseline_stripped": 0.45023924112319946
    },
    {
        "func_name": "TypeName",
        "normed_func_sha256": "d5684d4d62f54b30d28882da40876d002cb7ef0f485aedf958a63d17b5fbb2a5",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined * FUN_1400f6760(undefined *param_1,undefined4 *param_2)\n{\n  char *pcVar1;\n  undefined8 uVar2;\n  int local_28;\n  undefined4 local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  undefined2 local_10;\n  switch(*param_2) {\n  case 1:\n  case 4:\n    uVar2 = 5;\n    pcVar1 = \"Uint8\";\n    break;\n  case 2:\n  case 3:\n    uVar2 = 4;\n    pcVar1 = \"Int8\";\n    break;\n  case 5:\n    uVar2 = 5;\n    pcVar1 = \"Int16\";\n    break;\n  case 6:\n    uVar2 = 6;\n    pcVar1 = \"Uint16\";\n    break;\n  case 7:\n    uVar2 = 5;\n    pcVar1 = \"Int32\";\n    break;\n  case 8:\n    uVar2 = 6;\n    pcVar1 = \"Uint32\";\n    break;\n  case 9:\n    uVar2 = 5;\n    pcVar1 = \"Int64\";\n    break;\n  case 10:\n    uVar2 = 6;\n    pcVar1 = \"Uint64\";\n    break;\n  case 0xb:\n    uVar2 = 7;\n    pcVar1 = \"Float32\";\n    break;\n  case 0xc:\n    uVar2 = 7;\n    pcVar1 = \"Float64\";\n    break;\n  case 0xd:\n    uVar2 = 6;\n    pcVar1 = \"String\";\n    break;\n  case 0xe:\n    local_28 = param_2[1];\n    local_20 = *(undefined8 *)(param_2 + 2);\n    local_18 = *(undefined8 *)(param_2 + 4);\n    local_10 = *(undefined2 *)(param_2 + 6);\n    local_24 = 0;\n    FUN_1400f6760(param_1,&local_28);\n    return param_1;\n  case 0xf:\n    FUN_140016b90(param_1,*(undefined8 *)(param_2 + 2));\n    return param_1;\n  default:\n    uVar2 = 0x11;\n    pcVar1 = \"flatbuffers.Table\";\n  }\n  *(undefined8 *)(param_1 + 0x10) = 0;\n  *(undefined8 *)(param_1 + 0x18) = 0xf;\n  *param_1 = 0;\n  FUN_140043830(param_1,pcVar1,uVar2);\n  return param_1;\n}\n\n Revised code:\nstatic std::string GenType(const Type &type) {\n    switch (type.base_type) {\n      case BASE_TYPE_BOOL:\n      case BASE_TYPE_CHAR: return \"Int8\";\n      case BASE_TYPE_UTYPE:\n      case BASE_TYPE_UCHAR: return \"Uint8\";\n      case BASE_TYPE_SHORT: return \"Int16\";\n      case BASE_TYPE_USHORT: return \"Uint16\";\n      case BASE_TYPE_INT: return \"Int32\";\n      case BASE_TYPE_UINT: return \"Uint32\";\n      case BASE_TYPE_LONG: return \"Int64\";\n      case BASE_TYPE_ULONG: return \"Uint64\";\n      case BASE_TYPE_FLOAT: return \"Float32\";\n      case BASE_TYPE_DOUBLE: return \"Float64\";\n      case BASE_TYPE_STRING: return \"String\";\n      case BASE_TYPE_VECTOR: return GenType(type.VectorType());\n      case BASE_TYPE_STRUCT: return type.struct_def->name;\n      default: return \"flatbuffers.Table\";\n    }\n  }\n\n## Example:\n\n Input code:\nvoid FUN_1400a6dd0(undefined8 *param_1,longlong param_2,undefined8 param_3,undefined8 param_4)\n{\n  code *pcVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined auStack_68 [32];\n  undefined4 local_48;\n  char *local_38;\n  undefined8 uStack_30;\n  undefined local_28 [16];\n  undefined8 local_18;\n  ulonglong local_10;\n  local_10 = DAT_1403eb000 ^ (ulonglong)auStack_68;\n  local_48 = 0;\n  local_18 = param_4;\n  switch(*(undefined *)(param_2 + 2)) {\n  case 1:\n    pcVar2 = \"Double\";\n    param_1[1] = 6;\n    break;\n  case 2:\n    pcVar2 = \"Float\";\n    param_1[1] = 5;\n    break;\n  case 3:\n    pcVar2 = (char *)&DAT_140306f14;\n    param_1[1] = 5;\n    break;\n  case 4:\n    pcVar2 = (char *)&DAT_140306f24;\n    param_1[1] = 6;\n    break;\n  case 5:\n    pcVar2 = \"Int32\";\n    param_1[1] = 5;\n    break;\n  case 6:\n    pcVar2 = \"Fixed64\";\n    goto LAB_1400a6e5a;\n  case 7:\n    pcVar2 = \"Fixed32\";\n    goto LAB_1400a6e5a;\n  case 8:\n    pcVar2 = &DAT_140306f7c;\n    param_1[1] = 4;\n    break;\n  case 9:\n    pcVar2 = \"String\";\n    param_1[1] = 6;\n    break;\n  case 10:\n    pcVar2 = \"Group\";\n    param_1[1] = 5;\n    break;\n  case 0xb:\n    pcVar2 = \"Message\";\nLAB_1400a6e5a:\n    param_1[1] = 7;\n    break;\n  case 0xc:\n    pcVar2 = \"Bytes\";\n    param_1[1] = 5;\n    break;\n  case 0xd:\n    pcVar2 = (char *)&DAT_140306f1c;\n    param_1[1] = 6;\n    break;\n  case 0xe:\n    pcVar2 = &DAT_140306f84;\n    param_1[1] = 4;\n    break;\n  case 0xf:\n    pcVar2 = \"SFixed32\";\n    param_1[1] = 8;\n    break;\n  case 0x10:\n    pcVar2 = \"SFixed64\";\n    param_1[1] = 8;\n    break;\n  case 0x11:\n    pcVar2 = \"SInt32\";\n    param_1[1] = 6;\n    break;\n  case 0x12:\n    pcVar2 = (char *)&DAT_140306f34;\n    param_1[1] = 6;\n    break;\n  default:\n    uVar3 = FUN_1402cbed0(local_28,\n                          \"D:\\\\dev\\\\jam_galaxy\\\\freshrepo\\\\JamGalaxy\\\\3rdparty\\\\protobuf\\\\v28.2\\\\win-msvc-x64\\\\src\\\\src\\\\google\\\\protobuf\\\\compiler\\\\java\\\\helpers.cc\"\n                          ,0x2d1);\n    local_48 = 1;\n    local_38 = \"Can\\'t get here.\";\n    uStack_30 = 0xf;\n    FUN_1402cbb50(uVar3,&local_38);\n    FUN_1402cc1e0(local_28);\n    pcVar1 = (code *)swi(3);\n    (*pcVar1)();\n    return;\n  }\n  *param_1 = pcVar2;\n  FUN_14002ab90(param_4);\n  FUN_1402e2990(local_10 ^ (ulonglong)auStack_68);\n  return;\n}\n\n Revised code:\nabsl::string_view GetCapitalizedType(const FieldDescriptor* field,\n                                     bool immutable, Options options) {\n  switch (GetType(field)) {\n    case FieldDescriptor::TYPE_INT32:\n      return \"Int32\";\n    case FieldDescriptor::TYPE_UINT32:\n      return \"UInt32\";\n    case FieldDescriptor::TYPE_SINT32:\n      return \"SInt32\";\n    case FieldDescriptor::TYPE_FIXED32:\n      return \"Fixed32\";\n    case FieldDescriptor::TYPE_SFIXED32:\n      return \"SFixed32\";\n    case FieldDescriptor::TYPE_INT64:\n      return \"Int64\";\n    case FieldDescriptor::TYPE_UINT64:\n      return \"UInt64\";\n    case FieldDescriptor::TYPE_SINT64:\n      return \"SInt64\";\n    case FieldDescriptor::TYPE_FIXED64:\n      return \"Fixed64\";\n    case FieldDescriptor::TYPE_SFIXED64:\n      return \"SFixed64\";\n    case FieldDescriptor::TYPE_FLOAT:\n      return \"Float\";\n    case FieldDescriptor::TYPE_DOUBLE:\n      return \"Double\";\n    case FieldDescriptor::TYPE_BOOL:\n      return \"Bool\";\n    case FieldDescriptor::TYPE_STRING:\n      return \"String\";\n    case FieldDescriptor::TYPE_BYTES: {\n      return \"Bytes\";\n    }\n    case FieldDescriptor::TYPE_ENUM:\n      return \"Enum\";\n    case FieldDescriptor::TYPE_GROUP:\n      return \"Group\";\n    case FieldDescriptor::TYPE_MESSAGE:\n      return \"Message\";\n\n      // No default because we want the compiler to complain if any new\n      // types are added.\n  }\n\n  ABSL_LOG(FATAL) << \"Can't get here.\";\n  return {};\n}\n\n## Example:\n\n Input code:\nundefined FUN_008693d6(undefined8 param_1,undefined4 param_2)\n{\n  char cVar1;\n  undefined uVar2;\n  undefined8 uVar3;\n  long lVar4;\n  undefined4 local_a4;\n  undefined8 local_a0;\n  undefined8 local_98 [2];\n  undefined8 local_88 [2];\n  undefined local_78 [47];\n  undefined local_49;\n  undefined local_48 [47];\n  undefined local_19 [9];\n  local_a4 = param_2;\n  local_a0 = param_1;\n  local_98[0] = FUN_0083a376(param_1,&local_a4);\n  local_88[0] = FUN_0083a2f0(local_a0);\n  cVar1 = FUN_0083a39c(local_98,local_88);\n  if (cVar1 == '\\0') {\n    lVar4 = FUN_0083a354(local_98);\n    if ((*(byte *)(lVar4 + 0x12) & 1) != 0) {\n      FUN_007bf3ec(local_48,3,\"google/protobuf/extension_set.cc\",0xcf);\n      uVar3 = FUN_007bf0ea(local_48,\"Don\\'t lookup extension types if they aren\\'t present (2). \");\n      FUN_007bf556(local_19,uVar3);\n      FUN_007bf434(local_48);\n    }\n    lVar4 = FUN_0083a354(local_98);\n    uVar2 = *(undefined *)(lVar4 + 0x10);\n  }\n  else {\n    FUN_007bf3ec(local_78,3,\"google/protobuf/extension_set.cc\",0xcb);\n    uVar3 = FUN_007bf0ea(local_78,\"Don\\'t lookup extension types if they aren\\'t present (1). \");\n    FUN_007bf556(&local_49,uVar3);\n    FUN_007bf434(local_78);\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n Revised code:\nFieldType ExtensionSet::ExtensionType(int number) const {\n  map<int, Extension>::const_iterator iter = extensions_.find(number);\n  if (iter == extensions_.end()) {\n    GOOGLE_LOG(DFATAL) << \"Don't lookup extension types if they aren't present (1). \";\n    return 0;\n  }\n  if (iter->second.is_cleared) {\n    GOOGLE_LOG(DFATAL) << \"Don't lookup extension types if they aren't present (2). \";\n  }\n  return iter->second.type;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar * FUN_080917f0(undefined4 param_1)\n{\n  undefined4 uVar1;\n  char *pcVar2;\n  undefined local_20 [19];\n  undefined local_d;\n  switch(param_1) {\n  default:\n    FUN_080992e0(local_20,3,\"../../src/google/protobuf/compiler/java/java_extension.cc\",0x48);\n    uVar1 = FUN_080998e0(local_20,\"Can\\'t get here.\");\n    FUN_08099bc0(&local_d,uVar1);\n    FUN_08099a40(local_20);\n    pcVar2 = (char *)0x0;\n    break;\n  case 1:\n    pcVar2 = \"DOUBLE\";\n    break;\n  case 2:\n    pcVar2 = \"FLOAT\";\n    break;\n  case 3:\n    pcVar2 = \"INT64\";\n    break;\n  case 4:\n    pcVar2 = \"UINT64\";\n    break;\n  case 5:\n    pcVar2 = \"INT32\";\n    break;\n  case 6:\n    pcVar2 = \"FIXED64\";\n    break;\n  case 7:\n    pcVar2 = \"FIXED32\";\n    break;\n  case 8:\n    pcVar2 = \"BOOL\";\n    break;\n  case 9:\n    pcVar2 = \"STRING\";\n    break;\n  case 10:\n    pcVar2 = \"GROUP\";\n    break;\n  case 0xb:\n    pcVar2 = \"MESSAGE\";\n    break;\n  case 0xc:\n    pcVar2 = \"BYTES\";\n    break;\n  case 0xd:\n    pcVar2 = \"UINT32\";\n    break;\n  case 0xe:\n    pcVar2 = \"ENUM\";\n    break;\n  case 0xf:\n    pcVar2 = \"SFIXED32\";\n    break;\n  case 0x10:\n    pcVar2 = \"SFIXED64\";\n    break;\n  case 0x11:\n    pcVar2 = \"SINT32\";\n    break;\n  case 0x12:\n    pcVar2 = \"SINT64\";\n  }\n  return pcVar2;\n}",
        "output": "```cpp\nconst char* GetFieldTypeName(int field_type) {\n  switch (field_type) {\n    case 1: return \"DOUBLE\";\n    case 2: return \"FLOAT\";\n    case 3: return \"INT64\";\n    case 4: return \"UINT64\";\n    case 5: return \"INT32\";\n    case 6: return \"FIXED64\";\n    case 7: return \"FIXED32\";\n    case 8: return \"BOOL\";\n    case 9: return \"STRING\";\n    case 10: return \"GROUP\";\n    case 11: return \"MESSAGE\";\n    case 12: return \"BYTES\";\n    case 13: return \"UINT32\";\n    case 14: return \"ENUM\";\n    case 15: return \"SFIXED32\";\n    case 16: return \"SFIXED64\";\n    case 17: return \"SINT32\";\n    case 18: return \"SINT64\";\n    default:\n      GOOGLE_LOG(DFATAL) << \"Can't get here.\";\n      return nullptr;\n  }\n}\n```",
        "source_code": "const char* TypeName(FieldDescriptor::Type field_type) {\n  switch (field_type) {\n    case FieldDescriptor::TYPE_INT32   : return \"INT32\";\n    case FieldDescriptor::TYPE_UINT32  : return \"UINT32\";\n    case FieldDescriptor::TYPE_SINT32  : return \"SINT32\";\n    case FieldDescriptor::TYPE_FIXED32 : return \"FIXED32\";\n    case FieldDescriptor::TYPE_SFIXED32: return \"SFIXED32\";\n    case FieldDescriptor::TYPE_INT64   : return \"INT64\";\n    case FieldDescriptor::TYPE_UINT64  : return \"UINT64\";\n    case FieldDescriptor::TYPE_SINT64  : return \"SINT64\";\n    case FieldDescriptor::TYPE_FIXED64 : return \"FIXED64\";\n    case FieldDescriptor::TYPE_SFIXED64: return \"SFIXED64\";\n    case FieldDescriptor::TYPE_FLOAT   : return \"FLOAT\";\n    case FieldDescriptor::TYPE_DOUBLE  : return \"DOUBLE\";\n    case FieldDescriptor::TYPE_BOOL    : return \"BOOL\";\n    case FieldDescriptor::TYPE_STRING  : return \"STRING\";\n    case FieldDescriptor::TYPE_BYTES   : return \"BYTES\";\n    case FieldDescriptor::TYPE_ENUM    : return \"ENUM\";\n    case FieldDescriptor::TYPE_GROUP   : return \"GROUP\";\n    case FieldDescriptor::TYPE_MESSAGE : return \"MESSAGE\";\n  }\n  GOOGLE_LOG(FATAL) << \"Can't get here.\";\n  return NULL;\n}",
        "parsed_output": "pp\nconst char* GetFieldTypeName(int field_type) {\n  switch (field_type) {\n    case 1: return \"DOUBLE\";\n    case 2: return \"FLOAT\";\n    case 3: return \"INT64\";\n    case 4: return \"UINT64\";\n    case 5: return \"INT32\";\n    case 6: return \"FIXED64\";\n    case 7: return \"FIXED32\";\n    case 8: return \"BOOL\";\n    case 9: return \"STRING\";\n    case 10: return \"GROUP\";\n    case 11: return \"MESSAGE\";\n    case 12: return \"BYTES\";\n    case 13: return \"UINT32\";\n    case 14: return \"ENUM\";\n    case 15: return \"SFIXED32\";\n    case 16: return \"SFIXED64\";\n    case 17: return \"SINT32\";\n    case 18: return \"SINT64\";\n    default:\n      GOOGLE_LOG(DFATAL) << \"Can't get here.\";\n      return nullptr;\n  }\n}",
        "baseline_code_stripped": "char * FUN_080917f0(undefined4 param_1)\n{\n  undefined4 uVar1;\n  char *pcVar2;\n  undefined local_20 [19];\n  undefined local_d;\n  switch(param_1) {\n  default:\n    FUN_080992e0(local_20,3,\"../../src/google/protobuf/compiler/java/java_extension.cc\",0x48);\n    uVar1 = FUN_080998e0(local_20,\"Can\\'t get here.\");\n    FUN_08099bc0(&local_d,uVar1);\n    FUN_08099a40(local_20);\n    pcVar2 = (char *)0x0;\n    break;\n  case 1:\n    pcVar2 = \"DOUBLE\";\n    break;\n  case 2:\n    pcVar2 = \"FLOAT\";\n    break;\n  case 3:\n    pcVar2 = \"INT64\";\n    break;\n  case 4:\n    pcVar2 = \"UINT64\";\n    break;\n  case 5:\n    pcVar2 = \"INT32\";\n    break;\n  case 6:\n    pcVar2 = \"FIXED64\";\n    break;\n  case 7:\n    pcVar2 = \"FIXED32\";\n    break;\n  case 8:\n    pcVar2 = \"BOOL\";\n    break;\n  case 9:\n    pcVar2 = \"STRING\";\n    break;\n  case 10:\n    pcVar2 = \"GROUP\";\n    break;\n  case 0xb:\n    pcVar2 = \"MESSAGE\";\n    break;\n  case 0xc:\n    pcVar2 = \"BYTES\";\n    break;\n  case 0xd:\n    pcVar2 = \"UINT32\";\n    break;\n  case 0xe:\n    pcVar2 = \"ENUM\";\n    break;\n  case 0xf:\n    pcVar2 = \"SFIXED32\";\n    break;\n  case 0x10:\n    pcVar2 = \"SFIXED64\";\n    break;\n  case 0x11:\n    pcVar2 = \"SINT32\";\n    break;\n  case 0x12:\n    pcVar2 = \"SINT64\";\n  }\n  return pcVar2;\n}",
        "similarity_score_unixcoder": 0.9028364419937134,
        "similarity_score_baseline_stripped": 0.593778669834137
    },
    {
        "func_name": "log_Z3_algebraic_eval",
        "normed_func_sha256": "2b3e7f22436b94f80bd68b8460b22a2dc95cb730cfbf85d7aa1c78caa227c9db",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_0031e1cc(undefined8 param_1,int param_2,long param_3)\n{\n  undefined8 *puVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  uVar3 = FUN_00323de0();\n  if (param_2 != 0) {\n    uVar4 = FUN_0031e808();\n    puVar1 = (undefined8 *)(param_3 + 8);\n    bVar2 = param_2 != 0;\n    while (bVar2) {\n      param_2 = param_2 + -1;\n      FUN_0031de6c(uVar3,puVar1[-1],*puVar1,uVar4,1);\n      puVar1 = puVar1 + 2;\n      bVar2 = param_2 != 0;\n    }\n    FUN_0031e8c8();\n  }\n  FUN_0031e8f4(uVar3);\n  return;\n}\n\n Revised code:\nstatic GObject*\ng_object_constructor (GType                  type,\n          guint                  n_construct_properties,\n          GObjectConstructParam *construct_params)\n{\n  GObject *object;\n\n  /* create object */\n  object = (GObject*) g_type_create_instance (type);\n\n  /* set construction parameters */\n  if (n_construct_properties)\n    {\n      GObjectNotifyQueue *nqueue = g_object_notify_queue_freeze (object, FALSE);\n\n      /* set construct properties */\n      while (n_construct_properties--)\n  {\n    GValue *value = construct_params->value;\n    GParamSpec *pspec = construct_params->pspec;\n\n    construct_params++;\n    object_set_property (object, pspec, value, nqueue, TRUE);\n  }\n      g_object_notify_queue_thaw (object, nqueue);\n      /* the notification queue is still frozen from g_object_init(), so\n       * we don't need to handle it here, g_object_newv() takes\n       * care of that\n       */\n    }\n\n  return object;\n}\n\n## Example:\n\n Input code:\nvoid FUN_01d8f350(long param_1,undefined4 param_2,undefined4 param_3)\n{\n  undefined *puVar1;\n  if ((int)*(undefined8 *)(param_1 + 0xe8) - (int)*(undefined8 *)(param_1 + 0x20) < 0x20) {\n    FUN_01d87670();\n  }\n  FUN_01d875b0(param_1,param_2,0,param_3,0,1,1,0);\n  puVar1 = *(undefined **)(param_1 + 0x20);\n  *puVar1 = 0x6f;\n  *(undefined **)(param_1 + 0x20) = puVar1 + 1;\n  FUN_01d8ea60();\n  return;\n}\n\n Revised code:\nvoid Assembler::vmovdqa(XMMRegister dst, XMMRegister src) {\n  DCHECK(IsEnabled(AVX));\n  EnsureSpace ensure_space(this);\n  emit_vex_prefix(dst, xmm0, src, kL128, k66, k0F, kWIG);\n  emit(0x6F);\n  emit_sse_operand(dst, src);\n}\n\n## Example:\n\n Input code:\nvoid FUN_02c8c7e0(undefined8 param_1,undefined8 *param_2,undefined8 param_3)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  puVar1 = param_2 + 4;\n  if ((*(uint *)((long)param_2 + 0x14) & 0xf000000) == 0xf000000) {\n    puVar1 = (undefined8 *)(param_2[4] + 0x10);\n  }\n  uVar3 = *puVar1;\n  uVar2 = FUN_02e2acb0(*param_2);\n  FUN_02c8c4a0(param_1,uVar3,uVar2,param_3);\n  return;\n}\n\n Revised code:\nNode* EffectControlLinearizer::LowerCheckedInt32ToTaggedSigned(\n    Node* node, Node* frame_state) {\n  DCHECK(SmiValuesAre31Bits());\n  Node* value = node->InputAt(0);\n  const CheckParameters& params = CheckParametersOf(node->op());\n  return SmiTagOrDeopt(value, params, frame_state);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_012f3f90(undefined8 param_1,undefined8 param_2,int param_3,undefined8 *param_4)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  FUN_012ea5d0();\n  FUN_012ea740(param_1);\n  FUN_012ea740(param_2);\n  FUN_012ea6f0(param_3);\n  puVar1 = param_4 + (ulong)(param_3 - 1) + 1;\n  if (param_3 != 0) {\n    do {\n      uVar2 = *param_4;\n      param_4 = param_4 + 1;\n      FUN_012ea740(uVar2);\n    } while (param_4 != puVar1);\n  }\n  FUN_012ea830(param_3);\n  FUN_012ea6a0(0x207);\n  return;\n}",
        "output": "```c\nvoid ProcessParameters(void* param1, void* param2, int count, void** paramArray) {\n  void** currentParam;\n  void* value;\n\n  Initialize();\n  Process(param1);\n  Process(param2);\n  ProcessCount(count);\n\n  currentParam = paramArray + count;\n  if (count != 0) {\n    do {\n      value = *paramArray;\n      paramArray++;\n      Process(value);\n    } while (paramArray != currentParam);\n  }\n\n  FinalizeCount(count);\n  Finalize(0x207);\n}\n```",
        "source_code": "void log_Z3_algebraic_eval(Z3_context a0, Z3_ast a1, unsigned a2, Z3_ast const * a3) {\n  R();\n  P(a0);\n  P(a1);\n  U(a2);\n  for (unsigned i = 0; i < a2; i++) { P(a3[i]); }\n  Ap(a2);\n  C(519);\n}",
        "parsed_output": "void ProcessParameters(void* param1, void* param2, int count, void** paramArray) {\n  void** currentParam;\n  void* value;\n\n  Initialize();\n  Process(param1);\n  Process(param2);\n  ProcessCount(count);\n\n  currentParam = paramArray + count;\n  if (count != 0) {\n    do {\n      value = *paramArray;\n      paramArray++;\n      Process(value);\n    } while (paramArray != currentParam);\n  }\n\n  FinalizeCount(count);\n  Finalize(0x207);\n}",
        "baseline_code_stripped": "void FUN_012f3f90(undefined8 param_1,undefined8 param_2,int param_3,undefined8 *param_4)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  FUN_012ea5d0();\n  FUN_012ea740(param_1);\n  FUN_012ea740(param_2);\n  FUN_012ea6f0(param_3);\n  puVar1 = param_4 + (ulong)(param_3 - 1) + 1;\n  if (param_3 != 0) {\n    do {\n      uVar2 = *param_4;\n      param_4 = param_4 + 1;\n      FUN_012ea740(uVar2);\n    } while (param_4 != puVar1);\n  }\n  FUN_012ea830(param_3);\n  FUN_012ea6a0(0x207);\n  return;\n}",
        "similarity_score_unixcoder": 0.5210900902748108,
        "similarity_score_baseline_stripped": 0.49670955538749695
    },
    {
        "func_name": "CAAEquinoxesAndSolstices::LengthOfSummer",
        "normed_func_sha256": "de710b8ff868c8b978ae374914daad4f0d5ac6873216a44ff1afcd9f6b0ed833",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_00170d80(int param_1,double *param_2,double *param_3,double param_4,double param_5)\n{\n  char cVar1;\n  longdouble lVar2;\n  double dVar3;\n  double dVar4;\n  param_5 = *(double *)(param_1 + 0xe5d34) - param_5;\n  dVar4 = 0.0;\n  if (*(double *)(param_1 + 0xe5cfc) < 0.0) {\n    if (param_5 != 0.0 || param_4 != 0.0) {\n      dVar4 = atan2(-param_4,-param_5);\n    }\n  }\n  else {\n    dVar4 = 0.0;\n    if (param_5 != 0.0 || param_4 != 0.0) {\n      dVar4 = atan2(param_4,param_5);\n    }\n  }\n  *param_2 = dVar4 * *(double *)(param_1 + 0xe5d14) + *(double *)(param_1 + 0xe5be4);\n  dVar4 = *(double *)(param_1 + 0xe5cfc);\n  dVar3 = hypot(param_4,param_5);\n  dVar3 = ABS(dVar3);\n  if (dVar4 < 0.0) {\n    dVar3 = -dVar3;\n  }\n  dVar4 = pow(dVar3 * *(double *)(param_1 + 0xe5d2c),*(double *)(param_1 + 0xe5d04));\n  dVar4 = atan(dVar4);\n  cVar1 = *(char *)(param_1 + 0xe58c3);\n  dVar4 = 90.0 - (dVar4 * 57.29577951308232 + dVar4 * 57.29577951308232);\n  *param_3 = dVar4;\n  if (cVar1 != '\\0') {\n    lVar2 = (longdouble)gmtmap_lat_swap_quick(param_1,dVar4,param_1 + 0xe592c);\n    *param_3 = (double)lVar2;\n    return;\n  }\n  return;\n}\n\n Revised code:\nGMT_LOCAL void gmtproj_ilamb_sph (struct GMT_CTRL *GMT, double *lon, double *lat, double x, double y) {\n\tdouble theta, rho, t, dy;\n\n\tdy = GMT->current.proj.l_rho0 - y;\n\ttheta = (GMT->current.proj.l_N < 0.0) ? d_atan2 (-x, -dy) : d_atan2 (x, dy);\n\t*lon = theta * GMT->current.proj.l_i_Nr + GMT->current.proj.central_meridian;\n\n\trho = copysign (hypot (x, dy), GMT->current.proj.l_N);\n\tt = pow (rho * GMT->current.proj.l_i_rF, GMT->current.proj.l_i_N);\n\t*lat = 90.0 - 2.0 * atand (t);\n\tif (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_latc_to_latg (GMT, *lat);\n}\n\n## Example:\n\n Input code:\ndouble FUN_002307f0(double *param_1,double *param_2)\n{\n  double dVar1;\n  double dVar2;\n  double dVar3;\n  dVar3 = (param_2[2] - *param_2) * (param_1[2] - *param_1) +\n          (param_2[3] - param_2[1]) * (param_1[3] - param_1[1]);\n  dVar1 = (double)FUN_00163dc0();\n  dVar2 = (double)FUN_00163dc0(param_2);\n  dVar3 = dVar3 / (dVar1 * dVar2);\n  if (dVar3 < 0.0) {\n    dVar3 = -dVar3;\n  }\n  return dVar3;\n}\n\n Revised code:\nstatic qreal normProjection( const QLineF &l1, const QLineF &l2 )\n{\n    const qreal dotProduct = l1.dx() * l2.dx() + l1.dy() * l2.dy();\n    return qAbs( dotProduct / ( l1.length() * l2.length() ) );\n}\n\n## Example:\n\n Input code:\ndouble FUN_00159498(double param_1,double param_2)\n{\n  double dVar1;\n  double dVar2;\n  double dVar3;\n  double dVar4;\n  byte in_fflags;\n  if (ABS(param_1 - param_2) <= ABS(param_1) * 0.4) {\n    dVar1 = (param_1 + 6.02468004077673) - 0.5;\n    if (dVar1 / 2.718281828459045 < 0.0) {\n      dVar2 = (double)FUN_0010d700(in_fflags & 0x1f);\n    }\n    else {\n      dVar2 = SQRT(dVar1 / 2.718281828459045);\n    }\n    dVar3 = (double)FUN_00160abe(param_1);\n    if ((200.0 <= param_1) || (200.0 <= param_2)) {\n      dVar4 = (double)FUN_0016579a((((param_2 - param_1) - 6.02468004077673) + 0.5) / dVar1);\n      dVar1 = (double)FUN_0010d710((param_2 * -5.52468004077673) / dVar1 + dVar4 * param_1);\n      dVar1 = (dVar2 / dVar3) * dVar1;\n    }\n    else {\n      dVar4 = (double)FUN_0010d710(param_1 - param_2);\n      dVar1 = (double)FUN_0010d4b0(param_2 / dVar1,param_1);\n      dVar1 = dVar4 * dVar1 * (dVar2 / dVar3);\n    }\n  }\n  else {\n    dVar1 = (double)FUN_0010da10(param_2);\n    dVar2 = (double)FUN_0015780e(param_1);\n    if (-DAT_001f7338 <= (dVar1 * param_1 - param_2) - dVar2) {\n      dVar1 = (double)FUN_0010d710();\n      return dVar1;\n    }\n    FUN_0013dc5a(&DAT_001e9418,2,0);\n    dVar1 = 0.0;\n  }\n  return dVar1;\n}\n\n Revised code:\ndouble igam_fac(double a, double x)\n{\n    double ax, fac, res, num;\n\n    if (fabs(a - x) > 0.4 * fabs(a)) {\n\tax = a * log(x) - x - lgam(a);\n\tif (ax < -MAXLOG) {\n\t    sf_error(\"igam\", SF_ERROR_UNDERFLOW, NULL);\n\t    return 0.0;\n\t}\n\treturn exp(ax);\n    }\n\n    fac = a + lanczos_g - 0.5;\n    res = sqrt(fac / exp(1)) / lanczos_sum_expg_scaled(a);\n\n    if ((a < 200) && (x < 200)) {\n\tres *= exp(a - x) * pow(x / fac, a);\n    } else {\n\tnum = x - a - lanczos_g + 0.5;\n\tres *= exp(a * log1pmx(num / fac) + x * (0.5 - lanczos_g) / fac);\n    }\n\n    return res;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\ndouble FUN_18002d650(long param_1,char param_2,bool param_3)\n{\n  double dVar1;\n  double dVar2;\n  if (param_2 == '\\0') {\n    dVar1 = CAAEquinoxesAndSolstices::NorthwardEquinox(param_1 + 1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::SouthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  else {\n    dVar1 = CAAEquinoxesAndSolstices::SouthwardEquinox(param_1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::NorthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  return dVar1;\n}",
        "output": "```cpp\ndouble calculateEquinoxSolsticeDifference(long year, char isNorthernHemisphere, bool isJulianCalendar)\n{\n    double equinox, solstice;\n\n    if (isNorthernHemisphere == '\\0') {\n        equinox = CAAEquinoxesAndSolstices::NorthwardEquinox(year + 1, isJulianCalendar);\n        solstice = CAAEquinoxesAndSolstices::SouthernSolstice(year, isJulianCalendar);\n    } else {\n        equinox = CAAEquinoxesAndSolstices::SouthwardEquinox(year, isJulianCalendar);\n        solstice = CAAEquinoxesAndSolstices::NorthernSolstice(year, isJulianCalendar);\n    }\n\n    return equinox - solstice;\n}\n```",
        "source_code": "double CAAEquinoxesAndSolstices::LengthOfSummer(long Year, bool bNorthernHemisphere, bool bHighPrecision) noexcept\r\n{\r\n  if (bNorthernHemisphere)\r\n    return SouthwardEquinox(Year, bHighPrecision) - NorthernSolstice(Year, bHighPrecision);\r\n  else\r\n  {\r\n    //The Summer season wraps around into the following year for the southern hemisphere\r\n    return NorthwardEquinox(Year + 1, bHighPrecision) - SouthernSolstice(Year, bHighPrecision);\r\n  }\r\n}",
        "parsed_output": "pp\ndouble calculateEquinoxSolsticeDifference(long year, char isNorthernHemisphere, bool isJulianCalendar)\n{\n    double equinox, solstice;\n\n    if (isNorthernHemisphere == '\\0') {\n        equinox = CAAEquinoxesAndSolstices::NorthwardEquinox(year + 1, isJulianCalendar);\n        solstice = CAAEquinoxesAndSolstices::SouthernSolstice(year, isJulianCalendar);\n    } else {\n        equinox = CAAEquinoxesAndSolstices::SouthwardEquinox(year, isJulianCalendar);\n        solstice = CAAEquinoxesAndSolstices::NorthernSolstice(year, isJulianCalendar);\n    }\n\n    return equinox - solstice;\n}",
        "baseline_code_stripped": "double FUN_18002d650(long param_1,char param_2,bool param_3)\n{\n  double dVar1;\n  double dVar2;\n  if (param_2 == '\\0') {\n    dVar1 = CAAEquinoxesAndSolstices::NorthwardEquinox(param_1 + 1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::SouthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  else {\n    dVar1 = CAAEquinoxesAndSolstices::SouthwardEquinox(param_1,param_3);\n    dVar2 = CAAEquinoxesAndSolstices::NorthernSolstice(param_1,param_3);\n    dVar1 = dVar1 - dVar2;\n  }\n  return dVar1;\n}",
        "similarity_score_unixcoder": 0.7765808701515198,
        "similarity_score_baseline_stripped": 0.5614171624183655
    },
    {
        "func_name": "Scm_S32VectorSet",
        "normed_func_sha256": "747814e3360de27d88c17c45d311f75c97043d5c39faf4a77b6b7c2eea7dd68a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_000cb760(int param_1)\n{\n  undefined4 uVar1;\n  uVar1 = 0;\n  if ((*(uint *)(param_1 + 4) & 1) != 0) {\n    uVar1 = *(undefined4 *)((*(uint *)(param_1 + 4) & 0xfffffffe) + 8);\n  }\n  *(undefined4 *)(param_1 + 8) = uVar1;\n  return;\n}\n\n Revised code:\n::size_t LookupResourceAndParent::ByteSizeLong() const {\n// @@protoc_insertion_point(message_byte_size_start:Orthanc.DatabasePluginMessages.LookupResourceAndParent)\n  ::size_t total_size = 0;\n\n  ::uint32_t cached_has_bits = 0;\n  // Prevent compiler warnings about cached_has_bits being unused\n  (void) cached_has_bits;\n\n  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {\n    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();\n  }\n  int cached_size = ::_pbi::ToCachedSize(total_size);\n  SetCachedSize(cached_size);\n  return total_size;\n}\n\n## Example:\n\n Input code:\nint FUN_0003f849(int **param_1,int param_2)\n{\n  int *piVar1;\n  int iVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint *puVar6;\n  puVar6 = (uint *)param_1[param_2 + -1];\n  iVar2 = Scm_Length(puVar6);\n  if (2 < iVar2) {\n    uVar3 = Scm_Length(puVar6);\n    Scm_Error(\"too many arguments: up to 2 is expected, %d given.\",uVar3);\n  }\n  piVar1 = *param_1;\n  if ((((uint)piVar1 & 3) != 0) || (*piVar1 != 0x624e3)) {\n    Scm_Error(\"<u32vector> required, but got %S\",piVar1);\n  }\n  if (puVar6 == (uint *)0x26) {\n    uVar4 = Scm_MakeInteger(0);\n    puVar6 = (uint *)0x26;\n  }\n  else {\n    uVar4 = *puVar6;\n    puVar6 = (uint *)puVar6[1];\n  }\n  if ((uVar4 & 3) != 1) {\n    Scm_Error(\"small integer required, but got %S\",uVar4);\n  }\n  if (puVar6 == (uint *)0x26) {\n    uVar5 = Scm_MakeInteger(0xffffffff);\n  }\n  else {\n    uVar5 = *puVar6;\n  }\n  if ((uVar5 & 3) != 1) {\n    Scm_Error(\"small integer required, but got %S\",uVar5);\n  }\n  iVar2 = Scm_U32VectorToVector(piVar1,(int)uVar4 >> 2,(int)uVar5 >> 2);\n  if (iVar2 != 0) {\n    return iVar2;\n  }\n  return 0x46;\n}\n\n Revised code:\nstatic ScmObj uvlib_u32vector_TOvector(ScmObj *SCM_FP, int SCM_ARGCNT, void *data_)\n{\n  ScmObj v_scm;\n  ScmU32Vector* v;\n  ScmObj start_scm;\n  int start;\n  ScmObj end_scm;\n  int end;\n  ScmObj SCM_OPTARGS = SCM_ARGREF(SCM_ARGCNT-1);\n  SCM_ENTER_SUBR(\"u32vector->vector\");\n  if (Scm_Length(SCM_OPTARGS) > 2)\n    Scm_Error(\"too many arguments: up to 2 is expected, %d given.\", Scm_Length(SCM_OPTARGS));\n  v_scm = SCM_ARGREF(0);\n  if (!SCM_U32VECTORP(v_scm)) Scm_Error(\"<u32vector> required, but got %S\", v_scm);\n  v = SCM_U32VECTOR(v_scm);\n  if (SCM_NULLP(SCM_OPTARGS)) start_scm = Scm_MakeInteger(0);\n  else {\n    start_scm = SCM_CAR(SCM_OPTARGS);\n    SCM_OPTARGS = SCM_CDR(SCM_OPTARGS);\n  }\n  if (!SCM_INTP(start_scm)) Scm_Error(\"small integer required, but got %S\", start_scm);\n  start = SCM_INT_VALUE(start_scm);\n  if (SCM_NULLP(SCM_OPTARGS)) end_scm = Scm_MakeInteger(-1);\n  else {\n    end_scm = SCM_CAR(SCM_OPTARGS);\n    SCM_OPTARGS = SCM_CDR(SCM_OPTARGS);\n  }\n  if (!SCM_INTP(end_scm)) Scm_Error(\"small integer required, but got %S\", end_scm);\n  end = SCM_INT_VALUE(end_scm);\n  {\n{\nScmObj SCM_RESULT;\nSCM_RESULT = Scm_U32VectorToVector(v, start, end);\nSCM_RETURN(SCM_OBJ_SAFE(SCM_RESULT));\n}\n  }\n}\n\n## Example:\n\n Input code:\nvoid FUN_00576d90(int param_1,int param_2,undefined4 *param_3)\n{\n  undefined4 uVar1;\n  uVar1 = param_3[1];\n  *(undefined4 *)(param_1 + param_2 * 8) = *param_3;\n  *(undefined4 *)(param_1 + 4 + param_2 * 8) = uVar1;\n  return;\n}\n\n Revised code:\nstatic void assign_wxPosition(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)\n{\n    reinterpret_cast< ::wxPosition *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::wxPosition *>(sipSrc);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint Scm_S32VectorSet(int param_1,int param_2,undefined4 param_3,undefined4 param_4)\n{\n  undefined4 uVar1;\n  if ((param_2 < 0) || (*(int *)(param_1 + 4) >> 1 <= param_2)) {\n    Scm_Error(\"index out of range: %d\",param_2);\n  }\n  if ((*(byte *)(param_1 + 4) & 1) != 0) {\n    Scm_Error(\"uniform vector is immutable: %S\",param_1);\n  }\n  uVar1 = Scm_GetInteger32Clamp(param_3,param_4,0);\n  *(undefined4 *)(*(int *)(param_1 + 0xc) + param_2 * 4) = uVar1;\n  return param_1;\n}",
        "output": "```c\nstatic ScmObj Scm_S32VectorSet(ScmObj vec, int index, ScmObj value, ScmObj clamp)\n{\n    if (index < 0 || (SCM_S32VECTOR_SIZE(vec) <= index)) {\n        Scm_Error(\"index out of range: %d\", index);\n    }\n    if (SCM_S32VECTOR_IMMUTABLE(vec)) {\n        Scm_Error(\"uniform vector is immutable: %S\", vec);\n    }\n    int clamped_value = Scm_GetInteger32Clamp(value, clamp, 0);\n    SCM_S32VECTOR_SET(vec, index, clamped_value);\n    return vec;\n}\n```",
        "source_code": "ScmObj Scm_S32VectorSet(ScmS32Vector *vec, int index, ScmObj val, int clamp)\n{\n    ScmInt32 elt;\n    if (index < 0 || index >= SCM_S32VECTOR_SIZE(vec))\n        Scm_Error(\"index out of range: %d\", index);\n    SCM_UVECTOR_CHECK_MUTABLE(vec);\n    elt = (ScmInt32)Scm_GetInteger32Clamp(val, clamp, NULL);\n    SCM_S32VECTOR_ELEMENTS(vec)[index] = elt;\n    return SCM_OBJ(vec);\n}",
        "parsed_output": "static ScmObj Scm_S32VectorSet(ScmObj vec, int index, ScmObj value, ScmObj clamp)\n{\n    if (index < 0 || (SCM_S32VECTOR_SIZE(vec) <= index)) {\n        Scm_Error(\"index out of range: %d\", index);\n    }\n    if (SCM_S32VECTOR_IMMUTABLE(vec)) {\n        Scm_Error(\"uniform vector is immutable: %S\", vec);\n    }\n    int clamped_value = Scm_GetInteger32Clamp(value, clamp, 0);\n    SCM_S32VECTOR_SET(vec, index, clamped_value);\n    return vec;\n}",
        "baseline_code_stripped": "int Scm_S32VectorSet(int param_1,int param_2,undefined4 param_3,undefined4 param_4)\n{\n  undefined4 uVar1;\n  if ((param_2 < 0) || (*(int *)(param_1 + 4) >> 1 <= param_2)) {\n    Scm_Error(\"index out of range: %d\",param_2);\n  }\n  if ((*(byte *)(param_1 + 4) & 1) != 0) {\n    Scm_Error(\"uniform vector is immutable: %S\",param_1);\n  }\n  uVar1 = Scm_GetInteger32Clamp(param_3,param_4,0);\n  *(undefined4 *)(*(int *)(param_1 + 0xc) + param_2 * 4) = uVar1;\n  return param_1;\n}",
        "similarity_score_unixcoder": 0.8882717490196228,
        "similarity_score_baseline_stripped": 0.7355295419692993
    },
    {
        "func_name": "_wrap_SpinButton_SetValue",
        "normed_func_sha256": "4372c039ca3a0465f8cbb97b3b7a556824a043afd1618b9316bbe9bc9896b79b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined * FUN_00079184(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int *local_138;\n  undefined4 local_134;\n  undefined4 local_130;\n  undefined4 local_12c;\n  undefined *local_128;\n  undefined *local_124;\n  undefined4 local_120;\n  undefined auStack_11c [268];\n  local_130 = 0;\n  local_138 = (int *)0x0;\n  local_134 = 0;\n  local_120 = _DAT_00104c4c;\n  local_128 = PTR_DAT_00104c44;\n  local_124 = PTR_s_minVal_00104c48;\n  iVar1 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"OO:SpinButton_SetMin\",&local_128,&local_134,&local_130);\n  if (iVar1 != 0) {\n    FUN_00041f74(local_134,&local_138,_DAT_00113c10,1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",1);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    uVar2 = local_130;\n    iVar1 = PyNumber_Check(local_130);\n    if (iVar1 == 0) {\n      FUN_00041db4(\"number\",uVar2);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = PyInt_AsLong(uVar2);\n    }\n    local_12c = uVar2;\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",2);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    uVar3 = (**(code **)(_DAT_001124f8 + 0x10))();\n    (**(code **)(*local_138 + 0x2c0))(local_138,uVar2);\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    (**(code **)(_DAT_001124f8 + 0x14))(uVar3);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      __Py_NoneStruct = __Py_NoneStruct + 1;\n      return &_Py_NoneStruct;\n    }\n  }\n  return (undefined *)0x0;\n}\n\n Revised code:\nstatic PyObject *_wrap_SpinButton_SetMin(PyObject *, PyObject *args, PyObject *kwargs) {\n    PyObject *resultobj = NULL;\n    wxSpinButton *arg1 = (wxSpinButton *) 0 ;\n    int arg2 ;\n    PyObject * obj0 = 0 ;\n    PyObject * obj1 = 0 ;\n    char *kwnames[] = {\n        (char *) \"self\",(char *) \"minVal\", NULL \n    };\n    \n    if(!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"OO:SpinButton_SetMin\",kwnames,&obj0,&obj1)) goto fail;\n    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_wxSpinButton, SWIG_POINTER_EXCEPTION | 0);\n    if (SWIG_arg_fail(1)) SWIG_fail;\n    {\n        arg2 = static_cast<int >(SWIG_As_int(obj1)); \n        if (SWIG_arg_fail(2)) SWIG_fail;\n    }\n    {\n        PyThreadState* __tstate = wxPyBeginAllowThreads();\n        (arg1)->SetMin(arg2);\n        \n        wxPyEndAllowThreads(__tstate);\n        if (PyErr_Occurred()) SWIG_fail;\n    }\n    Py_INCREF(Py_None); resultobj = Py_None;\n    return resultobj;\n    fail:\n    return NULL;\n}\n\n## Example:\n\n Input code:\nundefined * FUN_000780f4(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint local_138;\n  undefined4 local_134;\n  undefined4 local_130;\n  undefined *local_12c;\n  undefined *local_128;\n  undefined4 local_124;\n  undefined auStack_120 [272];\n  local_130 = 0;\n  local_138 = 0;\n  local_134 = 0;\n  local_124 = _DAT_000e5ea4;\n  local_12c = PTR_DAT_000e5e9c;\n  local_128 = PTR_s_count_000e5ea0;\n  iVar1 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"OO:VScrolledWindow_SetLineCount\",&local_12c,&local_134,\n                     &local_130);\n  if (iVar1 != 0) {\n    FUN_0003fcc4(local_134,&local_138,_DAT_000f3574,1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_120,0x100,\"argument number %d:\",1);\n      iVar1 = FUN_0003b1e4(auStack_120,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    uVar2 = local_130;\n    iVar1 = PyNumber_Check(local_130);\n    if (iVar1 == 0) {\n      FUN_0003fb04(\"number\",uVar2);\n    }\n    else {\n      iVar1 = PyInt_AsLong(uVar2);\n      if (iVar1 < 0) {\n        FUN_0003fb04(\"unsigned number\",uVar2);\n      }\n    }\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_120,0x100,\"argument number %d:\",2);\n      iVar1 = FUN_0003b1e4(auStack_120,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    if (_DAT_000f1e0c == 0) {\n      _DAT_000f1e0c = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    uVar2 = (**(code **)(_DAT_000f1e0c + 0x10))();\n    wxVScrolledWindow::SetLineCount(local_138);\n    if (_DAT_000f1e0c == 0) {\n      _DAT_000f1e0c = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    (**(code **)(_DAT_000f1e0c + 0x14))(uVar2);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      __Py_NoneStruct = __Py_NoneStruct + 1;\n      return &_Py_NoneStruct;\n    }\n  }\n  return (undefined *)0x0;\n}\n\n Revised code:\nstatic PyObject *_wrap_VScrolledWindow_SetLineCount(PyObject *, PyObject *args, PyObject *kwargs) {\n    PyObject *resultobj = NULL;\n    wxPyVScrolledWindow *arg1 = (wxPyVScrolledWindow *) 0 ;\n    size_t arg2 ;\n    PyObject * obj0 = 0 ;\n    PyObject * obj1 = 0 ;\n    char *kwnames[] = {\n        (char *) \"self\",(char *) \"count\", NULL \n    };\n    \n    if(!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"OO:VScrolledWindow_SetLineCount\",kwnames,&obj0,&obj1)) goto fail;\n    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_wxPyVScrolledWindow, SWIG_POINTER_EXCEPTION | 0);\n    if (SWIG_arg_fail(1)) SWIG_fail;\n    {\n        arg2 = static_cast<size_t >(SWIG_As_unsigned_SS_long(obj1)); \n        if (SWIG_arg_fail(2)) SWIG_fail;\n    }\n    {\n        PyThreadState* __tstate = wxPyBeginAllowThreads();\n        (arg1)->SetLineCount(arg2);\n        \n        wxPyEndAllowThreads(__tstate);\n        if (PyErr_Occurred()) SWIG_fail;\n    }\n    Py_INCREF(Py_None); resultobj = Py_None;\n    return resultobj;\n    fail:\n    return NULL;\n}\n\n## Example:\n\n Input code:\nundefined * FUN_0003b8b4(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  undefined *puVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined4 local_134;\n  undefined4 local_130;\n  undefined *local_12c;\n  undefined4 local_128;\n  undefined *local_124;\n  undefined *local_120;\n  undefined4 local_11c;\n  undefined auStack_118 [264];\n  local_134 = 0;\n  local_130 = 0;\n  local_12c = (undefined *)0x0;\n  local_11c = _DAT_0009d1d4;\n  local_124 = PTR_DAT_0009d1cc;\n  local_120 = PTR_s_buffered_0009d1d0;\n  iVar2 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"OO:StyledTextCtrl_SetBufferedDraw\",&local_124,&local_130,\n                     &local_12c);\n  if (iVar2 != 0) {\n    FUN_0002d2e4(local_130,&local_134,_DAT_000a6df4,1);\n    iVar2 = PyErr_Occurred();\n    if (iVar2 != 0) {\n      PyOS_snprintf(auStack_118,0x100,\"argument number %d:\",1);\n      iVar2 = FUN_0002b364(auStack_118,1);\n      if (iVar2 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    puVar1 = local_12c;\n    if ((local_12c != &_Py_TrueStruct) && (local_12c != &_Py_ZeroStruct)) {\n      local_128 = 0;\n      iVar2 = PyNumber_Check(local_12c);\n      if (iVar2 == 0) {\n        FUN_0002d124(\"number\",puVar1);\n        PyErr_Clear();\n        FUN_0002d124(&DAT_00080a28,puVar1);\n      }\n      else {\n        local_128 = PyInt_AsLong(puVar1);\n      }\n    }\n    iVar2 = PyErr_Occurred();\n    if (iVar2 != 0) {\n      PyOS_snprintf(auStack_118,0x100,\"argument number %d:\",2);\n      iVar2 = FUN_0002b364(auStack_118,1);\n      if (iVar2 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    if (_DAT_000a5384 == 0) {\n      _DAT_000a5384 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    uVar3 = (**(code **)(_DAT_000a5384 + 0x10))();\n    wxStyledTextCtrl::SetBufferedDraw(SUB41(local_134,0));\n    if (_DAT_000a5384 == 0) {\n      _DAT_000a5384 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    (**(code **)(_DAT_000a5384 + 0x14))(uVar3);\n    iVar2 = PyErr_Occurred();\n    if (iVar2 == 0) {\n      __Py_NoneStruct = __Py_NoneStruct + 1;\n      return &_Py_NoneStruct;\n    }\n  }\n  return (undefined *)0x0;\n}\n\n Revised code:\nstatic PyObject *_wrap_StyledTextCtrl_SetBufferedDraw(PyObject *, PyObject *args, PyObject *kwargs) {\n    PyObject *resultobj = NULL;\n    wxStyledTextCtrl *arg1 = (wxStyledTextCtrl *) 0 ;\n    bool arg2 ;\n    PyObject * obj0 = 0 ;\n    PyObject * obj1 = 0 ;\n    char *kwnames[] = {\n        (char *) \"self\",(char *) \"buffered\", NULL \n    };\n    \n    if(!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"OO:StyledTextCtrl_SetBufferedDraw\",kwnames,&obj0,&obj1)) goto fail;\n    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_wxStyledTextCtrl, SWIG_POINTER_EXCEPTION | 0);\n    if (SWIG_arg_fail(1)) SWIG_fail;\n    {\n        arg2 = static_cast<bool >(SWIG_As_bool(obj1)); \n        if (SWIG_arg_fail(2)) SWIG_fail;\n    }\n    {\n        PyThreadState* __tstate = wxPyBeginAllowThreads();\n        (arg1)->SetBufferedDraw(arg2);\n        \n        wxPyEndAllowThreads(__tstate);\n        if (PyErr_Occurred()) SWIG_fail;\n    }\n    Py_INCREF(Py_None); resultobj = Py_None;\n    return resultobj;\n    fail:\n    return NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined * FUN_00078f64(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int *local_138;\n  undefined4 local_134;\n  undefined4 local_130;\n  undefined4 local_12c;\n  undefined *local_128;\n  undefined *local_124;\n  undefined4 local_120;\n  undefined auStack_11c [268];\n  local_130 = 0;\n  local_138 = (int *)0x0;\n  local_134 = 0;\n  local_120 = _DAT_00104c40;\n  local_128 = PTR_DAT_00104c38;\n  local_124 = PTR_DAT_00104c3c;\n  iVar1 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"OO:SpinButton_SetValue\",&local_128,&local_134,&local_130);\n  if (iVar1 != 0) {\n    FUN_00041f74(local_134,&local_138,_DAT_00113c10,1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",1);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    uVar2 = local_130;\n    iVar1 = PyNumber_Check(local_130);\n    if (iVar1 == 0) {\n      FUN_00041db4(\"number\",uVar2);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = PyInt_AsLong(uVar2);\n    }\n    local_12c = uVar2;\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",2);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    uVar3 = (**(code **)(_DAT_001124f8 + 0x10))();\n    (**(code **)(*local_138 + 700))(local_138,uVar2);\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    (**(code **)(_DAT_001124f8 + 0x14))(uVar3);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      __Py_NoneStruct = __Py_NoneStruct + 1;\n      return &_Py_NoneStruct;\n    }\n  }\n  return (undefined *)0x0;\n}",
        "output": "```c\nstatic PyObject *_wrap_SpinButton_SetValue(PyObject *, PyObject *args, PyObject *kwargs) {\n    PyObject *resultobj = NULL;\n    wxSpinButton *arg1 = (wxSpinButton *) 0 ;\n    int arg2 ;\n    PyObject * obj0 = 0 ;\n    PyObject * obj1 = 0 ;\n    char *kwnames[] = {\n        (char *) \"self\",(char *) \"value\", NULL \n    };\n    \n    if(!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"OO:SpinButton_SetValue\",kwnames,&obj0,&obj1)) goto fail;\n    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_wxSpinButton, SWIG_POINTER_EXCEPTION | 0);\n    if (SWIG_arg_fail(1)) SWIG_fail;\n    {\n        arg2 = static_cast<int >(SWIG_As_int(obj1)); \n        if (SWIG_arg_fail(2)) SWIG_fail;\n    }\n    {\n        PyThreadState* __tstate = wxPyBeginAllowThreads();\n        (arg1)->SetValue(arg2);\n        \n        wxPyEndAllowThreads(__tstate);\n        if (PyErr_Occurred()) SWIG_fail;\n    }\n    Py_INCREF(Py_None); resultobj = Py_None;\n    return resultobj;\n    fail:\n    return NULL;\n}\n```",
        "source_code": "static PyObject *_wrap_SpinButton_SetValue(PyObject *, PyObject *args, PyObject *kwargs) {\n    PyObject *resultobj = NULL;\n    wxSpinButton *arg1 = (wxSpinButton *) 0 ;\n    int arg2 ;\n    PyObject * obj0 = 0 ;\n    PyObject * obj1 = 0 ;\n    char *kwnames[] = {\n        (char *) \"self\",(char *) \"val\", NULL \n    };\n    \n    if(!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"OO:SpinButton_SetValue\",kwnames,&obj0,&obj1)) goto fail;\n    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_wxSpinButton, SWIG_POINTER_EXCEPTION | 0);\n    if (SWIG_arg_fail(1)) SWIG_fail;\n    {\n        arg2 = static_cast<int >(SWIG_As_int(obj1)); \n        if (SWIG_arg_fail(2)) SWIG_fail;\n    }\n    {\n        PyThreadState* __tstate = wxPyBeginAllowThreads();\n        (arg1)->SetValue(arg2);\n        \n        wxPyEndAllowThreads(__tstate);\n        if (PyErr_Occurred()) SWIG_fail;\n    }\n    Py_INCREF(Py_None); resultobj = Py_None;\n    return resultobj;\n    fail:\n    return NULL;\n}",
        "parsed_output": "static PyObject *_wrap_SpinButton_SetValue(PyObject *, PyObject *args, PyObject *kwargs) {\n    PyObject *resultobj = NULL;\n    wxSpinButton *arg1 = (wxSpinButton *) 0 ;\n    int arg2 ;\n    PyObject * obj0 = 0 ;\n    PyObject * obj1 = 0 ;\n    char *kwnames[] = {\n        (char *) \"self\",(char *) \"value\", NULL \n    };\n    \n    if(!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"OO:SpinButton_SetValue\",kwnames,&obj0,&obj1)) goto fail;\n    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_wxSpinButton, SWIG_POINTER_EXCEPTION | 0);\n    if (SWIG_arg_fail(1)) SWIG_fail;\n    {\n        arg2 = static_cast<int >(SWIG_As_int(obj1)); \n        if (SWIG_arg_fail(2)) SWIG_fail;\n    }\n    {\n        PyThreadState* __tstate = wxPyBeginAllowThreads();\n        (arg1)->SetValue(arg2);\n        \n        wxPyEndAllowThreads(__tstate);\n        if (PyErr_Occurred()) SWIG_fail;\n    }\n    Py_INCREF(Py_None); resultobj = Py_None;\n    return resultobj;\n    fail:\n    return NULL;\n}",
        "baseline_code_stripped": "undefined * FUN_00078f64(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int *local_138;\n  undefined4 local_134;\n  undefined4 local_130;\n  undefined4 local_12c;\n  undefined *local_128;\n  undefined *local_124;\n  undefined4 local_120;\n  undefined auStack_11c [268];\n  local_130 = 0;\n  local_138 = (int *)0x0;\n  local_134 = 0;\n  local_120 = _DAT_00104c40;\n  local_128 = PTR_DAT_00104c38;\n  local_124 = PTR_DAT_00104c3c;\n  iVar1 = PyArg_ParseTupleAndKeywords\n                    (param_2,param_3,\"OO:SpinButton_SetValue\",&local_128,&local_134,&local_130);\n  if (iVar1 != 0) {\n    FUN_00041f74(local_134,&local_138,_DAT_00113c10,1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",1);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    uVar2 = local_130;\n    iVar1 = PyNumber_Check(local_130);\n    if (iVar1 == 0) {\n      FUN_00041db4(\"number\",uVar2);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = PyInt_AsLong(uVar2);\n    }\n    local_12c = uVar2;\n    iVar1 = PyErr_Occurred();\n    if (iVar1 != 0) {\n      PyOS_snprintf(auStack_11c,0x100,\"argument number %d:\",2);\n      iVar1 = FUN_0003da74(auStack_11c,1);\n      if (iVar1 != 0) {\n        return (undefined *)0x0;\n      }\n    }\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    uVar3 = (**(code **)(_DAT_001124f8 + 0x10))();\n    (**(code **)(*local_138 + 700))(local_138,uVar2);\n    if (_DAT_001124f8 == 0) {\n      _DAT_001124f8 = PyCObject_Import(\"wx._core_\",\"_wxPyCoreAPI\");\n    }\n    (**(code **)(_DAT_001124f8 + 0x14))(uVar3);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      __Py_NoneStruct = __Py_NoneStruct + 1;\n      return &_Py_NoneStruct;\n    }\n  }\n  return (undefined *)0x0;\n}",
        "similarity_score_unixcoder": 0.9991927146911621,
        "similarity_score_baseline_stripped": 0.6331114172935486
    },
    {
        "func_name": "gen_aarch64_fcmla0v8hf",
        "normed_func_sha256": "9993a206e0c3c63f19e507a837715d8e0b7a32cb6924ca53e7f90e67cb5e1013",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_11140950(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  longlong lVar1;\n  undefined8 uVar2;\n  longlong lVar3;\n  lVar1 = FUN_108a6b18(0x4d);\n  *(undefined8 *)(lVar1 + 8) = param_3;\n  *(undefined8 *)(lVar1 + 0x10) = param_4;\n  *(undefined *)(lVar1 + 2) = 0x5e;\n  uVar2 = FUN_104dcb58(2,param_2);\n  lVar1 = FUN_108a6b18(0x14);\n  *(undefined *)(lVar1 + 2) = 0x5e;\n  *(undefined8 *)(lVar1 + 8) = uVar2;\n  *(undefined4 *)(lVar1 + 0x10) = 0x6d;\n  lVar3 = FUN_108a6b18(0x19);\n  *(undefined8 *)(lVar3 + 8) = param_1;\n  *(longlong *)(lVar3 + 0x10) = lVar1;\n  *(undefined *)(lVar3 + 2) = 0;\n  return;\n}\n\n Revised code:\nrtx\ngen_aarch64_pred_uminvnx8qi (rtx operand0 ATTRIBUTE_UNUSED,\n\trtx operand1 ATTRIBUTE_UNUSED,\n\trtx operand2 ATTRIBUTE_UNUSED,\n\trtx operand3 ATTRIBUTE_UNUSED)\n{\n  return gen_rtx_SET (operand0,\n\tgen_rtx_UNSPEC (VNx8QImode,\n\tgen_rtvec (2,\n\t\toperand1,\n\t\tgen_rtx_UMIN (VNx8QImode,\n\toperand2,\n\toperand3)),\n\t109));\n}\n\n## Example:\n\n Input code:\nvoid FUN_10fd7740(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  undefined8 uVar1;\n  longlong lVar2;\n  longlong lVar3;\n  uVar1 = FUN_10462568(2,param_3,param_2);\n  lVar2 = FUN_1083c208(0x14);\n  *(undefined8 *)(lVar2 + 8) = uVar1;\n  *(undefined *)(lVar2 + 2) = 0x71;\n  *(undefined4 *)(lVar2 + 0x10) = 0x7b;\n  lVar3 = FUN_1083c208(0x19);\n  *(undefined *)(lVar3 + 2) = 0;\n  *(undefined8 *)(lVar3 + 8) = param_1;\n  *(longlong *)(lVar3 + 0x10) = lVar2;\n  return;\n}\n\n Revised code:\nrtx\ngen_vec_mask_load_lanesvnx4dfvnx2df (rtx operand0 ATTRIBUTE_UNUSED,\n\trtx operand1 ATTRIBUTE_UNUSED,\n\trtx operand2 ATTRIBUTE_UNUSED)\n{\n  return gen_rtx_SET (operand0,\n\tgen_rtx_UNSPEC (VNx4DFmode,\n\tgen_rtvec (2,\n\t\toperand2,\n\t\toperand1),\n\t123));\n}\n\n## Example:\n\n Input code:\nvoid FUN_10d96590(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 uVar1;\n  longlong lVar2;\n  longlong lVar3;\n  uVar1 = FUN_101dcbb8(3,param_3,param_4,param_2);\n  lVar2 = FUN_105b6748(0x14);\n  *(undefined8 *)(lVar2 + 8) = uVar1;\n  *(undefined *)(lVar2 + 2) = 0x4a;\n  *(undefined4 *)(lVar2 + 0x10) = 0x17b;\n  lVar3 = FUN_105b6748(0x19);\n  *(undefined *)(lVar3 + 2) = 0;\n  *(undefined8 *)(lVar3 + 8) = param_1;\n  *(longlong *)(lVar3 + 0x10) = lVar2;\n  return;\n}\n\n Revised code:\nrtx\ngen_aarch64_sve_adcltvnx2di (rtx operand0 ATTRIBUTE_UNUSED,\n\trtx operand1 ATTRIBUTE_UNUSED,\n\trtx operand2 ATTRIBUTE_UNUSED,\n\trtx operand3 ATTRIBUTE_UNUSED)\n{\n  return gen_rtx_SET (operand0,\n\tgen_rtx_UNSPEC (VNx2DImode,\n\tgen_rtvec (3,\n\t\toperand2,\n\t\toperand3,\n\t\toperand1),\n\t379));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_10dda440(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 uVar1;\n  longlong lVar2;\n  longlong lVar3;\n  uVar1 = FUN_102c5b28(2,param_3,param_4);\n  lVar2 = FUN_106a7fd8(0x14);\n  *(undefined4 *)(lVar2 + 0x10) = 0x175;\n  *(undefined8 *)(lVar2 + 8) = uVar1;\n  *(undefined *)(lVar2 + 2) = 0x67;\n  lVar3 = FUN_106a7fd8(0x36);\n  *(undefined *)(lVar3 + 2) = 0x67;\n  *(undefined8 *)(lVar3 + 8) = param_2;\n  *(longlong *)(lVar3 + 0x10) = lVar2;\n  lVar2 = FUN_106a7fd8(0x19);\n  *(undefined *)(lVar2 + 2) = 0;\n  *(undefined8 *)(lVar2 + 8) = param_1;\n  *(longlong *)(lVar2 + 0x10) = lVar3;\n  return;\n}",
        "output": "rtx\ngen_aarch64_sve_usubltvnx4si (rtx operand0 ATTRIBUTE_UNUSED,\n\trtx operand1 ATTRIBUTE_UNUSED,\n\trtx operand2 ATTRIBUTE_UNUSED,\n\trtx operand3 ATTRIBUTE_UNUSED)\n{\n  return gen_rtx_SET (operand0,\n\tgen_rtx_UNSPEC (VNx4SImode,\n\tgen_rtvec (3,\n\t\toperand3,\n\t\toperand2,\n\t\tgen_rtx_UNSPEC (VNx4SImode,\n\t\tgen_rtvec (2,\n\t\t\toperand1,\n\t\t\toperand0),\n\t\t103)),\n\t373));\n}",
        "source_code": "rtx\ngen_aarch64_fcmla0v8hf (rtx operand0 ATTRIBUTE_UNUSED,\n\trtx operand1 ATTRIBUTE_UNUSED,\n\trtx operand2 ATTRIBUTE_UNUSED,\n\trtx operand3 ATTRIBUTE_UNUSED)\n{\n  return gen_rtx_SET (operand0,\n\tgen_rtx_PLUS (V8HFmode,\n\toperand1,\n\tgen_rtx_UNSPEC (V8HFmode,\n\tgen_rtvec (2,\n\t\toperand2,\n\t\toperand3),\n\t373)));\n}",
        "parsed_output": "rtx\ngen_aarch64_sve_usubltvnx4si (rtx operand0 ATTRIBUTE_UNUSED,\n\trtx operand1 ATTRIBUTE_UNUSED,\n\trtx operand2 ATTRIBUTE_UNUSED,\n\trtx operand3 ATTRIBUTE_UNUSED)\n{\n  return gen_rtx_SET (operand0,\n\tgen_rtx_UNSPEC (VNx4SImode,\n\tgen_rtvec (3,\n\t\toperand3,\n\t\toperand2,\n\t\tgen_rtx_UNSPEC (VNx4SImode,\n\t\tgen_rtvec (2,\n\t\t\toperand1,\n\t\t\toperand0),\n\t\t103)),\n\t373));\n}",
        "baseline_code_stripped": "void FUN_10dda440(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 uVar1;\n  longlong lVar2;\n  longlong lVar3;\n  uVar1 = FUN_102c5b28(2,param_3,param_4);\n  lVar2 = FUN_106a7fd8(0x14);\n  *(undefined4 *)(lVar2 + 0x10) = 0x175;\n  *(undefined8 *)(lVar2 + 8) = uVar1;\n  *(undefined *)(lVar2 + 2) = 0x67;\n  lVar3 = FUN_106a7fd8(0x36);\n  *(undefined *)(lVar3 + 2) = 0x67;\n  *(undefined8 *)(lVar3 + 8) = param_2;\n  *(longlong *)(lVar3 + 0x10) = lVar2;\n  lVar2 = FUN_106a7fd8(0x19);\n  *(undefined *)(lVar2 + 2) = 0;\n  *(undefined8 *)(lVar2 + 8) = param_1;\n  *(longlong *)(lVar2 + 0x10) = lVar3;\n  return;\n}",
        "similarity_score_unixcoder": 0.9285577535629272,
        "similarity_score_baseline_stripped": 0.4848305284976959
    },
    {
        "func_name": "netdfs_dissect_struct_dfs_Info7",
        "normed_func_sha256": "a48f04ed5282635da9004526d138dcf00b3d91031e468b552e50939e57c80577",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nuint FUN_007f8cb0(undefined4 param_1,uint param_2,int param_3,int param_4,undefined4 param_5,\n                 undefined4 param_6)\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  iVar1 = *(int *)(param_3 + 0xec);\n  if ((*(int *)(iVar1 + 0xc) == 0) && ((param_2 & 7) != 0)) {\n    param_2 = (param_2 & 0xfffffff8) + 8;\n  }\n  uVar5 = 0;\n  uVar4 = 0;\n  if (param_4 != 0) {\n    uVar4 = proto_tree_add_item(param_4,param_6,param_1,param_2,0xffffffff,1);\n    uVar5 = proto_item_add_subtree(uVar4,DAT_0214f730);\n  }\n  uVar2 = FUN_007f8c60(param_3,uVar5,param_5,0,DAT_0214f8d4);\n  FUN_01015860(param_1,uVar2,param_3,uVar5,param_5,DAT_0214fb74);\n  uVar3 = FUN_007f8c60(param_3,uVar5,param_5,0,DAT_0214f9dc);\n  proto_item_set_len(uVar4,uVar3 - param_2);\n  if ((((*(byte *)(*(int *)(iVar1 + 0x34) + 0x48) & 1) != 0) &&\n      (*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0)) && ((uVar3 & 7) != 0)) {\n    uVar3 = (uVar3 & 0xfffffff8) + 8;\n  }\n  return uVar3;\n}\n\n Revised code:\nint\nsamr_dissect_struct_DomInfo13(tvbuff_t *tvb _U_, int offset _U_, packet_info *pinfo _U_, proto_tree *parent_tree _U_, guint8 *drep _U_, int hf_index _U_, guint32 param _U_)\n{\n\tproto_item *item = NULL;\n\tproto_tree *tree = NULL;\n\tdcerpc_info *di = pinfo->private_data;\n\tint old_offset;\n\n\tALIGN_TO_8_BYTES;\n\n\told_offset = offset;\n\n\tif (parent_tree) {\n\t\titem = proto_tree_add_item(parent_tree, hf_index, tvb, offset, -1, TRUE);\n\t\ttree = proto_item_add_subtree(item, ett_samr_samr_DomInfo13);\n\t}\n\t\n\toffset = samr_dissect_element_DomInfo13_sequence_num(tvb, offset, pinfo, tree, drep);\n\n\toffset = samr_dissect_element_DomInfo13_domain_create_time(tvb, offset, pinfo, tree, drep);\n\n\toffset = samr_dissect_element_DomInfo13_modified_count_at_last_promotion(tvb, offset, pinfo, tree, drep);\n\n\n\tproto_item_set_len(item, offset-old_offset);\n\n\n\tif (di->call_data->flags & DCERPC_IS_NDR64) {\n\t\tALIGN_TO_8_BYTES;\n\t}\n\n\treturn offset;\n}\n\n## Example:\n\n Input code:\nint FUN_00b10a40(undefined4 param_1,int param_2,undefined4 param_3,int param_4,undefined4 param_5)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  uVar3 = 0;\n  uVar1 = 0;\n  if (param_4 != 0) {\n    uVar3 = proto_tree_add_text(param_4,param_1,param_2,0xffffffff,\"LOGON_HOURS:\");\n    uVar1 = proto_item_add_subtree(uVar3,_DAT_0150bba4);\n  }\n  iVar2 = dissect_ndr_ucvarray(param_1,param_2,param_3,uVar1,param_5,FUN_00b10b20);\n  proto_item_set_len(uVar3,iVar2 - param_2);\n  return iVar2;\n}\n\n Revised code:\nstatic int\ndissect_LOGON_HOURS_hours(tvbuff_t *tvb, int offset,\n\t\t\t  packet_info *pinfo, proto_tree *parent_tree,\n\t\t\t  guint8 *drep)\n{\n\tproto_item *item=NULL;\n\tproto_tree *tree=NULL;\n\tint old_offset=offset;\n\n\tif(parent_tree){\n\t\titem = proto_tree_add_text(parent_tree, tvb, offset, -1,\n\t\t\t\"LOGON_HOURS:\");\n\t\ttree = proto_item_add_subtree(item, ett_nt_logon_hours_hours);\n\t}\n\n\toffset = dissect_ndr_ucvarray(tvb, offset, pinfo, tree, drep,\n\t\t\tdissect_LOGON_HOURS_entry);\n\n\tproto_item_set_len(item, offset-old_offset);\n\treturn offset;\n\n\treturn offset;\n}\n\n## Example:\n\n Input code:\nint FUN_028d3450(undefined8 param_1,int param_2,undefined8 param_3,undefined8 param_4)\n{\n  ushort uVar1;\n  ulong uVar2;\n  undefined8 uVar3;\n  uVar1 = tvb_get_ntohs(param_1,param_2 + 1);\n  uVar2 = val_to_str_ext_const(0xa2,&PTR__try_val_to_str_ext_init_05b0a8a0,\"Unknown\");\n  uVar3 = proto_tree_add_subtree(param_4,param_1,param_2,uVar1 + 3,DAT_069f2d28,0,uVar2);\n  proto_tree_add_item(uVar3,DAT_05b02508,param_1,param_2 + 1,2,0);\n  proto_tree_add_item(uVar3,DAT_05b02418,param_1,param_2 + 3,3,0);\n  proto_tree_add_item(uVar3,DAT_05b02414,param_1,param_2 + 6,2,0);\n  uVar2 = uVar2 & 0xffffffff00000000;\n  proto_tree_add_bitmask\n            (uVar3,param_1,param_2 + 8,DAT_05b02408,DAT_05b02170,&PTR_DAT_04d36460,uVar2);\n  proto_tree_add_item(uVar3,DAT_05b02404,param_1,param_2 + 9,1,0);\n  proto_tree_add_bitmask\n            (uVar3,param_1,param_2 + 10,DAT_05b023f4,DAT_05b0216c,&PTR_DAT_04d36440,\n             uVar2 & 0xffffffff00000000);\n  proto_tree_add_item(uVar3,DAT_05b023f0,param_1,param_2 + 0xb,1,0);\n  return uVar1 + 3;\n}\n\n Revised code:\nstatic int\ndecode_gtp_add_trs_inf(tvbuff_t * tvb, int offset, packet_info * pinfo _U_, proto_tree * tree, session_args_t * args _U_)\n{\n\n    guint16     length;\n    proto_tree *ext_tree;\n\n    static int * const trigger_flags[] = {\n        &hf_gtp_trace_triggers_ggsn_mbms,\n        &hf_gtp_trace_triggers_ggsn_pdp,\n        NULL\n    };\n\n    static int * const loi_flags[] = {\n        &hf_gtp_trace_loi_ggsn_gmb,\n        &hf_gtp_trace_loi_ggsn_gi,\n        &hf_gtp_trace_loi_ggsn_gn,\n        NULL\n    };\n\n    length = tvb_get_ntohs(tvb, offset + 1);\n    ext_tree = proto_tree_add_subtree(tree, tvb, offset, 3 + length, ett_gtp_ies[GTP_EXT_ADD_TRS_INF], NULL,\n                    val_to_str_ext_const(GTP_EXT_ADD_TRS_INF, &gtp_val_ext, \"Unknown\"));\n\n    offset++;\n    proto_tree_add_item(ext_tree, hf_gtp_ext_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset = offset + 2;\n    proto_tree_add_item(ext_tree, hf_gtp_trace_ref2, tvb, offset, 3, ENC_BIG_ENDIAN);\n    offset += 3;\n    proto_tree_add_item(ext_tree, hf_gtp_trace_rec_session_ref, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n    proto_tree_add_bitmask(ext_tree, tvb, offset, hf_gtp_trace_triggers_ggsn, ett_gtp_trace_triggers_ggsn, trigger_flags, ENC_BIG_ENDIAN);\n    offset++;\n    proto_tree_add_item(ext_tree, hf_gtp_trace_depth, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n    proto_tree_add_bitmask(ext_tree, tvb, offset, hf_gtp_trace_loi_ggsn, ett_gtp_trace_loi_ggsn, loi_flags, ENC_BIG_ENDIAN);\n    offset++;\n    proto_tree_add_item(ext_tree, hf_gtp_trace_activity_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    return 3 + length;\n\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_0137dda0(undefined4 param_1,uint param_2,int param_3,int param_4,undefined4 param_5,\n                undefined4 param_6)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  if ((*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0) && ((param_2 & 3) != 0)) {\n    param_2 = (param_2 & 0xfffffffc) + 4;\n  }\n  uVar1 = 0;\n  uVar3 = 0;\n  if (param_4 != 0) {\n    uVar3 = proto_tree_add_item(param_4,param_6,param_1,param_2,0xffffffff,1);\n    uVar1 = proto_item_add_subtree(uVar3,DAT_0274f2c4);\n  }\n  iVar2 = dissect_ndr_uuid_t(param_1,param_2,param_3,uVar1,param_5,DAT_0274f3c8,0);\n  proto_item_set_len(uVar3,iVar2 - param_2);\n  return iVar2;\n}",
        "output": "```c\nstatic int\ndissect_ndr_uuid(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *parent_tree, guint8 *drep _U_, int hf_index _U_)\n{\n    proto_item *item = NULL;\n    proto_tree *tree = NULL;\n    int old_offset = offset;\n\n    ALIGN_TO_4_BYTES;\n\n    if (parent_tree) {\n        item = proto_tree_add_item(parent_tree, hf_index, tvb, offset, -1, TRUE);\n        tree = proto_item_add_subtree(item, ett_ndr_uuid);\n    }\n\n    offset = dissect_ndr_uuid_t(tvb, offset, pinfo, tree, drep, ett_ndr_uuid, 0);\n\n    proto_item_set_len(item, offset - old_offset);\n\n    return offset;\n}\n```",
        "source_code": "int\nnetdfs_dissect_struct_dfs_Info7(tvbuff_t *tvb _U_, int offset _U_, packet_info *pinfo _U_, proto_tree *parent_tree _U_, guint8 *drep _U_, int hf_index _U_, guint32 param _U_)\n{\n\tproto_item *item = NULL;\n\tproto_tree *tree = NULL;\n\tint old_offset;\n\n\tALIGN_TO_4_BYTES;\n\n\told_offset = offset;\n\n\tif (parent_tree) {\n\t\titem = proto_tree_add_item(parent_tree, hf_index, tvb, offset, -1, TRUE);\n\t\ttree = proto_item_add_subtree(item, ett_netdfs_dfs_Info7);\n\t}\n\t\n\toffset = netdfs_dissect_element_dfs_Info7_generation_guid(tvb, offset, pinfo, tree, drep);\n\n\n\tproto_item_set_len(item, offset-old_offset);\n\n\treturn offset;\n}",
        "parsed_output": "static int\ndissect_ndr_uuid(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *parent_tree, guint8 *drep _U_, int hf_index _U_)\n{\n    proto_item *item = NULL;\n    proto_tree *tree = NULL;\n    int old_offset = offset;\n\n    ALIGN_TO_4_BYTES;\n\n    if (parent_tree) {\n        item = proto_tree_add_item(parent_tree, hf_index, tvb, offset, -1, TRUE);\n        tree = proto_item_add_subtree(item, ett_ndr_uuid);\n    }\n\n    offset = dissect_ndr_uuid_t(tvb, offset, pinfo, tree, drep, ett_ndr_uuid, 0);\n\n    proto_item_set_len(item, offset - old_offset);\n\n    return offset;\n}",
        "baseline_code_stripped": "int FUN_0137dda0(undefined4 param_1,uint param_2,int param_3,int param_4,undefined4 param_5,\n                undefined4 param_6)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  if ((*(int *)(*(int *)(param_3 + 0xec) + 0xc) == 0) && ((param_2 & 3) != 0)) {\n    param_2 = (param_2 & 0xfffffffc) + 4;\n  }\n  uVar1 = 0;\n  uVar3 = 0;\n  if (param_4 != 0) {\n    uVar3 = proto_tree_add_item(param_4,param_6,param_1,param_2,0xffffffff,1);\n    uVar1 = proto_item_add_subtree(uVar3,DAT_0274f2c4);\n  }\n  iVar2 = dissect_ndr_uuid_t(param_1,param_2,param_3,uVar1,param_5,DAT_0274f3c8,0);\n  proto_item_set_len(uVar3,iVar2 - param_2);\n  return iVar2;\n}",
        "similarity_score_unixcoder": 0.8994839191436768,
        "similarity_score_baseline_stripped": 0.709363579750061
    },
    {
        "func_name": "YUVProgramContext::updateUProjection",
        "normed_func_sha256": "54cc64237870bf521c109ddb31036fe18f5055766efe64a8abe1744dd89c4844",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __thiscall Imath_2_5::Matrix44<float>::Matrix44(Matrix44_float_ *this)\n{\n  *(undefined4 *)(this + 0x3c) = 0x3f800000;\n  *(undefined8 *)(this + 8) = 0;\n  *(undefined8 *)this = 0;\n  *(undefined8 *)(this + 0x18) = 0;\n  *(undefined8 *)(this + 0x10) = 0;\n  *(undefined8 *)(this + 0x28) = 0;\n  *(undefined8 *)(this + 0x20) = 0;\n  *(undefined4 *)this = 0x3f800000;\n  *(undefined4 *)(this + 0x14) = 0x3f800000;\n  *(undefined4 *)(this + 0x28) = 0x3f800000;\n  *(undefined8 *)(this + 0x34) = 0;\n  *(undefined8 *)(this + 0x2c) = 0;\n  return;\n}\n\n Revised code:\nIMATH_HOSTDEVICE Matrix44<T>\nMatrix44<T>::gjInverse (bool singExc) const\n{\n    int i, j, k;\n    Matrix44 s;\n    Matrix44 t (*this);\n\n    // Forward elimination\n\n    for (i = 0; i < 3 ; i++)\n    {\n        int pivot = i;\n\n        T pivotsize = t[i][i];\n\n        if (pivotsize < 0)\n            pivotsize = -pivotsize;\n\n        for (j = i + 1; j < 4; j++)\n        {\n            T tmp = t[j][i];\n\n            if (tmp < 0)\n                tmp = -tmp;\n\n            if (tmp > pivotsize)\n            {\n                pivot = j;\n                pivotsize = tmp;\n            }\n        }\n\n        if (pivotsize == 0)\n        {\n#ifndef __CUDACC__\n            if (singExc)\n                throw ::IMATH_INTERNAL_NAMESPACE::SingMatrixExc (\"Cannot invert singular matrix.\");\n#endif\n\n            return Matrix44();\n        }\n\n        if (pivot != i)\n        {\n            for (j = 0; j < 4; j++)\n            {\n                T tmp;\n\n                tmp = t[i][j];\n                t[i][j] = t[pivot][j];\n                t[pivot][j] = tmp;\n\n                tmp = s[i][j];\n                s[i][j] = s[pivot][j];\n                s[pivot][j] = tmp;\n            }\n        }\n\n        for (j = i + 1; j < 4; j++)\n        {\n            T f = t[j][i] / t[i][i];\n\n            for (k = 0; k < 4; k++)\n            {\n                t[j][k] -= f * t[i][k];\n                s[j][k] -= f * s[i][k];\n            }\n        }\n    }\n\n    // Backward substitution\n\n    for (i = 3; i >= 0; --i)\n    {\n        T f;\n\n        if ((f = t[i][i]) == 0)\n        {\n#ifndef __CUDACC__\n            if (singExc)\n                throw ::IMATH_INTERNAL_NAMESPACE::SingMatrixExc (\"Cannot invert singular matrix.\");\n#endif\n\n            return Matrix44();\n        }\n\n        for (j = 0; j < 4; j++)\n        {\n            t[i][j] /= f;\n            s[i][j] /= f;\n        }\n\n        for (j = 0; j < i; j++)\n        {\n            f = t[j][i];\n\n            for (k = 0; k < 4; k++)\n            {\n                t[j][k] -= f * t[i][k];\n                s[j][k] -= f * s[i][k];\n            }\n        }\n    }\n\n    return s;\n}\n\n## Example:\n\n Input code:\nvoid __thiscall qglviewer::Camera::computeProjectionMatrix(Camera *this)\n{\n  long in_FS_OFFSET;\n  float fVar1;\n  float fVar2;\n  double dVar3;\n  double local_20;\n  double local_18;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  fVar1 = (float)(**(code **)(*(long *)this + 0x60))();\n  fVar2 = (float)(**(code **)(*(long *)this + 0x68))(this);\n  if (*(int *)(this + 0x50) == 0) {\n    dVar3 = tan((double)*(float *)(this + 0x20) * 0.5);\n    *(undefined8 *)(this + 0x150) = 0;\n    *(double *)(this + 0x100) = (double)(float)(1.0 / dVar3);\n    *(double *)(this + 0xd8) =\n         (double)((float)(1.0 / dVar3) /\n                 ((float)*(int *)(this + 0x18) / (float)*(int *)(this + 0x1c)));\n    *(undefined8 *)(this + 0x130) = 0xbff0000000000000;\n    *(double *)(this + 0x128) = (double)((fVar1 + fVar2) / (fVar1 - fVar2));\n    *(double *)(this + 0x148) =\n         (((double)fVar1 + (double)fVar1) * (double)fVar2) / (double)(fVar1 - fVar2);\n  }\n  else if (*(int *)(this + 0x50) == 1) {\n    (**(code **)(*(long *)this + 0x70))(this,&local_20,&local_18);\n    *(undefined8 *)(this + 0x130) = 0;\n    *(undefined8 *)(this + 0x150) = 0x3ff0000000000000;\n    *(double *)(this + 0xd8) = 1.0 / local_20;\n    *(double *)(this + 0x100) = 1.0 / local_18;\n    *(double *)(this + 0x128) = -2.0 / (double)(fVar2 - fVar1);\n    *(double *)(this + 0x148) =\n         (double)((float)((uint)(fVar2 + fVar1) ^ 0x80000000) / (fVar2 - fVar1));\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid Camera::computeProjectionMatrix() const\n{\n  const float ZNear = zNear();\n  const float ZFar  = zFar();\n\n  switch (type())\n    {\n    case Camera::PERSPECTIVE:\n      {\n\t// #CONNECTION# all non null coefficients were set to 0.0 in constructor.\n\tconst float f = 1.0/tan(fieldOfView()/2.0);\n\tprojectionMatrix_[0]  = f/aspectRatio();\n\tprojectionMatrix_[5]  = f;\n\tprojectionMatrix_[10] = (ZNear + ZFar) / (ZNear - ZFar);\n\tprojectionMatrix_[11] = -1.0;\n\tprojectionMatrix_[14] = 2.0 * ZNear * ZFar / (ZNear - ZFar);\n\tprojectionMatrix_[15] = 0.0;\n\t// same as gluPerspective( 180.0*fieldOfView()/M_PI, aspectRatio(), zNear(), zFar() );\n\tbreak;\n      }\n    case Camera::ORTHOGRAPHIC:\n      {\n\tGLdouble w, h;\n\tgetOrthoWidthHeight(w,h);\n\tprojectionMatrix_[0]  = 1.0/w;\n\tprojectionMatrix_[5]  = 1.0/h;\n\tprojectionMatrix_[10] = -2.0/(ZFar - ZNear);\n\tprojectionMatrix_[11] = 0.0;\n\tprojectionMatrix_[14] = -(ZFar + ZNear)/(ZFar - ZNear);\n\tprojectionMatrix_[15] = 1.0;\n\t// same as glOrtho( -w, w, -h, h, zNear(), zFar() );\n\tbreak;\n      }\n    }\n}\n\n## Example:\n\n Input code:\nundefined4 __thiscall Wintermute::VideoTheoraPlayer::display(VideoTheoraPlayer *this,uint param_1)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  int *piVar3;\n  piVar3 = *(int **)(this + 800);\n  if (piVar3 == (int *)0x0) {\n    return 0;\n  }\n  if (this[0x386] != (VideoTheoraPlayer)0x0) {\n    uVar1 = (**(code **)(*piVar3 + 0x60))(piVar3);\n    uVar2 = (**(code **)(**(int **)(this + 800) + 100))();\n    piVar3 = *(int **)(this + 800);\n    if (*(float *)(this + 0x36c) == 100.0) {\n      uVar1 = (**(code **)(*piVar3 + 0x20))\n                        (piVar3,*(undefined4 *)(this + 0x348),*(undefined4 *)(this + 0x34c),0,0,\n                         uVar2,uVar1,param_1,0,0,0);\n      return uVar1;\n    }\n    uVar1 = (**(code **)(*piVar3 + 0x1c))\n                      (*(float *)(this + 0x36c),piVar3,*(undefined4 *)(this + 0x348),\n                       *(undefined4 *)(this + 0x34c),0,0,uVar2,uVar1,param_1,0,0,0);\n    return uVar1;\n  }\n  return 0;\n}\n\n Revised code:\nbool VideoTheoraPlayer::display(uint32 alpha) {\n\tRect32 rc;\n\tbool res;\n\n\tif (_texture && _videoFrameReady) {\n\t\trc.setRect(0, 0, _texture->getWidth(), _texture->getHeight());\n\t\tif (_playZoom == 100.0f) {\n\t\t\tres = _texture->displayTrans(_posX, _posY, rc, alpha);\n\t\t} else {\n\t\t\tres = _texture->displayTransZoom(_posX, _posY, rc, _playZoom, _playZoom, alpha);\n\t\t}\n\t} else {\n\t\tres = STATUS_FAILED;\n\t}\n\t// TODO: Add subtitles-support\n/*\tif (m_Subtitler && _gameRef->m_VideoSubtitles) {\n\t\tm_Subtitler->display();\n\t}*/\n\n\treturn res;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall YUVProgramContext::updateUProjection(YUVProgramContext *this)\n{\n  *(undefined4 *)(this + 0x78) = 0x40000000;\n  *(undefined4 *)(this + 0x7c) = 0;\n  *(undefined4 *)(this + 0x80) = 0;\n  *(undefined4 *)(this + 0x84) = 0;\n  *(undefined4 *)(this + 0x88) = 0;\n  *(undefined4 *)(this + 0x8c) = 0x40000000;\n  __aeabi_memclr8(this + 0x90,0x18);\n  *(undefined4 *)(this + 0xa8) = 0xbf800000;\n  *(undefined4 *)(this + 0xac) = 0xbf800000;\n  *(undefined4 *)(this + 0xb0) = 0;\n  *(undefined4 *)(this + 0xb4) = 0x3f800000;\n  if ((*(int *)(this + 0x104) != 0) && (*(int *)(this + 0x100) != 0)) {\n    *(float *)(this + 0x78) = 2.0 / (float)(longlong)*(int *)(this + 0x100);\n    *(float *)(this + 0x8c) = 2.0 / (float)(longlong)*(int *)(this + 0x104);\n  }\n  return;\n}",
        "output": "```cpp\nvoid YUVProgramContext::updateUProjection() {\n    // Initialize projection matrix elements\n    uProjectionMatrix[0] = 2.0f;  // 0x40000000\n    uProjectionMatrix[1] = 0.0f;\n    uProjectionMatrix[2] = 0.0f;\n    uProjectionMatrix[3] = 0.0f;\n    uProjectionMatrix[4] = 0.0f;\n    uProjectionMatrix[5] = 2.0f;  // 0x40000000\n    memset(&uProjectionMatrix[6], 0, sizeof(float) * 6);  // Clear remaining elements\n    uProjectionMatrix[10] = -1.0f;  // 0xbf800000\n    uProjectionMatrix[11] = -1.0f;  // 0xbf800000\n    uProjectionMatrix[12] = 0.0f;\n    uProjectionMatrix[13] = 1.0f;  // 0x3f800000\n\n    // Update projection matrix based on dimensions\n    if (uWidth != 0 && uHeight != 0) {\n        uProjectionMatrix[0] = 2.0f / static_cast<float>(uWidth);\n        uProjectionMatrix[5] = 2.0f / static_cast<float>(uHeight);\n    }\n}\n```",
        "source_code": "void YUVProgramContext::updateUProjection() {\n    mUProjection[0][0] = 2.0f;\n    mUProjection[0][1] = 0.0f;\n    mUProjection[0][2] = 0.0f;\n    mUProjection[0][3] = 0.0f;\n    mUProjection[1][0] = 0.0f;\n    mUProjection[1][1] = 2.0f;\n    mUProjection[1][2] = 0.0f;\n    mUProjection[1][3] = 0.0f;\n    mUProjection[2][0] = 0.0f;\n    mUProjection[2][1] = 0.0f;\n    mUProjection[2][2] = 0.0f;\n    mUProjection[2][3] = 0.0f;\n    mUProjection[3][0] = -1.0f;\n    mUProjection[3][1] = -1.0f;\n    mUProjection[3][2] = 0.0f;\n    mUProjection[3][3] = 1.0f;\n\n    if (mWindowHeight != 0 && mWindowWidth != 0) {\n        mUProjection[0][0] = 2.0f / mWindowWidth;\n        mUProjection[1][1] = 2.0f / mWindowHeight;\n    }\n}",
        "parsed_output": "pp\nvoid YUVProgramContext::updateUProjection() {\n    // Initialize projection matrix elements\n    uProjectionMatrix[0] = 2.0f;  // 0x40000000\n    uProjectionMatrix[1] = 0.0f;\n    uProjectionMatrix[2] = 0.0f;\n    uProjectionMatrix[3] = 0.0f;\n    uProjectionMatrix[4] = 0.0f;\n    uProjectionMatrix[5] = 2.0f;  // 0x40000000\n    memset(&uProjectionMatrix[6], 0, sizeof(float) * 6);  // Clear remaining elements\n    uProjectionMatrix[10] = -1.0f;  // 0xbf800000\n    uProjectionMatrix[11] = -1.0f;  // 0xbf800000\n    uProjectionMatrix[12] = 0.0f;\n    uProjectionMatrix[13] = 1.0f;  // 0x3f800000\n\n    // Update projection matrix based on dimensions\n    if (uWidth != 0 && uHeight != 0) {\n        uProjectionMatrix[0] = 2.0f / static_cast<float>(uWidth);\n        uProjectionMatrix[5] = 2.0f / static_cast<float>(uHeight);\n    }\n}",
        "baseline_code_stripped": "void __thiscall YUVProgramContext::updateUProjection(YUVProgramContext *this)\n{\n  *(undefined4 *)(this + 0x78) = 0x40000000;\n  *(undefined4 *)(this + 0x7c) = 0;\n  *(undefined4 *)(this + 0x80) = 0;\n  *(undefined4 *)(this + 0x84) = 0;\n  *(undefined4 *)(this + 0x88) = 0;\n  *(undefined4 *)(this + 0x8c) = 0x40000000;\n  __aeabi_memclr8(this + 0x90,0x18);\n  *(undefined4 *)(this + 0xa8) = 0xbf800000;\n  *(undefined4 *)(this + 0xac) = 0xbf800000;\n  *(undefined4 *)(this + 0xb0) = 0;\n  *(undefined4 *)(this + 0xb4) = 0x3f800000;\n  if ((*(int *)(this + 0x104) != 0) && (*(int *)(this + 0x100) != 0)) {\n    *(float *)(this + 0x78) = 2.0 / (float)(longlong)*(int *)(this + 0x100);\n    *(float *)(this + 0x8c) = 2.0 / (float)(longlong)*(int *)(this + 0x104);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.8589282631874084,
        "similarity_score_baseline_stripped": 0.6691746115684509
    },
    {
        "func_name": "decode_sib_address",
        "normed_func_sha256": "74b135bce90d50efa45fe04a912714fb565c7b76973ffef47e435c514a8773aa",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint FUN_0002cbe0(int *param_1)\n{\n  int iVar1;\n  if (param_1 != (int *)0x0) {\n    iVar1 = *param_1;\n    if (iVar1 == 2) {\n      switch(param_1[2]) {\n      case 1:\n        if ((*(byte *)(param_1 + 5) & 2) != 0) {\n          return *(int *)(DAT_002e5220 + 0x90) << 3;\n        }\n        if ((*(byte *)(param_1 + 5) & 1) != 0) {\n          return *(int *)(DAT_002e5220 + 0x8c) << 3;\n        }\n        return *(int *)(DAT_002e5220 + 0x88) << 3;\n      case 2:\n        return *(int *)(DAT_002e5220 + 0xa4) << 3;\n      case 3:\n        return 0x20;\n      case 4:\n      case 5:\n        return *(int *)(DAT_002e5220 + 0x80) << 3;\n      case 7:\n        return *(int *)(param_1[0xf] + 0xcc) << 3;\n      case 9:\n      case 0xc:\n        return 1;\n      case 10:\n      case 0xb:\n        return param_1[9];\n      }\n    }\n    else {\n      if (iVar1 != 1) {\n        FUN_0002ac30(1,\"SDCCsymt.c\",0x4a8,iVar1);\n      }\n      switch(param_1[2]) {\n      case 1:\n      case 2:\n      case 3:\n        return *(int *)(DAT_002e5220 + 0x94) << 3;\n      case 4:\n      case 5:\n      case 7:\n      case 9:\n        return *(int *)(DAT_002e5220 + 0x98) << 3;\n      case 6:\n        return *(int *)(DAT_002e5220 + 0x9c) << 3;\n      case 8:\n        iVar1 = FUN_0002c9b0(param_1[0x18]);\n        return iVar1 * param_1[3] * 8;\n      }\n    }\n  }\n  return 0;\n}\n\n Revised code:\nunsigned int\nbitsForType (sym_link * p)\n{\n  if (!p)\n    return 0;\n  if (IS_SPEC (p))\n    {                           \n      switch (SPEC_NOUN (p))\n        {                       \n        case V_INT:\n          if (IS_LONGLONG (p))\n            return LONGLONGSIZE * 8;\n          if (IS_LONG (p))\n            return LONGSIZE * 8;\n          return INTSIZE * 8;\n        case V_FLOAT:\n          return FLOATSIZE * 8;\n        case V_FIXED16X16:\n          return (32);\n        case V_BOOL:\n          return BOOLSIZE * 8;\n        case V_CHAR:\n          return CHARSIZE * 8;\n        case V_VOID:\n          return 0;\n        case V_STRUCT:\n          return SPEC_STRUCT (p)->size * 8;\n        case V_LABEL:\n          return 0;\n        case V_SBIT:\n        case V_BIT:\n          return 1;\n        case V_BITFIELD:\n        case V_BBITFIELD:\n          return SPEC_BLEN (p);\n        default:\n          return 0;\n        }\n    }\n  switch (DCL_TYPE (p))\n    {\n    case ARRAY:\n      return DCL_ELEM (p) * getSize (p->next) * 8;\n    case IPOINTER:\n    case PPOINTER:\n    case POINTER:\n      return (PTRSIZE * 8);\n    case EEPPOINTER:\n    case FPOINTER:\n    case CPOINTER:\n    case FUNCTION:\n      return (FPTRSIZE * 8);\n    case GPOINTER:\n      return (GPTRSIZE * 8);\n    default:\n      return 0;\n    }\n}\n\n## Example:\n\n Input code:\nint FUN_00b72900(long param_1,long param_2)\n{\n  byte bVar1;\n  ushort uVar2;\n  int iVar3;\n  ushort *puVar4;\n  DAT_01208410 = param_1;\n  DAT_01208418 = *(undefined8 *)(param_2 + 8);\n  puVar4 = *(ushort **)(param_2 + 0x10);\n  uVar2 = *puVar4;\n  if (uVar2 != 0x28) {\n    if (0x28 < uVar2) {\n      if (uVar2 == 0x2c) {\n        return 0;\n      }\n      if (uVar2 == 0x37) {\n        iVar3 = FUN_00b4f418(param_2);\n        if (iVar3 < 0) {\n          return -1;\n        }\n        return iVar3 + 1;\n      }\n      if (uVar2 != 0x2a) {\n        DAT_01208410 = param_1;\n        return -1;\n      }\n      DAT_01208410 = param_1;\n      return 0;\n    }\n    if (uVar2 == 0x21) {\n      DAT_01208410 = param_1;\n      return 0;\n    }\n    if (uVar2 != 0x26) {\n      DAT_01208410 = param_1;\n      return -1;\n    }\n  }\n  bVar1 = *(byte *)(param_1 + 2);\n  DAT_01208420 = puVar4;\n  if (bVar1 == 0x3e) {\n    iVar3 = FUN_00b564d0(param_2);\n    if (iVar3 != 0) {\n      return -1;\n    }\n    iVar3 = 4;\n  }\n  else {\n    if (bVar1 < 0x3f) {\n      if (bVar1 == 0x3c) {\n        iVar3 = FUN_00b564d0(param_2);\n        if (iVar3 != 0) {\n          return -1;\n        }\n        return 5;\n      }\n      if (0x3c < bVar1) {\n        iVar3 = FUN_00b564d0(param_2,0x3d);\n        if (iVar3 != 0) {\n          return -1;\n        }\n        return 7;\n      }\n      if (bVar1 != 0x3b) {\n        DAT_01208410 = param_1;\n        return -1;\n      }\n      iVar3 = FUN_00b564d0(param_2);\n      if (iVar3 != 0) {\n        return -1;\n      }\n      return 3;\n    }\n    if (bVar1 == 0x42) {\n      iVar3 = FUN_00b564d0(param_2);\n      if (iVar3 != 0) {\n        return -1;\n      }\n      iVar3 = 8;\n    }\n    else if (bVar1 == 0x44) {\n      iVar3 = FUN_00b564d0(param_2);\n      if (iVar3 != 0) {\n        return -1;\n      }\n      iVar3 = 9;\n    }\n    else {\n      if ((bVar1 != 0x40) || (iVar3 = FUN_00b564d0(param_2), iVar3 != 0)) {\n        return -1;\n      }\n      iVar3 = 6;\n    }\n  }\n  return iVar3;\n}\n\n Revised code:\nstatic int\npattern5 (rtx x1)\n{\n  rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\n  rtx x2, x3, x4, x5;\n  int res ATTRIBUTE_UNUSED;\n  x2 = XEXP (x1, 0);\n  operands[0] = x2;\n  x3 = XEXP (x1, 1);\n  x4 = XEXP (x3, 0);\n  operands[1] = x4;\n  x5 = XEXP (x3, 1);\n  switch (GET_CODE (x5))\n    {\n    case CONST_INT:\n    case REG:\n    case SUBREG:\n      return 0;\n\n    case MINUS:\n      res = pattern3 (x3);\n      if (res >= 0)\n        return res + 1; /* [1, 2] */\n      return -1;\n\n    case CONST_VECTOR:\n    case CONST:\n      operands[2] = x5;\n      switch (GET_MODE (operands[0]))\n        {\n        case E_V8QImode:\n          if (pattern4 (x3, E_V8QImode) != 0)\n            return -1;\n          return 3;\n\n        case E_V16QImode:\n          if (pattern4 (x3, E_V16QImode) != 0)\n            return -1;\n          return 4;\n\n        case E_V4HImode:\n          if (pattern4 (x3, E_V4HImode) != 0)\n            return -1;\n          return 5;\n\n        case E_V8HImode:\n          if (pattern4 (x3, E_V8HImode) != 0)\n            return -1;\n          return 6;\n\n        case E_V2SImode:\n          if (pattern4 (x3, E_V2SImode) != 0)\n            return -1;\n          return 7;\n\n        case E_V4SImode:\n          if (pattern4 (x3, E_V4SImode) != 0)\n            return -1;\n          return 8;\n\n        case E_V2DImode:\n          if (pattern4 (x3, E_V2DImode) != 0)\n            return -1;\n          return 9;\n\n        default:\n          return -1;\n        }\n\n    default:\n      return -1;\n    }\n}\n\n## Example:\n\n Input code:\nvoid FUN_001bba08(int param_1,int param_2,int param_3,int param_4)\n{\n  uint uVar1;\n  long lVar2;\n  int iVar3;\n  int iVar4;\n  iVar4 = param_1 * 0x20;\n  if (DAT_002d0524 == 8) {\n    if (DAT_00322d44 - 2U < 6) {\n      iVar3 = (&DAT_00cd2b80)[DAT_00322d44];\n      iVar4 = DAT_002d0510 + (&DAT_00cd2b60)[DAT_00322d44] + iVar4;\n    }\n    else {\n      iVar4 = DAT_002d0510 + DAT_00cd2b08 + iVar4;\n      iVar3 = DAT_00cd2b44;\n    }\n  }\n  else if (DAT_002d0524 == 9) {\n    if (DAT_00322d48 != 0) {\n      uVar1 = DAT_00322d48;\n      if (0xb < DAT_00322d48) {\n        uVar1 = (2 < DAT_00322d48 - 0x11) + 0xc;\n      }\n      iVar4 = DAT_002d0510 + (&DAT_00cd2ba0)[(int)uVar1] + iVar4;\n      uVar1 = DAT_00322d48;\n      if (0xb < DAT_00322d48) {\n        uVar1 = (2 < DAT_00322d48 - 0x11) + 0xc;\n      }\n      iVar3 = (&DAT_00cd2bd8)[(int)uVar1] + DAT_002d050c + (param_2 + 2) * 0x20;\n      goto joined_r0x001bbaf4;\n    }\n    iVar4 = DAT_002d0510 + DAT_00cd2b0c + iVar4;\n    iVar3 = DAT_00cd2b48;\n  }\n  else {\n    if (DAT_002d0524 - 4U < 6) {\n      lVar2 = (long)DAT_002d0524;\n      iVar4 = DAT_002d0510 + (&DAT_00cd2ae8)[lVar2] + iVar4;\n    }\n    else if (DAT_002d0524 == 0xf) {\n      lVar2 = 4;\n      iVar4 = DAT_002d0510 + DAT_00cd2af8 + iVar4;\n    }\n    else {\n      lVar2 = 0;\n      iVar4 = DAT_002d0510 + DAT_00cd2ae8 + iVar4;\n    }\n    iVar3 = (&DAT_00cd2b24)[lVar2];\n  }\n  iVar3 = iVar3 + DAT_002d050c + (param_2 + 2) * 0x20;\njoined_r0x001bbaf4:\n  if (param_1 == 0) {\n    if (param_4 == -1) {\n      param_4 = *(int *)(&DAT_00322d50 + (long)param_2 * 4);\n    }\n    else {\n      *(int *)(&DAT_00322d50 + (long)param_2 * 4) = param_4;\n    }\n  }\n  if (param_3 != 0) {\n    param_4 = (&DAT_00cd3418)[param_4];\n  }\n  FUN_001aeae0(iVar4,iVar3,0x20,0x20,param_4);\n  FUN_001b0aa8(DAT_003e6058,iVar4,iVar3,param_4,0);\n  return;\n}\n\n Revised code:\nstatic void drawCursorExt(int xpos, int ypos, boolean active, int graphic)\n{\n#if 1\n  static int cursor_array[MAX_LEV_FIELDY];\n#else\n  static int cursor_array[SCR_FIELDY];\n#endif\n  int x = mSX + TILEX * xpos;\n  int y = mSY + TILEY * (MENU_SCREEN_START_YPOS + ypos);\n\n  if (xpos == 0)\n  {\n    if (graphic != -1)\n      cursor_array[ypos] = graphic;\n    else\n      graphic = cursor_array[ypos];\n  }\n\n  if (active)\n    graphic = BUTTON_ACTIVE(graphic);\n\n  DrawBackgroundForGraphic(x, y, TILEX, TILEY, graphic);\n  DrawGraphicThruMaskExt(drawto, x, y, graphic, 0);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_0010fb20(uint param_1,int param_2)\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  switch(param_1 & 7) {\n  case 0:\n    iVar2 = _DAT_00323378;\n    break;\n  case 1:\n    iVar2 = _DAT_00323380;\n    break;\n  case 2:\n    iVar2 = DAT_00323384;\n    break;\n  case 3:\n    iVar2 = DAT_0032337c;\n    break;\n  case 5:\n    if (param_2 == 0) {\n      iVar2 = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n      DAT_00323398 = DAT_00323398 + 4;\n      break;\n    }\n  case 4:\n    DAT_003233ac = DAT_003233ac | 1;\n    iVar2 = _DAT_00323388;\n    break;\n  case 6:\n    iVar2 = DAT_00323390;\n    break;\n  case 7:\n    iVar2 = DAT_00323394;\n  }\n  bVar1 = (byte)((int)param_1 >> 6);\n  switch((int)param_1 >> 3 & 7) {\n  case 0:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323378;\n  case 1:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323380;\n  case 2:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323384;\n  case 3:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032337c;\n  case 4:\n    iVar3 = 0;\n    break;\n  case 5:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032338c;\n  case 6:\n    iVar3 = (1 << (bVar1 & 3)) * DAT_00323390;\n    break;\n  case 7:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323394;\n  }\n  return iVar2 + iVar3;\n}",
        "output": "```c\nint calculateValue(uint param_1, int param_2)\n{\n    int baseValue;\n    int multiplier = 0;\n    byte shiftAmount = (byte)((int)param_1 >> 6);\n\n    // Determine base value based on lower 3 bits of param_1\n    switch (param_1 & 7) {\n        case 0:\n            baseValue = _DAT_00323378;\n            break;\n        case 1:\n            baseValue = _DAT_00323380;\n            break;\n        case 2:\n            baseValue = DAT_00323384;\n            break;\n        case 3:\n            baseValue = DAT_0032337c;\n            break;\n        case 4:\n            DAT_003233ac |= 1;\n            baseValue = _DAT_00323388;\n            break;\n        case 5:\n            if (param_2 == 0) {\n                baseValue = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n                DAT_00323398 += 4;\n                break;\n            }\n            // Fallthrough intended for case 5 when param_2 != 0\n        case 6:\n            baseValue = DAT_00323390;\n            break;\n        case 7:\n            baseValue = DAT_00323394;\n            break;\n        default:\n            baseValue = 0; // Default case to handle unexpected values\n    }\n\n    // Determine multiplier based on bits 3-5 of param_1\n    switch ((int)param_1 >> 3 & 7) {\n        case 0:\n            multiplier = (1 << (shiftAmount & 3)) * _DAT_00323378;\n            break;\n        case 1:\n            multiplier = (1 << (shiftAmount & 3)) * _DAT_00323380;\n            break;\n        case 2:\n            multiplier = (1 << (shiftAmount & 3)) * DAT_00323384;\n            break;\n        case 3:\n            multiplier = (1 << (shiftAmount & 3)) * DAT_0032337c;\n            break;\n        case 4:\n            multiplier = 0;\n            break;\n        case 5:\n            multiplier = (1 << (shiftAmount & 3)) * DAT_0032338c;\n            break;\n        case 6:\n            multiplier = (1 << (shiftAmount & 3)) * DAT_00323390;\n            break;\n        case 7:\n            multiplier = (1 << (shiftAmount & 3)) * DAT_00323394;\n            break;\n        default:\n            multiplier = 0; // Default case to handle unexpected values\n    }\n\n    return baseValue + multiplier;\n}\n```",
        "source_code": "u32\ndecode_sib_address(int sib, int mod)\n{\n    u32 base = 0, i = 0, scale = 1;\n\n    switch (sib & 0x07) {\n    case 0:\n        DECODE_PRINTF(\"[EAX]\");\n        base = M.x86.R_EAX;\n        break;\n    case 1:\n        DECODE_PRINTF(\"[ECX]\");\n        base = M.x86.R_ECX;\n        break;\n    case 2:\n        DECODE_PRINTF(\"[EDX]\");\n        base = M.x86.R_EDX;\n        break;\n    case 3:\n        DECODE_PRINTF(\"[EBX]\");\n        base = M.x86.R_EBX;\n        break;\n    case 4:\n        DECODE_PRINTF(\"[ESP]\");\n        base = M.x86.R_ESP;\n        M.x86.mode |= SYSMODE_SEG_DS_SS;\n        break;\n    case 5:\n        if (mod == 0) {\n            base = fetch_long_imm();\n            DECODE_PRINTF2(\"%08x\", base);\n        }\n        else {\n            DECODE_PRINTF(\"[EBP]\");\n            base = M.x86.R_ESP;\n            M.x86.mode |= SYSMODE_SEG_DS_SS;\n        }\n        break;\n    case 6:\n        DECODE_PRINTF(\"[ESI]\");\n        base = M.x86.R_ESI;\n        break;\n    case 7:\n        DECODE_PRINTF(\"[EDI]\");\n        base = M.x86.R_EDI;\n        break;\n    }\n    switch ((sib >> 3) & 0x07) {\n    case 0:\n        DECODE_PRINTF(\"[EAX\");\n        i = M.x86.R_EAX;\n        break;\n    case 1:\n        DECODE_PRINTF(\"[ECX\");\n        i = M.x86.R_ECX;\n        break;\n    case 2:\n        DECODE_PRINTF(\"[EDX\");\n        i = M.x86.R_EDX;\n        break;\n    case 3:\n        DECODE_PRINTF(\"[EBX\");\n        i = M.x86.R_EBX;\n        break;\n    case 4:\n        i = 0;\n        break;\n    case 5:\n        DECODE_PRINTF(\"[EBP\");\n        i = M.x86.R_EBP;\n        break;\n    case 6:\n        DECODE_PRINTF(\"[ESI\");\n        i = M.x86.R_ESI;\n        break;\n    case 7:\n        DECODE_PRINTF(\"[EDI\");\n        i = M.x86.R_EDI;\n        break;\n    }\n    scale = 1 << ((sib >> 6) & 0x03);\n    if (((sib >> 3) & 0x07) != 4) {\n        if (scale == 1) {\n            DECODE_PRINTF(\"]\");\n        }\n        else {\n            DECODE_PRINTF2(\"*%d]\", scale);\n        }\n    }\n    return base + (i * scale);\n}",
        "parsed_output": "int calculateValue(uint param_1, int param_2)\n{\n    int baseValue;\n    int multiplier = 0;\n    byte shiftAmount = (byte)((int)param_1 >> 6);\n\n    // Determine base value based on lower 3 bits of param_1\n    switch (param_1 & 7) {\n        case 0:\n            baseValue = _DAT_00323378;\n            break;\n        case 1:\n            baseValue = _DAT_00323380;\n            break;\n        case 2:\n            baseValue = DAT_00323384;\n            break;\n        case 3:\n            baseValue = DAT_0032337c;\n            break;\n        case 4:\n            DAT_003233ac |= 1;\n            baseValue = _DAT_00323388;\n            break;\n        case 5:\n            if (param_2 == 0) {\n                baseValue = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n                DAT_00323398 += 4;\n                break;\n            }\n            // Fallthrough intended for case 5 when param_2 != 0\n        case 6:\n            baseValue = DAT_00323390;\n            break;\n        case 7:\n            baseValue = DAT_00323394;\n            break;\n        default:\n            baseValue = 0; // Default case to handle unexpected values\n    }\n\n    // Determine multiplier based on bits 3-5 of param_1\n    switch ((int)param_1 >> 3 & 7) {\n        case 0:\n            multiplier = (1 << (shiftAmount & 3)) * _DAT_00323378;\n            break;\n        case 1:\n            multiplier = (1 << (shiftAmount & 3)) * _DAT_00323380;\n            break;\n        case 2:\n            multiplier = (1 << (shiftAmount & 3)) * DAT_00323384;\n            break;\n        case 3:\n            multiplier = (1 << (shiftAmount & 3)) * DAT_0032337c;\n            break;\n        case 4:\n            multiplier = 0;\n            break;\n        case 5:\n            multiplier = (1 << (shiftAmount & 3)) * DAT_0032338c;\n            break;\n        case 6:\n            multiplier = (1 << (shiftAmount & 3)) * DAT_00323390;\n            break;\n        case 7:\n            multiplier = (1 << (shiftAmount & 3)) * DAT_00323394;\n            break;\n        default:\n            multiplier = 0; // Default case to handle unexpected values\n    }\n\n    return baseValue + multiplier;\n}",
        "baseline_code_stripped": "int FUN_0010fb20(uint param_1,int param_2)\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  switch(param_1 & 7) {\n  case 0:\n    iVar2 = _DAT_00323378;\n    break;\n  case 1:\n    iVar2 = _DAT_00323380;\n    break;\n  case 2:\n    iVar2 = DAT_00323384;\n    break;\n  case 3:\n    iVar2 = DAT_0032337c;\n    break;\n  case 5:\n    if (param_2 == 0) {\n      iVar2 = (*(code *)PTR_FUN_00322b18)((uint)DAT_00323398 + (uint)DAT_003233a0 * 0x10);\n      DAT_00323398 = DAT_00323398 + 4;\n      break;\n    }\n  case 4:\n    DAT_003233ac = DAT_003233ac | 1;\n    iVar2 = _DAT_00323388;\n    break;\n  case 6:\n    iVar2 = DAT_00323390;\n    break;\n  case 7:\n    iVar2 = DAT_00323394;\n  }\n  bVar1 = (byte)((int)param_1 >> 6);\n  switch((int)param_1 >> 3 & 7) {\n  case 0:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323378;\n  case 1:\n    return iVar2 + (1 << (bVar1 & 3)) * _DAT_00323380;\n  case 2:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323384;\n  case 3:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032337c;\n  case 4:\n    iVar3 = 0;\n    break;\n  case 5:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_0032338c;\n  case 6:\n    iVar3 = (1 << (bVar1 & 3)) * DAT_00323390;\n    break;\n  case 7:\n    return iVar2 + (1 << (bVar1 & 3)) * DAT_00323394;\n  }\n  return iVar2 + iVar3;\n}",
        "similarity_score_unixcoder": 0.6588332056999207,
        "similarity_score_baseline_stripped": 0.5846819281578064
    },
    {
        "func_name": "m68k_op_move_16_tos_al",
        "normed_func_sha256": "bad3fcf49b58e1f1f5a12d5855427450193d1155115a7d1fe59121577ee083ca",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_0043e3c0(void)\n{\n  undefined8 uVar1;\n  if (DAT_00978f64 == 0) {\n    return 0;\n  }\n  uVar1 = FUN_0042f540();\n  return uVar1;\n}\n\n Revised code:\nint MPIDI_CH3I_MRAIL_CM_Alloc(MPIDI_PG_t * pg)\n{\n    int mpi_errno   = MPI_SUCCESS;\n\n#ifdef _ENABLE_UD_\n    pg->ch.mrail->cm_shmem.remote_ud_info = NULL;\n    if (rdma_enable_hybrid) {\n        pg->ch.mrail->cm_shmem.remote_ud_info = (mv2_ud_exch_info_t **)\n                        MPIU_Malloc(pg->size * sizeof(mv2_ud_exch_info_t*));\n        if (pg->ch.mrail->cm_shmem.remote_ud_info == NULL) {\n            MPIU_ERR_SETFATALANDJUMP1(mpi_errno, MPI_ERR_INTERN, \"**nomem\",\n                    \"**nomem %s\", \"remote_ud_info\");\n        }\n    }\n#endif /* _ENABLE_UD_ */\n\n    if (mv2_shmem_backed_ud_cm) {\n        mpi_errno = MPIDI_CH3I_CM_Create_region(pg);\n    } else {\n#ifdef _ENABLE_UD_\n        if (rdma_enable_hybrid) {\n            int i = 0;\n            for (i = 0; i < pg->size; i++) {\n                pg->ch.mrail->cm_shmem.remote_ud_info[i] = (mv2_ud_exch_info_t *)\n                            MPIU_Malloc(rdma_num_hcas * sizeof(mv2_ud_exch_info_t));\n            }\n        }\n#endif /* _ENABLE_UD_ */\n    }\n\n  fn_fail:\n    return mpi_errno;\n}\n\n## Example:\n\n Input code:\nvoid FUN_0374fb80(void)\n{\n  undefined4 uVar1;\n  if (DAT_06b1c84c != '\\0') {\n    return;\n  }\n  uVar1 = FUN_037536a0();\n  FUN_00e0a5a0(uVar1);\n}\n\n Revised code:\nvoid V8Initializer::Initialize(IsolateHolder::ScriptMode mode) {\n  static bool v8_is_initialized = false;\n  if (v8_is_initialized)\n    return;\n\n  v8::V8::InitializePlatform(V8Platform::Get());\n\n  if (!base::FeatureList::IsEnabled(features::kV8OptimizeJavascript)) {\n    // We avoid explicitly passing --opt if kV8OptimizeJavascript is enabled\n    // since it is the default, and doing so would override flags passed\n    // explicitly, e.g., via --js-flags=--no-opt.\n    static const char no_optimize[] = \"--no-opt\";\n    v8::V8::SetFlagsFromString(no_optimize, sizeof(no_optimize) - 1);\n  }\n\n  if (!base::FeatureList::IsEnabled(features::kV8FlushBytecode)) {\n    static const char no_flush_bytecode[] = \"--no-flush-bytecode\";\n    v8::V8::SetFlagsFromString(no_flush_bytecode,\n                               sizeof(no_flush_bytecode) - 1);\n  }\n\n  if (!base::FeatureList::IsEnabled(features::kV8LazyFeedbackAllocation)) {\n    static const char no_lazy_feedback_allocation[] =\n        \"--no-lazy-feedback-allocation\";\n    v8::V8::SetFlagsFromString(no_lazy_feedback_allocation,\n                               sizeof(no_lazy_feedback_allocation) - 1);\n  }\n\n  if (!base::FeatureList::IsEnabled(features::kV8MemoryReducerForSmallHeaps)) {\n    static const char no_memory_reducer[] =\n        \"--no-memory-reducer-for-small-heaps\";\n    v8::V8::SetFlagsFromString(no_memory_reducer,\n                               sizeof(no_memory_reducer) - 1);\n  }\n\n  if (base::FeatureList::IsEnabled(features::kV8HugeMaxOldGenerationSize)) {\n    static const char huge_max_old_generation_size[] =\n        \"--huge_max_old_generation_size\";\n    v8::V8::SetFlagsFromString(huge_max_old_generation_size,\n                               sizeof(huge_max_old_generation_size) - 1);\n  }\n\n  if (base::FeatureList::IsEnabled(features::kV8GCBackgroundSchedule)) {\n    static const char gc_experiment_background_schedule[] =\n        \"--gc_experiment_background_schedule\";\n    v8::V8::SetFlagsFromString(gc_experiment_background_schedule,\n                               sizeof(gc_experiment_background_schedule) - 1);\n  }\n\n  if (base::FeatureList::IsEnabled(features::kV8GCLessCompaction)) {\n    static const char gc_experiment_less_compaction[] =\n        \"--gc_experiment_less_compaction\";\n    v8::V8::SetFlagsFromString(gc_experiment_less_compaction,\n                               sizeof(gc_experiment_less_compaction) - 1);\n  }\n\n  if (IsolateHolder::kStrictMode == mode) {\n    static const char use_strict[] = \"--use_strict\";\n    v8::V8::SetFlagsFromString(use_strict, sizeof(use_strict) - 1);\n  }\n\n#if defined(V8_USE_EXTERNAL_STARTUP_DATA)\n  v8::StartupData natives;\n  GetMappedFileData(g_mapped_natives, &natives);\n  v8::V8::SetNativesDataBlob(&natives);\n\n  if (g_mapped_snapshot) {\n    v8::StartupData snapshot;\n    GetMappedFileData(g_mapped_snapshot, &snapshot);\n    v8::V8::SetSnapshotDataBlob(&snapshot);\n  }\n#endif  // V8_USE_EXTERNAL_STARTUP_DATA\n\n  v8::V8::SetEntropySource(&GenerateEntropy);\n  v8::V8::Initialize();\n\n  v8_is_initialized = true;\n}\n\n## Example:\n\n Input code:\nvoid FUN_0021c070(void)\n{\n  undefined4 uVar1;\n  bool bVar2;\n  bVar2 = DAT_042e8c04 != 0;\n  uVar1 = FUN_00219eb0();\n  FUN_002000c0(uVar1,-bVar2);\n  return;\n}\n\n Revised code:\nvoid m68k_op_sne_8_al(void)\n{\n\tm68ki_write_8(EA_AL_8(), COND_NE() ? 0xff : 0);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00e28907(void)\n{\n  undefined4 uVar1;\n  if (DAT_03e4ce14 == 0) {\n    FUN_00de4420();\n  }\n  else {\n    uVar1 = FUN_00de3aef();\n    FUN_00de40bf(uVar1);\n  }\n  return;\n}",
        "output": "void handle_data_processing(void)\n{\n    if (data_flag == 0) {\n        process_default_data();\n    } else {\n        uint32_t result = fetch_custom_data();\n        process_custom_data(result);\n    }\n}",
        "source_code": "static void m68k_op_move_16_tos_al(void)\n{\n\tif(FLAG_S)\n\t{\n\t\tuint new_sr = OPER_AL_16();\n\t\tm68ki_trace_t0();\t\t\t   /* auto-disable (see m68kcpu.h) */\n\t\tm68ki_set_sr(new_sr);\n\t\treturn;\n\t}\n\tm68ki_exception_privilege_violation();\n}",
        "parsed_output": "void handle_data_processing(void)\n{\n    if (data_flag == 0) {\n        process_default_data();\n    } else {\n        uint32_t result = fetch_custom_data();\n        process_custom_data(result);\n    }\n}",
        "baseline_code_stripped": "void FUN_00e28907(void)\n{\n  undefined4 uVar1;\n  if (DAT_03e4ce14 == 0) {\n    FUN_00de4420();\n  }\n  else {\n    uVar1 = FUN_00de3aef();\n    FUN_00de40bf(uVar1);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.36108484864234924,
        "similarity_score_baseline_stripped": 0.4923078119754791
    },
    {
        "func_name": "ImageDataParameter::release_source",
        "normed_func_sha256": "737cbad3d711833c3121204f21422ae18966e99fe00aef7adee8545670e25d4a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __fastcall FUN_100db820(MessageLite *param_1)\n{\n  uint *puVar1;\n  undefined4 uVar2;\n  puVar1 = (uint *)thunk_FUN_10081470(1);\n  *puVar1 = *puVar1 | 0x40000;\n  if (*(int *)(param_1 + 0x154) == 0) {\n    google::protobuf::MessageLite::GetArenaForAllocation(param_1);\n    uVar2 = __RTC_CheckEsp();\n    uVar2 = thunk_FUN_1005ae40(uVar2);\n    *(undefined4 *)(param_1 + 0x154) = uVar2;\n  }\n  __RTC_CheckEsp();\n  return;\n}\n\n Revised code:\ninline void V1LayerParameter::set_allocated_hdf5_data_param(::opencv_caffe::HDF5DataParameter* hdf5_data_param) {\n  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();\n  if (message_arena == NULL) {\n    delete hdf5_data_param_;\n  }\n  if (hdf5_data_param) {\n    ::google::protobuf::Arena* submessage_arena = NULL;\n    if (message_arena != submessage_arena) {\n      hdf5_data_param = ::google::protobuf::internal::GetOwnedMessage(\n          message_arena, hdf5_data_param, submessage_arena);\n    }\n    set_has_hdf5_data_param();\n  } else {\n    clear_has_hdf5_data_param();\n  }\n  hdf5_data_param_ = hdf5_data_param;\n  // @@protoc_insertion_point(field_set_allocated:opencv_caffe.V1LayerParameter.hdf5_data_param)\n}\n\n## Example:\n\n Input code:\nvoid __fastcall FUN_1002dab0(CodeGeneratorResponse *param_1)\n{\n  bool bVar1;\n  uint *puVar2;\n  bVar1 = google::protobuf::compiler::CodeGeneratorResponse::_internal_has_error(param_1);\n  if (bVar1) {\n    puVar2 = (uint *)thunk_FUN_10027670(0);\n    *puVar2 = *puVar2 & 0xfffffffe;\n    google::protobuf::internal::ArenaStringPtr::Release((ArenaStringPtr *)(param_1 + 0x20));\n    __RTC_CheckEsp();\n  }\n  __RTC_CheckEsp();\n  return;\n}\n\n Revised code:\ninline std::string* CodeGeneratorResponse::release_error() {\n  // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorResponse.error)\n  if (!_internal_has_error()) {\n    return nullptr;\n  }\n  _impl_._has_bits_[0] &= ~0x00000001u;\n  auto* p = _impl_.error_.Release();\n#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING\n  if (_impl_.error_.IsDefault()) {\n    _impl_.error_.Set(\"\", GetArenaForAllocation());\n  }\n#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING\n  return p;\n}\n\n## Example:\n\n Input code:\nField * google::protobuf::Arena::CreateMaybeMessage_google__protobuf__Field_(Arena *param_1)\n{\n  Field *pFVar1;\n  if (param_1 != (Arena *)0x0) {\n    if (*(long *)(param_1 + 0x70) != 0) {\n      OnArenaAllocation(param_1,(type_info *)0x0,0x60);\n    }\n    pFVar1 = (Field *)AllocateAlignedNoHook((ulong)param_1);\n    Field::Field(pFVar1,param_1);\n    return pFVar1;\n  }\n  pFVar1 = (Field *)operator_new(0x60);\n  Field::Field(pFVar1,(Arena *)0x0);\n  return pFVar1;\n}\n\n Revised code:\nPROTOBUF_NOINLINE PROTOBUF_NAMESPACE_ID::Field* Arena::CreateMaybeMessage< PROTOBUF_NAMESPACE_ID::Field >(Arena* arena) {\n  return Arena::CreateMessageInternal< PROTOBUF_NAMESPACE_ID::Field >(arena);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall FUN_100e7930(MessageLite *param_1)\n{\n  uint *puVar1;\n  Arena *pAVar2;\n  puVar1 = (uint *)thunk_FUN_1008f9a0(0);\n  *puVar1 = *puVar1 | 1;\n  google::protobuf::MessageLite::GetArenaForAllocation(param_1);\n  pAVar2 = (Arena *)__RTC_CheckEsp();\n  google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(param_1 + 0x10),pAVar2);\n  __RTC_CheckEsp();\n  __RTC_CheckEsp();\n  return;\n}",
        "output": "inline std::string* MessageLite::mutable_string_field() {\n  ::google::protobuf::Arena* arena = GetArenaForAllocation();\n  _impl_._has_bits_[0] |= 0x00000001u;\n  return _impl_.string_field_.Mutable(arena);\n}",
        "source_code": "inline std::string* ImageDataParameter::release_source() {\n  // @@protoc_insertion_point(field_release:opencv_caffe.ImageDataParameter.source)\n  if (!_internal_has_source()) {\n    return nullptr;\n  }\n  _has_bits_[0] &= ~0x00000001u;\n  auto* p = source_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());\n#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING\n  if (source_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {\n    source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), \"\", GetArenaForAllocation());\n  }\n#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING\n  return p;\n}",
        "parsed_output": "inline std::string* MessageLite::mutable_string_field() {\n  ::google::protobuf::Arena* arena = GetArenaForAllocation();\n  _impl_._has_bits_[0] |= 0x00000001u;\n  return _impl_.string_field_.Mutable(arena);\n}",
        "baseline_code_stripped": "void __fastcall FUN_100e7930(MessageLite *param_1)\n{\n  uint *puVar1;\n  Arena *pAVar2;\n  puVar1 = (uint *)thunk_FUN_1008f9a0(0);\n  *puVar1 = *puVar1 | 1;\n  google::protobuf::MessageLite::GetArenaForAllocation(param_1);\n  pAVar2 = (Arena *)__RTC_CheckEsp();\n  google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(param_1 + 0x10),pAVar2);\n  __RTC_CheckEsp();\n  __RTC_CheckEsp();\n  return;\n}",
        "similarity_score_unixcoder": 0.5907964706420898,
        "similarity_score_baseline_stripped": 0.48968306183815
    },
    {
        "func_name": "OpmlParser::defaultEnd",
        "normed_func_sha256": "cf621c8237672c026956ee9cf7554f3fc184a1b1f28e29888c6096f512283f9b",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_00094240(int param_1,void *param_2,undefined4 param_3,int param_4)\n{\n  bool bVar1;\n  int iVar2;\n  int *piVar3;\n  int *local_38;\n  QTextStream *local_34;\n  undefined4 local_30;\n  undefined4 uStack_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  int local_1c;\n  local_1c = __stack_chk_guard;\n  if (param_1 == 0) {\n    if (param_2 != (void *)0x0) {\n      operator_delete(param_2);\n    }\n    goto LAB_0009435c;\n  }\n  if (param_1 != 1) goto LAB_0009435c;\n  piVar3 = **(int ***)(param_4 + 4);\n  iVar2 = KJob::error();\n  if ((iVar2 != 0) && (iVar2 = FUN_00099fe4(), *(char *)(iVar2 + 9) != '\\0')) {\n    iVar2 = FUN_00099fe4();\n    local_20 = *(undefined4 *)(iVar2 + 4);\n    local_30 = 2;\n    uStack_2c = 0;\n    local_28 = 0;\n    local_24 = 0;\n    QMessageLogger::warning();\n    (**(code **)(*piVar3 + 0x40))(&local_38,piVar3);\n    QDebug::putString((QChar *)&local_34,(int)local_38 + local_38[3]);\n    if (local_34[0x14] != (QTextStream)0x0) {\n      QTextStream::operator__(local_34,' ');\n    }\n    if (*local_38 == 0) {\nLAB_00094388:\n      QArrayData::deallocate((QArrayData *)local_38,2,4);\n    }\n    else if (*local_38 != -1) {\n      DataMemoryBarrier(0xb);\n      do {\n        iVar2 = *local_38;\n        bVar1 = (bool)hasExclusiveAccess(local_38);\n      } while (!bVar1);\n      *local_38 = iVar2 + -1;\n      DataMemoryBarrier(0xb);\n      if (iVar2 + -1 == 0) goto LAB_00094388;\n    }\n    QDebug::_QDebug((QDebug *)&local_34);\n  }\n  QObject::deleteLater();\nLAB_0009435c:\n  if (local_1c == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nint Akonadi::SubscriptionDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QDialog::qt_metacall(_c, _id, _a);\n    return _id;\n}\n\n## Example:\n\n Input code:\nvoid FUN_0021ae80(long param_1)\n{\n  QString *pQVar1;\n  int iVar2;\n  long lVar3;\n  int *piVar4;\n  QDebug aQStack_38 [8];\n  int *local_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  if ((*(byte *)(param_1 + 0xd8) & 1) == 0) {\n    return;\n  }\n  lVar3 = FUN_003189e4(&__stack_chk_guard,*(byte *)(param_1 + 0xd8),0);\n  if (*(char *)(lVar3 + 0x10) != '\\0') {\n    lVar3 = FUN_003189e4();\n    local_18 = *(undefined8 *)(lVar3 + 8);\n    local_28 = 0;\n    uStack_20 = 0;\n    local_30 = (int *)0x2;\n    QMessageLogger::debug();\n    FUN_00180f70(aQStack_38,\"\\thyperref\");\n    QDebug::_QDebug(aQStack_38);\n  }\n  pQVar1 = (QString *)(param_1 + 0x38);\n  QString::fromUtf8_helper(\"\\\\usepackage\",0xb);\n  QString::append(pQVar1);\n  if ((*local_30 == 0) ||\n     ((*local_30 != -1 && (iVar2 = FUN_003bb1b0(0xffffffff,local_30), iVar2 == 1)))) {\n    QArrayData::deallocate((QArrayData *)local_30,2,8);\n  }\n  piVar4 = *(int **)(param_1 + 0xe0);\n  if (piVar4[1] != 0) {\n    local_30 = piVar4;\n    if (1 < *piVar4 + 1U) {\n      FUN_003bb1b0(1);\n    }\n    QString::insert((int)&local_30,(QChar)0x0);\n    FUN_001b5240(&local_30,0x5d);\n    QString::append(pQVar1);\n    FUN_0017fea0(aQStack_38);\n    FUN_0017fea0(&local_30);\n  }\n  QString::fromUtf8_helper(\"{hyperref}\\n\",0xb);\n  QString::append(pQVar1);\n  FUN_0017fea0(&local_30);\n  if (*(int *)(*(long *)(param_1 + 0xe8) + 4) != 0) {\n    QString::fromUtf8_helper(\"\\\\hypersetup{\",0xc);\n    QString::append((QString *)&local_30);\n    FUN_001b5100(&local_30,&DAT_003e0ed0);\n    QString::append(pQVar1);\n    FUN_0017fea0(aQStack_38);\n    FUN_0017fea0(&local_30);\n  }\n  if (local_8 - ___stack_chk_guard == 0) {\n    QString::append(SUB81(pQVar1,0));\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);\n}\n\n Revised code:\nvoid QuickDocument::printHyperref()\n{\n    if (! m_currentHyperref)\n        return;\n\n    KILE_DEBUG_MAIN << \"\\thyperref\";\n\n    // output hyperref package\n    m_td.tagBegin += \"\\\\usepackage\";\n    if (! m_hyperrefdriver.isEmpty())\n        m_td.tagBegin += '[' + m_hyperrefdriver + ']';\n    m_td.tagBegin += \"{hyperref}\\n\";\n\n    // output hyperref options\n    if (! m_hyperrefsetup.isEmpty()) {\n        m_td.tagBegin += \"\\\\hypersetup{\" + m_hyperrefsetup + \"%\\n}\\n\";\n    }\n\n    m_td.tagBegin += '\\n';\n\n\n}\n\n## Example:\n\n Input code:\nvoid FUN_017e7af0(long param_1,undefined8 param_2,undefined8 param_3)\n{\n  bool bVar1;\n  int iVar2;\n  undefined8 uVar3;\n  void *pvVar4;\n  long local_88;\n  undefined8 local_80;\n  QgsExpressionContext *local_78;\n  undefined8 uStack_70;\n  long *local_68 [4];\n  long local_48;\n  bVar1 = true;\n  local_48 = ___stack_chk_guard;\n  local_80 = 0;\n  local_88 = param_1;\n  if (param_1 != 0) {\n    iVar2 = (**(code **)(sipAPI__core + 0x3a8))();\n    bVar1 = iVar2 != 0;\n  }\n  iVar2 = (**(code **)(sipAPI__core + 0x370))\n                    (&local_80,param_2,param_3,&PTR_s_parent_02918aa0,0,\"BJ8J8\",&local_88,\n                     sipExportedTypes__core._6928_8_,local_68,sipExportedTypes__core._6704_8_,\n                     &local_78,sipExportedTypes__core._6736_8_,&uStack_70);\n  if (iVar2 == 0) {\n    (**(code **)(sipAPI__core + 0x2a0))\n              (local_80,\"QgsExpressionNodeUnaryOperator\",\"evalNode\",\n               \"evalNode(self, parent: Optional[QgsExpression], context: Optional[QgsExpressionContext]) -> Any\"\n              );\n    uVar3 = 0;\n  }\n  else {\n    uVar3 = PyEval_SaveThread();\n    pvVar4 = operator_new(0x10);\n    if (bVar1) {\n      QgsExpressionNodeUnaryOperator::evalNode((QgsExpression *)local_68[0],local_78);\n    }\n    else {\n      (**(code **)(*local_68[0] + 0x60))(local_68[0],local_78,uStack_70);\n    }\n    PyEval_RestoreThread(uVar3);\n    uVar3 = (**(code **)(sipAPI__core + 0x90))(pvVar4,PTR_s_QVariant_0281a590,0);\n  }\n  if (local_48 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(uVar3,&__stack_chk_guard,0,local_48 - ___stack_chk_guard);\n}\n\n Revised code:\nstatic PyObject *meth_QgsExpressionNodeUnaryOperator_evalNode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));\n\n    {\n        ::QgsExpression* a0;\n        const ::QgsExpressionContext* a1;\n        ::QgsExpressionNodeUnaryOperator *sipCpp;\n\n        static const char *sipKwdList[] = {\n            sipName_parent,\n            sipName_context,\n        };\n\n        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, \"BJ8J8\", &sipSelf, sipType_QgsExpressionNodeUnaryOperator, &sipCpp, sipType_QgsExpression, &a0, sipType_QgsExpressionContext, &a1))\n        {\n            ::QVariant*sipRes;\n\n            Py_BEGIN_ALLOW_THREADS\n            try\n            {\n            sipRes = new ::QVariant((sipSelfWasArg ? sipCpp->::QgsExpressionNodeUnaryOperator::evalNode(a0, a1) : sipCpp->evalNode(a0, a1)));\n            }\n            catch (...)\n            {\n                Py_BLOCK_THREADS\n\n                void *sipExcState = SIP_NULLPTR;\n                sipExceptionHandler sipExcHandler;\n                std::exception_ptr sipExcPtr = std::current_exception();\n\n                while ((sipExcHandler = sipNextExceptionHandler(&sipExcState)) != SIP_NULLPTR)\n                    if (sipExcHandler(sipExcPtr))\n                        return SIP_NULLPTR;\n\n                sipRaiseUnknownException();\n                return SIP_NULLPTR;\n            }\n            Py_END_ALLOW_THREADS\n\n            return sipConvertFromNewType(sipRes, sipType_QVariant, SIP_NULLPTR);\n        }\n    }\n\n    sipNoMethod(sipParseErr, sipName_QgsExpressionNodeUnaryOperator, sipName_evalNode, doc_QgsExpressionNodeUnaryOperator_evalNode);\n\n    return SIP_NULLPTR;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid OpmlParser::defaultEnd(QSharedPointer *param_1,Thread *param_2)\n{\n  void *pvVar1;\n  int iVar2;\n  ulong uVar3;\n  QSharedPointer QVar4;\n  undefined8 local_20;\n  void *pvStack_18;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  ThreadWeaver::Job::defaultEnd(param_1 + 4,param_2);\n  uVar3 = (**(code **)(**(long **)param_2 + 0x48))();\n  QVar4 = (QSharedPointer)&local_20;\n  if ((uVar3 & 1) == 0) {\n    pvStack_18 = *(void **)(param_2 + 8);\n    local_20 = *(undefined8 *)param_2;\n    if (pvStack_18 != (void *)0x0) {\n      FUN_0032a300(&local_20);\n    }\n    failed((OpmlParser *)param_1,QVar4);\n    if (pvStack_18 != (void *)0x0) {\n      FUN_003441a0();\n    }\n  }\n  pvStack_18 = *(void **)(param_2 + 8);\n  local_20 = *(undefined8 *)param_2;\n  if (pvStack_18 != (void *)0x0) {\n    FUN_006e2be0(1);\n    FUN_006e2be0(1,(long)pvStack_18 + 4);\n  }\n  done((OpmlParser *)param_1,QVar4);\n  pvVar1 = pvStack_18;\n  if (pvStack_18 != (void *)0x0) {\n    iVar2 = FUN_006e2be0(0xffffffff,(long)pvStack_18 + 4);\n    if (iVar2 == 1) {\n      (**(code **)((long)pvVar1 + 8))(pvVar1);\n    }\n    iVar2 = FUN_006e2be0(0xffffffff,pvVar1);\n    if (iVar2 == 1) {\n      operator_delete(pvVar1);\n    }\n  }\n  if (local_8 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);\n}",
        "output": "```cpp\nvoid OpmlParser::defaultEnd(QSharedPointer<QObject> *result, Thread *thread)\n{\n    ThreadWeaver::Job::defaultEnd(result + 4, thread);\n\n    if (!((*reinterpret_cast<ulong *>(*reinterpret_cast<long **>(thread)) + 0x48)() & 1)) {\n        QSharedPointer<QObject> errorResult;\n        errorResult.reset(reinterpret_cast<QObject *>(thread->data));\n        if (errorResult) {\n            processError(errorResult);\n        }\n        failed(this, errorResult);\n        if (errorResult) {\n            cleanupError();\n        }\n    }\n\n    QSharedPointer<QObject> successResult;\n    successResult.reset(reinterpret_cast<QObject *>(thread->data));\n    if (successResult) {\n        processSuccess(successResult);\n        processSuccess(successResult, reinterpret_cast<long>(successResult.data()) + 4);\n    }\n    done(this, successResult);\n\n    if (successResult) {\n        if (decrementRefCount(reinterpret_cast<long>(successResult.data()) + 4) == 1) {\n            successResult->cleanup();\n        }\n        if (decrementRefCount(successResult.data()) == 1) {\n            delete successResult.data();\n        }\n    }\n}\n```",
        "source_code": "void\nOpmlParser::defaultEnd(const ThreadWeaver::JobPointer& self, ThreadWeaver::Thread *thread)\n{\n    ThreadWeaver::Job::defaultEnd(self, thread);\n    if (!self->success()) {\n        Q_EMIT failed(self);\n    }\n    Q_EMIT done(self);\n}",
        "parsed_output": "pp\nvoid OpmlParser::defaultEnd(QSharedPointer<QObject> *result, Thread *thread)\n{\n    ThreadWeaver::Job::defaultEnd(result + 4, thread);\n\n    if (!((*reinterpret_cast<ulong *>(*reinterpret_cast<long **>(thread)) + 0x48)() & 1)) {\n        QSharedPointer<QObject> errorResult;\n        errorResult.reset(reinterpret_cast<QObject *>(thread->data));\n        if (errorResult) {\n            processError(errorResult);\n        }\n        failed(this, errorResult);\n        if (errorResult) {\n            cleanupError();\n        }\n    }\n\n    QSharedPointer<QObject> successResult;\n    successResult.reset(reinterpret_cast<QObject *>(thread->data));\n    if (successResult) {\n        processSuccess(successResult);\n        processSuccess(successResult, reinterpret_cast<long>(successResult.data()) + 4);\n    }\n    done(this, successResult);\n\n    if (successResult) {\n        if (decrementRefCount(reinterpret_cast<long>(successResult.data()) + 4) == 1) {\n            successResult->cleanup();\n        }\n        if (decrementRefCount(successResult.data()) == 1) {\n            delete successResult.data();\n        }\n    }\n}",
        "baseline_code_stripped": "void OpmlParser::defaultEnd(QSharedPointer *param_1,Thread *param_2)\n{\n  void *pvVar1;\n  int iVar2;\n  ulong uVar3;\n  QSharedPointer QVar4;\n  undefined8 local_20;\n  void *pvStack_18;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  ThreadWeaver::Job::defaultEnd(param_1 + 4,param_2);\n  uVar3 = (**(code **)(**(long **)param_2 + 0x48))();\n  QVar4 = (QSharedPointer)&local_20;\n  if ((uVar3 & 1) == 0) {\n    pvStack_18 = *(void **)(param_2 + 8);\n    local_20 = *(undefined8 *)param_2;\n    if (pvStack_18 != (void *)0x0) {\n      FUN_0032a300(&local_20);\n    }\n    failed((OpmlParser *)param_1,QVar4);\n    if (pvStack_18 != (void *)0x0) {\n      FUN_003441a0();\n    }\n  }\n  pvStack_18 = *(void **)(param_2 + 8);\n  local_20 = *(undefined8 *)param_2;\n  if (pvStack_18 != (void *)0x0) {\n    FUN_006e2be0(1);\n    FUN_006e2be0(1,(long)pvStack_18 + 4);\n  }\n  done((OpmlParser *)param_1,QVar4);\n  pvVar1 = pvStack_18;\n  if (pvStack_18 != (void *)0x0) {\n    iVar2 = FUN_006e2be0(0xffffffff,(long)pvStack_18 + 4);\n    if (iVar2 == 1) {\n      (**(code **)((long)pvVar1 + 8))(pvVar1);\n    }\n    iVar2 = FUN_006e2be0(0xffffffff,pvVar1);\n    if (iVar2 == 1) {\n      operator_delete(pvVar1);\n    }\n  }\n  if (local_8 - ___stack_chk_guard == 0) {\n    return;\n  }\n  __stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);\n}",
        "similarity_score_unixcoder": 0.7789154052734375,
        "similarity_score_baseline_stripped": 0.5953972339630127
    },
    {
        "func_name": "sipQgsMapLayer::sipProtectVirt_decodedSource",
        "normed_func_sha256": "4c76efd72899d90139badcb6bbc0e4297c58126a1f2a435049d3f2114dd040ba",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nQVariant *\nsipQgsProcessingParameterRange::valueAsStringList\n          (QVariant *param_1,QgsProcessingContext *param_2,bool *param_3)\n{\n  QVariant *pQVar1;\n  undefined4 *puVar2;\n  int in_GS_OFFSET;\n  bool *in_stack_00000010;\n  undefined4 in_stack_00000014;\n  undefined4 uStack_40;\n  undefined auStack_3c [8];\n  QgsProcessingContext *local_34;\n  undefined4 local_30;\n  _func_void__sipSimpleWrapper_ptr_PyGILState_STATE *local_24;\n  undefined4 local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x118fe39;\n  local_34 = (QgsProcessingContext *)param_3;\n  local_30 = in_stack_00000014;\n  local_20 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  pQVar1 = (QVariant *)\n           (**(code **)(sipAPI__core + 0x260))\n                     (&local_24,param_2 + 0x6b,param_2 + 0x60,0,\"valueAsStringList\");\n  if (pQVar1 == (QVariant *)0x0) {\n    QgsProcessingParameterDefinition::valueAsStringList(param_1,param_2,(bool *)local_34);\n    puVar2 = &uStack_40;\n  }\n  else {\n    uStack_40 = local_30;\n    sipVH__core_731((PyGILState_STATE)param_1,local_24,\n                    (_sipSimpleWrapper *)sipImportedVirtErrorHandlers__core_QtCore,\n                    *(_object **)(param_2 + 0x60),pQVar1,local_34,in_stack_00000010);\n    puVar2 = (undefined4 *)auStack_3c;\n  }\n  if (*(int *)((int)puVar2 + 0x1c) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return param_1;\n  }\n  *(undefined **)((int)puVar2 + -4) = &UNK_0118fef2;\n  FUN_01a625e0();\n}\n\n Revised code:\n::QStringList sipQgsProcessingParameterRange::valueAsStringList(const ::QVariant& a0, ::QgsProcessingContext& a1, bool& a2) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[7]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_valueAsStringList);\n\n    if (!sipMeth)\n        return ::QgsProcessingParameterRange::valueAsStringList(a0, a1, a2);\n\n    extern ::QStringList sipVH__core_731(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const ::QVariant&, ::QgsProcessingContext&, bool&);\n\n    return sipVH__core_731(sipGILState, sipImportedVirtErrorHandlers__core_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2);\n}\n\n## Example:\n\n Input code:\nvoid FUN_0081e000(int param_1,undefined4 param_2,int *param_3)\n{\n  QString *pQVar1;\n  int in_GS_OFFSET;\n  undefined local_2c [8];\n  int local_24;\n  undefined4 local_20;\n  local_20 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  QString::fromUtf8((QByteArrayView)local_2c);\n  pQVar1 = (QString *)FUN_0042eec0();\n  QString::operator_((QString *)(param_1 + 0xc),pQVar1);\n  if (param_3 != (int *)0x0) {\n    LOCK();\n    *param_3 = *param_3 + -1;\n    UNLOCK();\n    if (*param_3 == 0) {\n      QArrayData::deallocate((QArrayData *)param_3,2,4);\n    }\n  }\n  if (local_24 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  FUN_00d74ab0();\n}\n\n Revised code:\nvoid begin (const Xml_string& tagname, Xml_attr attr)\n\t{\n\t\tm_name = attr[\"name\"];\n\t}\n\n## Example:\n\n Input code:\nQVariant *\nsipQgsProcessingParameterMatrix::valueAsJsonObject(QVariant *param_1,QgsProcessingContext *param_2)\n{\n  QVariant *pQVar1;\n  undefined4 *puVar2;\n  int in_GS_OFFSET;\n  QgsProcessingContext *in_stack_0000000c;\n  undefined4 in_stack_00000010;\n  undefined4 uStack_40;\n  undefined auStack_3c [12];\n  undefined4 local_30;\n  _func_void__sipSimpleWrapper_ptr_PyGILState_STATE *local_24;\n  undefined4 local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x118c979;\n  local_30 = in_stack_00000010;\n  local_20 = *(undefined4 *)(in_GS_OFFSET + 0x14);\n  pQVar1 = (QVariant *)\n           (**(code **)(sipAPI__core + 0x260))\n                     (&local_24,param_2 + 0x71,param_2 + 0x68,0,\"valueAsJsonObject\");\n  if (pQVar1 == (QVariant *)0x0) {\n    uStack_40 = local_30;\n    QgsProcessingParameterDefinition::valueAsJsonObject(param_1,param_2);\n    puVar2 = &uStack_40;\n  }\n  else {\n    sipVH__core_729((PyGILState_STATE)param_1,local_24,\n                    (_sipSimpleWrapper *)sipImportedVirtErrorHandlers__core_QtCore,\n                    *(_object **)(param_2 + 0x68),pQVar1,in_stack_0000000c);\n    puVar2 = (undefined4 *)auStack_3c;\n  }\n  if (*(int *)((int)puVar2 + 0x1c) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return param_1;\n  }\n  *(undefined **)((int)puVar2 + -4) = &UNK_0118ca23;\n  FUN_01a625e0();\n}\n\n Revised code:\n::QVariant sipQgsProcessingParameterMatrix::valueAsJsonObject(const ::QVariant& a0, ::QgsProcessingContext& a1) const\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[5]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_valueAsJsonObject);\n\n    if (!sipMeth)\n        return ::QgsProcessingParameterMatrix::valueAsJsonObject(a0, a1);\n\n    extern ::QVariant sipVH__core_729(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const ::QVariant&, ::QgsProcessingContext&);\n\n    return sipVH__core_729(sipGILState, sipImportedVirtErrorHandlers__core_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nQString * sipQgsMapLayer::sipProtectVirt_decodedSource\n                    (bool param_1,QString *param_2,QString *param_3,QgsReadWriteContext *param_4)\n{\n  long lVar1;\n  undefined7 in_register_00000039;\n  QString *pQVar2;\n  long in_FS_OFFSET;\n  pQVar2 = (QString *)CONCAT71(in_register_00000039,param_1);\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((char)param_3 == '\\0') {\n    (**(code **)(*(long *)param_2 + 0x260))(pQVar2);\n  }\n  else {\n    QgsMapLayer::decodedSource(pQVar2,param_2,param_4);\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pQVar2;\n  }\n  __stack_chk_fail();\n}",
        "output": "```cpp\nQString sipQgsMapLayer::sipProtectVirt_decodedSource(bool param_1, const QString& param_2, const QString& param_3, QgsReadWriteContext& param_4) const\n{\n    QString result;\n    if (param_3.isEmpty()) {\n        sipCallMethod(result, sipPySelf, sipName_decodedSource, param_1);\n    } else {\n        result = QgsMapLayer::decodedSource(param_1, param_2, param_4);\n    }\n    return result;\n}\n```",
        "source_code": "::QString sipQgsMapLayer::sipProtectVirt_decodedSource(bool sipSelfWasArg, const ::QString& a0, const ::QString& a1, const ::QgsReadWriteContext& a2) const\n{\n    return (sipSelfWasArg ? ::QgsMapLayer::decodedSource(a0, a1, a2) : decodedSource(a0, a1, a2));\n}",
        "parsed_output": "pp\nQString sipQgsMapLayer::sipProtectVirt_decodedSource(bool param_1, const QString& param_2, const QString& param_3, QgsReadWriteContext& param_4) const\n{\n    QString result;\n    if (param_3.isEmpty()) {\n        sipCallMethod(result, sipPySelf, sipName_decodedSource, param_1);\n    } else {\n        result = QgsMapLayer::decodedSource(param_1, param_2, param_4);\n    }\n    return result;\n}",
        "baseline_code_stripped": "QString * sipQgsMapLayer::sipProtectVirt_decodedSource\n                    (bool param_1,QString *param_2,QString *param_3,QgsReadWriteContext *param_4)\n{\n  long lVar1;\n  undefined7 in_register_00000039;\n  QString *pQVar2;\n  long in_FS_OFFSET;\n  pQVar2 = (QString *)CONCAT71(in_register_00000039,param_1);\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((char)param_3 == '\\0') {\n    (**(code **)(*(long *)param_2 + 0x260))(pQVar2);\n  }\n  else {\n    QgsMapLayer::decodedSource(pQVar2,param_2,param_4);\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pQVar2;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.8468418121337891,
        "similarity_score_baseline_stripped": 0.6999660134315491
    },
    {
        "func_name": "s_forward",
        "normed_func_sha256": "ee40c9a65acefd1731e6e43be0d81616867d5c1c4935994809e8e5b6e1c25fee",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\ndouble FUN_0051edc0(int *param_1)\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  ulong uVar4;\n  long lVar5;\n  ulong uVar6;\n  long lVar7;\n  double dVar8;\n  double extraout_XMM0_Qa;\n  double extraout_XMM0_Qa_00;\n  double extraout_XMM0_Qa_01;\n  double dVar9;\n  undefined auVar10 [16];\n  uVar3 = param_1[5];\n  uVar6 = (ulong)uVar3;\n  if ((int)uVar3 < 0x7b2) {\n    dVar8 = 0.0;\n    auVar10 = ZEXT816(0x4076d00000000000);\n    do {\n      dVar9 = auVar10._0_8_;\n      if ((uVar3 & 3) == 0) {\n        iVar1 = FUN_0051ed80(uVar3);\n        dVar9 = (double)iVar1;\n        dVar8 = extraout_XMM0_Qa_00;\n      }\n      uVar3 = uVar3 + 1;\n      dVar8 = dVar8 - dVar9;\n    } while (uVar3 != 0x7b2);\n  }\n  else {\n    dVar8 = 0.0;\n    uVar4 = 0x7b2;\n    iVar1 = 0x16d;\n    if (uVar3 != 0x7b2) {\n      while( true ) {\n        uVar3 = (int)uVar4 + 1;\n        uVar4 = (ulong)uVar3;\n        dVar8 = dVar8 + (double)iVar1;\n        if ((uint)uVar6 == uVar3) break;\n        iVar1 = 0x16d;\n        if ((uVar3 & 3) == 0) {\n          iVar1 = FUN_0051ed80(uVar3);\n          dVar8 = extraout_XMM0_Qa;\n        }\n      }\n    }\n  }\n  iVar1 = param_1[3];\n  if (iVar1 < 1) {\n    dVar8 = dVar8 + (double)param_1[7];\n  }\n  else {\n    if (0 < param_1[4]) {\n      lVar5 = 1;\n      auVar10 = ZEXT816(0x403f000000000000);\n      uVar3 = 0;\n      lVar7 = (ulong)(param_1[4] - 1) + 1;\n      uVar4 = uVar6 & 3;\n      while( true ) {\n        dVar8 = dVar8 + (double)uVar3 + auVar10._0_8_;\n        if (lVar7 == lVar5) break;\n        uVar3 = 0;\n        auVar10._0_8_ = (double)(&DAT_0057b080)[lVar5];\n        auVar10._8_8_ = 0;\n        if (((int)lVar5 == 1) && (uVar4 == 0)) {\n          iVar2 = FUN_0051ed80(uVar6 & 0xffffffff);\n          uVar3 = (uint)(0x16d < iVar2);\n          dVar8 = extraout_XMM0_Qa_01;\n        }\n        lVar5 = lVar5 + 1;\n      }\n    }\n    dVar8 = dVar8 + ((double)iVar1 - 1.0);\n  }\n  return ((double)param_1[1] + (dVar8 * 24.0 + (double)param_1[2]) * 60.0) * 60.0 + (double)*param_1\n  ;\n}\n\n Revised code:\ndouble\ngtimegm(struct tm *tm)\n{\n    int i;\n    /* returns sec from year ZERO_YEAR, defined in gp_time.h */\n    double dsec = 0.;\n\n    if (tm->tm_year < ZERO_YEAR) {\n\tfor (i = tm->tm_year; i < ZERO_YEAR; i++) {\n\t    dsec -= (double) gdysize(i);\n\t}\n    } else {\n\tfor (i = ZERO_YEAR; i < tm->tm_year; i++) {\n\t    dsec += (double) gdysize(i);\n\t}\n    }\n    if (tm->tm_mday > 0) {\n\tfor (i = 0; i < tm->tm_mon; i++) {\n\t    dsec += (double) mndday[i] + (i == 1 && (gdysize(tm->tm_year) > 365));\n\t}\n\tdsec += (double) tm->tm_mday - 1;\n    } else {\n\tdsec += (double) tm->tm_yday;\n    }\n    dsec *= (double) 24;\n\n    dsec += tm->tm_hour;\n    dsec *= 60.0;\n    dsec += tm->tm_min;\n    dsec *= 60.0;\n    dsec += tm->tm_sec;\n\n    FPRINTF((stderr, \"broken-down time : %02d/%02d/%d:%02d:%02d:%02d = %g seconds\\n\", tm->tm_mday, tm->tm_mon + 1, tm->tm_year, tm->tm_hour,\n\t     tm->tm_min, tm->tm_sec, dsec));\n\n    return (dsec);\n}\n\n## Example:\n\n Input code:\ndouble FUN_00198a6c(long param_1)\n{\n  long lVar1;\n  undefined8 uVar2;\n  int iVar3;\n  int iVar4;\n  double dVar5;\n  double dVar6;\n  double extraout_fa0;\n  double dVar7;\n  double dVar8;\n  iVar3 = *(int *)(param_1 + 4);\n  dVar6 = *(double *)(param_1 + 0x20);\n  dVar8 = 0.0;\n  if (0 < iVar3) {\n    iVar4 = 1;\nLAB_00198ac0:\n    do {\n      dVar5 = 0.0;\n      dVar7 = 0.0;\n      lVar1 = FUN_0018f40c(2,1,dVar6 * *(double *)(param_1 + 0x18));\n      if (lVar1 != 0) {\n        dVar5 = (double)FUN_00126210(0);\n      }\n      FUN_00123620(lVar1);\n      if (*(int *)(param_1 + 4) == iVar4) {\n        dVar8 = 0.0;\n        lVar1 = FUN_0018f40c(2,1,dVar6 + dVar5 + *(double *)(param_1 + 0x28));\n        uVar2 = 0;\n        dVar7 = dVar6;\n        if (lVar1 != 0) {\n          dVar8 = (double)FUN_00126210();\n          FUN_00123620(lVar1);\n          iVar3 = *(int *)(param_1 + 4);\n          iVar4 = iVar4 + 1;\n          dVar6 = dVar6 - dVar6;\n          if (iVar3 < iVar4) break;\n          goto LAB_00198ac0;\n        }\n      }\n      else {\n        lVar1 = FUN_0018f40c(2,1,(*(double *)(param_1 + 0x38) - dVar5) - *(double *)(param_1 + 0x28)\n                            );\n        uVar2 = 0;\n        if (lVar1 != 0) {\n          uVar2 = FUN_00126210(0);\n          dVar7 = extraout_fa0;\n        }\n      }\n      FUN_00123620(lVar1,uVar2);\n      iVar3 = *(int *)(param_1 + 4);\n      iVar4 = iVar4 + 1;\n      dVar6 = dVar6 - dVar7;\n    } while (iVar4 <= iVar3);\n    dVar6 = *(double *)(param_1 + 0x20);\n  }\n  return (*(double *)(param_1 + 0x38) * (double)(iVar3 + -1) + dVar8) - dVar6;\n}\n\n Revised code:\ngdouble bet_data_finance_get_total_cost (EcheanceStruct *s_echeance)\n{\n    gdouble capital_du;\n    gdouble cost;\n    gdouble echeance = 0.0;\n    gdouble interets;\n    gdouble principal;\n    gint index;\n\n\n    capital_du = s_echeance->capital;\n\n    for (index = 1; index <= s_echeance->nbre_echeances; index++)\n    {\n        interets = bet_data_finance_get_interets (capital_du, s_echeance->taux_periodique);\n\n        if (index == s_echeance->nbre_echeances)\n        {\n            echeance = bet_data_finance_get_last_echeance (\n                        capital_du,\n                        interets,\n                        s_echeance->frais);\n            principal = capital_du;\n        }\n        else\n            principal = bet_data_finance_get_principal (\n                        s_echeance->total_echeance,\n                        interets,\n                        s_echeance->frais);\n\n        capital_du -= principal;\n    }\n\n    cost = (s_echeance->total_echeance * (s_echeance->nbre_echeances - 1))\n                        + echeance - s_echeance->capital;\n\n    return cost;\n}\n\n## Example:\n\n Input code:\ndouble FUN_18018cd90(undefined8 param_1,double param_2,double param_3,char param_4)\n{\n  bool bVar1;\n  undefined auVar2 [16];\n  undefined auVar3 [16];\n  double dVar4;\n  uint in_EAX;\n  uint uVar5;\n  longlong lVar6;\n  double extraout_XMM0_Qa;\n  double extraout_XMM0_Qa_00;\n  double dVar7;\n  undefined4 uVar8;\n  double local_res10;\n  undefined8 local_58;\n  double *local_50;\n  lVar6 = (longlong)param_2;\n  uVar8 = (undefined4)((ulonglong)param_2 >> 0x20);\n  local_res10 = param_2;\n  if ((lVar6 != -0x8000000000000000) && ((double)lVar6 != param_2)) {\n    auVar2._8_4_ = SUB84(param_2,0);\n    auVar2._0_8_ = param_2;\n    auVar2._12_4_ = uVar8;\n    uVar5 = movmskpd(in_EAX,auVar2);\n    in_EAX = uVar5 & 1;\n    local_res10 = (double)(lVar6 - (ulonglong)in_EAX);\n  }\n  dVar7 = 0.0;\n  if (0.0 <= local_res10) {\n    if (param_4 == '\\0') {\n      in_EAX = FUN_180189590(0,&local_res10);\n      dVar7 = extraout_XMM0_Qa_00;\n    }\n    else {\n      local_50 = &local_res10;\n      local_58 = param_1;\n      in_EAX = FUN_180189460(&local_58);\n      dVar7 = extraout_XMM0_Qa;\n    }\n  }\n  dVar4 = local_res10;\n  if (((dVar7 != param_3) &&\n      (lVar6 = (longlong)param_2, dVar4 = param_2, lVar6 != -0x8000000000000000)) &&\n     ((double)lVar6 != param_2)) {\n    auVar3._8_4_ = SUB84(param_2,0);\n    auVar3._0_8_ = param_2;\n    auVar3._12_4_ = uVar8;\n    uVar5 = movmskpd(in_EAX,auVar3);\n    dVar4 = (double)(lVar6 + (ulonglong)(uVar5 & 1 ^ 1));\n  }\n  do {\n    local_res10 = dVar4 + 1.0;\n    if (1.797693134862316e+308 < local_res10) {\n      return dVar4;\n    }\n    if (param_4 == '\\0') {\n      dVar7 = (double)FUN_180189590(param_1,&local_res10);\n    }\n    else {\n      local_50 = &local_res10;\n      local_58 = param_1;\n      dVar7 = (double)FUN_180189460(&local_58);\n    }\n    if (dVar7 != param_3) {\n      if (param_4 == '\\0') {\n        bVar1 = dVar7 < param_3;\n      }\n      else {\n        bVar1 = param_3 < dVar7;\n      }\n      local_res10 = dVar4;\n      if (!bVar1 && param_3 != dVar7) {\n        return dVar4;\n      }\n    }\n    dVar4 = local_res10 + 1.0;\n  } while( true );\n}\n\n Revised code:\ninline typename Dist::value_type round_to_ceil(const Dist& d, typename Dist::value_type result, typename Dist::value_type p, bool c)\n{\n   BOOST_MATH_STD_USING\n   typename Dist::value_type cc = floor(result);\n   typename Dist::value_type pp = cc >= support(d).first ? c ? cdf(complement(d, cc)) : cdf(d, cc) : 0;\n   if(pp == p)\n      result = cc;\n   else\n      result = ceil(result);\n   while(true)\n   {\n      cc = result + 1;\n      if(cc > support(d).second)\n         break;\n      typename Dist::value_type pp = c ? cdf(complement(d, cc)) : cdf(d, cc);\n      if(pp == p)\n         result = cc;\n      else if(c ? pp < p : pp > p)\n         break;\n      result += 1;\n   }\n   return result;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nXY s_forward(LP lp,PJ_conflict56 *P)\n{\n  undefined8 extraout_RAX;\n  undefined8 uVar1;\n  undefined8 extraout_RAX_00;\n  undefined8 extraout_RDX;\n  undefined8 uVar2;\n  undefined8 extraout_RDX_00;\n  int iVar3;\n  double dVar4;\n  double p;\n  double dVar5;\n  double dVar6;\n  double dVar7;\n  double in_XMM1_Qa;\n  double dVar8;\n  double V;\n  double dVar9;\n  double r;\n  XY XVar10;\n  iVar3 = 10;\n  dVar4 = sin(in_XMM1_Qa);\n  dVar7 = P->B;\n  dVar8 = in_XMM1_Qa * 1.10265779;\n  while( true ) {\n    dVar5 = dVar8 * dVar8 + 1.0;\n    dVar9 = SQRT(dVar5);\n    if (dVar5 < 0.0) {\n      sqrt(dVar5);\n    }\n    dVar5 = P->A;\n    dVar6 = log(dVar9 + dVar8);\n    dVar5 = (((dVar5 - dVar9) * dVar8 - dVar6) - dVar4 * dVar7) / (P->A - (dVar9 + dVar9));\n    dVar8 = dVar8 - dVar5;\n    uVar1 = extraout_RAX;\n    uVar2 = extraout_RDX;\n    if ((double)((ulong)dVar5 & 0x7fffffffffffffff) < 1e-10) break;\n    iVar3 = iVar3 + -1;\n    if (iVar3 == 0) {\nLAB_0042e78a:\n      XVar10.y = (double)uVar2;\n      XVar10.x = (double)uVar1;\n      return XVar10;\n    }\n  }\n  dVar7 = dVar8 * dVar8 + 1.0;\n  if (dVar7 < 0.0) {\n    sqrt(dVar7);\n    uVar1 = extraout_RAX_00;\n    uVar2 = extraout_RDX_00;\n  }\n  goto LAB_0042e78a;\n}",
        "output": "```c\nXY s_forward(LP lp, PJ_conflict56 *P) {\n    XY result;\n    int max_iterations = 10;\n    double sin_phi = sin(P->phi);\n    double B = P->B;\n    double x = P->phi * 1.10265779;\n\n    while (max_iterations > 0) {\n        double x_squared = x * x + 1.0;\n        double sqrt_x_squared = sqrt(x_squared);\n        double A = P->A;\n        double log_term = log(sqrt_x_squared + x);\n        double delta = (((A - sqrt_x_squared) * x - log_term) - sin_phi * B) / (A - 2 * sqrt_x_squared);\n\n        x -= delta;\n\n        if (fabs(delta) < 1e-10) {\n            break;\n        }\n\n        max_iterations--;\n        if (max_iterations == 0) {\n            result.x = NAN;\n            result.y = NAN;\n            return result;\n        }\n    }\n\n    double final_x_squared = x * x + 1.0;\n    sqrt(final_x_squared); // Ensure no negative values for sqrt\n    result.x = x;\n    result.y = sqrt(final_x_squared);\n\n    return result;\n}\n```",
        "source_code": "static PJ_XY s_forward (PJ_LP lp, PJ *P) {           /* Spheroidal, forward */\n    PJ_XY xy = {0.0,0.0};\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(P->opaque);\n    double p, r, V;\n    int i;\n\n    p = Q->B * sin(lp.phi);\n    lp.phi *=  1.10265779;\n    for (i = NITER; i ; --i) {\n        r = sqrt(1. + lp.phi * lp.phi);\n        lp.phi -= V = ( (Q->A - r) * lp.phi - log(lp.phi + r) - p ) /\n            (Q->A - 2. * r);\n        if (fabs(V) < EPS)\n            break;\n    }\n    if (!i)\n        lp.phi = p < 0. ? -CON_POLE : CON_POLE;\n    xy.x = Q->C_x * lp.lam * (Q->D - sqrt(1. + lp.phi * lp.phi));\n    xy.y = Q->C_y * lp.phi;\n\n    return xy;\n}",
        "parsed_output": "XY s_forward(LP lp, PJ_conflict56 *P) {\n    XY result;\n    int max_iterations = 10;\n    double sin_phi = sin(P->phi);\n    double B = P->B;\n    double x = P->phi * 1.10265779;\n\n    while (max_iterations > 0) {\n        double x_squared = x * x + 1.0;\n        double sqrt_x_squared = sqrt(x_squared);\n        double A = P->A;\n        double log_term = log(sqrt_x_squared + x);\n        double delta = (((A - sqrt_x_squared) * x - log_term) - sin_phi * B) / (A - 2 * sqrt_x_squared);\n\n        x -= delta;\n\n        if (fabs(delta) < 1e-10) {\n            break;\n        }\n\n        max_iterations--;\n        if (max_iterations == 0) {\n            result.x = NAN;\n            result.y = NAN;\n            return result;\n        }\n    }\n\n    double final_x_squared = x * x + 1.0;\n    sqrt(final_x_squared); // Ensure no negative values for sqrt\n    result.x = x;\n    result.y = sqrt(final_x_squared);\n\n    return result;\n}",
        "baseline_code_stripped": "XY s_forward(LP lp,PJ_conflict56 *P)\n{\n  undefined8 extraout_RAX;\n  undefined8 uVar1;\n  undefined8 extraout_RAX_00;\n  undefined8 extraout_RDX;\n  undefined8 uVar2;\n  undefined8 extraout_RDX_00;\n  int iVar3;\n  double dVar4;\n  double p;\n  double dVar5;\n  double dVar6;\n  double dVar7;\n  double in_XMM1_Qa;\n  double dVar8;\n  double V;\n  double dVar9;\n  double r;\n  XY XVar10;\n  iVar3 = 10;\n  dVar4 = sin(in_XMM1_Qa);\n  dVar7 = P->B;\n  dVar8 = in_XMM1_Qa * 1.10265779;\n  while( true ) {\n    dVar5 = dVar8 * dVar8 + 1.0;\n    dVar9 = SQRT(dVar5);\n    if (dVar5 < 0.0) {\n      sqrt(dVar5);\n    }\n    dVar5 = P->A;\n    dVar6 = log(dVar9 + dVar8);\n    dVar5 = (((dVar5 - dVar9) * dVar8 - dVar6) - dVar4 * dVar7) / (P->A - (dVar9 + dVar9));\n    dVar8 = dVar8 - dVar5;\n    uVar1 = extraout_RAX;\n    uVar2 = extraout_RDX;\n    if ((double)((ulong)dVar5 & 0x7fffffffffffffff) < 1e-10) break;\n    iVar3 = iVar3 + -1;\n    if (iVar3 == 0) {\nLAB_0042e78a:\n      XVar10.y = (double)uVar2;\n      XVar10.x = (double)uVar1;\n      return XVar10;\n    }\n  }\n  dVar7 = dVar8 * dVar8 + 1.0;\n  if (dVar7 < 0.0) {\n    sqrt(dVar7);\n    uVar1 = extraout_RAX_00;\n    uVar2 = extraout_RDX_00;\n  }\n  goto LAB_0042e78a;\n}",
        "similarity_score_unixcoder": 0.7567535638809204,
        "similarity_score_baseline_stripped": 0.5989173650741577
    },
    {
        "func_name": "height",
        "normed_func_sha256": "5d1f9df4664c91cd46d2740d85bdb4ef00d7987182ef1c16a6786e34bc2c586d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl\njs::GetArrayBufferViewLengthAndData(JSObject *param_1,uint *param_2,bool *param_3,uchar **param_4)\n{\n  int iVar1;\n  uint uVar2;\n  if ((undefined **)**(int **)param_1 == &PTR_s_DataView_105064d0) {\n    uVar2 = *(uint *)(param_1 + 0x18);\n  }\n  else {\n    iVar1 = FUN_1005b010();\n    uVar2 = iVar1 * *(int *)(param_1 + 0x18);\n  }\n  *param_2 = uVar2;\n  if ((undefined **)**(int **)param_1 == &PTR_s_DataView_105064d0) {\n    *param_3 = false;\n    *param_4 = *(uchar **)(param_1 + (*(uint *)(*(int *)(param_1 + 4) + 8) >> 0x1b) * 8 + 0x10);\n    return;\n  }\n  *param_3 = (bool)((byte)(*(uint *)(*(int *)(param_1 + 0xc) + -0x10) >> 3) & 1);\n  *param_4 = *(uchar **)(param_1 + 0x28);\n  return;\n}\n\n Revised code:\nJS_FRIEND_API void js::GetArrayBufferViewLengthAndData(JSObject* obj,\n                                                       uint32_t* length,\n                                                       bool* isSharedMemory,\n                                                       uint8_t** data) {\n  MOZ_ASSERT(obj->is<ArrayBufferViewObject>());\n\n  *length = obj->is<DataViewObject>()\n                ? obj->as<DataViewObject>().byteLength()\n                : obj->as<TypedArrayObject>().byteLength();\n\n  if (obj->is<DataViewObject>()) {\n    DataViewObject& dv = obj->as<DataViewObject>();\n    *isSharedMemory = dv.isSharedMemory();\n    *data = static_cast<uint8_t*>(\n        dv.dataPointerEither().unwrap(/*safe - caller sees isShared flag*/));\n  } else {\n    TypedArrayObject& ta = obj->as<TypedArrayObject>();\n    *isSharedMemory = ta.isSharedMemory();\n    *data = static_cast<uint8_t*>(\n        ta.viewDataEither().unwrap(/*safe - caller sees isShared flag*/));\n  }\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_00107098(undefined4 param_1)\n{\n  ushort uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  iVar2 = lua_tointegerx(param_1,1,0);\n  if (iVar2 == 0) {\nLAB_001070f0:\n    lua_pushnil(param_1);\n    return 1;\n  }\n  iVar2 = iVar2 * 8;\n  uVar1 = *(ushort *)(varmem + iVar2 + 2);\n  if (2 < uVar1) {\n    if (uVar1 == 0x1d) {\n      uVar3 = char_height(*(undefined4 *)(varmem + iVar2 + 0x10 + 4),\n                          *(undefined4 *)(varmem + iVar2 + 0x10));\n      lua_pushinteger(param_1,uVar3);\n      return 1;\n    }\n    if (uVar1 != 3 && uVar1 != 0xf) goto LAB_001070f0;\n  }\n  lua_pushinteger(param_1,*(undefined4 *)(varmem + iVar2 + 0x24));\n  return 1;\n}\n\n Revised code:\nstatic int lua_nodelib_direct_getheight(lua_State * L)\n{\n    halfword n = lua_tointeger(L, 1);\n    if (n) {\n        halfword t = type(n);\n        if (t == hlist_node || t == vlist_node || t == rule_node) {\n            lua_pushinteger(L,height(n));\n        } else if (t == glyph_node) {\n            lua_pushinteger(L, char_height(font(n),character(n)));\n        } else if (t == unset_node || t == ins_node) {\n            lua_pushinteger(L,height(n));\n        } else {\n            lua_pushnil(L);\n        }\n    } else {\n        lua_pushnil(L);\n    }\n    return 1;\n}\n\n## Example:\n\n Input code:\nlonglong yaksuri_seqi_pack_resized_blkhindx_blklen_7_float\n                   (undefined4 param_1,undefined4 param_2,undefined4 param_3,int param_4,\n                   uint param_5,int param_6)\n{\n  int in_GS_OFFSET;\n  longlong lVar1;\n  if (param_6 == 0 && (uint)(10 < param_5) <= (uint)-param_6) {\n    lVar1 = (*(code *)((int)&__DT_PLTGOT + *(int *)(&DAT_02721414 + param_5 * 4)))\n                      (*(undefined4 *)(*(int *)(param_4 + 0x30) + 0x30),\n                       *(undefined4 *)(param_4 + 0x14),\n                       *(undefined4 *)(*(int *)(param_4 + 0x30) + 0x38),param_2);\n    return lVar1;\n  }\n  if (*(int *)(in_GS_OFFSET + 0x14) == *(int *)(in_GS_OFFSET + 0x14)) {\n    return (ulonglong)(-param_6 - (uint)(10 < param_5)) << 0x20;\n  }\n  __stack_chk_fail_local();\n}\n\n Revised code:\nint yaksuri_seqi_pack_resized_blkhindx_blklen_7_float(const void *inbuf, void *outbuf, uintptr_t count, yaksi_type_s * type, yaksa_op_t op)\n{\n    int rc = YAKSA_SUCCESS;\n    const char *restrict sbuf = (const char *) inbuf;\n    char *restrict dbuf = (char *) outbuf;\n    uintptr_t extent ATTRIBUTE((unused)) = type->extent;\n    \n    uintptr_t extent1 ATTRIBUTE((unused)) = type->extent;\n    \n    intptr_t count2 = type->u.resized.child->u.blkhindx.count;\n    intptr_t blocklength2 ATTRIBUTE((unused)) = type->u.resized.child->u.blkhindx.blocklength;\n    intptr_t *restrict array_of_displs2 = type->u.resized.child->u.blkhindx.array_of_displs;\n    uintptr_t extent2 ATTRIBUTE((unused)) = type->u.resized.child->extent;\n    \n    uintptr_t idx = 0;\n    switch (op) {\n        case YAKSA_OP__MIN:\n        {\n            for (intptr_t i = 0; i < count; i++) {\n                for (intptr_t j2 = 0; j2 < count2; j2++) {\n                    for (intptr_t k2 = 0; k2 < 7; k2++) {\n                        YAKSURI_SEQI_OP_MIN_FLOAT(float, *((const float *) (const void *) (sbuf + i * extent + array_of_displs2[j2] + k2 * sizeof(float))), *((float *) (void *) (dbuf + idx)));\n                        idx += sizeof(float);\n                    }\n                }\n            }\n            break;\n        }\n        \n        case YAKSA_OP__SUM:\n        {\n            for (intptr_t i = 0; i < count; i++) {\n                for (intptr_t j2 = 0; j2 < count2; j2++) {\n                    for (intptr_t k2 = 0; k2 < 7; k2++) {\n                        YAKSURI_SEQI_OP_SUM(*((const float *) (const void *) (sbuf + i * extent + array_of_displs2[j2] + k2 * sizeof(float))), *((float *) (void *) (dbuf + idx)));\n                        idx += sizeof(float);\n                    }\n                }\n            }\n            break;\n        }\n        \n        case YAKSA_OP__REPLACE:\n        {\n            for (intptr_t i = 0; i < count; i++) {\n                for (intptr_t j2 = 0; j2 < count2; j2++) {\n                    for (intptr_t k2 = 0; k2 < 7; k2++) {\n                        YAKSURI_SEQI_OP_REPLACE(*((const float *) (const void *) (sbuf + i * extent + array_of_displs2[j2] + k2 * sizeof(float))), *((float *) (void *) (dbuf + idx)));\n                        idx += sizeof(float);\n                    }\n                }\n            }\n            break;\n        }\n        \n        case YAKSA_OP__PROD:\n        {\n            for (intptr_t i = 0; i < count; i++) {\n                for (intptr_t j2 = 0; j2 < count2; j2++) {\n                    for (intptr_t k2 = 0; k2 < 7; k2++) {\n                        YAKSURI_SEQI_OP_PROD(*((const float *) (const void *) (sbuf + i * extent + array_of_displs2[j2] + k2 * sizeof(float))), *((float *) (void *) (dbuf + idx)));\n                        idx += sizeof(float);\n                    }\n                }\n            }\n            break;\n        }\n        \n        case YAKSA_OP__MAX:\n        {\n            for (intptr_t i = 0; i < count; i++) {\n                for (intptr_t j2 = 0; j2 < count2; j2++) {\n                    for (intptr_t k2 = 0; k2 < 7; k2++) {\n                        YAKSURI_SEQI_OP_MAX_FLOAT(float, *((const float *) (const void *) (sbuf + i * extent + array_of_displs2[j2] + k2 * sizeof(float))), *((float *) (void *) (dbuf + idx)));\n                        idx += sizeof(float);\n                    }\n                }\n            }\n            break;\n        }\n        \n        default:\n            break;\n    }\n    \n    return rc;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nulong WebCore::jsImageData_height(JSGlobalObject *param_1,long param_2,PropertyName param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(long *)(param_2 + 0x18) + 8);\n  if (-1 < (int)uVar1) {\n    return (long)(int)uVar1 | 0xfffe000000000000;\n  }\n  return (long)(double)(ulong)uVar1 + 0x2000000000000;\n}",
        "output": "```cpp\nunsigned long WebCore::jsImageData_height(JSGlobalObject* globalObject, long imageData, PropertyName propertyName) {\n    uint32_t height = *reinterpret_cast<uint32_t*>(*reinterpret_cast<long*>(imageData + 0x18) + 8);\n    if (static_cast<int32_t>(height) >= 0) {\n        return static_cast<unsigned long>(static_cast<int32_t>(height)) | 0xFFFE000000000000;\n    }\n    return static_cast<unsigned long>(static_cast<double>(static_cast<unsigned long>(height))) + 0x2000000000000;\n}\n```",
        "source_code": "constexpr int height() const { return m_height; }",
        "parsed_output": "pp\nunsigned long WebCore::jsImageData_height(JSGlobalObject* globalObject, long imageData, PropertyName propertyName) {\n    uint32_t height = *reinterpret_cast<uint32_t*>(*reinterpret_cast<long*>(imageData + 0x18) + 8);\n    if (static_cast<int32_t>(height) >= 0) {\n        return static_cast<unsigned long>(static_cast<int32_t>(height)) | 0xFFFE000000000000;\n    }\n    return static_cast<unsigned long>(static_cast<double>(static_cast<unsigned long>(height))) + 0x2000000000000;\n}",
        "baseline_code_stripped": "ulong WebCore::jsImageData_height(JSGlobalObject *param_1,long param_2,PropertyName param_3)\n{\n  uint uVar1;\n  uVar1 = *(uint *)(*(long *)(param_2 + 0x18) + 8);\n  if (-1 < (int)uVar1) {\n    return (long)(int)uVar1 | 0xfffe000000000000;\n  }\n  return (long)(double)(ulong)uVar1 + 0x2000000000000;\n}",
        "similarity_score_unixcoder": 0.5200611352920532,
        "similarity_score_baseline_stripped": 0.5196185111999512
    },
    {
        "func_name": "Sbk_QImageCaptureFunc_captureSession",
        "normed_func_sha256": "3a8a92028ce3d53e3ec4fb73e267768b0a429ed5dd2ebb4956cf541cd1f1b84c",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint * FUN_00081540(_object *param_1)\n{\n  int iVar1;\n  void *pvVar2;\n  int *piVar3;\n  iVar1 = Shiboken::Object::isValid(param_1);\n  if (iVar1 != 0) {\n    pvVar2 = (void *)Shiboken::Conversions::cppPointer\n                               (*(_typeobject **)(DAT_003d3278 + 0x10),(SbkObject *)param_1);\n    piVar3 = (int *)Shiboken::Conversions::copyToPython\n                              (*(_typeobject **)(DAT_003d3278 + 0x10),pvVar2);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      return piVar3;\n    }\n    if ((piVar3 != (int *)0x0) && (iVar1 = *piVar3, *piVar3 = iVar1 + -1, iVar1 + -1 == 0)) {\n      _Py_Dealloc(piVar3);\n    }\n  }\n  return (int *)0x0;\n}\n\n Revised code:\nstatic PyObject *Sbk_QAbstractTextDocumentLayout_PaintContext___copy__(PyObject *self)\n{\n    if (!Shiboken::Object::isValid(self))\n        return {};\n    auto &cppSelf = *reinterpret_cast< ::QAbstractTextDocumentLayout::PaintContext *>(Shiboken::Conversions::cppPointer(SbkPySide6_QtGuiTypes[SBK_QABSTRACTTEXTDOCUMENTLAYOUT_PAINTCONTEXT_IDX], reinterpret_cast<SbkObject *>(self)));\n    PyObject *pyResult = Shiboken::Conversions::copyToPython(SbkPySide6_QtGuiTypes[SBK_QABSTRACTTEXTDOCUMENTLAYOUT_PAINTCONTEXT_IDX], &cppSelf);\n    if (PyErr_Occurred() || !pyResult) {\n        Py_XDECREF(pyResult);\n        return {};\n    }\n    return pyResult;\n}\n\n## Example:\n\n Input code:\nlong * FUN_00144bb4(_object *param_1)\n{\n  char cVar1;\n  long lVar2;\n  void *pvVar3;\n  long *plVar4;\n  cVar1 = Shiboken::Object::isValid(param_1);\n  if (cVar1 != '\\0') {\n    Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_001ca260 + 0x108),(SbkObject *)param_1);\n    lVar2 = PyErr_Occurred();\n    if (lVar2 == 0) {\n      pvVar3 = (void *)QMediaCaptureSession::videoSink();\n      plVar4 = (long *)Shiboken::Conversions::pointerToPython\n                                 (*(_typeobject **)(DAT_001ca260 + 0x210),pvVar3);\n      Shiboken::Object::setParent(param_1,(_object *)plVar4);\n      lVar2 = PyErr_Occurred();\n      if (lVar2 == 0) {\n        return plVar4;\n      }\n      if ((plVar4 != (long *)0x0) && (lVar2 = *plVar4, *plVar4 = lVar2 + -1, lVar2 + -1 == 0)) {\n        _Py_Dealloc(plVar4);\n      }\n    }\n    else {\n      PyErr_Occurred();\n    }\n  }\n  return (long *)0x0;\n}\n\n Revised code:\nstatic PyObject *Sbk_QMediaCaptureSessionFunc_videoSink(PyObject *self)\n{\n    if (!Shiboken::Object::isValid(self))\n        return {};\n    auto cppSelf = reinterpret_cast< ::QMediaCaptureSession *>(Shiboken::Conversions::cppPointer(SbkPySide6_QtMultimediaTypes[SBK_QMEDIACAPTURESESSION_IDX], reinterpret_cast<SbkObject *>(self)));\n    SBK_UNUSED(cppSelf)\n    PyObject *pyResult{};\n    Shiboken::AutoDecRef errInfo{};\n    static const char *fullName = \"PySide6.QtMultimedia.QMediaCaptureSession.videoSink\";\n    SBK_UNUSED(fullName)\n\n    // Call function/method\n    {\n\n        if (!PyErr_Occurred()) {\n            // videoSink()const\n            QVideoSink * cppResult = const_cast<const ::QMediaCaptureSession *>(cppSelf)->videoSink();\n            pyResult = Shiboken::Conversions::pointerToPython(SbkPySide6_QtMultimediaTypes[SBK_QVIDEOSINK_IDX], cppResult);\n            Shiboken::Object::setParent(self, pyResult);\n        }\n    }\n\n    if (PyErr_Occurred() || !pyResult) {\n        Py_XDECREF(pyResult);\n        return {};\n    }\n    return pyResult;\n}\n\n## Example:\n\n Input code:\nint * FUN_00312e78(_object *param_1)\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *pvVar3;\n  int *piVar4;\n  iVar1 = Shiboken::Object::isValid(param_1);\n  if (iVar1 != 0) {\n    Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_00abc2bc + 0x35c),(SbkObject *)param_1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      uVar2 = PyEval_SaveThread();\n      pvVar3 = (void *)QGraphicsLayoutItem::parentLayoutItem();\n      PyEval_RestoreThread(uVar2);\n      piVar4 = (int *)Shiboken::Conversions::pointerToPython\n                                (*(SbkObjectType **)(DAT_00abc2bc + 0x35c),pvVar3);\n      Shiboken::Object::setParent(param_1,(_object *)piVar4);\n      iVar1 = PyErr_Occurred();\n      if (iVar1 == 0) {\n        return piVar4;\n      }\n      if ((piVar4 != (int *)0x0) && (iVar1 = *piVar4, *piVar4 = iVar1 + -1, iVar1 + -1 == 0)) {\n        (**(code **)(piVar4[1] + 0x18))(piVar4);\n        return (int *)0x0;\n      }\n    }\n    else {\n      PyErr_Occurred();\n    }\n  }\n  return (int *)0x0;\n}\n\n Revised code:\nstatic PyObject* Sbk_QGraphicsLayoutItemFunc_parentLayoutItem(PyObject* self)\n{\n    ::QGraphicsLayoutItem* cppSelf = 0;\n    SBK_UNUSED(cppSelf)\n    if (!Shiboken::Object::isValid(self))\n        return 0;\n    cppSelf = ((::QGraphicsLayoutItem*)Shiboken::Conversions::cppPointer(SbkPySide_QtGuiTypes[SBK_QGRAPHICSLAYOUTITEM_IDX], (SbkObject*)self));\n    PyObject* pyResult = 0;\n\n    // Call function/method\n    {\n\n        if (!PyErr_Occurred()) {\n            // parentLayoutItem()const\n            PyThreadState* _save = PyEval_SaveThread(); // Py_BEGIN_ALLOW_THREADS\n            QGraphicsLayoutItem * cppResult = const_cast<const ::QGraphicsLayoutItem*>(cppSelf)->parentLayoutItem();\n            PyEval_RestoreThread(_save); // Py_END_ALLOW_THREADS\n            pyResult = Shiboken::Conversions::pointerToPython((SbkObjectType*)SbkPySide_QtGuiTypes[SBK_QGRAPHICSLAYOUTITEM_IDX], cppResult);\n            Shiboken::Object::setParent(self, pyResult);\n        }\n    }\n\n    if (PyErr_Occurred() || !pyResult) {\n        Py_XDECREF(pyResult);\n        return 0;\n    }\n    return pyResult;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint * FUN_00043be8(_object *param_1)\n{\n  int iVar1;\n  void *pvVar2;\n  int *piVar3;\n  iVar1 = Shiboken::Object::isValid(param_1);\n  if (iVar1 != 0) {\n    Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_000a4c00 + 0x74),(SbkObject *)param_1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      pvVar2 = (void *)QImageCapture::captureSession();\n      piVar3 = (int *)Shiboken::Conversions::pointerToPython\n                                (*(_typeobject **)(DAT_000a4c00 + 0x84),pvVar2);\n      Shiboken::Object::setParent(param_1,(_object *)piVar3);\n      iVar1 = PyErr_Occurred();\n      if (iVar1 == 0) {\n        return piVar3;\n      }\n      if ((piVar3 != (int *)0x0) && (iVar1 = *piVar3, *piVar3 = iVar1 + -1, iVar1 + -1 == 0)) {\n        _Py_Dealloc(piVar3);\n      }\n    }\n    else {\n      PyErr_Occurred();\n    }\n  }\n  return (int *)0x0;\n}",
        "output": "```c\nstatic PyObject *Sbk_QImageCaptureFunc_captureSession(PyObject *self)\n{\n    if (!Shiboken::Object::isValid(self))\n        return {};\n    auto cppSelf = reinterpret_cast< ::QImageCapture *>(Shiboken::Conversions::cppPointer(SbkPySide6_QtMultimediaTypes[SBK_QIMAGECAPTURE_IDX], reinterpret_cast<SbkObject *>(self)));\n    PyObject *pyResult = nullptr;\n\n    // Call function/method\n    {\n        if (!PyErr_Occurred()) {\n            // captureSession()const\n            QMediaCaptureSession *cppResult = const_cast<const ::QImageCapture *>(cppSelf)->captureSession();\n            pyResult = Shiboken::Conversions::pointerToPython(SbkPySide6_QtMultimediaTypes[SBK_QMEDIACAPTURESESSION_IDX], cppResult);\n            Shiboken::Object::setParent(self, pyResult);\n        }\n    }\n\n    if (PyErr_Occurred() || !pyResult) {\n        Py_XDECREF(pyResult);\n        return {};\n    }\n    return pyResult;\n}\n```",
        "source_code": "static PyObject *Sbk_QImageCaptureFunc_captureSession(PyObject *self)\n{\n    if (!Shiboken::Object::isValid(self))\n        return {};\n    auto *cppSelf = reinterpret_cast< ::QImageCapture *>(Shiboken::Conversions::cppPointer(SbkPySide6_QtMultimediaTypes[SBK_QIMAGECAPTURE_IDX], reinterpret_cast<SbkObject *>(self)));\n    SBK_UNUSED(cppSelf)\n    PyObject *pyResult{};\n\n    // Call function/method\n    {\n\n        if (!PyErr_Occurred()) {\n            // captureSession()const\n            QMediaCaptureSession * cppResult = const_cast<const ::QImageCapture *>(cppSelf)->captureSession();\n            pyResult = Shiboken::Conversions::pointerToPython(SbkPySide6_QtMultimediaTypes[SBK_QMEDIACAPTURESESSION_IDX], cppResult);\n            // Ownership transferences (return value heuristics).\n            Shiboken::Object::setParent(self, pyResult);\n        }\n    }\n\n    if (PyErr_Occurred() || !pyResult) {\n        Py_XDECREF(pyResult);\n        return {};\n    }\n    return pyResult;\n}",
        "parsed_output": "static PyObject *Sbk_QImageCaptureFunc_captureSession(PyObject *self)\n{\n    if (!Shiboken::Object::isValid(self))\n        return {};\n    auto cppSelf = reinterpret_cast< ::QImageCapture *>(Shiboken::Conversions::cppPointer(SbkPySide6_QtMultimediaTypes[SBK_QIMAGECAPTURE_IDX], reinterpret_cast<SbkObject *>(self)));\n    PyObject *pyResult = nullptr;\n\n    // Call function/method\n    {\n        if (!PyErr_Occurred()) {\n            // captureSession()const\n            QMediaCaptureSession *cppResult = const_cast<const ::QImageCapture *>(cppSelf)->captureSession();\n            pyResult = Shiboken::Conversions::pointerToPython(SbkPySide6_QtMultimediaTypes[SBK_QMEDIACAPTURESESSION_IDX], cppResult);\n            Shiboken::Object::setParent(self, pyResult);\n        }\n    }\n\n    if (PyErr_Occurred() || !pyResult) {\n        Py_XDECREF(pyResult);\n        return {};\n    }\n    return pyResult;\n}",
        "baseline_code_stripped": "int * FUN_00043be8(_object *param_1)\n{\n  int iVar1;\n  void *pvVar2;\n  int *piVar3;\n  iVar1 = Shiboken::Object::isValid(param_1);\n  if (iVar1 != 0) {\n    Shiboken::Conversions::cppPointer(*(_typeobject **)(DAT_000a4c00 + 0x74),(SbkObject *)param_1);\n    iVar1 = PyErr_Occurred();\n    if (iVar1 == 0) {\n      pvVar2 = (void *)QImageCapture::captureSession();\n      piVar3 = (int *)Shiboken::Conversions::pointerToPython\n                                (*(_typeobject **)(DAT_000a4c00 + 0x84),pvVar2);\n      Shiboken::Object::setParent(param_1,(_object *)piVar3);\n      iVar1 = PyErr_Occurred();\n      if (iVar1 == 0) {\n        return piVar3;\n      }\n      if ((piVar3 != (int *)0x0) && (iVar1 = *piVar3, *piVar3 = iVar1 + -1, iVar1 + -1 == 0)) {\n        _Py_Dealloc(piVar3);\n      }\n    }\n    else {\n      PyErr_Occurred();\n    }\n  }\n  return (int *)0x0;\n}",
        "similarity_score_unixcoder": 0.9572881460189819,
        "similarity_score_baseline_stripped": 0.6691700220108032
    },
    {
        "func_name": "WLog_JournaldAppender_Open",
        "normed_func_sha256": "1dd3e8d936cbafc5f6816d19b94ec94c1cf2886c2b6ac4bc194ccf21c23464fc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_00111b52(long param_1,long param_2)\n{\n  undefined8 uVar1;\n  if (param_2 != 0) {\n    uVar1 = FUN_00105760(*(undefined8 *)(param_1 + 0x18));\n    return uVar1;\n  }\n  return 0x57;\n}\n\n Revised code:\nstatic WERROR local_delete_value(TALLOC_CTX *mem_ctx, struct registry_key *key,\n\t\t\t\t const char *name)\n{\n\tconst struct local_key *local = (const struct local_key *)key;\n\n\tif (name == NULL) {\n\t\treturn WERR_INVALID_PARAMETER;\n\t}\n\n\treturn hive_key_del_value(mem_ctx, local->hive_key, name);\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_00017770(int param_1)\n{\n  undefined4 uVar1;\n  if ((*(int *)(param_1 + 0x50) != 0) && (*(int *)(param_1 + 0x80) != 0)) {\n    uVar1 = FUN_00016cd0();\n    return uVar1;\n  }\n  return 0;\n}\n\n Revised code:\nbool AAAHandler::received(Message& msg)\n{\n    if (m_query.null() || m_account.null())\n\treturn false;\n    String query(m_query);\n    String account(m_account);\n    msg.replaceParams(query,true);\n    msg.replaceParams(account,true);\n    if (query.null() || account.null())\n\treturn false;\n\n    switch (m_type)\n    {\n\tcase Regist:\n\t{\n\t    if (!msg.getBoolValue(YSTRING(\"register_register\"),true))\n\t\treturn false;\n\t    if (s_critical)\n\t\treturn failure(&msg);\n\t    Message m(\"database\");\n\t    prepareQuery(m,account,query,true);\n\t    if (Engine::dispatch(m))\n\t\tif (m.getIntValue(\"affected\") >= 1 || m.getIntValue(\"rows\") >=1)\n\t\t    return true;\n\t    return false;\n\t}\n\tbreak;\n\tcase Auth:\n\t{\n\t    if (!msg.getBoolValue(YSTRING(\"auth_register\"),true))\n\t\treturn false;\n\t    Message m(\"database\");\n\t    prepareQuery(m,account,query,true);\n\t    if (Engine::dispatch(m))\n\t\tif (m.getIntValue(\"rows\") >=1)\n\t\t{\n\t\t    Array* a = static_cast<Array*>(m.userObject(YATOM(\"Array\")));\n\t\t    if (!copyParams(msg,a,m_result)) {\n\t\t\tDebug(&module,DebugWarn,\"Misconfigured result column for '%s'\",name().c_str());\n\t\t\tmsg.setParam(\"error\",\"failure\");\n\t\t\treturn false;\n\t\t    }\n\t\t    return true;\n\t\t}\n\t    return false;\n\t}\n\tbreak;\n\tcase PreRoute:\n\t{\n\t    if (!msg.getBoolValue(YSTRING(\"preroute_register\"),true))\n\t\treturn false;\n\t    if (s_critical)\n\t\treturn failure(&msg);\n\t    Message m(\"database\");\n\t    prepareQuery(m,account,query,true);\n\t    if (Engine::dispatch(m))\n\t\tif (m.getIntValue(\"rows\") >=1)\n\t\t{\n\t\t    Array* a = static_cast<Array*>(m.userObject(YATOM(\"Array\")));\n\t\t    copyParams(msg,a,m_result);\n\t\t}\n\t    return false;\n\t}\n\tbreak;\n\tcase Route:\n\t{\n\t    if (!msg.getBoolValue(YSTRING(\"route_register\"),true))\n\t\treturn false;\n\t    if (s_critical)\n\t\treturn failure(&msg);\n\t    Message m(\"database\");\n\t    prepareQuery(m,account,query,true);\n\t    if (Engine::dispatch(m))\n\t\tif (m.getIntValue(\"rows\") >=1)\n\t\t{\n\t\t    Array* a = static_cast<Array*>(m.userObject(YATOM(\"Array\")));\n\t\t    copyParams(msg,a,m_result);\n\t\t    if (msg.retValue().null())\n\t\t    {\n\t\t\t// we know about the user but has no address of record\n\t\t\tif (s_errOffline) {\n\t\t\t    msg.retValue() = \"-\";\n\t\t\t    msg.setParam(\"error\",\"offline\");\n\t\t\t    msg.setParam(\"reason\",\"Offline\");\n\t\t\t}\n\t\t\treturn false;\n\t\t    }\n\t\t    return true;\n\t\t}\n\t    return false;\n\t}\n\tbreak;\n\tcase UnRegist:\n\t{\n\t    if (!msg.getBoolValue(YSTRING(\"register_register\"),true))\n\t\treturn false;\n\t    // no error check needed on unregister - we return false\n\t    Message m(\"database\");\n\t    prepareQuery(m,account,query,true);\n\t    // we don't enqueue the message because we must assure ourselves that this message is processed synchronously\n\t    Engine::dispatch(m);\n\t}\n\tbreak;\n\tcase Timer:\n\t{\n\t    u_int32_t t = msg.msgTime().sec();\n\t    if (t >= s_nextTime)\n\t\t// we expire users every 30 seconds\n\t\ts_nextTime = t + s_expire;\n\t    else\n\t\treturn false;\n\t    // no error check needed - we enqueue the query and return false\n\t    Message* m = new Message(\"database\");\n\t    prepareQuery(*m,account,query,false);\n\t    Engine::enqueue(m);\n\t}\n\tbreak;\n    }\n    return false;\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_0059cc10(long param_1,long param_2)\n{\n  undefined8 uVar1;\n  if (*(int *)(param_1 + 0x18) == *(int *)(param_2 + 0x18)) {\n    uVar1 = FUN_00681c20(param_1,param_2,1);\n    return uVar1;\n  }\n  return 0;\n}\n\n Revised code:\nbool lldb_private::operator==(const Declaration &lhs, const Declaration &rhs) {\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n  if (lhs.GetColumn() == rhs.GetColumn())\n    if (lhs.GetLine() == rhs.GetLine())\n      return lhs.GetFile() == rhs.GetFile();\n#else\n  if (lhs.GetLine() == rhs.GetLine())\n    return FileSpec::Equal(lhs.GetFile(), rhs.GetFile(), true);\n#endif\n  return false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_0016bd00(long param_1,long param_2)\n{\n  undefined8 uVar1;\n  if ((param_1 != 0) && (param_2 != 0)) {\n    if (*(long *)(param_2 + 0xa8) != 0) {\n      return 1;\n    }\n    uVar1 = FUN_0016bc90(param_2);\n    return uVar1;\n  }\n  return 0;\n}",
        "output": "static bool validate_and_process(const Object *obj1, const Object *obj2) {\n    if (obj1 == nullptr || obj2 == nullptr) {\n        return false;\n    }\n\n    if (obj2->field_a8 != 0) {\n        return true;\n    }\n\n    return process_object(obj2);\n}",
        "source_code": "static BOOL WLog_JournaldAppender_Open(wLog* log, wLogAppender* appender)\n{\n\tint fd;\n\twLogJournaldAppender *journaldAppender;\n\n\tif (!log || !appender)\n\t\treturn FALSE;\n\n\tjournaldAppender = (wLogJournaldAppender*)appender;\n\tif (journaldAppender->stream)\n\t\treturn TRUE;\n\n\tfd = sd_journal_stream_fd(journaldAppender->identifier, LOG_INFO, 1);\n\tif (fd < 0)\n\t\treturn FALSE;\n\n\tjournaldAppender->stream = fdopen(fd, \"w\");\n\tif (!journaldAppender->stream)\n\t{\n\t\tclose(fd);\n\t\treturn FALSE;\n\t}\n\n\tsetbuffer(journaldAppender->stream, NULL, 0);\n\treturn TRUE;\n}",
        "parsed_output": "static bool validate_and_process(const Object *obj1, const Object *obj2) {\n    if (obj1 == nullptr || obj2 == nullptr) {\n        return false;\n    }\n\n    if (obj2->field_a8 != 0) {\n        return true;\n    }\n\n    return process_object(obj2);\n}",
        "baseline_code_stripped": "undefined8 FUN_0016bd00(long param_1,long param_2)\n{\n  undefined8 uVar1;\n  if ((param_1 != 0) && (param_2 != 0)) {\n    if (*(long *)(param_2 + 0xa8) != 0) {\n      return 1;\n    }\n    uVar1 = FUN_0016bc90(param_2);\n    return uVar1;\n  }\n  return 0;\n}",
        "similarity_score_unixcoder": 0.3238237798213959,
        "similarity_score_baseline_stripped": 0.39779341220855713
    },
    {
        "func_name": "getOwnerMapEntry",
        "normed_func_sha256": "3c8d100d28598420d1b1dc27264508985fadea02aec7b74919849025848d959e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_004809b0(int *param_1)\n{\n  char cVar1;\n  undefined4 uVar2;\n  cVar1 = FUN_00481f10(param_1,&DAT_cccccccc,&DAT_cccccccc);\n  if (cVar1 == '\\0') {\n    FUN_0049c620(s_Invalid_style_006f3050,param_1,0);\n    do {\n    } while( true );\n  }\n  if ((param_1 != (int *)0x0) && (*param_1 != 0)) {\n    uVar2 = 0;\n    while (cVar1 = FUN_004822c0(param_1,uVar2), cVar1 != -1) {\n      uVar2 = FUN_00482390(cVar1,uVar2);\n    }\n  }\n  __RTC_CheckEsp();\n  return;\n}\n\n Revised code:\nuint16_t _lv_style_get_mem_size(const lv_style_t * style)\n{\n    LV_ASSERT_STYLE(style);\n\n    if(style == NULL || style->map == NULL) return 0;\n\n    size_t i = 0;\n    uint8_t prop_id;\n    while((prop_id = get_style_prop_id(style, i)) != _LV_STYLE_CLOSING_PROP) {\n        i = get_next_prop_index(prop_id, i);\n    }\n\n    return i + sizeof(lv_style_property_t);\n}\n\n## Example:\n\n Input code:\nvoid FUN_08072740(char *param_1,undefined param_2)\n{\n  int iVar1;\n  undefined *local_10;\n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    while (iVar1 = FUN_08072620(param_1,&local_10), iVar1 == 0) {\n      *local_10 = param_2;\n      param_1 = local_10 + 1;\n      if (param_1 == (char *)0x0) {\n        return;\n      }\n      if (*param_1 == '\\0') {\n        return;\n      }\n    }\n  }\n  return;\n}\n\n Revised code:\nvoid\nutf8_normalize (char *string, char replacement)\n{\n    char *error;\n    \n    while (string && string[0])\n    {\n        if (utf8_is_valid (string, &error))\n            return;\n        error[0] = replacement;\n        string = error + 1;\n    }\n}\n\n## Example:\n\n Input code:\nint FUN_0021eda0(undefined8 param_1)\n{\n  char cVar1;\n  int iVar2;\n  undefined8 local_20;\n  iVar2 = 0;\n  local_20 = 3;\n  while( true ) {\n    cVar1 = FUN_0021e3d0(param_1,&local_20);\n    if (cVar1 == '\\0') break;\n    iVar2 = iVar2 + 1;\n    FUN_0021eb30(param_1,local_20);\n  }\n  return iVar2;\n}\n\n Revised code:\nint32_t RBBITableBuilder::removeDuplicateStates() {\n    IntPair dupls = {3, 0};\n    int32_t numStatesRemoved = 0;\n\n    while (findDuplicateState(&dupls)) {\n        // printf(\"Removing duplicate states (%d, %d)\\n\", dupls.first, dupls.second);\n        removeState(dupls);\n        ++numStatesRemoved;\n    }\n    return numStatesRemoved;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_1025e6a0(char *param_1)\n{\n  int iVar1;\n  undefined4 *local_c;\n  local_c = &DAT_10410960;\n  while ((local_c != (undefined4 *)\"XML-1.00\" &&\n         (iVar1 = strcmp(param_1,(char *)local_c[1]), iVar1 != 0))) {\n    local_c = local_c + 2;\n  }\n  __RTC_CheckEsp();\n  return;\n}",
        "output": "```c\nvoid find_xml_version(const char *version) {\n    const char *current = \"XML-1.00\";\n    const uint32_t *entry = &DAT_10410960;\n\n    while (entry != (const uint32_t *)current && strcmp(version, (const char *)entry[1]) != 0) {\n        entry += 2;\n    }\n}\n```",
        "source_code": "static inline const OwnerMapEntry *getOwnerMapEntry(const char *name)\n{\n    for (const OwnerMapEntry &entry : ownerMap) {\n        if (strcmp(name, entry.name) == 0) {\n            return &entry;\n        }\n    }\n    return nullptr;\n}",
        "parsed_output": "void find_xml_version(const char *version) {\n    const char *current = \"XML-1.00\";\n    const uint32_t *entry = &DAT_10410960;\n\n    while (entry != (const uint32_t *)current && strcmp(version, (const char *)entry[1]) != 0) {\n        entry += 2;\n    }\n}",
        "baseline_code_stripped": "void FUN_1025e6a0(char *param_1)\n{\n  int iVar1;\n  undefined4 *local_c;\n  local_c = &DAT_10410960;\n  while ((local_c != (undefined4 *)\"XML-1.00\" &&\n         (iVar1 = strcmp(param_1,(char *)local_c[1]), iVar1 != 0))) {\n    local_c = local_c + 2;\n  }\n  __RTC_CheckEsp();\n  return;\n}",
        "similarity_score_unixcoder": 0.5028805732727051,
        "similarity_score_baseline_stripped": 0.3582296073436737
    },
    {
        "func_name": "gettime",
        "normed_func_sha256": "412011dd2933e049b60bbbb16f239d8d0e688a37ee59997a2060d613ff13fdec",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_00182640(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uStack_38;\n  uVar1 = FUN_00112100();\n  FUN_00113560(param_1,uVar1);\n  uVar1 = FUN_001122a0();\n  uVar2 = FUN_00114740();\n  uVar1 = FUN_00113560(uVar1,uVar2);\n  FUN_00111e40(uVar1,param_2,param_3,param_4,uStack_38);\n  return;\n}\n\n Revised code:\nvoid our_dialog_add_to_content_area(GtkWindow *dlg, GtkWidget *w,\n                                    bool expand, bool fill, guint padding)\n{\n#if GTK_CHECK_VERSION(3,0,0)\n    /* GtkWindow is a GtkBin, hence contains exactly one child, which\n     * here we always expect to be a vbox */\n    GtkBox *vbox = GTK_BOX(gtk_bin_get_child(GTK_BIN(dlg)));\n\n    gtk_box_pack_start(vbox, w, expand, fill, padding);\n#else\n    gtk_box_pack_start(\n        GTK_BOX(gtk_dialog_get_content_area(GTK_DIALOG(dlg))),\n        w, expand, fill, padding);\n#endif\n}\n\n## Example:\n\n Input code:\nint FUN_0005b630(undefined4 param_1,int param_2)\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  int iVar5;\n  int in_FS_OFFSET;\n  undefined4 uStack_68;\n  undefined4 uStack_64;\n  undefined4 uStack_60;\n  undefined4 uStack_5c;\n  undefined4 uStack_58;\n  undefined4 uStack_54;\n  int iStack_50;\n  undefined4 uStack_4c;\n  int iStack_48;\n  undefined4 uStack_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  int iStack_38;\n  undefined4 local_24;\n  undefined4 *local_18;\n  iVar3 = param_2;\n  local_18 = &param_1;\n  iStack_38 = param_2 * 2;\n  local_24 = param_1;\n  uStack_3c = 0;\n  uStack_40 = *(undefined4 *)(*(int *)(*(int *)(in_FS_OFFSET + 0x18) + 0x30) + 0x18);\n  uStack_44 = 0x5b663;\n  uVar1 = FUN_0003cc88();\n  iStack_48 = iVar3;\n  iStack_50 = 0x5b66f;\n  uStack_4c = uVar1;\n  iVar2 = FUN_0003c4c8();\n  puVar4 = &uStack_44;\n  iVar5 = iVar2;\n  if (iVar2 != -1) {\n    iStack_48 = 0;\n    uStack_4c = 0;\n    iStack_50 = iVar3;\n    uStack_54 = local_24;\n    uStack_58 = 0xffffffff;\n    uStack_60 = 0;\n    puVar4 = &uStack_64;\n    uStack_64 = 0;\n    uStack_68 = 0x5b68c;\n    uStack_5c = uVar1;\n    iVar3 = FUN_0003c098();\n    if (iVar3 == 0) {\n      iVar5 = -1;\n      FUN_0003c520(iVar2);\n      puVar4 = &uStack_68;\n    }\n  }\n  *(undefined4 *)((int)puVar4 + -8) = uVar1;\n  *(undefined4 *)((int)puVar4 + -0xc) = 0;\n  *(undefined4 *)((int)puVar4 + -0x10) =\n       *(undefined4 *)(*(int *)(*(int *)(in_FS_OFFSET + 0x18) + 0x30) + 0x18);\n  *(undefined4 *)((int)puVar4 + -0x14) = 0x5b6a7;\n  FUN_0003cc98();\n  return iVar5;\n}\n\n Revised code:\nHANDLE WINAPI FindFirstVolumeA(LPSTR volume, DWORD len)\n{\n    WCHAR *buffer = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );\n    HANDLE handle = FindFirstVolumeW( buffer, len );\n\n    if (handle != INVALID_HANDLE_VALUE)\n    {\n        if (!WideCharToMultiByte( CP_ACP, 0, buffer, -1, volume, len, NULL, NULL ))\n        {\n            FindVolumeClose( handle );\n            handle = INVALID_HANDLE_VALUE;\n        }\n    }\n    HeapFree( GetProcessHeap(), 0, buffer );\n    return handle;\n}\n\n## Example:\n\n Input code:\nvoid FUN_0019a7ec(int param_1,undefined4 param_2)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 *puVar3;\n  undefined4 uVar4;\n  uVar1 = FUN_0033d2c8();\n  FUN_000dbfac(uVar1,*(undefined4 *)(param_1 + 0x20));\n  uVar2 = FUN_00207d64();\n  puVar3 = (undefined4 *)FUN_000c5f44();\n  uVar4 = *puVar3;\n  *puVar3 = uVar1;\n  FUN_00255268(param_2);\n  *puVar3 = uVar4;\n  FUN_00207d80(uVar2);\n  FUN_000dbfac(uVar1,0);\n  return;\n}\n\n Revised code:\nstatic void\nmi_print_breakpoint_for_event (struct mi_interp *mi, breakpoint *bp)\n{\n  ui_out *mi_uiout = interp_ui_out (mi);\n\n  /* We want the output from print_breakpoint to go to\n     mi->event_channel.  One approach would be to just call\n     print_breakpoint, and then use mi_out_put to send the current\n     content of mi_uiout into mi->event_channel.  However, that will\n     break if anything is output to mi_uiout prior to calling the\n     breakpoint_created notifications.  So, we use\n     ui_out_redirect.  */\n  mi_uiout->redirect (mi->event_channel);\n\n  TRY\n    {\n      scoped_restore restore_uiout\n\t= make_scoped_restore (&current_uiout, mi_uiout);\n\n      print_breakpoint (bp);\n    }\n  CATCH (ex, RETURN_MASK_ALL)\n    {\n      exception_print (gdb_stderr, ex);\n    }\n  END_CATCH\n\n  mi_uiout->redirect (NULL);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_0001bd34(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 uVar3;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  uStack_10 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  iVar1 = FUN_00029940(1,&uStack_10);\n  if (iVar1 < 0) {\n    puVar2 = (undefined4 *)FUN_000283d6(iVar1);\n    uVar3 = FUN_0002831c(*puVar2);\n    FUN_00017ef8(3,\"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\",uVar3);\n    uStack_10 = 0;\n  }\n  return uStack_10;\n}",
        "output": "```c\nint get_monotonic_time(struct timespec *ts)\n{\n    int result = clock_gettime(CLOCK_MONOTONIC, ts);\n    if (result < 0) {\n        const char *error_message = strerror(errno);\n        fprintf(stderr, \"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\", error_message);\n        ts->tv_sec = 0;\n        ts->tv_nsec = 0;\n    }\n    return result;\n}\n```",
        "source_code": "static time_t gettime(void)\n{\n    struct timespec ts;\n    int ret;\n\n    ret = clock_gettime(CLOCK_MONOTONIC, &ts);\n    if (ret < 0) {\n        ERROR(\"clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\", strerror(errno));\n        return 0;\n    }\n\n    return ts.tv_sec;\n}",
        "parsed_output": "int get_monotonic_time(struct timespec *ts)\n{\n    int result = clock_gettime(CLOCK_MONOTONIC, ts);\n    if (result < 0) {\n        const char *error_message = strerror(errno);\n        fprintf(stderr, \"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\", error_message);\n        ts->tv_sec = 0;\n        ts->tv_nsec = 0;\n    }\n    return result;\n}",
        "baseline_code_stripped": "undefined4 FUN_0001bd34(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 uVar3;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  uStack_10 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  iVar1 = FUN_00029940(1,&uStack_10);\n  if (iVar1 < 0) {\n    puVar2 = (undefined4 *)FUN_000283d6(iVar1);\n    uVar3 = FUN_0002831c(*puVar2);\n    FUN_00017ef8(3,\"<3>fs_mgr: clock_gettime(CLOCK_MONOTONIC) failed: %s\\n\",uVar3);\n    uStack_10 = 0;\n  }\n  return uStack_10;\n}",
        "similarity_score_unixcoder": 0.8757668137550354,
        "similarity_score_baseline_stripped": 0.43212634325027466
    },
    {
        "func_name": "get_origcol_name",
        "normed_func_sha256": "d8241c3295ea1b4e9eb02519639dbfe48eda6c6a7a10d246126bbda521ff0ede",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_18003a490(longlong param_1,int *param_2,undefined8 param_3,undefined8 param_4)\n{\n  ulonglong *puVar1;\n  undefined8 uVar2;\n  puVar1 = (ulonglong *)FUN_1800384d0(0x20);\n  if (puVar1 == (ulonglong *)0x0) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    FUN_180039e40(puVar1);\n    if (param_2 == (int *)0x0) {\n      FUN_180039ed0(puVar1,0x4000,param_3,param_4);\n    }\n    else {\n      FUN_180039ed0(puVar1,(longlong)*param_2,param_3,param_4);\n    }\n    *(ulonglong **)(param_1 + 0x18) = puVar1;\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n Revised code:\nstatic int\nsb_rdahead_setup( Sockbuf_IO_Desc *sbiod, void *arg )\n{\n\tSockbuf_Buf\t\t*p;\n\n\tassert( sbiod != NULL );\n\n\tp = LBER_MALLOC( sizeof( *p ) );\n\tif ( p == NULL )\n\t\treturn -1;\n\tber_pvt_sb_buf_init( p );\n\tif ( arg == NULL )\n\t\tber_pvt_sb_grow_buffer( p, DEFAULT_READAHEAD );\n\telse\n\t\tber_pvt_sb_grow_buffer( p, *((int *)arg) );\n\tsbiod->sbiod_pvt = p;\n   return 0;\n}\n\n## Example:\n\n Input code:\nundefined8\nFUN_1801f0f70(longlong param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n             undefined8 *param_5)\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  longlong lVar4;\n  void *local_18 [2];\n  puVar2 = param_5;\n  if (param_5 != (undefined8 *)0x0) {\n    *param_5 = 0;\n  }\n  param_5 = (undefined8 *)0x0;\n  FUN_1801f0c30(param_1,local_18,param_3,param_4,&param_5);\n  if (local_18[0] == (void *)0x0) {\n    lVar4 = (**(code **)(**(longlong **)(param_1 + 0x30) + 0x20))\n                      (*(longlong **)(param_1 + 0x30),param_5);\n    uVar1 = *(undefined8 *)(lVar4 + 8);\n    uVar3 = FUN_1801fdfc0(uVar1,param_2);\n    FUN_1801ea5d0(uVar3,FUN_1801f1030,*(undefined8 *)(param_1 + 0x30),param_5);\n    if (puVar2 != (undefined8 *)0x0) {\n      *puVar2 = uVar1;\n    }\n  }\n  else {\n    uVar3 = FUN_1801ea570(local_18);\n  }\n  free(local_18[0]);\n  return uVar3;\n}\n\n Revised code:\nIterator* TableCache::NewIterator(const ReadOptions& options,\n                                  uint64_t file_number,\n                                  uint64_t file_size,\n                                  Table** tableptr) {\n  if (tableptr != nullptr) {\n    *tableptr = nullptr;\n  }\n\n  Cache::Handle* handle = nullptr;\n  Status s = FindTable(file_number, file_size, &handle);\n  if (!s.ok()) {\n    return NewErrorIterator(s);\n  }\n\n  Table* table =\n    reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table.get();\n  Iterator* result = table->NewIterator(options);\n  result->RegisterCleanup(&UnrefEntry, cache_.get(), handle);\n  if (tableptr != nullptr) {\n    *tableptr = table;\n  }\n  return result;\n}\n\n## Example:\n\n Input code:\nundefined8\nFUN_00411b30(long param_1,undefined8 param_2,ulong param_3,int param_4,undefined8 *param_5)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  puVar1 = (undefined8 *)Xalloc(param_3 + 0x18);\n  if (puVar1 != (undefined8 *)0x0) {\n    *puVar1 = *param_5;\n    uVar2 = param_5[1];\n    puVar1[2] = puVar1 + 3;\n    puVar1[1] = uVar2;\n    memcpy(puVar1 + 3,(void *)param_5[2],param_3);\n    if (param_4 != 0) {\n      if (*(int *)(puVar1 + 1) == 0x10) {\n        FUN_00413cb0(puVar1[2],param_3 >> 1);\n      }\n      else if (*(int *)(puVar1 + 1) == 0x20) {\n        FUN_00413b60(puVar1[2],param_3 >> 2);\n      }\n    }\n    uVar2 = FUN_004142c0(param_1,*(undefined8 *)(param_1 + 0x380),param_2,(int)param_3 + 0x18,3,\n                         puVar1);\n    return uVar2;\n  }\n  return 0;\n}\n\n Revised code:\nstatic Bool\npropTagStoreData(server, tid, dlen, swapit, ptdp)\n    XServerPtr\tserver;\n    XID         tid;\n    unsigned long dlen;\n    Bool\tswapit;\n    PropertyTagDataPtr ptdp;\n{\n    PropertyTagDataPtr new;\n\n    new = (PropertyTagDataPtr) xalloc(dlen + sizeof(PropertyTagDataRec));\n    if (!new)\n\treturn FALSE;\n    *new = *ptdp;\n    new->data = (pointer) (new + 1);\n    memcpy((char *) new->data, (char *) ptdp->data, dlen);\n    /* save data in proxy format */\n    if (swapit) {\n\tswitch (new->format) {\n\tcase 32:\n\t    SwapLongs((CARD32 *) new->data, dlen >> 2);\n\t    break;\n\tcase 16:\n\t    SwapShorts((short *) new->data, dlen >> 1);\n\t    break;\n\t}\n    }\n    return TagStoreDataNC(server, server->prop_cache, tid,\n\t\t\t  (dlen + sizeof(PropertyTagDataRec)),\n\t\t\t  LbxTagTypeProperty, new);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined * FUN_180025924(longlong param_1,int param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 *puVar1;\n  uint uVar2;\n  undefined *puVar3;\n  undefined *puVar4;\n  uVar2 = abs(param_2);\n  if ((((*(char *)(param_1 + 0x7c8) == '\\0') || (*(char *)(param_1 + 0x7ca) == '\\0')) ||\n      (puVar1 = *(undefined8 **)(*(longlong *)(param_1 + 0x8e0) + (longlong)(int)uVar2 * 8),\n      puVar1 == (undefined8 *)0x0)) || (puVar4 = (undefined *)*puVar1, puVar4 == (undefined *)0x0))\n  {\n    puVar3 = &DAT_18007904c;\n    if (-1 < param_2) {\n      puVar3 = &DAT_180079050;\n    }\n    puVar4 = &DAT_18009f6f8;\n    thunk_FUN_180007388(&DAT_18009f6f8,puVar3,(ulonglong)uVar2,param_4);\n  }\n  return puVar4;\n}",
        "output": "```c\nstatic void *\nget_data_pointer(longlong base, int index, void *arg1, void *arg2)\n{\n    void **data_ptr;\n    unsigned int abs_index;\n    void *result;\n    void *default_data;\n\n    abs_index = abs(index);\n\n    if ((*(char *)(base + 0x7c8) == '\\0') || \n        (*(char *)(base + 0x7ca) == '\\0') || \n        ((data_ptr = *(void ***)(*(longlong *)(base + 0x8e0) + (longlong)abs_index * 8)) == NULL) || \n        ((result = *data_ptr) == NULL)) \n    {\n        default_data = (index >= 0) ? &DAT_180079050 : &DAT_18007904c;\n        result = &DAT_18009f6f8;\n        thunk_FUN_180007388(&DAT_18009f6f8, default_data, (unsigned long)abs_index, arg2);\n    }\n\n    return result;\n}\n```",
        "source_code": "char * __WINAPI get_origcol_name(lprec *lp, int colnr)\n{\n  MYBOOL newcol;\n  char   *ptr;\n\n  newcol = (MYBOOL) (colnr < 0);\n  colnr = abs(colnr);\n#ifdef Paranoia\n  if(((lp->presolve_undo->var_to_orig == NULL) && newcol) ||\n     (colnr > MAX(lp->columns, lp->presolve_undo->orig_columns))) {\n    report(lp, IMPORTANT, \"get_origcol_name: Column %d out of range\", colnr);\n    return(NULL);\n  }\n#endif\n\n  if(lp->names_used && lp->use_col_names && (lp->col_name[colnr] != NULL) && (lp->col_name[colnr]->name != NULL)) {\n#ifdef Paranoia\n    if(lp->col_name[colnr]->index != colnr)\n      report(lp, SEVERE, \"get_origcol_name: Inconsistent column ordinal %d vs %d\\n\",\n                         colnr, lp->col_name[colnr]->index);\n#endif\n    ptr = lp->col_name[colnr]->name;\n  }\n  else {\n    if(lp->rowcol_name == NULL)\n      if (!allocCHAR(lp, &lp->rowcol_name, 20, FALSE))\n        return(NULL);\n    ptr = lp->rowcol_name;\n    if(newcol)\n      sprintf(ptr, COLNAMEMASK2, colnr);\n    else\n      sprintf(ptr, COLNAMEMASK, colnr);\n  }\n  return(ptr);\n}",
        "parsed_output": "static void *\nget_data_pointer(longlong base, int index, void *arg1, void *arg2)\n{\n    void **data_ptr;\n    unsigned int abs_index;\n    void *result;\n    void *default_data;\n\n    abs_index = abs(index);\n\n    if ((*(char *)(base + 0x7c8) == '\\0') || \n        (*(char *)(base + 0x7ca) == '\\0') || \n        ((data_ptr = *(void ***)(*(longlong *)(base + 0x8e0) + (longlong)abs_index * 8)) == NULL) || \n        ((result = *data_ptr) == NULL)) \n    {\n        default_data = (index >= 0) ? &DAT_180079050 : &DAT_18007904c;\n        result = &DAT_18009f6f8;\n        thunk_FUN_180007388(&DAT_18009f6f8, default_data, (unsigned long)abs_index, arg2);\n    }\n\n    return result;\n}",
        "baseline_code_stripped": "undefined * FUN_180025924(longlong param_1,int param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 *puVar1;\n  uint uVar2;\n  undefined *puVar3;\n  undefined *puVar4;\n  uVar2 = abs(param_2);\n  if ((((*(char *)(param_1 + 0x7c8) == '\\0') || (*(char *)(param_1 + 0x7ca) == '\\0')) ||\n      (puVar1 = *(undefined8 **)(*(longlong *)(param_1 + 0x8e0) + (longlong)(int)uVar2 * 8),\n      puVar1 == (undefined8 *)0x0)) || (puVar4 = (undefined *)*puVar1, puVar4 == (undefined *)0x0))\n  {\n    puVar3 = &DAT_18007904c;\n    if (-1 < param_2) {\n      puVar3 = &DAT_180079050;\n    }\n    puVar4 = &DAT_18009f6f8;\n    thunk_FUN_180007388(&DAT_18009f6f8,puVar3,(ulonglong)uVar2,param_4);\n  }\n  return puVar4;\n}",
        "similarity_score_unixcoder": 0.5002573132514954,
        "similarity_score_baseline_stripped": 0.5044341087341309
    },
    {
        "func_name": "slot_QOcspResponse___hash__",
        "normed_func_sha256": "0b296d92f8636ca7e86b4fecbd86eb21c738c9ac8e6b0314791c451819fecd54",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_00127900(void)\n{\n  QGeoCoordinate *pQVar1;\n  undefined8 uVar2;\n  pQVar1 = (QGeoCoordinate *)(**(code **)(DAT_00143978 + 0x360))();\n  if (pQVar1 != (QGeoCoordinate *)0x0) {\n    uVar2 = qHash(pQVar1,0);\n    return uVar2;\n  }\n  return 0;\n}\n\n Revised code:\nstatic Py_hash_t slot_QGeoCoordinate___hash__(PyObject *sipSelf)\n{\n     ::QGeoCoordinate *sipCpp = reinterpret_cast< ::QGeoCoordinate *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QGeoCoordinate));\n\n    if (!sipCpp)\n        return 0;\n\n\n    {\n        {\n            Py_hash_t sipRes = 0;\n\n#line 69 \"/home/abuild/rpmbuild/BUILD/PyQt6-6.5.0/sip/QtPositioning/qgeocoordinate.sip\"\n        sipRes = qHash(*sipCpp);\n#line 476 \"/home/abuild/rpmbuild/BUILD/PyQt6-6.5.0/build/QtPositioning/sipQtPositioningQGeoCoordinate.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    return 0;\n}\n\n## Example:\n\n Input code:\nundefined4 FUN_001f3340(void)\n{\n  undefined4 uVar1;\n  QFont *pQVar2;\n  pQVar2 = (QFont *)(**(code **)(DAT_0043f2d8 + 0x2b8))();\n  uVar1 = 0;\n  if (pQVar2 != (QFont *)0x0) {\n    uVar1 = qHash(pQVar2,0);\n  }\n  return uVar1;\n}\n\n Revised code:\nstatic long slot_QFont___hash__(PyObject *sipSelf)\n{\n     ::QFont *sipCpp = reinterpret_cast< ::QFont *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QFont));\n\n    if (!sipCpp)\n        return 0;\n\n\n    {\n        {\n            long sipRes = 0;\n\n#line 223 \"/builddir/build/BUILD/PyQt5_gpl-5.11.3/x86_64-redhat-linux-gnu/sip/QtGui/qfont.sip\"\n        sipRes = qHash(*sipCpp);\n#line 1960 \"/builddir/build/BUILD/PyQt5_gpl-5.11.3/x86_64-redhat-linux-gnu/QtGui/sipQtGuiQFont.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    return 0;\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_002f4980(undefined8 param_1)\n{\n  QKeySequence *pQVar1;\n  undefined8 uVar2;\n  longlong in_r12;\n  pQVar1 = (QKeySequence *)\n           (**(code **)(*(longlong *)((longlong)&__DT_RELA[0x3a1e].r_addend + in_r12) + 0x360))\n                     (param_1,*(undefined8 *)((longlong)&__DT_RELA[0x14ab].r_info + in_r12));\n  if (pQVar1 != (QKeySequence *)0x0) {\n    uVar2 = qHash(pQVar1,0);\n    return uVar2;\n  }\n  return 0;\n}\n\n Revised code:\nstatic Py_hash_t slot_QKeySequence___hash__(PyObject *sipSelf)\n{\n     ::QKeySequence *sipCpp = reinterpret_cast< ::QKeySequence *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QKeySequence));\n\n    if (!sipCpp)\n        return 0;\n\n\n    {\n        {\n            Py_hash_t sipRes = 0;\n\n#line 233 \"/home/abuild/rpmbuild/BUILD/PyQt6-6.1.1/sip/QtGui/qkeysequence.sip\"\n        sipRes = qHash(*sipCpp);\n#line 391 \"/home/abuild/rpmbuild/BUILD/PyQt6-6.1.1/build/QtGui/sipQtGuiQKeySequence.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    return 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 FUN_00161c60(void)\n{\n  undefined4 uVar1;\n  QOcspResponse *pQVar2;\n  pQVar2 = (QOcspResponse *)(**(code **)(DAT_001ddbe0 + 0x2b8))();\n  uVar1 = 0;\n  if (pQVar2 != (QOcspResponse *)0x0) {\n    uVar1 = qHash(pQVar2,0);\n  }\n  return uVar1;\n}",
        "output": "```c\nstatic long slot_QOcspResponse___hash__(PyObject *sipSelf)\n{\n     ::QOcspResponse *sipCpp = reinterpret_cast< ::QOcspResponse *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QOcspResponse));\n\n    if (!sipCpp)\n        return 0;\n\n\n    {\n        {\n            long sipRes = 0;\n\n#line 223 \"/path/to/sip/QtNetwork/qocspresponse.sip\"\n        sipRes = qHash(*sipCpp);\n#line 1960 \"/path/to/build/QtNetwork/sipQtNetworkQOcspResponse.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    return 0;\n}\n```",
        "source_code": "static long slot_QOcspResponse___hash__(PyObject *sipSelf)\n{\n     ::QOcspResponse *sipCpp = reinterpret_cast< ::QOcspResponse *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf, sipType_QOcspResponse));\n\n    if (!sipCpp)\n        return 0L;\n\n\n    {\n        {\n            long sipRes = 0;\n\n#line 81 \"/home/abuild/rpmbuild/BUILD/PyQt5-5.15.9/sip/QtNetwork/qocspresponse.sip\"\n        sipRes = qHash(*sipCpp);\n#line 244 \"/home/abuild/rpmbuild/BUILD/PyQt5-5.15.9/build/QtNetwork/sipQtNetworkQOcspResponse.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    return 0;\n}",
        "parsed_output": "static long slot_QOcspResponse___hash__(PyObject *sipSelf)\n{\n     ::QOcspResponse *sipCpp = reinterpret_cast< ::QOcspResponse *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QOcspResponse));\n\n    if (!sipCpp)\n        return 0;\n\n\n    {\n        {\n            long sipRes = 0;\n\n#line 223 \"/path/to/sip/QtNetwork/qocspresponse.sip\"\n        sipRes = qHash(*sipCpp);\n#line 1960 \"/path/to/build/QtNetwork/sipQtNetworkQOcspResponse.cpp\"\n\n            return sipRes;\n        }\n    }\n\n    return 0;\n}",
        "baseline_code_stripped": "undefined4 FUN_00161c60(void)\n{\n  undefined4 uVar1;\n  QOcspResponse *pQVar2;\n  pQVar2 = (QOcspResponse *)(**(code **)(DAT_001ddbe0 + 0x2b8))();\n  uVar1 = 0;\n  if (pQVar2 != (QOcspResponse *)0x0) {\n    uVar1 = qHash(pQVar2,0);\n  }\n  return uVar1;\n}",
        "similarity_score_unixcoder": 0.9831758737564087,
        "similarity_score_baseline_stripped": 0.6350752115249634
    },
    {
        "func_name": "glColorSubTable",
        "normed_func_sha256": "2364801c7017a6a794153dfddf4da5ab244b2c58ae079b057e0294d3611960fe",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid glColor4b(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n{\n  int iVar1;\n  iVar1 = NtCurrentTeb();\n  iVar1 = *(int *)(iVar1 + 0xbe8);\n  if ((DAT_7a8e1a60 & 8) != 0) {\n    wine_dbg_log(3,&DAT_7a8e1a60,\"glColor4b\",\"(%d, %d, %d, %d)\\n\",param_1,param_2,param_3,param_4);\n  }\n  (**(code **)(iVar1 + 0xac))(param_1,param_2,param_3,param_4);\n  return;\n}\n\n Revised code:\nvoid WINAPI glColor4b( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha ) {\n  const struct opengl_funcs *funcs = NtCurrentTeb()->glTable;\n  TRACE(\"(%d, %d, %d, %d)\\n\", red, green, blue, alpha );\n  funcs->gl.p_glColor4b( red, green, blue, alpha );\n}\n\n## Example:\n\n Input code:\nvoid glColorFragmentOp3ATI\n               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n               undefined4 param_9,undefined4 param_10,undefined4 param_11,undefined4 param_12,\n               undefined4 param_13)\n{\n  int iVar1;\n  iVar1 = NtCurrentTeb();\n  iVar1 = *(int *)(iVar1 + 0xbe8);\n  if ((DAT_7a8e1a50 & 8) != 0) {\n    wine_dbg_log(3,&DAT_7a8e1a50,\"glColorFragmentOp3ATI\",\n                 \"(%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)\\n\",param_1,param_2,param_3,\n                 param_4,param_5,param_6,param_7,param_8,param_9,param_10,param_11,param_12,param_13\n                );\n  }\n  (**(code **)(iVar1 + 0x870))\n            (param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,param_10,\n             param_11,param_12,param_13);\n  return;\n}\n\n Revised code:\nstatic void WINAPI glColorFragmentOp3ATI( GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod ) {\n  const struct opengl_funcs *funcs = NtCurrentTeb()->glTable;\n  TRACE(\"(%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)\\n\", op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod );\n  funcs->ext.p_glColorFragmentOp3ATI( op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod );\n}\n\n## Example:\n\n Input code:\nvoid glGetProgramParameterfvNV\n               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n{\n  int iVar1;\n  iVar1 = NtCurrentTeb();\n  iVar1 = *(int *)(iVar1 + 0xbe8);\n  if ((DAT_7a8e1a50 & 8) != 0) {\n    wine_dbg_log(3,&DAT_7a8e1a50,\"glGetProgramParameterfvNV\",\"(%d, %d, %d, %p)\\n\",param_1,param_2,\n                 param_3,param_4);\n  }\n  (**(code **)(iVar1 + 0x123c))(param_1,param_2,param_3,param_4);\n  return;\n}\n\n Revised code:\nstatic void WINAPI glGetProgramParameterfvNV( GLenum target, GLuint index, GLenum pname, GLfloat* params ) {\n  const struct opengl_funcs *funcs = NtCurrentTeb()->glTable;\n  TRACE(\"(%d, %d, %d, %p)\\n\", target, index, pname, params );\n  funcs->ext.p_glGetProgramParameterfvNV( target, index, pname, params );\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid glColorSubTable(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                    undefined4 param_5,undefined4 param_6)\n{\n  int iVar1;\n  iVar1 = NtCurrentTeb();\n  iVar1 = *(int *)(iVar1 + 0xbe8);\n  if ((DAT_7a8e1a50 & 8) != 0) {\n    wine_dbg_log(3,&DAT_7a8e1a50,\"glColorSubTable\",\"(%d, %d, %d, %d, %d, %p)\\n\",param_1,param_2,\n                 param_3,param_4,param_5,param_6);\n  }\n  (**(code **)(iVar1 + 0x898))(param_1,param_2,param_3,param_4,param_5,param_6);\n  return;\n}",
        "output": "```c\nstatic void WINAPI glColorSubTable( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void* data ) {\n  const struct opengl_funcs *funcs = NtCurrentTeb()->glTable;\n  TRACE(\"(%d, %d, %d, %d, %d, %p)\\n\", target, start, count, format, type, data );\n  funcs->gl.p_glColorSubTable( target, start, count, format, type, data );\n}\n```",
        "source_code": "static void WINAPI glColorSubTable( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void* data ) {\n  const struct opengl_funcs *funcs = NtCurrentTeb()->glTable;\n  TRACE(\"(%d, %d, %d, %d, %d, %p)\\n\", target, start, count, format, type, data );\n  funcs->ext.p_glColorSubTable( target, start, count, format, type, data );\n}",
        "parsed_output": "static void WINAPI glColorSubTable( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void* data ) {\n  const struct opengl_funcs *funcs = NtCurrentTeb()->glTable;\n  TRACE(\"(%d, %d, %d, %d, %d, %p)\\n\", target, start, count, format, type, data );\n  funcs->gl.p_glColorSubTable( target, start, count, format, type, data );\n}",
        "baseline_code_stripped": "void glColorSubTable(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                    undefined4 param_5,undefined4 param_6)\n{\n  int iVar1;\n  iVar1 = NtCurrentTeb();\n  iVar1 = *(int *)(iVar1 + 0xbe8);\n  if ((DAT_7a8e1a50 & 8) != 0) {\n    wine_dbg_log(3,&DAT_7a8e1a50,\"glColorSubTable\",\"(%d, %d, %d, %d, %d, %p)\\n\",param_1,param_2,\n                 param_3,param_4,param_5,param_6);\n  }\n  (**(code **)(iVar1 + 0x898))(param_1,param_2,param_3,param_4,param_5,param_6);\n  return;\n}",
        "similarity_score_unixcoder": 0.9928944110870361,
        "similarity_score_baseline_stripped": 0.5819120407104492
    },
    {
        "func_name": "dt_image_set_aspect_ratio_if_different",
        "normed_func_sha256": "30a3c39745c11eadde56c03c3e646d671a1f6c24ae560fcd2d0e4336fbbbb9b6",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_01559d70(undefined8 param_1,ulong param_2)\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  uint uVar4;\n  uVar4 = (uint)param_1;\n  if (uVar4 < 0xc0000c) {\n    if (uVar4 < 0xc00004) {\n      return;\n    }\n    FUN_01559c10(uVar4 & 0xf,param_2 & 0xff);\n    return;\n  }\n  if (uVar4 == 0xc00011) {\n    lVar2 = (long)((DAT_037e2a54 + DAT_037e2a64) - DAT_0358eaf4) * (long)DAT_036ff9fc;\n    uVar3 = lVar2 / (long)DAT_036ff9f8;\n    iVar1 = FUN_019bad30(param_1,param_2,lVar2 % (long)DAT_036ff9f8);\n    if (iVar1 < (int)uVar3) {\n      FUN_00d6b880(uVar3 & 0xffffffff);\n    }\n    DAT_036ffa08 = 0;\n    _DAT_036ffa0c = (int)(char)param_2;\n    FUN_019bc1d0();\n    return;\n  }\n  return;\n}\n\n Revised code:\nvoid __fastcall tengaiWriteByte(UINT32 sekAddress, UINT8 byteValue)\r\n{\r\n\tswitch (sekAddress) {\r\n\t\tcase 0xC00004:\r\n\t\tcase 0xC00005:\r\n\t\tcase 0xC00006:\r\n\t\tcase 0xC00007:\r\n\t\tcase 0xC00008:\r\n\t\tcase 0xC00009:\r\n\t\tcase 0xC0000A:\r\n\t\tcase 0xC0000B:\r\n\t\t\ttengaiMCUWrite(sekAddress & 0x0F, byteValue);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 0xC00011:\t\t\t\t\t\t\t// Sound latch\r\n\t\t\tSendSoundCommand(byteValue);\r\n\t\t\tbreak;\r\n\r\n\t\tdefault: {\r\n//\t\t\tbprintf(PRINT_NORMAL, \"Attempt to write byte value %x to location %x\\n\", byteValue, sekAddress);\r\n\t\t}\r\n\t}\r\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_0010c680(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  int *piVar1;\n  long lVar2;\n  undefined8 uVar3;\n  FUN_001257e0(&DAT_00147168,0x40,&DAT_00147160);\n  piVar1 = *(int **)(DAT_00147168 + -8 + (long)DAT_00147160 * 8);\n  *piVar1 = DAT_00147160 + -1;\n  lVar2 = av_strdup(param_3);\n  *(long *)(piVar1 + 2) = lVar2;\n  if (lVar2 == 0) {\n    uVar3 = 0xfffffff4;\n  }\n  else {\n    _DAT_001470ec = 1;\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n Revised code:\nstatic int opt_filter_complex(void *optctx, const char *opt, const char *arg)\n{\n    FilterGraph *fg;\n    ALLOC_ARRAY_ELEM(filtergraphs, nb_filtergraphs);\n    fg = filtergraphs[nb_filtergraphs - 1];\n    fg->index      = nb_filtergraphs - 1;\n    fg->graph_desc = av_strdup(arg);\n    if (!fg->graph_desc)\n        return AVERROR(ENOMEM);\n    input_stream_potentially_available = 1;\n    return 0;\n}\n\n## Example:\n\n Input code:\nvoid FUN_00205728(undefined8 param_1,uint param_2)\n{\n  if (0x7ff < (int)param_2) {\n    param_2 = 0x800;\n  }\n  if (*(short *)(&DAT_01053724 + (ulong)(param_2 & ((int)param_2 >> 0x1f ^ 0xffffffffU)) * 2) != 0)\n  {\n    FUN_0023b1c4(param_1,0x3f4ccccd,0,DAT_00ce9f28,3,\n                 (long)*(short *)(&DAT_01053724 +\n                                 (ulong)(param_2 & ((int)param_2 >> 0x1f ^ 0xffffffffU)) * 2),100,\n                 0x400);\n    return;\n  }\n  return;\n}\n\n Revised code:\nstatic void GAME_EXPORT pfnPlaySoundByIndex( int iSound, float volume )\n{\n\tint hSound;\n\n\t// make sure what we in-bounds\n\tiSound = bound( 0, iSound, MAX_SOUNDS );\n\thSound = cl.sound_index[iSound];\n\tif( !hSound ) return;\n\n\tS_StartSound( NULL, cl.viewentity, CHAN_ITEM, hSound, volume, ATTN_NORM, PITCH_NORM, SND_STOP_LOOPING );\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid dt_image_set_aspect_ratio_if_different(float param_1,int param_2,int param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  if (param_1 <= 0.0) {\n    return;\n  }\n  lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x72);\n  if (0.1 < ABS(*(float *)(lVar1 + 0x420) - param_1)) {\n    dt_image_cache_read_release(DAT_005d3ad0);\n    lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x77);\n    uVar2 = DAT_005d3ad0;\n    *(float *)(lVar1 + 0x420) = param_1;\n    dt_image_cache_write_release(uVar2,lVar1,0);\n  }\n  else {\n    dt_image_cache_read_release(DAT_005d3ad0);\n  }\n  lVar1 = DAT_005d3af8;\n  if ((param_3 != 0) && (*(int *)(DAT_005d3af8 + 0x40) == 0xe)) {\n    uVar2 = g_list_prepend(0,(long)param_2);\n    dt_collection_update_query(lVar1,3,0x10,uVar2);\n    return;\n  }\n  return;\n}",
        "output": "```c\nvoid dt_image_set_aspect_ratio_if_different(float aspect_ratio, int image_id, int update_query)\n{\n    if (aspect_ratio <= 0.0f) {\n        return;\n    }\n\n    long image_cache_entry = dt_image_cache_get(DAT_005d3ad0, image_id, 0x72);\n    if (fabs(*(float *)(image_cache_entry + 0x420) - aspect_ratio) > 0.1f) {\n        dt_image_cache_read_release(DAT_005d3ad0);\n        image_cache_entry = dt_image_cache_get(DAT_005d3ad0, image_id, 0x77);\n        *(float *)(image_cache_entry + 0x420) = aspect_ratio;\n        dt_image_cache_write_release(DAT_005d3ad0, image_cache_entry, 0);\n    } else {\n        dt_image_cache_read_release(DAT_005d3ad0);\n    }\n\n    if (update_query != 0 && *(int *)(DAT_005d3af8 + 0x40) == 0xe) {\n        void *query_list = g_list_prepend(NULL, (long)image_id);\n        dt_collection_update_query(DAT_005d3af8, 3, 0x10, query_list);\n    }\n}\n```",
        "source_code": "void dt_image_set_aspect_ratio_if_different(const int32_t imgid, const float aspect_ratio, const gboolean raise)\n{\n  if (aspect_ratio > .0f)\n  {\n    /* fetch image from cache */\n    dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'r');\n\n    /* set image aspect ratio */\n    if(fabs(image->aspect_ratio - aspect_ratio) > 0.1)\n    {\n      dt_image_cache_read_release(darktable.image_cache, image);\n      dt_image_t *wimage = dt_image_cache_get(darktable.image_cache, imgid, 'w');\n      wimage->aspect_ratio = aspect_ratio;\n      dt_image_cache_write_release(darktable.image_cache, wimage, DT_IMAGE_CACHE_SAFE);\n    }\n    else\n      dt_image_cache_read_release(darktable.image_cache, image);\n\n    if(raise && darktable.collection->params.sort == DT_COLLECTION_SORT_ASPECT_RATIO)\n      dt_collection_update_query(darktable.collection, DT_COLLECTION_CHANGE_RELOAD,\n                                 DT_COLLECTION_PROP_ASPECT_RATIO, g_list_prepend(NULL, GINT_TO_POINTER(imgid)));\n  }\n}",
        "parsed_output": "void dt_image_set_aspect_ratio_if_different(float aspect_ratio, int image_id, int update_query)\n{\n    if (aspect_ratio <= 0.0f) {\n        return;\n    }\n\n    long image_cache_entry = dt_image_cache_get(DAT_005d3ad0, image_id, 0x72);\n    if (fabs(*(float *)(image_cache_entry + 0x420) - aspect_ratio) > 0.1f) {\n        dt_image_cache_read_release(DAT_005d3ad0);\n        image_cache_entry = dt_image_cache_get(DAT_005d3ad0, image_id, 0x77);\n        *(float *)(image_cache_entry + 0x420) = aspect_ratio;\n        dt_image_cache_write_release(DAT_005d3ad0, image_cache_entry, 0);\n    } else {\n        dt_image_cache_read_release(DAT_005d3ad0);\n    }\n\n    if (update_query != 0 && *(int *)(DAT_005d3af8 + 0x40) == 0xe) {\n        void *query_list = g_list_prepend(NULL, (long)image_id);\n        dt_collection_update_query(DAT_005d3af8, 3, 0x10, query_list);\n    }\n}",
        "baseline_code_stripped": "void dt_image_set_aspect_ratio_if_different(float param_1,int param_2,int param_3)\n{\n  long lVar1;\n  undefined8 uVar2;\n  if (param_1 <= 0.0) {\n    return;\n  }\n  lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x72);\n  if (0.1 < ABS(*(float *)(lVar1 + 0x420) - param_1)) {\n    dt_image_cache_read_release(DAT_005d3ad0);\n    lVar1 = dt_image_cache_get(DAT_005d3ad0,param_2,0x77);\n    uVar2 = DAT_005d3ad0;\n    *(float *)(lVar1 + 0x420) = param_1;\n    dt_image_cache_write_release(uVar2,lVar1,0);\n  }\n  else {\n    dt_image_cache_read_release(DAT_005d3ad0);\n  }\n  lVar1 = DAT_005d3af8;\n  if ((param_3 != 0) && (*(int *)(DAT_005d3af8 + 0x40) == 0xe)) {\n    uVar2 = g_list_prepend(0,(long)param_2);\n    dt_collection_update_query(lVar1,3,0x10,uVar2);\n    return;\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.8441108465194702,
        "similarity_score_baseline_stripped": 0.7183497548103333
    },
    {
        "func_name": "op_c0b0_13_ff",
        "normed_func_sha256": "ad2ef31d2a29e4cb947a8d9f46ffb0b7618efa02c4c4aab3227f7aa5fe05868d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 op_b120_12_ff(uint param_1)\n{\n  uint uVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  int iVar4;\n  ushort uVar5;\n  int iVar6;\n  uVar1 = (param_1 & 7) + 8;\n  OpcodeFamily = 3;\n  iVar4 = (&regs)[uVar1] - *(int *)(areg_byteinc + (ulong)(param_1 & 7) * 4);\n  CurrentInstrCycles = 0xe;\n  uVar3 = (&regs)[(ulong)(param_1 >> 9) & 7];\n  iVar6 = memory_get_byte(iVar4);\n  uVar5 = DAT_015be208;\n  DAT_015be22c = (ushort)iVar6;\n  DAT_015be228 = DAT_015be22c | (ushort)(iVar6 << 8);\n  if (hardware_bus_error != 0) {\n    DAT_015be1e0 = DAT_015be1e0 + 4;\n    cpu_bus_rmw = 0;\n    (&regs)[uVar1] = iVar4;\n    exception2_setup(param_1,iVar4,1,0);\n    ExceptionX_constprop_0(2,0xffffffff);\n    return 0x600;\n  }\n  uVar2 = (uint)(char)((byte)uVar3 ^ (byte)iVar6);\n  (&regs)[uVar1] = iVar4;\n  DAT_015be20a = uVar5;\n  regflags = ((int)uVar2 >> 7 & 1U) << 7 | (uint)((byte)uVar3 == (byte)iVar6) << 6;\n  DAT_015be208 = memory_get_wordi(DAT_015be1e0 + 4);\n  uVar5 = DAT_015be20a;\n  DAT_015be22c = DAT_015be208;\n  if (hardware_bus_error == 0) {\n    DAT_015be22a = (ushort)(uVar2 & 0xffff);\n    DAT_015be228 = DAT_015be22a | (ushort)(uVar2 << 8);\n    DAT_015be258 = DAT_015be25c;\n    memory_put_byte(iVar4,uVar2);\n    if (hardware_bus_error == 0) {\n      DAT_015be1e0 = DAT_015be1e0 + 2;\n      return 0xe00;\n    }\n    DAT_015be1e0 = DAT_015be1e0 + 4;\n    uVar1 = uVar5 | 0x10000;\n    if (DAT_015be246 == '\\0') {\n      uVar1 = (uint)uVar5;\n    }\n    cpu_bus_rmw = 0;\n    exception2_setup(uVar1,iVar4,0,0,1);\n    DAT_015be22a = CONCAT11(DAT_015be22a._1_1_,(char)(uVar2 & 0xffff));\n    ExceptionX_constprop_0(2,0xffffffff);\n    return 0xe00;\n  }\n  DAT_015be228 = DAT_015be208;\n  exception2_fetch_common_lto_priv_0(param_1 | 0x20000,4);\n  if (DAT_015bde24 == 0x109aa) {\n    DAT_028f06d0 = 0xffffffff;\n  }\n  ExceptionX_constprop_0(2,0xffffffff);\n  return 0xa00;\n}\n\n Revised code:\nuae_u32 REGPARAM2 op_b120_12_ff(uae_u32 opcode)\n{\n\tint count_cycles = 0;\n\tuae_u32 real_opcode = opcode;\n\tuae_u32 srcreg = ((real_opcode >> 9) & 7);\n\tuae_u32 dstreg = real_opcode & 7;\n\tOpcodeFamily = 3;\n\tCurrentInstrCycles = 14; \n\tuae_s8 src = m68k_dreg(regs, srcreg);\n\tuaecptr dsta;\n\tdsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tuae_s8 dst = get_byte_000(dsta);\n\tif(hardware_bus_error) {\n\t\tcpu_bus_rmw=false;\n\t\tm68k_incpci(4);\n\t\tm68k_areg(regs, dstreg) = dsta;\n\t\texception2_read(opcode, dsta + 0, 0x0, 1);\n\t\treturn 6 * CYCLE_UNIT / 2 + count_cycles;\n\t}\n\tm68k_areg(regs, dstreg) = dsta;\n\tsrc ^= dst;\n\tCLEAR_CZNV();\n\tSET_ZFLG(((uae_s8)(src)) == 0);\n\tSET_NFLG(((uae_s8)(src)) < 0);\n\tregs.ir = regs.irc;\n\topcode |= 0x20000;\n\tget_word_000_prefetch(4);\n\tif(hardware_bus_error) {\n\t\tint pcoffset = 0;\n\t\texception2_fetch_opcode(opcode, 4, pcoffset);\n\t\treturn 10 * CYCLE_UNIT / 2 + count_cycles;\n\t}\n\topcode = regs.ir;\n\tipl_fetch();\n\tput_byte_000(dsta, src);\n\tif(hardware_bus_error) {\n\t\tcpu_bus_rmw=false;\n\t\tm68k_incpci(4);\n\t\tif (regs.t1) opcode |= 0x10000;\n\t\texception2_write(opcode, dsta + 0, 0x0, src, 1);\n\t\treturn 14 * CYCLE_UNIT / 2 + count_cycles;\n\t}\n\tm68k_incpci(2);\n\treturn 14 * CYCLE_UNIT / 2 + count_cycles;\n}\n\n## Example:\n\n Input code:\nvoid op_c138_14_ff(uint param_1)\n{\n  undefined4 uVar1;\n  byte bVar2;\n  uint uVar3;\n  int iVar4;\n  iVar4 = (int)(short)DAT_0148fac8;\n  OpcodeFamily = 2;\n  uVar1 = (&regs)[param_1 >> 9 & 7];\n  CurrentInstrCycles = 0x10;\n  DAT_0148fac8 = (*x_get_iword)(4);\n  DAT_0148fae8 = DAT_0148fac8;\n  DAT_0148faec._0_2_ = DAT_0148fac8;\n  if (hardware_bus_error == 0) {\n    bVar2 = (*x_get_byte)(iVar4);\n    if (hardware_bus_error == 0) {\n      bVar2 = (byte)uVar1 & bVar2;\n      regflags = ((int)((char)bVar2 >> 7) & 1U) << 0xf | (uint)(bVar2 == 0) << 0xe;\n      DAT_0148faca = DAT_0148fac8;\n      DAT_0148fac8 = (*x_get_iword)(6);\n      DAT_0148fae8 = DAT_0148fac8;\n      DAT_0148faec._0_2_ = DAT_0148fac8;\n      if (hardware_bus_error == 0) {\n        uVar3 = (uint)DAT_0148faca;\n        DAT_0148fb18 = DAT_0148fb1c;\n        (*x_put_byte)(iVar4,(int)(char)bVar2);\n        if (hardware_bus_error == 0) {\n          DAT_0148faa0 = DAT_0148faa0 + 4;\n          return;\n        }\n        DAT_0148faa0 = DAT_0148faa0 + 6;\n        cpu_bus_rmw = 0;\n        if (DAT_0148fb06 != '\\0') {\n          uVar3 = uVar3 | 0x10000;\n        }\n        exception2_setup(uVar3,iVar4,0,0,1);\n        DAT_0148faea._0_1_ = bVar2;\n      }\n      else {\n        exception2_fetch_common_lto_priv_0(param_1 | 0x20000,6);\n        if (DAT_013fd63c == 0x109aa) {\n          DAT_0271a028 = 0xffffffff;\n        }\n      }\n    }\n    else {\n      DAT_0148faa0 = DAT_0148faa0 + 4;\n      cpu_bus_rmw = 0;\n      exception2_setup(param_1,iVar4,1,0,1);\n    }\n  }\n  else {\n    exception2_fetch_common_lto_priv_0(param_1,4);\n  }\n  ExceptionX_constprop_0(2,0xffffffff);\n  return;\n}\n\n Revised code:\nvoid REGPARAM2 op_c138_14_ff(uae_u32 opcode)\n{\n\tuae_u32 real_opcode = opcode;\n\tuae_u32 srcreg = ((real_opcode >> 9) & 7);\n\tOpcodeFamily = 2;\n\tCurrentInstrCycles = 16; \n\tuae_s8 src = m68k_dreg(regs, srcreg);\n\tuaecptr dsta;\n\tdsta = (uae_s32)(uae_s16)get_word_ce000_prefetch(4);\n\tif(hardware_bus_error) {\n\t\tint pcoffset = 0;\n\t\texception2_fetch(opcode, 4, 0);\n\t\treturn;\n\t}\n\tuae_s8 dst = x_get_byte(dsta);\n\tif(hardware_bus_error) {\n\t\tcpu_bus_rmw=false;\n\t\tm68k_incpci(4);\n\t\texception2_read(opcode, dsta + 0, 0x0, 1);\n\t\treturn;\n\t}\n\tsrc &= dst;\n\tCLEAR_CZNV();\n\tSET_ZFLG(((uae_s8)(src)) == 0);\n\tSET_NFLG(((uae_s8)(src)) < 0);\n\tregs.ir = regs.irc;\n\topcode |= 0x20000;\n\tget_word_ce000_prefetch(6);\n\tif(hardware_bus_error) {\n\t\tint pcoffset = 0;\n\t\texception2_fetch_opcode(opcode, 6, pcoffset);\n\t\treturn;\n\t}\n\topcode = regs.ir;\n\tipl_fetch();\n\tx_put_byte(dsta, src);\n\tif(hardware_bus_error) {\n\t\tcpu_bus_rmw=false;\n\t\tm68k_incpci(6);\n\t\tif (regs.t1) opcode |= 0x10000;\n\t\texception2_write(opcode, dsta + 0, 0x0, src, 1);\n\t\treturn;\n\t}\n\tm68k_incpci(4);\n\treturn;\n}\n\n## Example:\n\n Input code:\nvoid op_b170_14_ff(uint param_1)\n{\n  undefined4 uVar1;\n  ushort uVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  uVar1 = (&regs)[param_1 >> 9 & 7];\n  OpcodeFamily = 3;\n  CurrentInstrCycles = 0x12;\n  if (-1 < DAT_016f14ac) {\n    (*x_do_cycles)(cpucycleunit * 2);\n  }\n  uVar2 = DAT_01467dc8;\n  DAT_01467dc8 = (*x_get_iword)(4);\n  iVar4 = (&regs)[uVar2 >> 0xc];\n  if ((uVar2 & 0x800) == 0) {\n    iVar4 = (int)(short)(&regs)[uVar2 >> 0xc];\n  }\n  uVar5 = (int)(char)uVar2 + (&regs)[(param_1 & 7) + 8] + iVar4;\n  DAT_01467de8 = DAT_01467dc8;\n  DAT_01467dec = DAT_01467dc8;\n  if (hardware_bus_error != 0) {\n    exception2_fetch(param_1,4,0xfffffffe);\n    return;\n  }\n  if ((uVar5 & 1) != 0) {\n    DAT_01467da0 = DAT_01467da0 + 2;\n    exception3_read_access(param_1,uVar5,1,1);\n    return;\n  }\n  DAT_01467e18 = DAT_01467e1c;\n  uVar2 = (*x_get_word)(uVar5);\n  if (hardware_bus_error == 0) {\n    uVar3 = uVar2 ^ (ushort)uVar1;\n    regflags = ((int)((short)uVar3 >> 0xf) & 1U) << 0xf | (uint)((ushort)uVar1 == uVar2) << 0xe;\n    DAT_01467dca = DAT_01467dc8;\n    DAT_01467dc8 = (*x_get_iword)(6);\n    DAT_01467de8 = DAT_01467dc8;\n    DAT_01467dec = DAT_01467dc8;\n    if (hardware_bus_error != 0) {\n      exception2_fetch_opcode(param_1 | 0x20000,6,0);\n      return;\n    }\n    uVar6 = (uint)DAT_01467dca;\n    (*x_put_word)(uVar5,(int)(short)uVar3);\n    if (hardware_bus_error == 0) {\n      DAT_01467da0 = DAT_01467da0 + 4;\n      return;\n    }\n    DAT_01467da0 = DAT_01467da0 + 6;\n    cpu_bus_rmw = 0;\n    if (DAT_01467e06 != '\\0') {\n      uVar6 = uVar6 | 0x10000;\n    }\n    exception2_write(uVar6,uVar5,1,(int)(short)uVar3,1);\n    return;\n  }\n  DAT_01467da0 = DAT_01467da0 + 2;\n  cpu_bus_rmw = 0;\n  exception2_read(param_1,uVar5,1,1);\n  return;\n}\n\n Revised code:\nvoid REGPARAM2 op_b170_14_ff(uae_u32 opcode)\n{\n\tuae_u32 real_opcode = opcode;\n\tuae_u32 srcreg = ((real_opcode >> 9) & 7);\n\tuae_u32 dstreg = real_opcode & 7;\n\tOpcodeFamily = 3;\n\tCurrentInstrCycles = 18; \n\tuae_s16 src = m68k_dreg(regs, srcreg);\n\tuaecptr dsta;\n\tdo_cycles_ce000_internal(2);\n\tdsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_word_ce000_prefetch(4));\n\tif(hardware_bus_error) {\n\t\tint pcoffset = 0;\n\t\texception2_fetch(opcode, 4, -2);\n\t\treturn;\n\t}\n\tif (dsta & 1) {\n\t\tm68k_incpci(2);\n\t\texception3_read_access(opcode, dsta, 1, 1);\n\t\treturn;\n\t}\n\tipl_fetch();\n\tuae_s16 dst = x_get_word(dsta);\n\tif(hardware_bus_error) {\n\t\tcpu_bus_rmw=false;\n\t\tm68k_incpci(2);\n\t\texception2_read(opcode, dsta + 0, 0x1, 1);\n\t\treturn;\n\t}\n\tsrc ^= dst;\n\tCLEAR_CZNV();\n\tSET_ZFLG(((uae_s16)(src)) == 0);\n\tSET_NFLG(((uae_s16)(src)) < 0);\n\tregs.ir = regs.irc;\n\topcode |= 0x20000;\n\tget_word_ce000_prefetch(6);\n\tif(hardware_bus_error) {\n\t\tint pcoffset = 0;\n\t\texception2_fetch_opcode(opcode, 6, pcoffset);\n\t\treturn;\n\t}\n\topcode = regs.ir;\n\tx_put_word(dsta, src);\n\tif(hardware_bus_error) {\n\t\tcpu_bus_rmw=false;\n\t\tm68k_incpci(6);\n\t\tif (regs.t1) opcode |= 0x10000;\n\t\texception2_write(opcode, dsta + 0, 0x1, src, 1);\n\t\treturn;\n\t}\n\tm68k_incpci(4);\n\treturn;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid op_c0b0_13_ff(uint param_1)\n{\n  int iVar1;\n  ushort uVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  ulong uVar6;\n  OpcodeFamily = 2;\n  CurrentInstrCycles = 0x14;\n  if (-1 < DAT_015bde08) {\n    (*x_do_cycles)((long)(cpucycleunit << 1));\n  }\n  uVar2 = DAT_015be208;\n  iVar1 = (&regs)[(param_1 & 7) + 8];\n  DAT_015be208 = (*x_get_iword)(4);\n  iVar3 = (int)(short)(&regs)[uVar2 >> 0xc];\n  if ((uVar2 & 0x800) != 0) {\n    iVar3 = (&regs)[uVar2 >> 0xc];\n  }\n  uVar5 = iVar1 + (char)uVar2 + iVar3;\n  DAT_015be228 = DAT_015be208;\n  DAT_015be22c = DAT_015be208;\n  if (hardware_bus_error != 0) {\n    exception2_fetch_common_lto_priv_0(param_1,4);\n    DAT_028f06b8 = DAT_028f06b8 + -2;\n    ExceptionX_constprop_0(2,0xffffffff);\n    return;\n  }\n  if ((uVar5 & 1) != 0) {\n    DAT_015be1e0 = DAT_015be1e0 + 2;\n    (*x_do_cycles)((long)(cpucycleunit << 2));\n    exception3_read(param_1,uVar5,2,1);\n    return;\n  }\n  iVar3 = (*x_get_word)(uVar5);\n  if (hardware_bus_error == 0) {\n    uVar5 = uVar5 + 2;\n    uVar4 = (*x_get_word)(uVar5);\n    if (hardware_bus_error == 0) {\n      uVar6 = (ulong)(param_1 >> 9) & 7;\n      DAT_015be20a = DAT_015be208;\n      uVar5 = (iVar3 << 0x10 | uVar4) & (&regs)[uVar6];\n      DAT_015be258 = DAT_015be25c;\n      regflags = (uint)(uVar5 == 0) << 6 | (uVar5 >> 0x1f) << 7;\n      DAT_015be208 = (*x_get_iword)(6);\n      DAT_015be228 = DAT_015be208;\n      DAT_015be22c = DAT_015be208;\n      if (hardware_bus_error == 0) {\n        if (-1 < DAT_015bde08) {\n          (*x_do_cycles)((long)(cpucycleunit << 1));\n        }\n        (&regs)[uVar6] = uVar5;\n        DAT_015be1e0 = DAT_015be1e0 + 4;\n        return;\n      }\n      (&regs)[uVar6] = uVar5;\n      exception2_fetch_common_lto_priv_0(param_1,6);\n      if (DAT_015bde24 == 0x109aa) {\n        DAT_028f06d0 = 0xffffffff;\n      }\n      goto LAB_008a3414;\n    }\n  }\n  DAT_015be1e0 = DAT_015be1e0 + 2;\n  cpu_bus_rmw = 0;\n  exception2_setup(param_1,uVar5,1,1);\nLAB_008a3414:\n  ExceptionX_constprop_0(2,0xffffffff);\n  return;\n}",
        "output": "```c\nvoid REGPARAM2 op_c0b0_13_ff(uae_u32 opcode)\n{\n\tuae_u32 real_opcode = opcode;\n\tuae_u32 srcreg = ((real_opcode >> 9) & 7);\n\tuae_u32 dstreg = real_opcode & 7;\n\tOpcodeFamily = 2;\n\tCurrentInstrCycles = 20; \n\tdo_cycles_ce000_internal(2);\n\tuae_s16 disp = get_word_ce000_prefetch(4);\n\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), disp);\n\tif (hardware_bus_error) {\n\t\texception2_fetch(opcode, 4, -2);\n\t\tExceptionX(2, -1);\n\t\treturn;\n\t}\n\tif (dsta & 1) {\n\t\tm68k_incpci(2);\n\t\tdo_cycles_ce000_internal(4);\n\t\texception3_read_access(opcode, dsta, 2, 1);\n\t\treturn;\n\t}\n\tuae_s16 high = x_get_word(dsta);\n\tif (hardware_bus_error) {\n\t\tm68k_incpci(2);\n\t\tcpu_bus_rmw = false;\n\t\texception2_read(opcode, dsta, 2, 1);\n\t\treturn;\n\t}\n\tdsta += 2;\n\tuae_s16 low = x_get_word(dsta);\n\tif (hardware_bus_error) {\n\t\tm68k_incpci(2);\n\t\tcpu_bus_rmw = false;\n\t\texception2_read(opcode, dsta, 2, 1);\n\t\treturn;\n\t}\n\tuae_u32 result = ((high << 16) | (uae_u16)low) & m68k_dreg(regs, srcreg);\n\tCLEAR_CZNV();\n\tSET_ZFLG(result == 0);\n\tSET_NFLG(((uae_s32)result) < 0);\n\tm68k_dreg(regs, srcreg) = result;\n\tregs.ir = regs.irc;\n\tget_word_ce000_prefetch(6);\n\tif (hardware_bus_error) {\n\t\texception2_fetch(opcode, 6, -2);\n\t\tExceptionX(2, -1);\n\t\treturn;\n\t}\n\tm68k_incpci(4);\n\treturn;\n}\n```",
        "source_code": "void REGPARAM2 op_c0b0_13_ff(uae_u32 opcode)\n{\n\tuae_u32 real_opcode = opcode;\n\tuae_u32 srcreg = (real_opcode & 7);\n\tuae_u32 dstreg = (real_opcode >> 9) & 7;\n\tOpcodeFamily = 2;\n\tCurrentInstrCycles = 20; \n\tuaecptr srca;\n\tdo_cycles_ce000_internal(2);\n\tsrca = get_disp_ea_000(m68k_areg(regs, srcreg), get_word_ce000_prefetch(4));\n\tif(hardware_bus_error) {\n\t\tint pcoffset = 0;\n\t\texception2_fetch(opcode, 4, -2);\n\t\treturn;\n\t}\n\tif (srca & 1) {\n\t\tm68k_incpci(2);\n\t\texception3_read_access(opcode, srca, 2, 1);\n\t\treturn;\n\t}\n\tuae_s32 src = x_get_word(srca) << 16;\n\tif(hardware_bus_error) {\n\t\tcpu_bus_rmw=false;\n\t\tm68k_incpci(2);\n\t\texception2_read(opcode, srca + 0, 0x1, 1);\n\t\treturn;\n\t}\n\tsrc |= x_get_word(srca + 2); \n\tif(hardware_bus_error) {\n\t\tcpu_bus_rmw=false;\n\t\tm68k_incpci(2);\n\t\texception2_read(opcode, srca + 2, 0x1, 1);\n\t\treturn;\n\t}\n\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV();\n\tSET_ZFLG(((uae_s32)(src)) == 0);\n\tSET_NFLG(((uae_s32)(src)) < 0);\n\tregs.ir = regs.irc;\n\tipl_fetch();\n\tget_word_ce000_prefetch(6);\n\tif(hardware_bus_error) {\n\t\tint pcoffset = 0;\n\t\tm68k_dreg(regs, dstreg) = (src);\n\t\texception2_fetch_opcode(opcode, 6, pcoffset);\n\t\treturn;\n\t}\n\tdo_cycles_ce000_internal(2);\n\tm68k_dreg(regs, dstreg) = (src);\n\tm68k_incpci(4);\n\treturn;\n}",
        "parsed_output": "void REGPARAM2 op_c0b0_13_ff(uae_u32 opcode)\n{\n\tuae_u32 real_opcode = opcode;\n\tuae_u32 srcreg = ((real_opcode >> 9) & 7);\n\tuae_u32 dstreg = real_opcode & 7;\n\tOpcodeFamily = 2;\n\tCurrentInstrCycles = 20; \n\tdo_cycles_ce000_internal(2);\n\tuae_s16 disp = get_word_ce000_prefetch(4);\n\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), disp);\n\tif (hardware_bus_error) {\n\t\texception2_fetch(opcode, 4, -2);\n\t\tExceptionX(2, -1);\n\t\treturn;\n\t}\n\tif (dsta & 1) {\n\t\tm68k_incpci(2);\n\t\tdo_cycles_ce000_internal(4);\n\t\texception3_read_access(opcode, dsta, 2, 1);\n\t\treturn;\n\t}\n\tuae_s16 high = x_get_word(dsta);\n\tif (hardware_bus_error) {\n\t\tm68k_incpci(2);\n\t\tcpu_bus_rmw = false;\n\t\texception2_read(opcode, dsta, 2, 1);\n\t\treturn;\n\t}\n\tdsta += 2;\n\tuae_s16 low = x_get_word(dsta);\n\tif (hardware_bus_error) {\n\t\tm68k_incpci(2);\n\t\tcpu_bus_rmw = false;\n\t\texception2_read(opcode, dsta, 2, 1);\n\t\treturn;\n\t}\n\tuae_u32 result = ((high << 16) | (uae_u16)low) & m68k_dreg(regs, srcreg);\n\tCLEAR_CZNV();\n\tSET_ZFLG(result == 0);\n\tSET_NFLG(((uae_s32)result) < 0);\n\tm68k_dreg(regs, srcreg) = result;\n\tregs.ir = regs.irc;\n\tget_word_ce000_prefetch(6);\n\tif (hardware_bus_error) {\n\t\texception2_fetch(opcode, 6, -2);\n\t\tExceptionX(2, -1);\n\t\treturn;\n\t}\n\tm68k_incpci(4);\n\treturn;\n}",
        "baseline_code_stripped": "void op_c0b0_13_ff(uint param_1)\n{\n  int iVar1;\n  ushort uVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  ulong uVar6;\n  OpcodeFamily = 2;\n  CurrentInstrCycles = 0x14;\n  if (-1 < DAT_015bde08) {\n    (*x_do_cycles)((long)(cpucycleunit << 1));\n  }\n  uVar2 = DAT_015be208;\n  iVar1 = (&regs)[(param_1 & 7) + 8];\n  DAT_015be208 = (*x_get_iword)(4);\n  iVar3 = (int)(short)(&regs)[uVar2 >> 0xc];\n  if ((uVar2 & 0x800) != 0) {\n    iVar3 = (&regs)[uVar2 >> 0xc];\n  }\n  uVar5 = iVar1 + (char)uVar2 + iVar3;\n  DAT_015be228 = DAT_015be208;\n  DAT_015be22c = DAT_015be208;\n  if (hardware_bus_error != 0) {\n    exception2_fetch_common_lto_priv_0(param_1,4);\n    DAT_028f06b8 = DAT_028f06b8 + -2;\n    ExceptionX_constprop_0(2,0xffffffff);\n    return;\n  }\n  if ((uVar5 & 1) != 0) {\n    DAT_015be1e0 = DAT_015be1e0 + 2;\n    (*x_do_cycles)((long)(cpucycleunit << 2));\n    exception3_read(param_1,uVar5,2,1);\n    return;\n  }\n  iVar3 = (*x_get_word)(uVar5);\n  if (hardware_bus_error == 0) {\n    uVar5 = uVar5 + 2;\n    uVar4 = (*x_get_word)(uVar5);\n    if (hardware_bus_error == 0) {\n      uVar6 = (ulong)(param_1 >> 9) & 7;\n      DAT_015be20a = DAT_015be208;\n      uVar5 = (iVar3 << 0x10 | uVar4) & (&regs)[uVar6];\n      DAT_015be258 = DAT_015be25c;\n      regflags = (uint)(uVar5 == 0) << 6 | (uVar5 >> 0x1f) << 7;\n      DAT_015be208 = (*x_get_iword)(6);\n      DAT_015be228 = DAT_015be208;\n      DAT_015be22c = DAT_015be208;\n      if (hardware_bus_error == 0) {\n        if (-1 < DAT_015bde08) {\n          (*x_do_cycles)((long)(cpucycleunit << 1));\n        }\n        (&regs)[uVar6] = uVar5;\n        DAT_015be1e0 = DAT_015be1e0 + 4;\n        return;\n      }\n      (&regs)[uVar6] = uVar5;\n      exception2_fetch_common_lto_priv_0(param_1,6);\n      if (DAT_015bde24 == 0x109aa) {\n        DAT_028f06d0 = 0xffffffff;\n      }\n      goto LAB_008a3414;\n    }\n  }\n  DAT_015be1e0 = DAT_015be1e0 + 2;\n  cpu_bus_rmw = 0;\n  exception2_setup(param_1,uVar5,1,1);\nLAB_008a3414:\n  ExceptionX_constprop_0(2,0xffffffff);\n  return;\n}",
        "similarity_score_unixcoder": 0.9820045828819275,
        "similarity_score_baseline_stripped": 0.8237745761871338
    },
    {
        "func_name": "MakeBlurSubpass",
        "normed_func_sha256": "c551a471ad8b43709f11d9770499c66ea32f26036ce1046db9043c89bb9d2df9",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __thiscall sipQgsBlurEffect::begin(sipQgsBlurEffect *this,QgsRenderContext *param_1)\n{\n  _object *p_Var1;\n  int in_GS_OFFSET;\n  PyGILState_STATE local_14;\n  int local_10;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  p_Var1 = (_object *)\n           (**(code **)(sipAPI__core + 0x260))(&local_14,this + 0x76,this + 0x6c,0,\"begin\");\n  if (p_Var1 == (_object *)0x0) {\n    QgsPaintEffect::begin((QgsRenderContext *)this);\n  }\n  else {\n    sipVH__core_360(local_14,(_func_void__sipSimpleWrapper_ptr_PyGILState_STATE *)\n                             sipImportedVirtErrorHandlers__core_QtCore,\n                    *(_sipSimpleWrapper **)(this + 0x6c),p_Var1,param_1);\n  }\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return;\n  }\n  FUN_01a625e0();\n}\n\n Revised code:\nvoid sipQgsBlurEffect::begin(::QgsRenderContext& a0)\n{\n    sip_gilstate_t sipGILState;\n    PyObject *sipMeth;\n\n    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[6], &sipPySelf, SIP_NULLPTR, sipName_begin);\n\n    if (!sipMeth)\n    {\n        ::QgsBlurEffect::begin(a0);\n        return;\n    }\n\n    extern void sipVH__core_360(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, ::QgsRenderContext&);\n\n    sipVH__core_360(sipGILState, sipImportedVirtErrorHandlers__core_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);\n}\n\n## Example:\n\n Input code:\nvoid CHyprOpenGLImpl::renderMirrored(void)\n{\n  long *in_a0;\n  long lVar1;\n  long in_a4;\n  ulong in_a5;\n  undefined in_a6;\n  undefined8 uStack_38;\n  ulong uStack_30;\n  long lStack_28;\n  gp = &__global_pointer_;\n  lVar1 = *in_a0;\n  uStack_30 = in_a5 & 0xffffffff | in_a4 << 0x20;\n  lStack_28 = ___stack_chk_guard;\n  uStack_38 = 0;\n  lVar1 = FUN_002467b8(in_a0 + 0x2b,lVar1 + 0x178,0,*(undefined8 *)(lVar1 + 0x20),\n                       *(undefined8 *)(lVar1 + 0x28));\n  if ((*(int *)(lVar1 + 0xf0) != -1) && (*(int *)(lVar1 + 0xd8) != 0)) {\n    renderTexture((CHyprOpenGLImpl *)in_a0,(CTexture *)(lVar1 + 0xd0),(wlr_box *)&uStack_38,0.0,0,\n                  false,(bool)in_a6);\n  }\n  if (___stack_chk_guard == lStack_28) {\n    return;\n  }\n  FUN_0017b600(0);\n}\n\n Revised code:\nvoid CHyprOpenGLImpl::renderMirrored() {\n    wlr_box    monbox = {0, 0, m_RenderData.pMonitor->vecPixelSize.x, m_RenderData.pMonitor->vecPixelSize.y};\n\n    const auto PFB = &m_mMonitorRenderResources[m_RenderData.pMonitor->pMirrorOf].monitorMirrorFB;\n\n    if (!PFB->isAllocated() || PFB->m_cTex.m_iTexID <= 0)\n        return;\n\n    renderTexture(PFB->m_cTex, &monbox, 1.f, 0, false, false);\n}\n\n## Example:\n\n Input code:\nvoid mozilla::gfx::FilterNodeUnpremultiplySoftware::Render(IntRectTyped *param_1)\n{\n  bool bVar1;\n  IntRectTyped *in_r1;\n  ConvolveMatrixEdgeMode in_r2;\n  int iVar2;\n  int *piVar3;\n  int *local_18;\n  int local_14;\n  local_14 = __stack_chk_guard;\n  FilterNodeSoftware::GetInputDataSourceSurface((uint)&local_18,in_r1,0,in_r2,(IntRectTyped *)0x0);\n  if (local_18 == (int *)0x0) {\n    *(undefined4 *)param_1 = 0;\n  }\n  else {\n    Unpremultiply((gfx *)param_1,(DataSourceSurface *)local_18);\n    piVar3 = local_18 + 1;\n    DataMemoryBarrier(0xb);\n    do {\n      iVar2 = *piVar3;\n      bVar1 = (bool)hasExclusiveAccess(piVar3);\n    } while (!bVar1);\n    *piVar3 = iVar2 + -1;\n    DataMemoryBarrier(0xb);\n    if (iVar2 == 1) {\n      (**(code **)(*local_18 + 4))(local_18);\n    }\n  }\n  if (local_14 != __stack_chk_guard) {\n    __stack_chk_fail(param_1);\n  }\n  return;\n}\n\n Revised code:\nalready_AddRefed<DataSourceSurface>\nFilterNodeUnpremultiplySoftware::Render(const IntRect& aRect)\n{\n  RefPtr<DataSourceSurface> input =\n    GetInputDataSourceSurface(IN_UNPREMULTIPLY_IN, aRect);\n  return input ? Unpremultiply(input) : nullptr;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid processEntry\nstd::\n_Function_handler<void(gpu::Batch&),render::BlurGaussian::run(std::shared_ptr<render::RenderContext>const&,task::VaryingSet5<std::shared_ptr<gpu::Framebuffer>,bool,unsigned_int,int,float>const&,std::shared_ptr<gpu::Framebuffer>&)::{lambda(gpu::Batch&)#1}>\n::_M_invoke(_Any_data *param_1,Batch *param_2)\n{\n  _Sp_counted_base____gnu_cxx___Lock_policy_2_ *in_stack_00000008;\n  if (in_stack_00000008 != (_Sp_counted_base____gnu_cxx___Lock_policy_2_ *)0x0) {\n    _Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release(in_stack_00000008);\n  }\n  _Unwind_Resume();\n}",
        "output": "```cpp\nvoid render::BlurGaussian::run(std::shared_ptr<render::RenderContext> const& context,\n                               task::VaryingSet5<std::shared_ptr<gpu::Framebuffer>, bool, unsigned int, int, float> const& varyingSet,\n                               std::shared_ptr<gpu::Framebuffer>& framebuffer) {\n    auto lambda = [](gpu::Batch& batch) {\n        // Implementation of the lambda function\n    };\n\n    if (auto countedBase = in_stack_00000008) {\n        countedBase->_M_release();\n    }\n\n    _Unwind_Resume();\n}\n```",
        "source_code": "std::shared_ptr<Texture> MakeBlurSubpass(\n    const ContentContext& renderer,\n    std::shared_ptr<Texture> input_texture,\n    const SamplerDescriptor& sampler_descriptor,\n    const GaussianBlurFragmentShader::BlurInfo& blur_info) {\n  ISize subpass_size = input_texture->GetSize();\n  ContentContext::SubpassCallback subpass_callback =\n      [&](const ContentContext& renderer, RenderPass& pass) {\n        GaussianBlurVertexShader::FrameInfo frame_info{\n            .mvp = Matrix::MakeOrthographic(ISize(1, 1)),\n            .texture_sampler_y_coord_scale = 1.0};\n\n        HostBuffer& host_buffer = pass.GetTransientsBuffer();\n\n        Command cmd;\n        ContentContextOptions options = OptionsFromPass(pass);\n        options.primitive_type = PrimitiveType::kTriangleStrip;\n        cmd.pipeline = renderer.GetGaussianBlurPipeline(options);\n        BindVertices<GaussianBlurVertexShader>(cmd, host_buffer,\n                                               {\n                                                   {Point(0, 0), Point(0, 0)},\n                                                   {Point(1, 0), Point(1, 0)},\n                                                   {Point(0, 1), Point(0, 1)},\n                                                   {Point(1, 1), Point(1, 1)},\n                                               });\n\n        GaussianBlurFragmentShader::BindTextureSampler(\n            cmd, input_texture,\n            renderer.GetContext()->GetSamplerLibrary()->GetSampler(\n                sampler_descriptor));\n        GaussianBlurVertexShader::BindFrameInfo(\n            cmd, host_buffer.EmplaceUniform(frame_info));\n        GaussianBlurFragmentShader::BindBlurInfo(\n            cmd, host_buffer.EmplaceUniform(blur_info));\n        pass.AddCommand(std::move(cmd));\n\n        return true;\n      };\n  std::shared_ptr<Texture> out_texture = renderer.MakeSubpass(\n      \"Gaussian Blur Filter\", subpass_size, subpass_callback);\n  return out_texture;\n}",
        "parsed_output": "pp\nvoid render::BlurGaussian::run(std::shared_ptr<render::RenderContext> const& context,\n                               task::VaryingSet5<std::shared_ptr<gpu::Framebuffer>, bool, unsigned int, int, float> const& varyingSet,\n                               std::shared_ptr<gpu::Framebuffer>& framebuffer) {\n    auto lambda = [](gpu::Batch& batch) {\n        // Implementation of the lambda function\n    };\n\n    if (auto countedBase = in_stack_00000008) {\n        countedBase->_M_release();\n    }\n\n    _Unwind_Resume();\n}",
        "baseline_code_stripped": "void processEntry\nstd::\n_Function_handler<void(gpu::Batch&),render::BlurGaussian::run(std::shared_ptr<render::RenderContext>const&,task::VaryingSet5<std::shared_ptr<gpu::Framebuffer>,bool,unsigned_int,int,float>const&,std::shared_ptr<gpu::Framebuffer>&)::{lambda(gpu::Batch&)#1}>\n::_M_invoke(_Any_data *param_1,Batch *param_2)\n{\n  _Sp_counted_base____gnu_cxx___Lock_policy_2_ *in_stack_00000008;\n  if (in_stack_00000008 != (_Sp_counted_base____gnu_cxx___Lock_policy_2_ *)0x0) {\n    _Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release(in_stack_00000008);\n  }\n  _Unwind_Resume();\n}",
        "similarity_score_unixcoder": 0.7054888010025024,
        "similarity_score_baseline_stripped": 0.6532571315765381
    },
    {
        "func_name": "airspy_gpio_write",
        "normed_func_sha256": "a13668954cf74923ee303bcc9d0e065bdefd4973a743b654a10491f09d1ffc6e",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid set_gpio_bit(long param_1,uint param_2,int param_3)\n{\n  uint uVar1;\n  uint uVar2;\n  uVar2 = (**(code **)(param_1 + 0x2e8))();\n  uVar1 = ~param_2 & uVar2;\n  if (param_3 != 0) {\n    uVar1 = param_2 | uVar2;\n  }\n  (**(code **)(param_1 + 0x2e0))(param_1,uVar1);\n  return;\n}\n\n Revised code:\nstatic void set_gpio_bit(struct snd_ice1712 *ice, unsigned int bit, int val)\n{\n\tunsigned int tmp = snd_ice1712_gpio_read(ice);\n\tif (val)\n\t\ttmp |= bit;\n\telse\n\t\ttmp &= ~bit;\n\tsnd_ice1712_gpio_write(ice, tmp);\n}\n\n## Example:\n\n Input code:\nvoid or51211_reset(long param_1)\n{\n  long lVar1;\n  int iVar2;\n  __fentry__();\n  lVar1 = *(long *)(*(long *)(param_1 + 0x308) + 0x38);\n  iVar2 = bttv_gpio_enable(*(undefined4 *)(lVar1 + 0x108),0x1f,0x1f);\n  if (iVar2 != 0) {\n    _printk(&DAT_00102478,iVar2);\n  }\n  bttv_write_gpio(*(undefined4 *)(lVar1 + 0x108),0x1f,0);\n  msleep(0x14);\n  bttv_write_gpio(*(undefined4 *)(lVar1 + 0x108),0x1f,1);\n  msleep(500);\n  return;\n}\n\n Revised code:\nstatic void or51211_reset(struct dvb_frontend * fe)\n{\n\tstruct dvb_bt8xx_card *bt = fe->dvb->priv;\n\n\t/* RESET DEVICE\n\t * reset is controlled by GPIO-0\n\t * when set to 0 causes reset and when to 1 for normal op\n\t * must remain reset for 128 clock cycles on a 50Mhz clock\n\t * also PRM1 PRM2 & PRM4 are controlled by GPIO-1,GPIO-2 & GPIO-4\n\t * We assume that the reset has be held low long enough or we\n\t * have been reset by a power on.  When the driver is unloaded\n\t * reset set to 0 so if reloaded we have been reset.\n\t */\n\t/* reset & PRM1,2&4 are outputs */\n\tint ret = bttv_gpio_enable(bt->bttv_nr, 0x001F, 0x001F);\n\tif (ret != 0)\n\t\tpr_warn(\"or51211: Init Error - Can't Reset DVR (%i)\\n\", ret);\n\tbttv_write_gpio(bt->bttv_nr, 0x001F, 0x0000);   /* Reset */\n\tmsleep(20);\n\t/* Now set for normal operation */\n\tbttv_write_gpio(bt->bttv_nr, 0x0001F, 0x0001);\n\t/* wait for operation to begin */\n\tmsleep(500);\n}\n\n## Example:\n\n Input code:\nvoid nvkm_gpio_set(long *param_1)\n{\n  long lVar1;\n  int iVar2;\n  int in_w4;\n  undefined uStack_c;\n  byte abStack_b [3];\n  long lStack_8;\n  lVar1 = sp_el0;\n  lStack_8 = *(long *)(lVar1 + 0x548);\n  iVar2 = nvkm_gpio_find();\n  if (iVar2 == 0) {\n    (**(code **)(*param_1 + 0x18))(param_1,uStack_c,abStack_b[in_w4] >> 1 & 1,abStack_b[in_w4] & 1);\n  }\n  if (lStack_8 == *(long *)(lVar1 + 0x548)) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic int\nnvkm_gpio_set(struct nvkm_gpio *gpio, int idx, u8 tag, u8 line, int state)\n{\n\tstruct dcb_gpio_func func;\n\tint ret;\n\tret = nvkm_gpio_find(gpio, idx, tag, line, &func);\n\tif (ret == 0) {\n\t\tint dir = !!(func.log[state] & 0x02);\n\t\tint out = !!(func.log[state] & 0x01);\n\t\tret = nvkm_gpio_drive(gpio, idx, func.line, dir, out);\n\t}\n\treturn ret;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nlong airspy_gpio_write(long param_1,int param_2,ulong param_3)\n{\n  long lVar1;\n  lVar1 = FUN_001025c0(*(undefined8 *)(param_1 + 8),0x40,0x15,\n                       (param_3 | (long)(param_2 << 5)) & 0xff,0,0,0);\n  if (lVar1 != 0) {\n    lVar1 = -1000;\n  }\n  return lVar1;\n}",
        "output": "```c\nstatic long airspy_gpio_write(struct airspy_device *dev, int pin, unsigned long value)\n{\n\tlong ret = airspy_control_transfer(dev->usb_dev, 0x40, 0x15, \n\t                                   (value | ((long)pin << 5)) & 0xff, 0, 0, 0);\n\tif (ret != 0) {\n\t\tret = -1000;\n\t}\n\treturn ret;\n}\n```",
        "source_code": "int ADDCALL airspy_gpio_write(airspy_device_t* device, airspy_gpio_port_t port, airspy_gpio_pin_t pin, uint8_t value)\n\t{\n\t\tint result;\n\t\tuint8_t port_pin;\n\n\t\tport_pin = ((uint8_t)port) << 5;\n\t\tport_pin = port_pin | pin;\n\n\t\tresult = libusb_control_transfer(\n\t\t\tdevice->usb_device,\n\t\t\tLIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,\n\t\t\tAIRSPY_GPIO_WRITE,\n\t\t\tvalue,\n\t\t\tport_pin,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\t0);\n\n\t\tif (result != 0)\n\t\t{\n\t\t\treturn AIRSPY_ERROR_LIBUSB;\n\t\t}\n\t\telse {\n\t\t\treturn AIRSPY_SUCCESS;\n\t\t}\n\t}",
        "parsed_output": "static long airspy_gpio_write(struct airspy_device *dev, int pin, unsigned long value)\n{\n\tlong ret = airspy_control_transfer(dev->usb_dev, 0x40, 0x15, \n\t                                   (value | ((long)pin << 5)) & 0xff, 0, 0, 0);\n\tif (ret != 0) {\n\t\tret = -1000;\n\t}\n\treturn ret;\n}",
        "baseline_code_stripped": "long airspy_gpio_write(long param_1,int param_2,ulong param_3)\n{\n  long lVar1;\n  lVar1 = FUN_001025c0(*(undefined8 *)(param_1 + 8),0x40,0x15,\n                       (param_3 | (long)(param_2 << 5)) & 0xff,0,0,0);\n  if (lVar1 != 0) {\n    lVar1 = -1000;\n  }\n  return lVar1;\n}",
        "similarity_score_unixcoder": 0.7822936773300171,
        "similarity_score_baseline_stripped": 0.6297171711921692
    },
    {
        "func_name": "colvarproxy_atoms::add_atom_slot",
        "normed_func_sha256": "6c361dc7e493660c93db11fd60de9ab98798f14c6d566ef27234b7495431f0f1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_14004af70(longlong *param_1)\n{\n  longlong lVar1;\n  undefined8 uVar2;\n  undefined8 local_res8;\n  undefined4 local_res10;\n  int local_res14;\n  undefined4 local_18;\n  int local_14;\n  undefined4 local_10;\n  undefined4 local_c;\n  if ((longlong *)param_1[0x3b] != (longlong *)0x0) {\n    lVar1 = *(longlong *)param_1[0x3b];\n    uVar2 = (**(code **)(*param_1 + 0x160))();\n    (**(code **)(lVar1 + 0x150))(param_1[0x3b],uVar2);\n    (**(code **)(*(longlong *)param_1[0x3b] + 0x338))((longlong *)param_1[0x3b],0);\n    (**(code **)(*(longlong *)param_1[0x3b] + 0x1f8))();\n    local_res8 = 0;\n    (**(code **)(*param_1 + 0x208))(param_1,&local_res10,&local_res8);\n    local_c = (**(code **)(*(longlong *)param_1[0x3b] + 0x250))();\n    local_10 = (**(code **)(*param_1 + 0x248))(param_1);\n    local_14 = (**(code **)(*param_1 + 0x250))(param_1);\n    local_14 = local_14 + local_res14;\n    local_18 = local_res10;\n    (**(code **)(*(longlong *)param_1[0x3b] + 0x298))((longlong *)param_1[0x3b],&local_18);\n  }\n  return;\n}\n\n Revised code:\nvoid ComboBox::OpenList()\n{\n\tif ( !m_Menu ) return;\n\n\tm_Menu->SetParent( GetCanvas() );\n\tm_Menu->SetHidden( false );\n\tm_Menu->BringToFront();\n\n\tGwen::Point p = LocalPosToCanvas( Gwen::Point( 0, 0 ) );\n\n\tm_Menu->SetBounds( Gwen::Rect ( p.x, p.y + Height(), Width(), m_Menu->Height()) );\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_14045c570(longlong param_1,int param_2,int param_3)\n{\n  int iVar1;\n  int local_res10;\n  int local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  if (param_1 == 0) {\n    local_18 = 0;\n  }\n  else {\n    local_res10 = param_2;\n    if (param_2 < 1) {\n      local_res10 = 1;\n    }\n    iVar1 = FUN_14042e500(param_1);\n    local_30 = FUN_140459140(0);\n    for (local_38 = 0; local_38 < iVar1; local_38 = local_38 + 1) {\n      local_20 = FUN_14042e5c0(param_1,local_38,2);\n      local_28 = FUN_14045c000(local_20,local_res10);\n      FUN_1404f9db0(local_30,local_28,0,0xffffffff);\n      FUN_140459310(&local_28);\n      FUN_14042dc00(&local_20);\n    }\n    if (param_3 == 0) {\n      local_18 = FUN_140459540(local_30);\n    }\n    else {\n      local_18 = FUN_1404ffef0(local_30);\n    }\n    FUN_140459310(&local_30);\n  }\n  return local_18;\n}\n\n Revised code:\nPTA  *\ngeneratePtaBoxa(BOXA    *boxa,\n                l_int32  width,\n                l_int32  removedups)\n{\nl_int32  i, n;\nBOX     *box;\nPTA     *ptad, *ptat, *pta;\n\n    if (!boxa)\n        return (PTA *)ERROR_PTR(\"boxa not defined\", __func__, NULL);\n    if (width < 1) {\n        L_WARNING(\"width < 1; setting to 1\\n\", __func__);\n        width = 1;\n    }\n\n    n = boxaGetCount(boxa);\n    ptat = ptaCreate(0);\n    for (i = 0; i < n; i++) {\n        box = boxaGetBox(boxa, i, L_CLONE);\n        pta = generatePtaBox(box, width);\n        ptaJoin(ptat, pta, 0, -1);\n        ptaDestroy(&pta);\n        boxDestroy(&box);\n    }\n\n    if (removedups)\n        ptaRemoveDupsByAset(ptat, &ptad);\n    else\n        ptad = ptaClone(ptat);\n\n    ptaDestroy(&ptat);\n    return ptad;\n}\n\n## Example:\n\n Input code:\nvoid FUN_1400dea80(longlong *param_1,int param_2,longlong param_3)\n{\n  longlong *plVar1;\n  longlong lVar2;\n  undefined4 local_28 [2];\n  undefined8 local_20;\n  undefined4 local_18;\n  undefined local_14;\n  undefined4 local_10;\n  undefined local_c;\n  lVar2 = 0;\n  if (param_3 != 0) {\n    plVar1 = (longlong *)FUN_140064cd0(param_3);\n    lVar2 = *plVar1;\n  }\n  if (param_1[(longlong)param_2 + 5] != lVar2) {\n    param_1[(longlong)param_2 + 5] = lVar2;\n    *(undefined *)(param_1 + 2) = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_14 = 0;\n    local_10 = 0;\n    local_c = 0;\n    local_28[0] = 7;\n    FUN_1403071e0(*(undefined8 *)(*param_1 + 0x24f8),local_28);\n    local_20 = 0;\n    local_18 = 0;\n    local_14 = 0;\n    plVar1 = *(longlong **)(param_1[1] + 0x2518);\n    local_10 = 0;\n    local_c = 0;\n    local_28[0] = 7;\n    *(undefined *)(plVar1 + 2) = 0;\n    FUN_1403071e0(*(undefined8 *)(*plVar1 + 0x24f8),local_28);\n    FUN_1403076d0(*(undefined8 *)(param_1[1] + 0x24f8),1);\n    if (param_2 == 6) {\n      FUN_1400dfda0(*(undefined8 *)(param_1[1] + 0x2518),0,0);\n    }\n    FUN_1400dfda0(param_1,0,0);\n  }\n  return;\n}\n\n Revised code:\nvoid TradeData::SetItem( TradeSlots slot, Item* item )\n{\n    ObjectGuid itemGuid = item ? item->GetObjectGuid() : ObjectGuid();\n\n    if (m_items[slot] == itemGuid)\n        return;\n\n    m_items[slot] = itemGuid;\n\n    SetAccepted(false);\n    GetTraderData()->SetAccepted(false);\n\n    Update();\n\n    // need remove possible trader spell applied to changed item\n    if (slot == TRADE_SLOT_NONTRADED)\n        GetTraderData()->SetSpell(0);\n\n    // need remove possible player spell applied (possible move reagent)\n    SetSpell(0);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint FUN_14040f294(longlong param_1,undefined4 param_2)\n{\n  undefined8 local_res8;\n  undefined4 local_res10 [2];\n  undefined local_38 [16];\n  undefined8 local_28;\n  local_res10[0] = param_2;\n  FUN_1400672ec(param_1 + 8,local_res10);\n  local_res8 = 1;\n  FUN_1403de08c(param_1 + 0x20,&local_res8);\n  local_res8 = 0x3ff0000000000000;\n  FUN_1403a4490(param_1 + 0x38,&local_res8);\n  local_res8 = 0;\n  FUN_1403a4490(param_1 + 0x50,&local_res8);\n  local_28 = 0;\n  local_38 = ZEXT816(0);\n  FUN_140259060(param_1 + 0x68,local_38);\n  local_28 = 0;\n  local_38 = ZEXT816(0);\n  FUN_140259060(param_1 + 0x80,local_38);\n  local_28 = 0;\n  local_38 = ZEXT816(0);\n  FUN_140259060(param_1 + 0x98,local_38);\n  return (int)(*(longlong *)(param_1 + 0x10) - *(longlong *)(param_1 + 8) >> 2) + -1;\n}",
        "output": "```c\nint ProcessData(longlong baseAddress, undefined4 inputParam)\n{\n    undefined8 value;\n    undefined4 paramArray[2];\n    undefined localBuffer[16];\n    undefined8 localValue;\n\n    paramArray[0] = inputParam;\n    InitializeData(baseAddress + 8, paramArray);\n\n    value = 1;\n    UpdateValue(baseAddress + 0x20, &value);\n\n    value = 0x3ff0000000000000; // Set to double precision 1.0\n    UpdateValue(baseAddress + 0x38, &value);\n\n    value = 0;\n    UpdateValue(baseAddress + 0x50, &value);\n\n    localValue = 0;\n    memset(localBuffer, 0, sizeof(localBuffer));\n    ResetData(baseAddress + 0x68, localBuffer);\n\n    localValue = 0;\n    memset(localBuffer, 0, sizeof(localBuffer));\n    ResetData(baseAddress + 0x80, localBuffer);\n\n    localValue = 0;\n    memset(localBuffer, 0, sizeof(localBuffer));\n    ResetData(baseAddress + 0x98, localBuffer);\n\n    return (int)((*(longlong *)(baseAddress + 0x10) - *(longlong *)(baseAddress + 8)) >> 2) - 1;\n}\n```",
        "source_code": "int colvarproxy_atoms::add_atom_slot(int atom_id)\n{\n  atoms_ids.push_back(atom_id);\n  atoms_ncopies.push_back(1);\n  atoms_masses.push_back(1.0);\n  atoms_charges.push_back(0.0);\n  atoms_positions.push_back(cvm::rvector(0.0, 0.0, 0.0));\n  atoms_total_forces.push_back(cvm::rvector(0.0, 0.0, 0.0));\n  atoms_new_colvar_forces.push_back(cvm::rvector(0.0, 0.0, 0.0));\n  return (atoms_ids.size() - 1);\n}",
        "parsed_output": "int ProcessData(longlong baseAddress, undefined4 inputParam)\n{\n    undefined8 value;\n    undefined4 paramArray[2];\n    undefined localBuffer[16];\n    undefined8 localValue;\n\n    paramArray[0] = inputParam;\n    InitializeData(baseAddress + 8, paramArray);\n\n    value = 1;\n    UpdateValue(baseAddress + 0x20, &value);\n\n    value = 0x3ff0000000000000; // Set to double precision 1.0\n    UpdateValue(baseAddress + 0x38, &value);\n\n    value = 0;\n    UpdateValue(baseAddress + 0x50, &value);\n\n    localValue = 0;\n    memset(localBuffer, 0, sizeof(localBuffer));\n    ResetData(baseAddress + 0x68, localBuffer);\n\n    localValue = 0;\n    memset(localBuffer, 0, sizeof(localBuffer));\n    ResetData(baseAddress + 0x80, localBuffer);\n\n    localValue = 0;\n    memset(localBuffer, 0, sizeof(localBuffer));\n    ResetData(baseAddress + 0x98, localBuffer);\n\n    return (int)((*(longlong *)(baseAddress + 0x10) - *(longlong *)(baseAddress + 8)) >> 2) - 1;\n}",
        "baseline_code_stripped": "int FUN_14040f294(longlong param_1,undefined4 param_2)\n{\n  undefined8 local_res8;\n  undefined4 local_res10 [2];\n  undefined local_38 [16];\n  undefined8 local_28;\n  local_res10[0] = param_2;\n  FUN_1400672ec(param_1 + 8,local_res10);\n  local_res8 = 1;\n  FUN_1403de08c(param_1 + 0x20,&local_res8);\n  local_res8 = 0x3ff0000000000000;\n  FUN_1403a4490(param_1 + 0x38,&local_res8);\n  local_res8 = 0;\n  FUN_1403a4490(param_1 + 0x50,&local_res8);\n  local_28 = 0;\n  local_38 = ZEXT816(0);\n  FUN_140259060(param_1 + 0x68,local_38);\n  local_28 = 0;\n  local_38 = ZEXT816(0);\n  FUN_140259060(param_1 + 0x80,local_38);\n  local_28 = 0;\n  local_38 = ZEXT816(0);\n  FUN_140259060(param_1 + 0x98,local_38);\n  return (int)(*(longlong *)(param_1 + 0x10) - *(longlong *)(param_1 + 8) >> 2) + -1;\n}",
        "similarity_score_unixcoder": 0.32614585757255554,
        "similarity_score_baseline_stripped": 0.43986305594444275
    },
    {
        "func_name": "MovieTrackingReconstructedCameras_rna_properties_next",
        "normed_func_sha256": "78e918cf391f4725031d9c8d6d807a56150d9073413c79db91690833415d5431",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid _Lmd3dcaption_TLMD3DCaption_SetTracing_qqri(int param_1,int param_2)\n{\n  if (param_2 != *(int *)(param_1 + 0x28)) {\n    *(int *)(param_1 + 0x28) = param_2;\n    FUN_005b7680();\n  }\n  return;\n}\n\n Revised code:\nStatic void\nuplcom_dtr(struct uplcom_softc *sc, int onoff)\n{\n\tDPRINTF((\"uplcom_dtr: onoff = %d\\n\", onoff));\n\tif (sc->sc_dtr == onoff)\n\t\treturn;\n\tsc->sc_dtr = onoff;\n\tuplcom_set_line_state(sc);\n}\n\n## Example:\n\n Input code:\nvoid FUN_0027a714(undefined8 *param_1)\n{\n  *param_1 = 0x314fd0;\n  param_1[1] = 0x315140;\n  Gst::BaseTransform::_BaseTransform((BaseTransform *)param_1);\n  Glib::ObjectBase::_ObjectBase((ObjectBase *)(param_1 + 1));\n  sigc::trackable::_trackable((trackable *)(param_1 + 5));\n  return;\n}\n\n Revised code:\nvoid VideoScale_Class::class_init_function(void* g_class, void* class_data)\n{\n  const auto klass = static_cast<BaseClassType*>(g_class);\n  CppClassParent::class_init_function(klass, class_data);\n\n\n}\n\n## Example:\n\n Input code:\nvoid FUN_0014460c(undefined8 *param_1)\n{\n  *param_1 = 0x198180;\n  param_1[1] = 0x1981d0;\n  Glib::Object::_Object((Object *)param_1);\n  Glib::ObjectBase::_ObjectBase((ObjectBase *)(param_1 + 1));\n  sigc::trackable::_trackable((trackable *)(param_1 + 5));\n  return;\n}\n\n Revised code:\nvoid Batch_Class::class_init_function(void* g_class, void* class_data)\n{\n  const auto klass = static_cast<BaseClassType*>(g_class);\n  CppClassParent::class_init_function(klass, class_data);\n\n\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid MovieTrackingReconstructedCameras_rna_properties_next(long param_1)\n{\n  rna_builtin_properties_next();\n  if (*(int *)(param_1 + 0x80) == 0) {\n    return;\n  }\n  MovieTrackingCamera_rna_properties_begin_part_0(param_1);\n  return;\n}",
        "output": "void MovieTrackingReconstructedCameras::rna_properties_next(long param_1)\n{\n    rna_builtin_properties_next();\n    if (*(int *)(param_1 + 0x80) == 0) {\n        return;\n    }\n    MovieTrackingCamera::rna_properties_begin_part_0(param_1);\n}",
        "source_code": "void MovieTrackingReconstructedCameras_rna_properties_next(CollectionPropertyIterator *iter)\n{\n    rna_builtin_properties_next(iter);\n\n    if (iter->valid)\n        iter->ptr = MovieTrackingReconstructedCameras_rna_properties_get(iter);\n}",
        "parsed_output": "void MovieTrackingReconstructedCameras::rna_properties_next(long param_1)\n{\n    rna_builtin_properties_next();\n    if (*(int *)(param_1 + 0x80) == 0) {\n        return;\n    }\n    MovieTrackingCamera::rna_properties_begin_part_0(param_1);\n}",
        "baseline_code_stripped": "void MovieTrackingReconstructedCameras_rna_properties_next(long param_1)\n{\n  rna_builtin_properties_next();\n  if (*(int *)(param_1 + 0x80) == 0) {\n    return;\n  }\n  MovieTrackingCamera_rna_properties_begin_part_0(param_1);\n  return;\n}",
        "similarity_score_unixcoder": 0.794338583946228,
        "similarity_score_baseline_stripped": 0.7925416231155396
    },
    {
        "func_name": "value_batch_import_job_collect_value",
        "normed_func_sha256": "0ae09ebc6a0290af6de28b613bcaa7c72026119866014b9f808b8f0b8bd386fb",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8\nvalue_importable_database_table_collect_value(undefined8 *param_1,undefined8 param_2,long **param_3)\n{\n  long *plVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  plVar1 = *param_3;\n  if (plVar1 == (long *)0x0) {\n    param_1[1] = 0;\n  }\n  else {\n    if ((undefined8 *)*plVar1 == (undefined8 *)0x0) {\n      uVar3 = g_type_name(*param_1);\n      uVar3 = g_strconcat(\"invalid unclassed object pointer for value type `\",uVar3,&DAT_00118929,0)\n      ;\n      return uVar3;\n    }\n    iVar2 = g_value_type_compatible(*(undefined8 *)*plVar1,*param_1);\n    if (iVar2 == 0) {\n      uVar3 = g_type_name(*param_1);\n      uVar4 = g_type_name(*(undefined8 *)*plVar1);\n      uVar3 = g_strconcat(\"invalid object type `\",uVar4,\"\\' for value type `\",uVar3,&DAT_00118929,0)\n      ;\n      return uVar3;\n    }\n    uVar3 = importable_database_table_ref(plVar1);\n    param_1[1] = uVar3;\n  }\n  return 0;\n}\n\n Revised code:\nstatic gchar* value_importable_database_table_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {\n#line 16 \"/builddir/build/BUILD/shotwell-0.23.1/plugins/common/SqliteSupport.vala\"\n\tif (collect_values[0].v_pointer) {\n#line 437 \"SqliteSupport.c\"\n\t\tImportableDatabaseTable* object;\n\t\tobject = collect_values[0].v_pointer;\n#line 16 \"/builddir/build/BUILD/shotwell-0.23.1/plugins/common/SqliteSupport.vala\"\n\t\tif (object->parent_instance.g_class == NULL) {\n#line 16 \"/builddir/build/BUILD/shotwell-0.23.1/plugins/common/SqliteSupport.vala\"\n\t\t\treturn g_strconcat (\"invalid unclassed object pointer for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n#line 444 \"SqliteSupport.c\"\n\t\t} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {\n#line 16 \"/builddir/build/BUILD/shotwell-0.23.1/plugins/common/SqliteSupport.vala\"\n\t\t\treturn g_strconcat (\"invalid object type `\", g_type_name (G_TYPE_FROM_INSTANCE (object)), \"' for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n#line 448 \"SqliteSupport.c\"\n\t\t}\n#line 16 \"/builddir/build/BUILD/shotwell-0.23.1/plugins/common/SqliteSupport.vala\"\n\t\tvalue->data[0].v_pointer = importable_database_table_ref (object);\n#line 452 \"SqliteSupport.c\"\n\t} else {\n#line 16 \"/builddir/build/BUILD/shotwell-0.23.1/plugins/common/SqliteSupport.vala\"\n\t\tvalue->data[0].v_pointer = NULL;\n#line 456 \"SqliteSupport.c\"\n\t}\n#line 16 \"/builddir/build/BUILD/shotwell-0.23.1/plugins/common/SqliteSupport.vala\"\n\treturn NULL;\n#line 460 \"SqliteSupport.c\"\n}\n\n## Example:\n\n Input code:\nundefined4\ngcp_c_compile_args_value_makefile_collect_value\n          (undefined4 *param_1,undefined4 param_2,int **param_3)\n{\n  int *piVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  piVar1 = *param_3;\n  if (piVar1 == (int *)0x0) {\n    param_1[1] = 0;\n    uVar3 = 0;\n  }\n  else if ((undefined4 *)*piVar1 == (undefined4 *)0x0) {\n    uVar3 = g_type_name(*param_1);\n    uVar3 = g_strconcat(\"invalid unclassed object pointer for value type `\",uVar3,&DAT_00020edb,0);\n  }\n  else {\n    iVar2 = g_value_type_compatible(*(undefined4 *)*piVar1,*param_1);\n    if (iVar2 == 0) {\n      uVar3 = g_type_name(*param_1);\n      uVar4 = g_type_name(*(undefined4 *)*piVar1);\n      uVar3 = g_strconcat(\"invalid object type `\",uVar4,\"\\' for value type `\",uVar3,&DAT_00020edb,0)\n      ;\n    }\n    else {\n      LOCK();\n      piVar1[1] = piVar1[1] + 1;\n      UNLOCK();\n      uVar3 = 0;\n      param_1[1] = piVar1;\n    }\n  }\n  return uVar3;\n}\n\n Revised code:\nstatic gchar* gcp_c_compile_args_value_makefile_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {\n\tif (collect_values[0].v_pointer) {\n\t\tGcpCCompileArgsMakefile* object;\n\t\tobject = collect_values[0].v_pointer;\n\t\tif (object->parent_instance.g_class == NULL) {\n\t\t\treturn g_strconcat (\"invalid unclassed object pointer for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n\t\t} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {\n\t\t\treturn g_strconcat (\"invalid object type `\", g_type_name (G_TYPE_FROM_INSTANCE (object)), \"' for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n\t\t}\n\t\tvalue->data[0].v_pointer = gcp_c_compile_args_makefile_ref (object);\n\t} else {\n\t\tvalue->data[0].v_pointer = NULL;\n\t}\n\treturn NULL;\n}\n\n## Example:\n\n Input code:\nundefined8\napp_models_value_photo_util_collect_value(undefined8 *param_1,undefined8 param_2,long **param_3)\n{\n  long *plVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  plVar1 = *param_3;\n  if (plVar1 == (long *)0x0) {\n    param_1[1] = 0;\n    return 0;\n  }\n  if ((undefined8 *)*plVar1 != (undefined8 *)0x0) {\n    iVar2 = g_value_type_compatible(*(undefined8 *)*plVar1);\n    if (iVar2 == 0) {\n      uVar3 = g_type_name(*param_1);\n      uVar4 = g_type_name(*(undefined8 *)*plVar1);\n      uVar3 = g_strconcat(\"invalid object type `\",uVar4,\"\\' for value type `\",uVar3,&DAT_00127172,0)\n      ;\n      return uVar3;\n    }\n    LOCK();\n    *(int *)(plVar1 + 1) = *(int *)(plVar1 + 1) + 1;\n    UNLOCK();\n    param_1[1] = plVar1;\n    return 0;\n  }\n  uVar3 = g_type_name(*param_1);\n  uVar3 = g_strconcat(\"invalid unclassed object pointer for value type `\",uVar3,&DAT_00127172,0);\n  return uVar3;\n}\n\n Revised code:\nstatic gchar*\napp_models_value_photo_util_collect_value (GValue* value,\n                                           guint n_collect_values,\n                                           GTypeCValue* collect_values,\n                                           guint collect_flags)\n{\n\tif (collect_values[0].v_pointer) {\n\t\tAppModelsPhotoUtil * object;\n\t\tobject = collect_values[0].v_pointer;\n\t\tif (object->parent_instance.g_class == NULL) {\n\t\t\treturn g_strconcat (\"invalid unclassed object pointer for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n\t\t} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {\n\t\t\treturn g_strconcat (\"invalid object type `\", g_type_name (G_TYPE_FROM_INSTANCE (object)), \"' for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n\t\t}\n\t\tvalue->data[0].v_pointer = app_models_photo_util_ref (object);\n\t} else {\n\t\tvalue->data[0].v_pointer = NULL;\n\t}\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4\nvalue_batch_import_job_collect_value(undefined4 *param_1,undefined4 param_2,int **param_3)\n{\n  int *piVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  piVar1 = *param_3;\n  if (piVar1 == (int *)0x0) {\n    param_1[1] = 0;\n    uVar3 = 0;\n  }\n  else if ((undefined4 *)*piVar1 == (undefined4 *)0x0) {\n    uVar3 = g_type_name(*param_1);\n    uVar3 = g_strconcat(\"invalid unclassed object pointer for value type `\",uVar3,&DAT_08365fe9,0);\n  }\n  else {\n    iVar2 = g_value_type_compatible(*(undefined4 *)*piVar1,*param_1);\n    if (iVar2 == 0) {\n      uVar3 = g_type_name(*param_1);\n      uVar4 = g_type_name(*(undefined4 *)*piVar1);\n      uVar3 = g_strconcat(\"invalid object type `\",uVar4,\"\\' for value type `\",uVar3,&DAT_08365fe9,0)\n      ;\n    }\n    else {\n      uVar3 = batch_import_job_ref(piVar1);\n      param_1[1] = uVar3;\n      uVar3 = 0;\n    }\n  }\n  return uVar3;\n}",
        "output": "```c\nstatic gchar* value_batch_import_job_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {\n\tif (collect_values[0].v_pointer) {\n\t\tBatchImportJob* object;\n\t\tobject = collect_values[0].v_pointer;\n\t\tif (object->parent_instance.g_class == NULL) {\n\t\t\treturn g_strconcat (\"invalid unclassed object pointer for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n\t\t} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {\n\t\t\treturn g_strconcat (\"invalid object type `\", g_type_name (G_TYPE_FROM_INSTANCE (object)), \"' for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n\t\t}\n\t\tvalue->data[0].v_pointer = batch_import_job_ref (object);\n\t} else {\n\t\tvalue->data[0].v_pointer = NULL;\n\t}\n\treturn NULL;\n}\n```",
        "source_code": "static gchar* value_batch_import_job_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {\n#line 160 \"/builddir/build/BUILD/shotwell-0.23.1/src/BatchImport.vala\"\n\tif (collect_values[0].v_pointer) {\n#line 3184 \"BatchImport.c\"\n\t\tBatchImportJob* object;\n\t\tobject = collect_values[0].v_pointer;\n#line 160 \"/builddir/build/BUILD/shotwell-0.23.1/src/BatchImport.vala\"\n\t\tif (object->parent_instance.g_class == NULL) {\n#line 160 \"/builddir/build/BUILD/shotwell-0.23.1/src/BatchImport.vala\"\n\t\t\treturn g_strconcat (\"invalid unclassed object pointer for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n#line 3191 \"BatchImport.c\"\n\t\t} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {\n#line 160 \"/builddir/build/BUILD/shotwell-0.23.1/src/BatchImport.vala\"\n\t\t\treturn g_strconcat (\"invalid object type `\", g_type_name (G_TYPE_FROM_INSTANCE (object)), \"' for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n#line 3195 \"BatchImport.c\"\n\t\t}\n#line 160 \"/builddir/build/BUILD/shotwell-0.23.1/src/BatchImport.vala\"\n\t\tvalue->data[0].v_pointer = batch_import_job_ref (object);\n#line 3199 \"BatchImport.c\"\n\t} else {\n#line 160 \"/builddir/build/BUILD/shotwell-0.23.1/src/BatchImport.vala\"\n\t\tvalue->data[0].v_pointer = NULL;\n#line 3203 \"BatchImport.c\"\n\t}\n#line 160 \"/builddir/build/BUILD/shotwell-0.23.1/src/BatchImport.vala\"\n\treturn NULL;\n#line 3207 \"BatchImport.c\"\n}",
        "parsed_output": "static gchar* value_batch_import_job_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {\n\tif (collect_values[0].v_pointer) {\n\t\tBatchImportJob* object;\n\t\tobject = collect_values[0].v_pointer;\n\t\tif (object->parent_instance.g_class == NULL) {\n\t\t\treturn g_strconcat (\"invalid unclassed object pointer for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n\t\t} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {\n\t\t\treturn g_strconcat (\"invalid object type `\", g_type_name (G_TYPE_FROM_INSTANCE (object)), \"' for value type `\", G_VALUE_TYPE_NAME (value), \"'\", NULL);\n\t\t}\n\t\tvalue->data[0].v_pointer = batch_import_job_ref (object);\n\t} else {\n\t\tvalue->data[0].v_pointer = NULL;\n\t}\n\treturn NULL;\n}",
        "baseline_code_stripped": "undefined4\nvalue_batch_import_job_collect_value(undefined4 *param_1,undefined4 param_2,int **param_3)\n{\n  int *piVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  piVar1 = *param_3;\n  if (piVar1 == (int *)0x0) {\n    param_1[1] = 0;\n    uVar3 = 0;\n  }\n  else if ((undefined4 *)*piVar1 == (undefined4 *)0x0) {\n    uVar3 = g_type_name(*param_1);\n    uVar3 = g_strconcat(\"invalid unclassed object pointer for value type `\",uVar3,&DAT_08365fe9,0);\n  }\n  else {\n    iVar2 = g_value_type_compatible(*(undefined4 *)*piVar1,*param_1);\n    if (iVar2 == 0) {\n      uVar3 = g_type_name(*param_1);\n      uVar4 = g_type_name(*(undefined4 *)*piVar1);\n      uVar3 = g_strconcat(\"invalid object type `\",uVar4,\"\\' for value type `\",uVar3,&DAT_08365fe9,0)\n      ;\n    }\n    else {\n      uVar3 = batch_import_job_ref(piVar1);\n      param_1[1] = uVar3;\n      uVar3 = 0;\n    }\n  }\n  return uVar3;\n}",
        "similarity_score_unixcoder": 0.875274658203125,
        "similarity_score_baseline_stripped": 0.7628924250602722
    },
    {
        "func_name": "ue_info_resp_r9_s::crit_exts_c_::to_json",
        "normed_func_sha256": "c98437c5d5336d5876237a4aa5026f37b2884023ae6f766e2580205e676a48e1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __thiscall\nasn1::rrc::epdcch_set_cfg_r11_s::mpdcch_cfg_r13_c_::setup_s_::mpdcch_start_sf_uess_r13_c_::to_json\n          (mpdcch_start_sf_uess_r13_c_ *this,json_writer *param_1)\n{\n  int in_GS_OFFSET;\n  basic_string local_50 [24];\n  basic_string local_38 [24];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x3360ad;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  FUN_00312c70();\n  json_writer::start_obj(param_1,local_38);\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_dispose();\n  if (*(int *)this == 0) {\n    fdd_r13_opts::to_string_abi_cxx11_();\n  }\n  else {\n    if (*(int *)this != 1) {\n      FUN_00313473();\n      goto LAB_00336166;\n    }\n    tdd_r13_opts::to_string_abi_cxx11_();\n  }\n  FUN_00312c70();\n  json_writer::write_str(param_1,local_38,local_50);\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_dispose();\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_dispose();\nLAB_00336166:\n  json_writer::end_obj(param_1);\n  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {\n    FUN_00597b50();\n  }\n  return;\n}\n\n Revised code:\nvoid epdcch_set_cfg_r11_s::mpdcch_cfg_r13_c_::setup_s_::mpdcch_start_sf_uess_r13_c_::to_json(json_writer& j) const\n{\n  j.start_obj();\n  switch (type_) {\n    case types::fdd_r13:\n      j.write_str(\"fdd-r13\", c.get<fdd_r13_e_>().to_string());\n      break;\n    case types::tdd_r13:\n      j.write_str(\"tdd-r13\", c.get<tdd_r13_e_>().to_string());\n      break;\n    default:\n      log_invalid_choice_id(type_, \"epdcch_set_cfg_r11_s::mpdcch_cfg_r13_c_::setup_s_::mpdcch_start_sf_uess_r13_c_\");\n  }\n  j.end_obj();\n}\n\n## Example:\n\n Input code:\nvoid FUN_00243690(int param_1,long *param_2)\n{\n  PropertyMap *this;\n  char cVar1;\n  undefined8 *puVar2;\n  undefined local_39;\n  long local_38;\n  char *local_30;\n  undefined auStack_20 [24];\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  if (*param_2 != 0) {\n    this = (PropertyMap *)(*param_2 + 0x18);\n    cVar1 = oox::PropertyMap::hasProperty(this,0x208);\n    if (cVar1 != '\\0') {\n      oox::PropertyMap::getProperty(this,0x208);\n      if (*(int *)(local_38 + 8) != 0) {\n        local_39 = false;\n        if (*(int *)(local_38 + 8) == 2) {\n          local_39 = *local_30 != '\\0';\n        }\n        puVar2 = (undefined8 *)typelib_static_type_getByTypeClass(2);\n        uno_type_any_construct(auStack_20,&local_39,*puVar2,FUN_001fff08);\n        oox::PropertySet::setAnyProperty(param_1,(Any *)0x208);\n        uno_any_destruct(auStack_20,FUN_00207cd8);\n      }\n      uno_any_destruct(&local_38,FUN_00207cd8);\n    }\n  }\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid ObjectFormatter::convertTextWrap( PropertySet& rPropSet, const ModelRef< TextBody >& rxTextProp )\n{\n    if( rxTextProp.is() )\n    {\n        PropertyMap& aPropMap = rxTextProp->getTextProperties().maPropertyMap;\n        if( aPropMap.hasProperty(PROP_TextWordWrap) )\n        {\n            Any aValue = aPropMap.getProperty( PROP_TextWordWrap );\n            if( aValue.hasValue() )\n            {\n                bool bValue = false;\n                aValue >>= bValue;\n                rPropSet.setProperty( PROP_TextWordWrap, bValue );\n            }\n        }\n    }\n}\n\n## Example:\n\n Input code:\nvoid __thiscall awkward::UnionBuilder::field(UnionBuilder *this,char *param_1,bool param_2)\n{\n  long *plVar1;\n  invalid_argument *this_00;\n  undefined *local_88 [2];\n  undefined auStack_78 [16];\n  undefined *local_68 [2];\n  undefined auStack_58 [16];\n  undefined *local_48 [2];\n  undefined auStack_38 [16];\n  if (this[0x90] != (UnionBuilder)0xff) {\n    plVar1 = *(long **)((long)(char)this[0x90] * 0x10 + *(long *)(this + 0x78));\n    (**(code **)(*plVar1 + 0xa8))(plVar1,param_1,param_2);\n    return;\n  }\n  this_00 = (invalid_argument *)__cxa_allocate_exception(0x10);\n  FUN_0022be0e(local_68,\n               \"\\n\\n(https://github.com/scikit-hep/awkward-1.0/blob/1.8.0/src/libawkward/builder/UnionBuilder.cpp#L408)\"\n              );\n  FUN_0022be0e(local_88,\"called \\'field\\' without \\'begin_record\\' at the same level before it\");\n  std::operator_((basic_string *)local_48,(basic_string *)local_88);\n  std::invalid_argument::invalid_argument(this_00,(basic_string *)local_48);\n  if (local_48[0] != auStack_38) {\n    operator_delete(local_48[0]);\n  }\n  if (local_88[0] != auStack_78) {\n    operator_delete(local_88[0]);\n  }\n  if (local_68[0] != auStack_58) {\n    operator_delete(local_68[0]);\n  }\n  __cxa_throw(this_00,&std::invalid_argument::typeinfo,std::invalid_argument::_invalid_argument);\n}\n\n Revised code:\nvoid\n  UnionBuilder::field(const char* key, bool check) {\n    if (current_ == -1) {\n      throw std::invalid_argument(\n        std::string(\"called 'field' without 'begin_record' at the same level before it\")\n        + FILENAME(__LINE__));\n    }\n    else {\n      contents_[(size_t)current_].get()->field(key, check);\n    }\n  }\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __thiscall\nasn1::rrc::ue_info_resp_r9_s::crit_exts_c_::to_json(crit_exts_c_ *this,json_writer *param_1)\n{\n  int in_GS_OFFSET;\n  basic_string local_38 [24];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x419753;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  FUN_00312c70();\n  json_writer::start_obj(param_1,local_38);\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_dispose();\n  if (*(int *)this == 0) {\n    FUN_00312c70();\n    json_writer::write_fieldname(param_1,local_38);\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_dispose();\n    c1_c_::to_json((c1_c_ *)(this + 4),param_1);\n  }\n  else if (*(int *)this != 1) {\n    FUN_00313473();\n  }\n  json_writer::end_obj(param_1);\n  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {\n    FUN_00597b50();\n  }\n  return;\n}",
        "output": "```cpp\nvoid ue_info_resp_r9_s::crit_exts_c_::to_json(json_writer& j) const {\n    j.start_obj();\n    switch (type_) {\n        case types::c1:\n            j.write_fieldname(\"c1\");\n            c1_.to_json(j);\n            break;\n        default:\n            log_invalid_choice_id(type_, \"ue_info_resp_r9_s::crit_exts_c_\");\n    }\n    j.end_obj();\n}\n```",
        "source_code": "void ue_info_resp_r9_s::crit_exts_c_::to_json(json_writer& j) const\n{\n  j.start_obj();\n  switch (type_) {\n    case types::c1:\n      j.write_fieldname(\"c1\");\n      c.get<c1_c_>().to_json(j);\n      break;\n    case types::crit_exts_future:\n      break;\n    default:\n      log_invalid_choice_id(type_, \"ue_info_resp_r9_s::crit_exts_c_\");\n  }\n  j.end_obj();\n}",
        "parsed_output": "pp\nvoid ue_info_resp_r9_s::crit_exts_c_::to_json(json_writer& j) const {\n    j.start_obj();\n    switch (type_) {\n        case types::c1:\n            j.write_fieldname(\"c1\");\n            c1_.to_json(j);\n            break;\n        default:\n            log_invalid_choice_id(type_, \"ue_info_resp_r9_s::crit_exts_c_\");\n    }\n    j.end_obj();\n}",
        "baseline_code_stripped": "void __thiscall\nasn1::rrc::ue_info_resp_r9_s::crit_exts_c_::to_json(crit_exts_c_ *this,json_writer *param_1)\n{\n  int in_GS_OFFSET;\n  basic_string local_38 [24];\n  int local_20;\n  undefined4 uStack_14;\n  uStack_14 = 0x419753;\n  local_20 = *(int *)(in_GS_OFFSET + 0x14);\n  FUN_00312c70();\n  json_writer::start_obj(param_1,local_38);\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_dispose();\n  if (*(int *)this == 0) {\n    FUN_00312c70();\n    json_writer::write_fieldname(param_1,local_38);\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::_M_dispose();\n    c1_c_::to_json((c1_c_ *)(this + 4),param_1);\n  }\n  else if (*(int *)this != 1) {\n    FUN_00313473();\n  }\n  json_writer::end_obj(param_1);\n  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {\n    FUN_00597b50();\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.9497551918029785,
        "similarity_score_baseline_stripped": 0.7716028690338135
    },
    {
        "func_name": "unget_input",
        "normed_func_sha256": "2e37a5956d46754db74015aebfe2377200026db811e88bf6019961c95f553b2f",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_0804c34a(int *param_1,int param_2,int *param_3)\n{\n  uint uVar1;\n  memset(param_1,0,0x360);\n  uVar1 = *(uint *)(param_2 + 8);\n  *param_1 = param_2;\n  param_1[1] = (int)param_3;\n  if (0xb < uVar1) {\n    if (*param_3 != 2) {\n      FUN_0805d734();\n      return;\n    }\n    FUN_0804bed3();\n    return;\n  }\n  if (DAT_081378f4 == 0) {\n    return;\n  }\n  FUN_0805d734();\n  return;\n}\n\n Revised code:\nvoid DecodeEncPkt(Packet *p, struct pcap_pkthdr *pkthdr, u_int8_t *pkt)\n{\n    struct enc_header *enc_h;\n    PROFILE_VARS;\n\n    PREPROC_PROFILE_START(decodePerfStats);\n\n    bzero((char *)p, sizeof(Packet));\n    p->pkth = pkthdr;\n    p->pkt = pkt;\n\n    if (p->pkth->caplen < ENC_HEADER_LEN)\n    {\n        if (pv.verbose_flag)\n        {\n            ErrorMessage(\"Captured data length < Encap header length!  (%d bytes)\\n\", p->pkth->caplen);\n        }\n        PREPROC_PROFILE_END(decodePerfStats);\n        return;\n    }\n\n    enc_h = (struct enc_header *)p->pkt;\n    if (enc_h->af == AF_INET)\n    {\n        DecodeIP(p->pkt + ENC_HEADER_LEN + IP_HEADER_LEN,\n                 pkthdr->caplen - ENC_HEADER_LEN - IP_HEADER_LEN, p);\n    }\n    else\n    {\n        ErrorMessage(\"[!] WARNING: Unknown address family! (af: 0x%x)\\n\",\n                enc_h->af);\n    }\n    PREPROC_PROFILE_END(decodePerfStats);\n    return;\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_006baba0(uint param_1)\n{\n  uint uVar1;\n  ulong uVar2;\n  uVar1 = DAT_02e906cc + 2;\n  DAT_02e906cc = DAT_02e906cc + 4;\n  FUN_005196f0(0x14,(int)*(char *)(DAT_02ee0720 + 1 + (ulong)uVar1));\n  uVar2 = (ulong)DAT_02e906cc;\n  DAT_02e906cc = DAT_02e906cc + 2;\n  FUN_00525c20((param_1 >> 9 & 7) + 8,\n               *(ushort *)(DAT_02ee0720 + uVar2) << 8 | *(ushort *)(DAT_02ee0720 + uVar2) >> 8,0x15,\n               0x16);\n  FUN_00524cc0(0x15,0x14,0x16);\n  if (100 < DAT_02e906cc) {\n    FUN_00524130();\n  }\n  return 0;\n}\n\n Revised code:\nuae_u32 REGPARAM2 op_11bc_0_comp_nf(uae_u32 opcode)\n{\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n\tuae_u32 dodgy=0;\n\tuae_u32 m68k_pc_offset_thisinst=m68k_pc_offset;\n\tm68k_pc_offset+=2;\n{\tuae_u8 scratchie=S1;\n{\tint src = scratchie++;\n\tmov_l_ri(src,(uae_s32)(uae_s8)comp_get_ibyte((m68k_pc_offset+=2)-2));\n{\tint dsta=scratchie++;\n\tcalc_disp_ea_020(dstreg+8,comp_get_iword((m68k_pc_offset+=2)-2),dsta,scratchie);\n\twritebyte(dsta,src,scratchie);\n}}}\t if (m68k_pc_offset > SYNC_PC_OFFSET) sync_m68k_pc();\nreturn 0;\n}\n\n## Example:\n\n Input code:\nvoid FUN_080854d0(int param_1,uint param_2)\n{\n  uint uVar1;\n  if (param_1 == 3) {\nLAB_08085530:\n    uVar1 = DAT_081a9c3c + 1;\n    if (**(uint **)(DAT_081a9c28 + 0x40) <= uVar1 && uVar1 != **(uint **)(DAT_081a9c28 + 0x40)) {\n      FUN_08080270();\n      uVar1 = DAT_081a9c3c + 1;\n    }\n  }\n  else {\n    if (param_1 != 4) {\n      if (param_1 != 1) {\n        dcgettext(\"opcodes\",\"<internal disassembler error>\",5);\n        goto LAB_08085516;\n      }\n      goto LAB_08085530;\n    }\n    if ((param_2 & 1) == 0) {\n      FUN_08080450();\n      uVar1 = DAT_081a9c3c;\n    }\n    else {\n      FUN_08080490();\n      uVar1 = DAT_081a9c3c;\n    }\n  }\n  DAT_081a9c3c = uVar1;\n  DAT_081a9d60 = 0x24;\n  FUN_08081d00();\nLAB_08085516:\n  FUN_080806f0();\n  return;\n}\n\n Revised code:\nstatic void\nOP_sI (int bytemode, int sizeflag)\n{\n  bfd_signed_vma op;\n  switch (bytemode)\n    {\n    case b_mode:\n    case b_T_mode:\n      FETCH_DATA (the_info, codep + 1);\n      op = *codep++;\n      if ((op & 0x80) != 0)\n\top -= 0x100;\n      if (bytemode == b_T_mode)\n\t{\n\t  if (address_mode != mode_64bit\n\t      || !(sizeflag & DFLAG))\n\t    {\n\t      if (sizeflag & DFLAG)\n\t\top &= 0xffffffff;\n\t      else\n\t\top &= 0xffff;\n\t  }\n\t}\n      else\n\t{\n\t  if (!(rex & REX_W))\n\t    {\n\t      if (sizeflag & DFLAG)\n\t\top &= 0xffffffff;\n\t      else\n\t\top &= 0xffff;\n\t    }\n\t}\n      break;\n    case v_mode:\n      if (sizeflag & DFLAG)\n\top = get32s ();\n      else\n\top = get16 ();\n      break;\n    default:\n      oappend (INTERNAL_DISASSEMBLER_ERROR);\n      return;\n    }\n  scratchbuf[0] = '$';\n  print_operand_value (scratchbuf + 1, 1, op);\n  oappend (scratchbuf + intel_syntax);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_08064d30(void *param_1,uint param_2)\n{\n  uint uVar1;\n  FUN_080566d0(1);\n  FUN_080566d0(0);\n  if (param_2 != 0) {\n    uVar1 = param_2 + DAT_0806ec08;\n    if (uVar1 < DAT_0806ec08) {\n      param_2 = ~DAT_0806ec08;\n      uVar1 = DAT_0806ec08 + param_2;\n    }\n    DAT_0806ec08 = uVar1;\n    DAT_0806ec0c = (void *)FUN_08061660(DAT_0806ec0c,uVar1 << 2);\n    if (param_2 < DAT_0806ec08) {\n      memmove((void *)((int)DAT_0806ec0c + param_2 * 4),DAT_0806ec0c,(DAT_0806ec08 - param_2) * 4);\n    }\n    memcpy(DAT_0806ec0c,param_1,param_2 * 4);\n  }\n  return;\n}",
        "output": "```c\nvoid UpdateDataBuffer(void *data, uint size)\n{\n    uint newSize;\n    PerformOperation(1);\n    PerformOperation(0);\n\n    if (size != 0) {\n        newSize = size + CurrentBufferSize;\n\n        if (newSize < CurrentBufferSize) {\n            size = ~CurrentBufferSize;\n            newSize = CurrentBufferSize + size;\n        }\n\n        CurrentBufferSize = newSize;\n        DataBuffer = (void *)ResizeBuffer(DataBuffer, newSize * 4);\n\n        if (size < CurrentBufferSize) {\n            memmove((void *)((int)DataBuffer + size * 4), DataBuffer, (CurrentBufferSize - size) * 4);\n        }\n\n        memcpy(DataBuffer, data, size * 4);\n    }\n}\n```",
        "source_code": "void unget_input(int *input, size_t input_len)\n{\n#ifndef NANO_TINY\n    allow_pending_sigwinch(TRUE);\n    allow_pending_sigwinch(FALSE);\n#endif\n\n    /* If input is empty, get out. */\n    if (input_len == 0)\n\treturn;\n\n    /* If adding input would put the keystroke buffer beyond maximum\n     * capacity, only add enough of input to put it at maximum\n     * capacity. */\n    if (key_buffer_len + input_len < key_buffer_len)\n\tinput_len = (size_t)-1 - key_buffer_len;\n\n    /* Add the length of input to the length of the keystroke buffer,\n     * and reallocate the keystroke buffer so that it has enough room\n     * for input. */\n    key_buffer_len += input_len;\n    key_buffer = (int *)nrealloc(key_buffer, key_buffer_len *\n\tsizeof(int));\n\n    /* If the keystroke buffer wasn't empty before, move its beginning\n     * forward far enough so that we can add input to its beginning. */\n    if (key_buffer_len > input_len)\n\tmemmove(key_buffer + input_len, key_buffer,\n\t\t(key_buffer_len - input_len) * sizeof(int));\n\n    /* Copy input to the beginning of the keystroke buffer. */\n    memcpy(key_buffer, input, input_len * sizeof(int));\n}",
        "parsed_output": "void UpdateDataBuffer(void *data, uint size)\n{\n    uint newSize;\n    PerformOperation(1);\n    PerformOperation(0);\n\n    if (size != 0) {\n        newSize = size + CurrentBufferSize;\n\n        if (newSize < CurrentBufferSize) {\n            size = ~CurrentBufferSize;\n            newSize = CurrentBufferSize + size;\n        }\n\n        CurrentBufferSize = newSize;\n        DataBuffer = (void *)ResizeBuffer(DataBuffer, newSize * 4);\n\n        if (size < CurrentBufferSize) {\n            memmove((void *)((int)DataBuffer + size * 4), DataBuffer, (CurrentBufferSize - size) * 4);\n        }\n\n        memcpy(DataBuffer, data, size * 4);\n    }\n}",
        "baseline_code_stripped": "void FUN_08064d30(void *param_1,uint param_2)\n{\n  uint uVar1;\n  FUN_080566d0(1);\n  FUN_080566d0(0);\n  if (param_2 != 0) {\n    uVar1 = param_2 + DAT_0806ec08;\n    if (uVar1 < DAT_0806ec08) {\n      param_2 = ~DAT_0806ec08;\n      uVar1 = DAT_0806ec08 + param_2;\n    }\n    DAT_0806ec08 = uVar1;\n    DAT_0806ec0c = (void *)FUN_08061660(DAT_0806ec0c,uVar1 << 2);\n    if (param_2 < DAT_0806ec08) {\n      memmove((void *)((int)DAT_0806ec0c + param_2 * 4),DAT_0806ec0c,(DAT_0806ec08 - param_2) * 4);\n    }\n    memcpy(DAT_0806ec0c,param_1,param_2 * 4);\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.5898624658584595,
        "similarity_score_baseline_stripped": 0.49002379179000854
    },
    {
        "func_name": "_call_cbs_sharedPainter_c0_0",
        "normed_func_sha256": "3d70bda2c224e8b00bab87ac9cfa331b2377604ae9f06121934ba2e61e775543",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_0071017c(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  long in_FS_OFFSET;\n  undefined local_11;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_11 = FUN_0070a2c6(param_2);\n  FUN_0071a8e0(param_4,&local_11);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return;\n}\n\n Revised code:\nstatic void _call_fp_focusNextChild_0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) \n{\n  __SUPPRESS_UNUSED_WARNING(args);\n  ret.write<bool > ((bool)((QAbstractButton_Adaptor *)cls)->fp_QAbstractButton_focusNextChild_0 ());\n}\n\n## Example:\n\n Input code:\nvoid FUN_01248aca(undefined8 param_1,long *param_2,undefined8 param_3,undefined8 param_4)\n{\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = (**(code **)(*param_2 + 0x78))(param_2);\n  FUN_0071aa9c(param_4,&local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return;\n}\n\n Revised code:\nstatic void _call_f_minimumSizeHint_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) \n{\n  __SUPPRESS_UNUSED_WARNING(args);\n  ret.write<QSize > ((QSize)((QInputDialog *)cls)->minimumSizeHint ());\n}\n\n## Example:\n\n Input code:\nvoid FUN_013391f4(undefined8 param_1,long *param_2,undefined8 param_3,undefined8 param_4)\n{\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_14 = (**(code **)(*param_2 + 0x28))(param_2);\n  FUN_0094652c(param_4,&local_14);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return;\n}\n\n Revised code:\nstatic void _call_f_expandingDirections_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) \n{\n  __SUPPRESS_UNUSED_WARNING(args);\n  ret.write<QFlags<Qt::Orientation> > ((QFlags<Qt::Orientation>)((QLayoutItem *)cls)->expandingDirections ());\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_01652240(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = FUN_01649c64(param_2);\n  FUN_007208fa(param_4,&local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return;\n}",
        "output": "```c\nstatic void _call_f_sizeHint_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) \n{\n  __SUPPRESS_UNUSED_WARNING(args);\n  ret.write<QSize > ((QSize)((QWidget *)cls)->sizeHint ());\n}\n```",
        "source_code": "static void _call_cbs_sharedPainter_c0_0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) \n{\n  __SUPPRESS_UNUSED_WARNING(args);\n  ret.write<QPainter * > ((QPainter *)((QRadioButton_Adaptor *)cls)->cbs_sharedPainter_c0_0 ());\n}",
        "parsed_output": "static void _call_f_sizeHint_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) \n{\n  __SUPPRESS_UNUSED_WARNING(args);\n  ret.write<QSize > ((QSize)((QWidget *)cls)->sizeHint ());\n}",
        "baseline_code_stripped": "void FUN_01652240(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = FUN_01649c64(param_2);\n  FUN_007208fa(param_4,&local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return;\n}",
        "similarity_score_unixcoder": 0.7437229156494141,
        "similarity_score_baseline_stripped": 0.36233919858932495
    },
    {
        "func_name": "phi12",
        "normed_func_sha256": "cdfd3a3d8c365e64ec130fffb0a304c1bd1f92c6ccc855f6754f4f04a5a4dcb0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_00345ae0(long param_1,uint param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5\n                 ,undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9,\n                 undefined4 param_10,undefined8 param_11)\n{\n  long lVar1;\n  long lVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  double dVar5;\n  lVar1 = FUN_00841300();\n  lVar2 = FUN_00a20af0();\n  uVar3 = lVar2 - *(long *)(lVar1 + 0x4f8);\n  if ((long)uVar3 < 0) {\n    dVar5 = (double)(uVar3 >> 1 | (ulong)((uint)uVar3 & 1));\n    dVar5 = dVar5 + dVar5;\n  }\n  else {\n    dVar5 = (double)uVar3;\n  }\n  dVar5 = (dVar5 * 1000.0) / *(double *)(lVar1 + 0x4f0);\n  if (9.223372036854776e+18 <= dVar5) {\n    *(long *)(param_1 + 0xc88) = (long)(dVar5 - 9.223372036854776e+18);\n    *(ulong *)(param_1 + 0xc88) = *(ulong *)(param_1 + 0xc88) ^ 0x8000000000000000;\n  }\n  else {\n    *(long *)(param_1 + 0xc88) = (long)dVar5;\n  }\n  (*DAT_00d160c8)(param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,param_10,param_11)\n  ;\n  lVar1 = FUN_00841300();\n  lVar2 = FUN_00a20af0();\n  uVar3 = lVar2 - *(long *)(lVar1 + 0x4f8);\n  if ((long)uVar3 < 0) {\n    dVar5 = (double)(uVar3 >> 1 | (ulong)((uint)uVar3 & 1));\n    dVar5 = dVar5 + dVar5;\n  }\n  else {\n    dVar5 = (double)uVar3;\n  }\n  dVar5 = (dVar5 * 1000.0) / *(double *)(lVar1 + 0x4f0);\n  if (9.223372036854776e+18 <= dVar5) {\n    uVar3 = (long)(dVar5 - 9.223372036854776e+18) ^ 0x8000000000000000;\n  }\n  else {\n    uVar3 = (ulong)dVar5;\n  }\n  *(ulong *)(param_1 + 0xc80) = uVar3 - *(long *)(param_1 + 0xc88);\n  if (1 < *(int *)(param_1 + 0x5c) - 3U) {\n    return;\n  }\n  uVar4 = *(undefined8 *)(param_1 + 0xe80);\n  lVar1 = FUN_001e4470(param_1);\n  uVar4 = FUN_00293ce0(uVar4,*(undefined8 *)(lVar1 + 8),(ulong)param_2 << 0x20 | 2);\n  FUN_003457c0(param_1,uVar4,param_3,param_4,param_5,param_6);\n  return;\n}\n\n Revised code:\nvoid WrappedOpenGL::glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset,\n                                           GLint yoffset, GLsizei width, GLsizei height,\n                                           GLenum format, GLenum type, const void *pixels)\n{\n  SERIALISE_TIME_CALL(GL.glTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width,\n                                                height, format, type, pixels));\n\n  if(IsCaptureMode(m_State))\n    Common_glTextureSubImage2DEXT(\n        GetResourceManager()->GetResourceRecord(TextureRes(GetCtx(), texture)), target, level,\n        xoffset, yoffset, width, height, format, type, pixels);\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_001ed460(undefined8 param_1,long param_2,long param_3)\n{\n  long *plVar1;\n  long lVar2;\n  long lVar3;\n  undefined8 uVar4;\n  long lVar5;\n  if ((DAT_002c89b8 == '\\x0f') && (*(char *)(param_2 + 0x538) == '\\0')) {\n    FUN_001724e0(param_2);\n  }\n  FUN_001acd90(param_2);\n  FUN_001acd70(param_2);\n  uVar4 = FUN_0015a4e0(0x73);\n  if (param_3 != 0) {\n    FUN_0014cad0(*(undefined8 *)(param_3 + 8),&DAT_0024d300);\n  }\n  FUN_001ecf70(param_2,uVar4);\n  if (*(long *)(*(long *)(param_2 + 0x10) + 0x60) != 0) {\n    FUN_0015a680(uVar4);\n  }\n  if (((*(long *)(param_2 + 8) != 0) &&\n      (plVar1 = *(long **)(*(long *)(param_2 + 8) + 0x108), plVar1 != (long *)0x0)) &&\n     (lVar2 = *plVar1, 0 < lVar2)) {\n    lVar5 = 0;\n    do {\n      lVar3 = lVar5 + 2;\n      lVar5 = lVar5 + 1;\n      FUN_00209cd0(param_1,plVar1[lVar3],1);\n    } while (lVar2 != lVar5);\n  }\n  FUN_001aa4b0(param_2);\n  *(undefined8 *)(param_2 + 0x30) = *(undefined8 *)(*(long *)(param_2 + 0x30) + 0x30);\n  if (*(long *)(param_2 + 0x550) != 0) {\n    FUN_001ed240(param_2);\n  }\n  return uVar4;\n}\n\n Revised code:\nN_LIB_PRIVATE N_NIMCALL(tyObject_TNode_bROa11lyF5vxEN9aYNbHmhw*, myClose_MUB8De3X2uYMDYQC7BTJ0w)(tyObject_ModuleGraphcolonObjectType__RZI3hCs0FTPYx8StfC81qQ* graph, tyObject_TPassContext_qNsm39cWb35W2r5AAd9ch87g* context, tyObject_TNode_bROa11lyF5vxEN9aYNbHmhw* n) {\n\ttyObject_TNode_bROa11lyF5vxEN9aYNbHmhw* result;\n\ttyObject_TContext_5TfOJKwTttj3W1t1tMzWUQ* c;\n\tresult = (tyObject_TNode_bROa11lyF5vxEN9aYNbHmhw*)0;\n\tc = ((tyObject_TContext_5TfOJKwTttj3W1t1tMzWUQ*) (context));\n\t{\n\t\tNIM_BOOL T3_;\n\t\tT3_ = (NIM_BOOL)0;\n\t\tT3_ = (gCmd_0oKScFtMiSKnjiHF9cU9c5GQ == ((tyEnum_TCommands_VH3ghgQVwLSg3krOAoXigw) 15));\n\t\tif (!(T3_)) goto LA4_;\n\t\tT3_ = !((*c).suggestionsMade);\n\t\tLA4_: ;\n\t\tif (!T3_) goto LA5_;\n\t\tsuggestSentinel_FIW7zCmUb6csB9aUVrWGDwQ(c);\n\t}\n\tLA5_: ;\n\tcloseScope_r2b7lx9cCbS9b0TH9b5UCNxAA(c);\n\trawCloseScope_xwamnOIxoPUrnfhDEzqSwQ(c);\n\tresult = newNode_IgnRxkID5wXTWvTZf9ct0rA(((tyEnum_TNodeKind_G4E4Gxe7oI2Cm03rkiOzQw) 115));\n\t{\n\t\tif (!!((n == NIM_NIL))) goto LA9_;\n\t\tinternalError_MXmtqrCmYwtOPkDCFgUWKQ((*n).info, ((NimStringDesc*) &TM_rF9caJawfOjYTjsgLVUSGFA_339));\n\t}\n\tLA9_: ;\n\taddCodeForGenerics_jzk1KGIc0vzv6pth3zm9bkw_10(c, result);\n\t{\n\t\tif (!!(((*(*c).module).ast == NIM_NIL))) goto LA13_;\n\t\tadd_gCCf68XrWL79bKes6htzFjQ_2(result, (*(*c).module).ast);\n\t}\n\tLA13_: ;\n\t{\n\t\tif (!!(((*c).Sup.rd == NIM_NIL))) goto LA17_;\n\t\treplayMethodDefs_pLOND8cbjAn0qCZSuKfJSg(graph, (*c).Sup.rd);\n\t}\n\tLA17_: ;\n\tpopOwner_GUp9bqvzgKkpf9bPbbUJGyQg(c);\n\tpopProcCon_JpIn6HCQok16g8frnWqg6Qsem(c);\n\t{\n\t\tif (!!(((*c).runnableExamples == NIM_NIL))) goto LA21_;\n\t\ttestExamples_Q86WPqYQzpDHXTptcEdXFQ_2(c);\n\t}\n\tLA21_: ;\n\treturn result;\n}\n\n## Example:\n\n Input code:\nundefined8 *\nFUN_140141f68(undefined8 *param_1,longlong param_2,undefined8 param_3,undefined8 param_4,\n             float param_5,undefined4 param_6,undefined4 param_7)\n{\n  undefined8 uVar1;\n  undefined4 uVar2;\n  longlong lVar3;\n  uVar2 = 0;\n  FUN_140143804(param_1,param_2,1,0,0);\n  *param_1 = CLaser::vftable;\n  param_1[6] = param_3;\n  *(undefined4 *)((longlong)param_1 + 0x7c) = param_6;\n  *(float *)(param_1 + 0xe) = param_5;\n  if ((*(char *)(param_2 + 0x4ea) != '\\0') && (param_5 < 10.0)) {\n    *(undefined4 *)(param_1 + 0xe) = 0x44480000;\n  }\n  param_1[0xd] = param_4;\n  *(undefined8 *)((longlong)param_1 + 0x74) = 0;\n  *(undefined4 *)((longlong)param_1 + 0x8c) = param_7;\n  *(undefined *)(param_1 + 0x10) = 0;\n  lVar3 = param_1[3];\n  if (*(char *)(lVar3 + 0x4f7) != '\\0') {\n    uVar1 = *(undefined8 *)(lVar3 + 0x4e0);\n    uVar2 = FUN_14025d300(uVar1,param_3);\n    uVar2 = FUN_14025efd8(uVar1,uVar2);\n    lVar3 = param_1[3];\n  }\n  *(undefined4 *)(param_1 + 0x12) = uVar2;\n  FUN_140144bbc(lVar3,param_1,0);\n  FUN_1401420ac(param_1);\n  return param_1;\n}\n\n Revised code:\nCLaser::CLaser(CGameWorld *pGameWorld, vec2 Pos, vec2 Direction, float StartEnergy, int Owner, int Type) :\n\tCEntity(pGameWorld, CGameWorld::ENTTYPE_LASER)\n{\n\tm_Pos = Pos;\n\tm_Owner = Owner;\n\tm_Energy = StartEnergy;\n\tif(pGameWorld->m_WorldConfig.m_IsFNG && m_Energy < 10.f)\n\t\tm_Energy = 800.0f;\n\tm_Dir = Direction;\n\tm_Bounces = 0;\n\tm_EvalTick = 0;\n\tm_Type = Type;\n\tm_ZeroEnergyBounceInLastTick = false;\n\tm_TuneZone = GameWorld()->m_WorldConfig.m_UseTuneZones ? Collision()->IsTune(Collision()->GetMapIndex(m_Pos)) : 0;\n\tGameWorld()->InsertEntity(this);\n\tDoBounce();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_1802a5f00(undefined8 *param_1,double *param_2,double *param_3)\n{\n  longlong lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int iVar4;\n  undefined8 uVar5;\n  double dVar6;\n  lVar1 = param_1[10];\n  iVar4 = FUN_1800ac760(*param_1,param_1[2],\"tlat_1\");\n  if ((iVar4 == 0) || (iVar4 = FUN_1800ac760(*param_1,param_1[2],\"tlat_2\"), iVar4 == 0)) {\n    return 0xffffffd7;\n  }\n  uVar5 = FUN_1800ac760(*param_1,param_1[2],\"rlat_1\");\n  uVar2 = param_1[2];\n  uVar3 = *param_1;\n  *(undefined8 *)(lVar1 + 0x48) = uVar5;\n  dVar6 = (double)FUN_1800ac760(uVar3,uVar2,\"rlat_2\");\n  *(double *)(lVar1 + 0x50) = dVar6;\n  *param_2 = (dVar6 - *(double *)(lVar1 + 0x48)) * 0.5;\n  dVar6 = (*(double *)(lVar1 + 0x50) + *(double *)(lVar1 + 0x48)) * 0.5;\n  *param_3 = dVar6;\n  if ((1e-10 <= (double)((ulonglong)*param_2 & 0x7fffffffffffffff)) &&\n     (1e-10 <= (double)((ulonglong)dVar6 & 0x7fffffffffffffff))) {\n    return 0;\n  }\n  return 0xffffffd6;\n}",
        "output": "```c\nint CalculateLatitudes(DataStruct *data, double *halfRange, double *midPoint) {\n    longlong dataOffset = data->offset;\n    int result;\n\n    // Check for required latitude keys\n    result = CheckKey(data->main, data->sub, \"tlat_1\");\n    if (result == 0 || (result = CheckKey(data->main, data->sub, \"tlat_2\")) == 0) {\n        return -41; // Error code 0xffffffd7\n    }\n\n    // Retrieve latitude values\n    double rlat1 = CheckKey(data->main, data->sub, \"rlat_1\");\n    double rlat2 = (double)CheckKey(data->main, data->sub, \"rlat_2\");\n\n    // Store values in the data structure\n    *(double *)(dataOffset + 0x48) = rlat1;\n    *(double *)(dataOffset + 0x50) = rlat2;\n\n    // Calculate half range and midpoint\n    *halfRange = (rlat2 - rlat1) * 0.5;\n    *midPoint = (rlat2 + rlat1) * 0.5;\n\n    // Validate calculated values\n    if ((fabs(*halfRange) >= 1e-10) && (fabs(*midPoint) >= 1e-10)) {\n        return 0; // Success\n    }\n\n    return -42; // Error code 0xffffffd6\n}\n```",
        "source_code": "static int phi12(PJ *P, double *del, double *sig) {\n    struct pj_opaque *Q = P->opaque;\n    int err = 0;\n\n    if (!pj_param(P->ctx, P->params, \"tlat_1\").i ||\n        !pj_param(P->ctx, P->params, \"tlat_2\").i) {\n        err = PJD_ERR_LAT_1_2_UNSPECIFIED;\n    } else {\n        Q->phi_1 = pj_param(P->ctx, P->params, \"rlat_1\").f;\n        Q->phi_2 = pj_param(P->ctx, P->params, \"rlat_2\").f;\n        *del = 0.5 * (Q->phi_2 - Q->phi_1);\n        *sig = 0.5 * (Q->phi_2 + Q->phi_1);\n        err = (fabs(*del) < EPS || fabs(*sig) < EPS) ? PJD_ERR_ABS_LAT1_EQ_ABS_LAT2 : 0;\n    }\n    return err;\n}",
        "parsed_output": "int CalculateLatitudes(DataStruct *data, double *halfRange, double *midPoint) {\n    longlong dataOffset = data->offset;\n    int result;\n\n    // Check for required latitude keys\n    result = CheckKey(data->main, data->sub, \"tlat_1\");\n    if (result == 0 || (result = CheckKey(data->main, data->sub, \"tlat_2\")) == 0) {\n        return -41; // Error code 0xffffffd7\n    }\n\n    // Retrieve latitude values\n    double rlat1 = CheckKey(data->main, data->sub, \"rlat_1\");\n    double rlat2 = (double)CheckKey(data->main, data->sub, \"rlat_2\");\n\n    // Store values in the data structure\n    *(double *)(dataOffset + 0x48) = rlat1;\n    *(double *)(dataOffset + 0x50) = rlat2;\n\n    // Calculate half range and midpoint\n    *halfRange = (rlat2 - rlat1) * 0.5;\n    *midPoint = (rlat2 + rlat1) * 0.5;\n\n    // Validate calculated values\n    if ((fabs(*halfRange) >= 1e-10) && (fabs(*midPoint) >= 1e-10)) {\n        return 0; // Success\n    }\n\n    return -42; // Error code 0xffffffd6\n}",
        "baseline_code_stripped": "undefined8 FUN_1802a5f00(undefined8 *param_1,double *param_2,double *param_3)\n{\n  longlong lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int iVar4;\n  undefined8 uVar5;\n  double dVar6;\n  lVar1 = param_1[10];\n  iVar4 = FUN_1800ac760(*param_1,param_1[2],\"tlat_1\");\n  if ((iVar4 == 0) || (iVar4 = FUN_1800ac760(*param_1,param_1[2],\"tlat_2\"), iVar4 == 0)) {\n    return 0xffffffd7;\n  }\n  uVar5 = FUN_1800ac760(*param_1,param_1[2],\"rlat_1\");\n  uVar2 = param_1[2];\n  uVar3 = *param_1;\n  *(undefined8 *)(lVar1 + 0x48) = uVar5;\n  dVar6 = (double)FUN_1800ac760(uVar3,uVar2,\"rlat_2\");\n  *(double *)(lVar1 + 0x50) = dVar6;\n  *param_2 = (dVar6 - *(double *)(lVar1 + 0x48)) * 0.5;\n  dVar6 = (*(double *)(lVar1 + 0x50) + *(double *)(lVar1 + 0x48)) * 0.5;\n  *param_3 = dVar6;\n  if ((1e-10 <= (double)((ulonglong)*param_2 & 0x7fffffffffffffff)) &&\n     (1e-10 <= (double)((ulonglong)dVar6 & 0x7fffffffffffffff))) {\n    return 0;\n  }\n  return 0xffffffd6;\n}",
        "similarity_score_unixcoder": 0.5633198022842407,
        "similarity_score_baseline_stripped": 0.6588954329490662
    },
    {
        "func_name": "_brick_for_each",
        "normed_func_sha256": "386b8dbb74bd68b2e21d780bf784c69d5c4a8ebad1b91f2da137479072a29155",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined8 FUN_001426f0(long param_1,undefined8 param_2,undefined8 param_3,code *param_4)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  puVar1 = (undefined8 *)__glusterfs_this_location();\n  plVar3 = *(long **)(param_1 + 0x2c0);\n  puVar1 = (undefined8 *)*puVar1;\n  while( true ) {\n    if ((long *)(param_1 + 0x2c0) == plVar3) {\n      return 0;\n    }\n    _gf_msg(*puVar1,\"glusterd-utils.c\",\"_brick_for_each\",0xb4,8,0,0,0,\"Found a brick - %s:%s\",\n            plVar3 + -0x9a0,plVar3 + -0x920);\n    uVar2 = (*param_4)(param_1,plVar3 + -0x9a0,param_2,param_3);\n    if ((int)uVar2 != 0) break;\n    plVar3 = (long *)*plVar3;\n  }\n  return uVar2;\n}\n\n Revised code:\nstatic int\n_brick_for_each (glusterd_volinfo_t *volinfo, dict_t *mod_dict,\n                         void *data,\n               int (*fn) (glusterd_volinfo_t *, glusterd_brickinfo_t *,\n                          dict_t *mod_dict, void *))\n{\n        int                  ret        = 0;\n        glusterd_brickinfo_t *brickinfo = NULL;\n        xlator_t             *this = THIS;\n\n        cds_list_for_each_entry (brickinfo, &volinfo->bricks, brick_list) {\n                gf_msg_debug (this->name, 0, \"Found a brick - %s:%s\",\n                              brickinfo->hostname, brickinfo->path);\n                ret = fn (volinfo, brickinfo, mod_dict, data);\n                if (ret)\n                        goto out;\n        }\nout:\n        return ret;\n}\n\n## Example:\n\n Input code:\nvoid FUN_0043a050(long param_1)\n{\n  undefined8 uVar1;\n  long *plVar2;\n  undefined8 *puVar3;\n  long **pplVar4;\n  puVar3 = *(undefined8 **)(param_1 + 0x38);\n  if (puVar3 != *(undefined8 **)(param_1 + 0x40)) {\n    do {\n      uVar1 = *puVar3;\n      puVar3 = puVar3 + 1;\n      FUN_00438d50(uVar1,param_1 + 0x38);\n    } while (*(undefined8 **)(param_1 + 0x40) != puVar3);\n  }\n  pplVar4 = *(long ***)(param_1 + 0x50);\n  if (pplVar4 != *(long ***)(param_1 + 0x58)) {\n    do {\n      while( true ) {\n        plVar2 = *pplVar4;\n        if (*(code **)(*plVar2 + 0x98) == FUN_0043e560) break;\n        pplVar4 = pplVar4 + 1;\n        (**(code **)(*plVar2 + 0x98))(plVar2,param_1 + 0x38);\n        if (*(long ***)(param_1 + 0x58) == pplVar4) {\n          return;\n        }\n      }\n      pplVar4 = pplVar4 + 1;\n      FUN_00438b50(plVar2 + 5,param_1 + 0x38);\n    } while (*(long ***)(param_1 + 0x58) != pplVar4);\n  }\n  return;\n}\n\n Revised code:\nvoid VariableManager::reindex_all()\n{\n    for (vector<Variable*>::iterator i = variables_.begin();\n            i != variables_.end(); ++i)\n        (*i)->set_var_idx(variables_);\n    for (vector<Function*>::iterator i = functions_.begin();\n            i != functions_.end(); ++i) {\n        (*i)->update_var_indices(variables_);\n    }\n}\n\n## Example:\n\n Input code:\nvoid FUN_05a7b970(undefined8 param_1,undefined8 *param_2,undefined8 param_3,undefined4 param_4,\n                 undefined4 param_5)\n{\n  long lVar1;\n  undefined4 *puVar2;\n  puVar2 = (undefined4 *)*param_2;\n  if (puVar2 != (undefined4 *)param_2[1]) {\n    do {\n      lVar1 = FUN_05a7c9d0(*puVar2);\n      if (lVar1 != 0) {\n        FUN_05a7cbf0(lVar1,param_3,param_4,param_5);\n      }\n      puVar2 = puVar2 + 1;\n    } while ((undefined4 *)param_2[1] != puVar2);\n  }\n  return;\n}\n\n Revised code:\nvoid AppCacheFrontendImpl::OnProgressEventRaised(\n    const std::vector<int>& host_ids,\n    const GURL& url,\n    int num_total,\n    int num_complete) {\n  for (std::vector<int>::const_iterator i = host_ids.begin();\n       i != host_ids.end(); ++i) {\n    WebApplicationCacheHostImpl* host = GetHost(*i);\n    if (host)\n      host->OnProgressEventRaised(url, num_total, num_complete);\n  }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 FUN_001562bf(long param_1,undefined8 param_2,undefined8 param_3,code *param_4)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  plVar3 = *(long **)(param_1 + 0x78);\n  if (plVar3 == (long *)(param_1 + 0x78)) {\n    uVar2 = 0;\n  }\n  else {\n    do {\n      puVar1 = (undefined8 *)__glusterfs_this_location();\n      _gf_msg(*(undefined8 *)*puVar1,\"glusterd-utils.c\",\"_brick_for_each\",0x179,8,0,0,0,\n              \"Found a brick - %s:%s\",(long)plVar3 + 0x9c,(long)plVar3 + 0x19b);\n      uVar2 = (*param_4)(param_1,plVar3,param_2,param_3);\n      if ((int)uVar2 != 0) {\n        return uVar2;\n      }\n      plVar3 = (long *)*plVar3;\n    } while (plVar3 != (long *)(param_1 + 0x78));\n  }\n  return uVar2;\n}",
        "output": "```c\nstatic int\n_brick_for_each(glusterd_volinfo_t *volinfo, dict_t *mod_dict, void *data,\n                int (*fn)(glusterd_volinfo_t *, glusterd_brickinfo_t *, dict_t *, void *))\n{\n    int ret = 0;\n    glusterd_brickinfo_t *brickinfo = NULL;\n    xlator_t *this = THIS;\n\n    cds_list_for_each_entry(brickinfo, &volinfo->bricks, brick_list) {\n        gf_msg_debug(this->name, 0, \"Found a brick - %s:%s\",\n                     brickinfo->hostname, brickinfo->path);\n        ret = fn(volinfo, brickinfo, mod_dict, data);\n        if (ret)\n            return ret;\n    }\n\n    return ret;\n}\n```",
        "source_code": "static int\n_brick_for_each(glusterd_volinfo_t *volinfo, dict_t *mod_dict, void *data,\n                int (*fn)(glusterd_volinfo_t *, glusterd_brickinfo_t *,\n                          dict_t *mod_dict, void *))\n{\n    int ret = 0;\n    glusterd_brickinfo_t *brickinfo = NULL;\n\n    cds_list_for_each_entry(brickinfo, &volinfo->bricks, brick_list)\n    {\n        gf_msg_debug(THIS->name, 0, \"Found a brick - %s:%s\",\n                     brickinfo->hostname, brickinfo->path);\n        ret = fn(volinfo, brickinfo, mod_dict, data);\n        if (ret)\n            goto out;\n    }\nout:\n    return ret;\n}",
        "parsed_output": "static int\n_brick_for_each(glusterd_volinfo_t *volinfo, dict_t *mod_dict, void *data,\n                int (*fn)(glusterd_volinfo_t *, glusterd_brickinfo_t *, dict_t *, void *))\n{\n    int ret = 0;\n    glusterd_brickinfo_t *brickinfo = NULL;\n    xlator_t *this = THIS;\n\n    cds_list_for_each_entry(brickinfo, &volinfo->bricks, brick_list) {\n        gf_msg_debug(this->name, 0, \"Found a brick - %s:%s\",\n                     brickinfo->hostname, brickinfo->path);\n        ret = fn(volinfo, brickinfo, mod_dict, data);\n        if (ret)\n            return ret;\n    }\n\n    return ret;\n}",
        "baseline_code_stripped": "undefined8 FUN_001562bf(long param_1,undefined8 param_2,undefined8 param_3,code *param_4)\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  plVar3 = *(long **)(param_1 + 0x78);\n  if (plVar3 == (long *)(param_1 + 0x78)) {\n    uVar2 = 0;\n  }\n  else {\n    do {\n      puVar1 = (undefined8 *)__glusterfs_this_location();\n      _gf_msg(*(undefined8 *)*puVar1,\"glusterd-utils.c\",\"_brick_for_each\",0x179,8,0,0,0,\n              \"Found a brick - %s:%s\",(long)plVar3 + 0x9c,(long)plVar3 + 0x19b);\n      uVar2 = (*param_4)(param_1,plVar3,param_2,param_3);\n      if ((int)uVar2 != 0) {\n        return uVar2;\n      }\n      plVar3 = (long *)*plVar3;\n    } while (plVar3 != (long *)(param_1 + 0x78));\n  }\n  return uVar2;\n}",
        "similarity_score_unixcoder": 0.9846038222312927,
        "similarity_score_baseline_stripped": 0.6788983941078186
    },
    {
        "func_name": "RadiosondeGUI::handleMessage",
        "normed_func_sha256": "577d08d89cc8a5cb466f07eb96973e83d917f7165c7dcbd4092e30504be6a41d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __thiscall ChatForm::insertChatMessage(ChatForm *this,shared_ptr param_1)\n{\n  uint uVar1;\n  long lVar2;\n  uint *puVar3;\n  uint uVar4;\n  undefined7 in_register_00000031;\n  undefined4 *puVar5;\n  int iVar6;\n  long in_FS_OFFSET;\n  undefined4 local_38;\n  undefined4 uStack_34;\n  undefined4 uStack_30;\n  undefined4 uStack_2c;\n  long local_20;\n  puVar5 = (undefined4 *)CONCAT71(in_register_00000031,param_1);\n  local_38 = *puVar5;\n  uStack_34 = puVar5[1];\n  uStack_30 = puVar5[2];\n  uStack_2c = puVar5[3];\n  lVar2 = *(long *)(puVar5 + 2);\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (lVar2 != 0) {\n    if (__libc_single_threaded == '\\0') {\n      LOCK();\n      *(int *)(lVar2 + 8) = *(int *)(lVar2 + 8) + 1;\n      UNLOCK();\n    }\n    else {\n      *(int *)(lVar2 + 8) = *(int *)(lVar2 + 8) + 1;\n    }\n  }\n  GenericChatForm::insertChatMessage((GenericChatForm *)this,SUB81(&local_38,0));\n  if ((_Sp_counted_base____gnu_cxx___Lock_policy_2_ *)CONCAT44(uStack_2c,uStack_30) !=\n      (_Sp_counted_base____gnu_cxx___Lock_policy_2_ *)0x0) {\n    std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release\n              ((_Sp_counted_base____gnu_cxx___Lock_policy_2_ *)CONCAT44(uStack_2c,uStack_30));\n  }\n  if (*(long *)(this + 0xf8) != 0) {\n    iVar6 = (int)&local_38;\n    QSplitter::sizes();\n    puVar3 = (uint *)CONCAT44(uStack_34,local_38);\n    if ((int)(puVar3[3] - puVar3[2]) < 2) {\n      QList<DhtServer>::operator__(iVar6);\n    }\n    if (*puVar3 < 2) {\n      uVar4 = puVar3[(long)(int)puVar3[2] * 2 + 6];\n      uVar1 = *puVar3;\n      if (uVar1 == 0) goto LAB_00285bbc;\nLAB_00285bb1:\n      if (uVar1 != 0xffffffff) {\n        LOCK();\n        *puVar3 = *puVar3 - 1;\n        UNLOCK();\n        if (*puVar3 == 0) goto LAB_00285bbc;\n      }\n    }\n    else {\n      QList<QComboBox*>::detach_helper((int)&local_38);\n      puVar3 = (uint *)CONCAT44(uStack_34,local_38);\n      uVar4 = puVar3[(long)(int)puVar3[2] * 2 + 6];\n      uVar1 = *puVar3;\n      if (uVar1 != 0) goto LAB_00285bb1;\nLAB_00285bbc:\n      QListData::dispose((Data *)CONCAT44(uStack_34,local_38));\n    }\n    if (uVar4 == 0) {\n      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        GenericNetCamView::setShowMessages(*(GenericNetCamView **)(this + 0xf8),true,true);\n        return;\n      }\n      goto LAB_00285c3a;\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\nLAB_00285c3a:\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid ChatForm::insertChatMessage(ChatMessage::Ptr msg)\n{\n    GenericChatForm::insertChatMessage(msg);\n    if (netcam && bodySplitter->sizes()[1] == 0) {\n        netcam->setShowMessages(true, true);\n    }\n}\n\n## Example:\n\n Input code:\nundefined8 * ArchiveModel::headerData(int param_1,Orientation param_2,int param_3)\n{\n  long lVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  QTextStream **ppQVar4;\n  undefined4 in_register_00000034;\n  undefined4 in_register_0000003c;\n  int in_R8D;\n  long in_FS_OFFSET;\n  QDebug local_60 [8];\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  long local_30;\n  puVar2 = (undefined8 *)CONCAT44(in_register_0000003c,param_1);\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (in_R8D == 0) {\n    lVar3 = *(long *)(CONCAT44(in_register_00000034,param_2) + 0x20);\n    if (param_3 < *(int *)(lVar3 + 0xc) - *(int *)(lVar3 + 8)) {\n      lVar1 = (long)*(int *)(lVar3 + 8) + (long)param_3;\n      if (*(uint *)(lVar3 + 0x10 + lVar1 * 8) < 0xc) {\n        puVar2 = (undefined8 *)\n                 (*(code *)(&DAT_001432a0 +\n                           *(int *)(&DAT_001432a0 + (ulong)*(uint *)(lVar3 + 0x10 + lVar1 * 8) * 4))\n                 )();\n        return puVar2;\n      }\n      i18ndc((char *)&local_58,\"Unnamed column\",\"??\");\n      QVariant::QVariant((QVariant *)puVar2,(QString *)&local_58);\n      QString::_QString((QString *)&local_58);\n      goto LAB_001337d1;\n    }\n    lVar3 = ARK();\n    if (*(char *)(lVar3 + 0x10) != '\\0') {\n      lVar3 = ARK();\n      local_40 = *(undefined8 *)(lVar3 + 8);\n      local_58 = 2;\n      local_50 = 0;\n      local_48 = 0;\n      QMessageLogger::debug();\n      ppQVar4 = (QTextStream **)QDebug::operator__(local_60,\"WEIRD: showColumns.size = \");\n      lVar3 = *(long *)(CONCAT44(in_register_00000034,param_2) + 0x20);\n      QTextStream::operator__(*ppQVar4,*(int *)(lVar3 + 0xc) - *(int *)(lVar3 + 8));\n      if ((*ppQVar4)[0x20] != (QTextStream)0x0) {\n        QTextStream::operator__(*ppQVar4,' ');\n      }\n      ppQVar4 = (QTextStream **)QDebug::operator__((QDebug *)ppQVar4,\" and section = \");\n      QTextStream::operator__(*ppQVar4,param_3);\n      if ((*ppQVar4)[0x20] != (QTextStream)0x0) {\n        QTextStream::operator__(*ppQVar4,' ');\n      }\n      QDebug::_QDebug(local_60);\n    }\n  }\n  *puVar2 = 0;\n  *(undefined4 *)(puVar2 + 1) = 0x80000000;\nLAB_001337d1:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar2;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nQVariant ArchiveModel::headerData(int section, Qt::Orientation, int role) const\n{\n    if (role == Qt::DisplayRole) {\n        if (section >= m_showColumns.size()) {\n            qCDebug(ARK) << \"WEIRD: showColumns.size = \" << m_showColumns.size()\n            << \" and section = \" << section;\n            return QVariant();\n        }\n\n        int columnId = m_showColumns.at(section);\n\n        switch (columnId) {\n        case FullPath:\n            return i18nc(\"Name of a file inside an archive\", \"Name\");\n        case Size:\n            return i18nc(\"Uncompressed size of a file inside an archive\", \"Size\");\n        case CompressedSize:\n            return i18nc(\"Compressed size of a file inside an archive\", \"Compressed\");\n        case Ratio:\n            return i18nc(\"Compression rate of file\", \"Rate\");\n        case Owner:\n            return i18nc(\"File's owner username\", \"Owner\");\n        case Group:\n            return i18nc(\"File's group\", \"Group\");\n        case Permissions:\n            return i18nc(\"File permissions\", \"Mode\");\n        case CRC:\n            return i18nc(\"CRC hash code\", \"CRC checksum\");\n        case BLAKE2:\n            return i18nc(\"BLAKE2 hash code\", \"BLAKE2 checksum\");\n        case Method:\n            return i18nc(\"Compression method\", \"Method\");\n        case Version:\n            // TODO: what exactly is a file version?\n            return i18nc(\"File version\", \"Version\");\n        case Timestamp:\n            return i18nc(\"Timestamp\", \"Date\");\n        default:\n            return i18nc(\"Unnamed column\", \"??\");\n        }\n    }\n    return QVariant();\n}\n\n## Example:\n\n Input code:\nvoid FUN_001ca410(long param_1,undefined4 param_2)\n{\n  QTextStream *this;\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  QTextStream *local_68;\n  int *local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  char *local_40;\n  long local_30;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_58 = 2;\n  local_40 = \"default\";\n  local_50 = 0;\n  local_48 = 0;\n  QMessageLogger::debug();\n  this = local_68;\n  QString::fromUtf8_helper((char *)&local_60,0x2c97a0);\n  QTextStream::operator__(this,(QString *)&local_60);\n  if (*local_60 != 0) {\n    if (*local_60 == -1) goto LAB_001ca4b8;\n    LOCK();\n    *local_60 = *local_60 + -1;\n    UNLOCK();\n    if (*local_60 != 0) goto LAB_001ca4b8;\n  }\n  QArrayData::deallocate((QArrayData *)local_60,2,8);\nLAB_001ca4b8:\n  if (local_68[0x20] != (QTextStream)0x0) {\n    QTextStream::operator__(local_68,' ');\n  }\n  QDebug::_QDebug((QDebug *)&local_68);\n  uVar1 = FUN_002037e0();\n  FUN_00202de0(uVar1,param_2);\n  QObject::blockSignals(SUB81(*(undefined8 *)(*(long *)(param_1 + 0x118) + 0x48),0));\n  QObject::blockSignals(SUB81(*(undefined8 *)(param_1 + 0x90),0));\n  KSelectAction::setCurrentItem((int)*(undefined8 *)(param_1 + 0x90));\n  QComboBox::setCurrentIndex((int)*(undefined8 *)(*(long *)(param_1 + 0x118) + 0x48));\n  QObject::blockSignals(SUB81(*(undefined8 *)(param_1 + 0x90),0));\n  QObject::blockSignals(SUB81(*(undefined8 *)(*(long *)(param_1 + 0x118) + 0x48),0));\n  FUN_00213330(*(undefined8 *)(param_1 + 0x50));\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return;\n}\n\n Revised code:\nvoid Kalzium::slotSwitchtoLookScheme(int which)\n{\n    qDebug() << \"slotSwitchtoLookScheme Kalzium\";\n\n    KalziumElementProperty::instance()->setScheme(which);\n\n    m_gradientWidget->scheme_combo->blockSignals(true);\n    look_action_schemes->blockSignals(true);\n\n    look_action_schemes->setCurrentItem(which);\n    m_gradientWidget->scheme_combo->setCurrentIndex(which);\n\n    look_action_schemes->blockSignals(false);\n    m_gradientWidget->scheme_combo->blockSignals(false);\n\n    m_legendWidget->updateContent();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined4 __thiscall RadiosondeGUI::handleMessage(RadiosondeGUI *this,Message *param_1)\n{\n  char cVar1;\n  undefined4 uVar2;\n  RS41Frame *pRVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  int *local_50;\n  long local_48;\n  local_48 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar2 = Radiosonde::MsgConfigureRadiosonde::match(param_1);\n  if ((char)uVar2 != '\\0') {\n    QString::operator_((QString *)(this + 0x88),(QString *)(param_1 + 0x10));\n    *(undefined4 *)(this + 0x90) = *(undefined4 *)(param_1 + 0x18);\n    *(Message *)(this + 0x94) = param_1[0x1c];\n    QString::operator_((QString *)(this + 0x98),(QString *)(param_1 + 0x20));\n    *(undefined4 *)(this + 0xa0) = *(undefined4 *)(param_1 + 0x28);\n    *(undefined2 *)(this + 0xa4) = *(undefined2 *)(param_1 + 0x2c);\n    *(undefined8 *)(this + 0xa8) = *(undefined8 *)(param_1 + 0x30);\n    *(undefined8 *)(this + 0xb0) = *(undefined8 *)(param_1 + 0x38);\n    if ((RadiosondeGUI *)0x38 < this + (0x74 - (long)param_1)) {\n      halt_baddata();\n    }\n    lVar4 = 0;\n    do {\n      *(undefined4 *)(this + lVar4 + 0xb8) = *(undefined4 *)(param_1 + lVar4 + 0x40);\n      lVar4 = lVar4 + 4;\n    } while (lVar4 != 0x40);\n    if ((RadiosondeGUI *)0x38 < this + (0x74 - (long)param_1)) {\n      halt_baddata();\n    }\n    lVar4 = 0;\n    do {\n      *(undefined4 *)(this + lVar4 + 0xf8) = *(undefined4 *)(param_1 + lVar4 + 0x80);\n      lVar4 = lVar4 + 4;\n    } while (lVar4 != 0x40);\n    blockApplySettings(this,true);\n    displaySettings(this);\n    blockApplySettings(this,false);\n    goto LAB_0011d43e;\n  }\n  cVar1 = MainCore::MsgPacket::match(param_1);\n  if (cVar1 == '\\0') goto LAB_0011d43e;\n  local_50 = *(int **)(param_1 + 0x18);\n  if (1 < *local_50 + 1U) {\n    LOCK();\n    *local_50 = *local_50 + 1;\n    UNLOCK();\n  }\n  pRVar3 = (RS41Frame *)RS41Frame::decode(SUB81(&local_50,0));\n  if (*local_50 == 0) {\nLAB_0011d5c0:\n    QArrayData::deallocate((QArrayData *)local_50,1,8);\n  }\n  else if (*local_50 != -1) {\n    LOCK();\n    *local_50 = *local_50 + -1;\n    UNLOCK();\n    if (*local_50 == 0) goto LAB_0011d5c0;\n  }\n  QDateTime::QDateTime((QDateTime *)&local_50,(QDateTime *)(param_1 + 0x20));\n  updateRadiosondes(this,pRVar3,(QDateTime)&local_50);\n  QDateTime::_QDateTime((QDateTime *)&local_50);\nLAB_0011d43e:\n  if (local_48 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n  __stack_chk_fail();\n}",
        "output": "```cpp\nvoid RadiosondeGUI::handleMessage(Message *msg)\n{\n    if (Radiosonde::MsgConfigureRadiosonde::match(msg)) {\n        this->name = msg->name;\n        this->frequency = msg->frequency;\n        this->id = msg->id;\n        this->type = msg->type;\n        this->altitude = msg->altitude;\n        this->latitude = msg->latitude;\n        this->longitude = msg->longitude;\n\n        for (int i = 0; i < 16; ++i) {\n            this->settings[i] = msg->settings[i];\n        }\n\n        for (int i = 0; i < 16; ++i) {\n            this->calibration[i] = msg->calibration[i];\n        }\n\n        blockApplySettings(true);\n        displaySettings();\n        blockApplySettings(false);\n        return;\n    }\n\n    if (MainCore::MsgPacket::match(msg)) {\n        int *refCount = msg->refCount;\n        if (*refCount > 1) {\n            LOCK();\n            (*refCount)++;\n            UNLOCK();\n        }\n\n        RS41Frame *frame = RS41Frame::decode(refCount);\n\n        if (*refCount == 0) {\n            QArrayData::deallocate(refCount, 1, 8);\n        } else if (*refCount != -1) {\n            LOCK();\n            (*refCount)--;\n            UNLOCK();\n            if (*refCount == 0) {\n                QArrayData::deallocate(refCount, 1, 8);\n            }\n        }\n\n        QDateTime timestamp = msg->timestamp;\n        updateRadiosondes(frame, timestamp);\n    }\n}\n```",
        "source_code": "bool RadiosondeGUI::handleMessage(const Message& message)\n{\n    if (Radiosonde::MsgConfigureRadiosonde::match(message))\n    {\n        qDebug(\"RadiosondeGUI::handleMessage: Radiosonde::MsgConfigureRadiosonde\");\n        const Radiosonde::MsgConfigureRadiosonde& cfg = (Radiosonde::MsgConfigureRadiosonde&) message;\n        m_settings = cfg.getSettings();\n        blockApplySettings(true);\n        displaySettings();\n        blockApplySettings(false);\n\n        return true;\n    }\n    else if (MainCore::MsgPacket::match(message))\n    {\n        MainCore::MsgPacket& report = (MainCore::MsgPacket&) message;\n\n        // Decode the message\n        RS41Frame *frame = RS41Frame::decode(report.getPacket());\n        // Update table\n        updateRadiosondes(frame, report.getDateTime());\n    }\n\n    return false;\n}",
        "parsed_output": "pp\nvoid RadiosondeGUI::handleMessage(Message *msg)\n{\n    if (Radiosonde::MsgConfigureRadiosonde::match(msg)) {\n        this->name = msg->name;\n        this->frequency = msg->frequency;\n        this->id = msg->id;\n        this->type = msg->type;\n        this->altitude = msg->altitude;\n        this->latitude = msg->latitude;\n        this->longitude = msg->longitude;\n\n        for (int i = 0; i < 16; ++i) {\n            this->settings[i] = msg->settings[i];\n        }\n\n        for (int i = 0; i < 16; ++i) {\n            this->calibration[i] = msg->calibration[i];\n        }\n\n        blockApplySettings(true);\n        displaySettings();\n        blockApplySettings(false);\n        return;\n    }\n\n    if (MainCore::MsgPacket::match(msg)) {\n        int *refCount = msg->refCount;\n        if (*refCount > 1) {\n            LOCK();\n            (*refCount)++;\n            UNLOCK();\n        }\n\n        RS41Frame *frame = RS41Frame::decode(refCount);\n\n        if (*refCount == 0) {\n            QArrayData::deallocate(refCount, 1, 8);\n        } else if (*refCount != -1) {\n            LOCK();\n            (*refCount)--;\n            UNLOCK();\n            if (*refCount == 0) {\n                QArrayData::deallocate(refCount, 1, 8);\n            }\n        }\n\n        QDateTime timestamp = msg->timestamp;\n        updateRadiosondes(frame, timestamp);\n    }\n}",
        "baseline_code_stripped": "undefined4 __thiscall RadiosondeGUI::handleMessage(RadiosondeGUI *this,Message *param_1)\n{\n  char cVar1;\n  undefined4 uVar2;\n  RS41Frame *pRVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  int *local_50;\n  long local_48;\n  local_48 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar2 = Radiosonde::MsgConfigureRadiosonde::match(param_1);\n  if ((char)uVar2 != '\\0') {\n    QString::operator_((QString *)(this + 0x88),(QString *)(param_1 + 0x10));\n    *(undefined4 *)(this + 0x90) = *(undefined4 *)(param_1 + 0x18);\n    *(Message *)(this + 0x94) = param_1[0x1c];\n    QString::operator_((QString *)(this + 0x98),(QString *)(param_1 + 0x20));\n    *(undefined4 *)(this + 0xa0) = *(undefined4 *)(param_1 + 0x28);\n    *(undefined2 *)(this + 0xa4) = *(undefined2 *)(param_1 + 0x2c);\n    *(undefined8 *)(this + 0xa8) = *(undefined8 *)(param_1 + 0x30);\n    *(undefined8 *)(this + 0xb0) = *(undefined8 *)(param_1 + 0x38);\n    if ((RadiosondeGUI *)0x38 < this + (0x74 - (long)param_1)) {\n      halt_baddata();\n    }\n    lVar4 = 0;\n    do {\n      *(undefined4 *)(this + lVar4 + 0xb8) = *(undefined4 *)(param_1 + lVar4 + 0x40);\n      lVar4 = lVar4 + 4;\n    } while (lVar4 != 0x40);\n    if ((RadiosondeGUI *)0x38 < this + (0x74 - (long)param_1)) {\n      halt_baddata();\n    }\n    lVar4 = 0;\n    do {\n      *(undefined4 *)(this + lVar4 + 0xf8) = *(undefined4 *)(param_1 + lVar4 + 0x80);\n      lVar4 = lVar4 + 4;\n    } while (lVar4 != 0x40);\n    blockApplySettings(this,true);\n    displaySettings(this);\n    blockApplySettings(this,false);\n    goto LAB_0011d43e;\n  }\n  cVar1 = MainCore::MsgPacket::match(param_1);\n  if (cVar1 == '\\0') goto LAB_0011d43e;\n  local_50 = *(int **)(param_1 + 0x18);\n  if (1 < *local_50 + 1U) {\n    LOCK();\n    *local_50 = *local_50 + 1;\n    UNLOCK();\n  }\n  pRVar3 = (RS41Frame *)RS41Frame::decode(SUB81(&local_50,0));\n  if (*local_50 == 0) {\nLAB_0011d5c0:\n    QArrayData::deallocate((QArrayData *)local_50,1,8);\n  }\n  else if (*local_50 != -1) {\n    LOCK();\n    *local_50 = *local_50 + -1;\n    UNLOCK();\n    if (*local_50 == 0) goto LAB_0011d5c0;\n  }\n  QDateTime::QDateTime((QDateTime *)&local_50,(QDateTime *)(param_1 + 0x20));\n  updateRadiosondes(this,pRVar3,(QDateTime)&local_50);\n  QDateTime::_QDateTime((QDateTime *)&local_50);\nLAB_0011d43e:\n  if (local_48 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.8212043046951294,
        "similarity_score_baseline_stripped": 0.6577950119972229
    },
    {
        "func_name": "uuid_unparse_x",
        "normed_func_sha256": "db8956c3fbd65a628f8a1ac65080658ed820ec9fc255ef3a8d58ae11eb600ecc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_001a3728(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 local_18;\n  undefined8 uStack_10;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  local_18 = param_2;\n  uStack_10 = param_3;\n  FUN_001a3570(param_1,&local_18,1,param_4,0,0,0,10);\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic ssize_t rxd_ep_inject(struct fid_ep *ep_fid, const void *buf, size_t len,\n\t\t\t     fi_addr_t dest_addr)\n{\n\tstruct rxd_ep *ep;\n\tstruct iovec iov;\n\n\tep = container_of(ep_fid, struct rxd_ep, util_ep.ep_fid.fid);\n\n\tiov.iov_base = (void *) buf;\n\tiov.iov_len = len;\n\n\treturn rxd_ep_generic_inject(ep, &iov, 1, dest_addr, 0, 0, ofi_op_msg,\n\t\t\t\t     RXD_NO_TX_COMP | RXD_INJECT);\n}\n\n## Example:\n\n Input code:\nvoid FUN_0027a080(undefined8 param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5)\n{\n  longlong in_r12;\n  longlong in_r13;\n  longlong local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  longlong local_10;\n  longlong local_8;\n  local_10 = in_r12 + 0x432040;\n  local_8 = *(longlong *)(in_r13 + -0x7010);\n  local_28 = CONCAT44(param_2,2);\n  local_20 = param_1;\n  local_18 = param_3;\n  FUN_00279de8(&local_28,param_4,&stack0x00000040,param_4,param_5,0);\n  if (local_8 == *(longlong *)(in_r13 + -0x7010)) {\n    return;\n  }\n  local_28 = in_r12 + 0x63ca80;\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid q_debug_call(const char *file, int line, const char *func, const char *fmt,\n    ...)\n{\n\t::std::va_list argp;\n\n\tva_start(argp, fmt);\n\n\tqDebugCallV(QMessageLogContext(file, line, func, \"default\"), fmt, argp);\n\n\tva_end(argp);\n}\n\n## Example:\n\n Input code:\nvoid FUN_0024d3d8(double param_1,int param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6,undefined8 param_7,undefined8 param_8,\n                 undefined8 param_9_00,undefined8 param_9,undefined8 param_11)\n{\n  undefined2 local_28 [8];\n  undefined2 local_18 [8];\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  if (param_2 == 0) {\n    __sprintf_chk(local_28,1,0xc,\"%d\",(int)param_1);\n    local_18[0] = 0x2a;\n  }\n  else if (param_2 == 1) {\n    local_28[0] = 0x2a;\n    __sprintf_chk(local_18,1,0xc,\"%d\",(int)(param_1 * 10.0));\n  }\n  __sprintf_chk(param_11,1,0xffffffffffffffff,\"-%s-%s-%s-%s-%s-*-%s-%s-75-75-%s-*-%s-%s\",param_3,\n                param_4,param_5,param_6,param_7,local_28,local_18,param_8,param_9_00,param_9);\n  if (local_8 != ___stack_chk_guard) {\n    __stack_chk_fail(1);\n  }\n  return;\n}\n\n Revised code:\nstatic int\ntext_get_xlfd (double  size,\n          int     size_type,\n          char   *foundry,\n          char   *family,\n          char   *weight,\n          char   *slant,\n          char   *set_width,\n          char   *spacing,\n          char   *registry,\n          char   *encoding,\n          char   *fontname)\n{\n  char pixel_size[12], point_size[12];\n\n  if (size > 0)\n    {\n      switch (size_type)\n   {\n   case PIXELS:\n     sprintf (pixel_size, \"%d\", (int) size);\n     sprintf (point_size, \"*\");\n     break;\n   case POINTS:\n     sprintf (pixel_size, \"*\");\n     sprintf (point_size, \"%d\", (int) (size * 10));\n     break;\n   }\n\n      /* create the fontname */\n      sprintf (fontname, \"-%s-%s-%s-%s-%s-*-%s-%s-75-75-%s-*-%s-%s\",\n          foundry,\n          family,\n          weight,\n          slant,\n          set_width,\n          pixel_size, point_size,\n          spacing,\n          registry, encoding);\n      return TRUE;\n    }\n  else\n    return FALSE;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00241a68(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6,undefined8 param_7)\n{\n  undefined4 local_18;\n  undefined2 local_14;\n  undefined2 local_12;\n  ushort local_10;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  FUN_00241a10(param_1,&local_18,0,param_4,param_5,param_2,param_7,param_3);\n  __sprintf_chk(param_2,1,0xffffffffffffffff,param_3,local_18,local_14,local_12,local_10 >> 8,\n                local_10 & 0xff);\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nstatic void format_and_log(const char *log_buffer, const char *format, const char *message,\n                           const char *param1, const char *param2, const char *param3,\n                           const char *param4)\n{\n    uint32_t value;\n    uint16_t high_byte, low_byte;\n    uint16_t combined_value;\n    long stack_guard;\n\n    stack_guard = ___stack_chk_guard;\n\n    process_log_data(log_buffer, &value, 0, param1, param2, format, param4, message);\n\n    sprintf(log_buffer, format, message, value, high_byte, low_byte, combined_value >> 8,\n            combined_value & 0xff);\n\n    if (stack_guard != ___stack_chk_guard) {\n        __stack_chk_fail();\n    }\n}\n```",
        "source_code": "static void uuid_unparse_x(const guuid_t uu, char *out, const char *fmt)\n{\n\tstruct uuid uuid;\n\n\tuuid_unpack(uu, &uuid);\n\tsprintf(out, fmt,\n\t\tuuid.time_low, uuid.time_mid, uuid.time_hi_and_version,\n\t\tuuid.clock_seq >> 8, uuid.clock_seq & 0xFF,\n\t\tuuid.node[0], uuid.node[1], uuid.node[2],\n\t\tuuid.node[3], uuid.node[4], uuid.node[5]);\n}",
        "parsed_output": "static void format_and_log(const char *log_buffer, const char *format, const char *message,\n                           const char *param1, const char *param2, const char *param3,\n                           const char *param4)\n{\n    uint32_t value;\n    uint16_t high_byte, low_byte;\n    uint16_t combined_value;\n    long stack_guard;\n\n    stack_guard = ___stack_chk_guard;\n\n    process_log_data(log_buffer, &value, 0, param1, param2, format, param4, message);\n\n    sprintf(log_buffer, format, message, value, high_byte, low_byte, combined_value >> 8,\n            combined_value & 0xff);\n\n    if (stack_guard != ___stack_chk_guard) {\n        __stack_chk_fail();\n    }\n}",
        "baseline_code_stripped": "void FUN_00241a68(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6,undefined8 param_7)\n{\n  undefined4 local_18;\n  undefined2 local_14;\n  undefined2 local_12;\n  ushort local_10;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  FUN_00241a10(param_1,&local_18,0,param_4,param_5,param_2,param_7,param_3);\n  __sprintf_chk(param_2,1,0xffffffffffffffff,param_3,local_18,local_14,local_12,local_10 >> 8,\n                local_10 & 0xff);\n  if (local_8 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.5785284638404846,
        "similarity_score_baseline_stripped": 0.45459458231925964
    },
    {
        "func_name": "Msg_PBackgroundIDBRequestConstructor",
        "normed_func_sha256": "cb55eb7c8f536637ae5fd3e404ce1e90fe84835296b24eec9eecaee31b8dbf12",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __thiscall mozilla::ipc::ThreadLink::SendMessage(ThreadLink *this,Message *param_1)\n{\n  int iVar1;\n  int iVar2;\n  iVar2 = *(int *)(*(int *)(this + 4) + 0x1c);\n  iVar1 = MessageLoop::current();\n  if (iVar2 == *(int *)(iVar1 + 8)) {\n    if (*(MessageChannel **)(this + 8) != (MessageChannel *)0x0) {\n      MessageChannel::OnMessageReceivedFromLink(*(MessageChannel **)(this + 8),param_1);\n    }\n    if (param_1 != (Message *)0x0) {\n      (**(code **)(*(int *)param_1 + 4))(param_1);\n    }\n    return;\n  }\n  __fprintf_chk(stderr,1,\"Assertion failure: %s, at %s:%d\\n\",\n                \"mWorkerLoopID == MessageLoop::current()->id() (not on worker thread!)\",\n                \"/builddir/build/BUILD/icecat-52.7.3/objdir/dist/include/mozilla/ipc/MessageChannel.h\"\n                ,0x1b8);\n  nsTraceRefcnt::WalkTheStack(stderr);\n  fflush(stderr);\n  gMozCrashReason =\n       \"MOZ_RELEASE_ASSERT(mWorkerLoopID == MessageLoop::current()->id()) (not on worker thread!)\";\n  _xul52 = 0x1b8;\n  abort();\n}\n\n Revised code:\nvoid\nThreadLink::SendMessage(Message *msg)\n{\n    mChan->AssertWorkerThread();\n    mChan->mMonitor->AssertCurrentThreadOwns();\n\n    if (mTargetChan)\n        mTargetChan->OnMessageReceivedFromLink(Move(*msg));\n    delete msg;\n}\n\n## Example:\n\n Input code:\nundefined4 __thiscall\ncontent::WebSharedWorkerProxy::Send(WebSharedWorkerProxy *this,Message *param_1)\n{\n  Message **ppMVar1;\n  Message *local_14 [2];\n  local_14[0] = param_1;\n  if (this[0x20] != (WebSharedWorkerProxy)0x0) {\n    ___Znwj__GLIBCXX_3_4_from_thumb(0x1c);\n  }\n  ppMVar1 = *(Message ***)(this + 0x14);\n  if (ppMVar1 != *(Message ***)(this + 0x18)) {\n    if (ppMVar1 != (Message **)0x0) {\n      *ppMVar1 = param_1;\n      ppMVar1 = *(Message ***)(this + 0x14);\n    }\n    *(Message ***)(this + 0x14) = ppMVar1 + 1;\n    return 1;\n  }\n  std::vector<IPC::Message*,std::allocator<IPC::Message*>>::_M_realloc_insert_IPC__Message_const__\n            ((vector_IPC__Message__std__allocator_IPC__Message___ *)(this + 0x10),\n             (__normal_iterator)ppMVar1,local_14);\n  return 1;\n}\n\n Revised code:\nbool WebSharedWorkerProxy::Send(IPC::Message* message) {\n  // It's possible that messages will be sent before the worker is created, in\n  // which case route_id_ will be none.  Or the worker object can be interacted\n  // with before the browser process told us that it started, in which case we\n  // also want to queue the message.\n  if (!created_) {\n    queued_messages_.push_back(message);\n    return true;\n  }\n\n  // For now we proxy all messages to the worker process through the browser.\n  // Revisit if we find this slow.\n  // TODO(jabdelmalek): handle sync messages if we need them.\n  IPC::Message* wrapped_msg = new ViewHostMsg_ForwardToWorker(*message);\n  delete message;\n  return router_->Send(wrapped_msg);\n}\n\n## Example:\n\n Input code:\nvoid __fastcall FUN_100e7930(MessageLite *param_1)\n{\n  uint *puVar1;\n  Arena *pAVar2;\n  puVar1 = (uint *)thunk_FUN_1008f9a0(0);\n  *puVar1 = *puVar1 | 1;\n  google::protobuf::MessageLite::GetArenaForAllocation(param_1);\n  pAVar2 = (Arena *)__RTC_CheckEsp();\n  google::protobuf::internal::ArenaStringPtr::Mutable((ArenaStringPtr *)(param_1 + 0x10),pAVar2);\n  __RTC_CheckEsp();\n  __RTC_CheckEsp();\n  return;\n}\n\n Revised code:\ninline std::string* ImageDataParameter::release_source() {\n  // @@protoc_insertion_point(field_release:opencv_caffe.ImageDataParameter.source)\n  if (!_internal_has_source()) {\n    return nullptr;\n  }\n  _has_bits_[0] &= ~0x00000001u;\n  auto* p = source_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());\n#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING\n  if (source_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {\n    source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), \"\", GetArenaForAllocation());\n  }\n#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING\n  return p;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nMessage * mozilla::dom::indexedDB::PBackgroundIDBTransaction::Msg_PBackgroundIDBRequestConstructor\n                    (int param_1)\n{\n  Message *this;\n  this = (Message *)moz_xmalloc(0x48);\n  IPC::Message::Message\n            (this,param_1,0x1a0006,1,0,0,\n             \"PBackgroundIDBTransaction::Msg_PBackgroundIDBRequestConstructor\");\n  return this;\n}",
        "output": "Message* PBackgroundIDBTransaction::CreateRequestConstructorMessage(int transactionId) {\n    return new IPC::Message(transactionId, 0x1a0006, IPC::Message::PRIORITY_NORMAL, 0, 0,\n                            \"PBackgroundIDBTransaction::Msg_PBackgroundIDBRequestConstructor\");\n}",
        "source_code": "IPC::Message*\nMsg_PBackgroundIDBRequestConstructor(int32_t routingId)\n{\n    return new IPC::Message(routingId, Msg_PBackgroundIDBRequestConstructor__ID, IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, \"PBackgroundIDBTransaction::Msg_PBackgroundIDBRequestConstructor\");\n}",
        "parsed_output": "Message* PBackgroundIDBTransaction::CreateRequestConstructorMessage(int transactionId) {\n    return new IPC::Message(transactionId, 0x1a0006, IPC::Message::PRIORITY_NORMAL, 0, 0,\n                            \"PBackgroundIDBTransaction::Msg_PBackgroundIDBRequestConstructor\");\n}",
        "baseline_code_stripped": "Message * mozilla::dom::indexedDB::PBackgroundIDBTransaction::Msg_PBackgroundIDBRequestConstructor\n                    (int param_1)\n{\n  Message *this;\n  this = (Message *)moz_xmalloc(0x48);\n  IPC::Message::Message\n            (this,param_1,0x1a0006,1,0,0,\n             \"PBackgroundIDBTransaction::Msg_PBackgroundIDBRequestConstructor\");\n  return this;\n}",
        "similarity_score_unixcoder": 0.8853619694709778,
        "similarity_score_baseline_stripped": 0.775827169418335
    },
    {
        "func_name": "SidePanelWidget::grabPixmapColor",
        "normed_func_sha256": "68a0e6de4ad7d42e7e0314f104dd0b56c1d58cdb8620541a88f74cd27b94c723",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid FUN_0012a0d8(QPixmap *param_1,undefined8 param_2,undefined8 param_3)\n{\n  char cVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined8 uVar4;\n  undefined8 local_50;\n  QSize aQStack_48 [24];\n  undefined8 local_30;\n  QImage aQStack_28 [24];\n  undefined8 local_10;\n  long local_8;\n  local_8 = ___stack_chk_guard;\n  QPixmap::QPixmap(param_1);\n  *(undefined8 *)(param_1 + 0x24) = 0;\n  FUN_00111f20(param_2,param_3,0x18);\n  cVar1 = QImage::isNull();\n  if (cVar1 == '\\0') {\n    iVar2 = QImage::height();\n    if ((0x30 < iVar2) || (iVar2 = QImage::width(), 0x30 < iVar2)) {\n      local_50 = 0x3000000030;\n      QImage::scaled(aQStack_48,(AspectRatioMode)&local_50,1);\n      uVar4 = local_30;\n      local_30 = local_10;\n      local_10 = uVar4;\n      QImage::_QImage(aQStack_28);\n    }\n    QPixmap::fromImage((QImage *)aQStack_48,0);\n    uVar4 = *(undefined8 *)(param_1 + 0x18);\n    *(undefined8 *)(param_1 + 0x18) = local_10;\n    local_10 = uVar4;\n    QPixmap::_QPixmap((QPixmap *)aQStack_28);\n    uVar3 = FUN_00110b60(param_2,param_3,0x18);\n    *(undefined4 *)(param_1 + 0x20) = uVar3;\n  }\n  QImage::_QImage((QImage *)aQStack_48);\n  if (local_8 != ___stack_chk_guard) {\n    __stack_chk_fail();\n  }\n  return;\n}\n\n Revised code:\nPreviewCursor::PreviewCursor(const XCursorThemeData &theme, const QString &name)\n{\n    // Create the preview pixmap\n    QImage image = theme.loadImage(name, previewSize);\n    if (image.isNull()) return;\n    int maxSize = previewSize*2;\n    if (image.height() > maxSize || image.width() > maxSize)\n    image = image.scaled(maxSize, maxSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);\n    mPixmap = QPixmap::fromImage(image);\n    // load the cursor\n    mCursorHandle = theme.loadCursorHandle(name, previewSize);\n}\n\n## Example:\n\n Input code:\nvoid FUN_0026ea08(long param_1,QColor *param_2)\n{\n  long lVar1;\n  char cVar2;\n  long lVar3;\n  undefined4 local_18;\n  undefined8 local_14;\n  undefined2 local_c;\n  lVar1 = ___stack_chk_guard;\n  cVar2 = QColor::operator__((QColor *)(param_1 + 0x34),param_2);\n  if (cVar2 != '\\0') {\n    QColor::operator_((QColor *)(param_1 + 0x34),param_2);\n    lVar3 = *(long *)(param_1 + 0x48);\n    QColor::dark((int)param_2);\n    *(undefined4 *)(lVar3 + 4) = local_18;\n    *(undefined8 *)(lVar3 + 8) = local_14;\n    *(undefined2 *)(lVar3 + 0x10) = local_c;\n    QWidget::update();\n  }\n  if (lVar1 == ___stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nvoid\nKLed::setColor(const QColor& col)\n{\n    if (led_color != col) {\n        led_color = col;\n        d->offcolor = col.dark(d->dark_factor);\n        delete d->on_map;\n        d->on_map = 0;\n        delete d->off_map;\n        d->off_map = 0;\n        update();\n    }\n}\n\n## Example:\n\n Input code:\nundefined4 * FUN_0001dfa8(undefined4 *param_1,QWidget *param_2)\n{\n  bool bVar1;\n  undefined4 uVar2;\n  undefined4 *this;\n  QGLFormat aQStack_54 [4];\n  QPainter aQStack_50 [4];\n  undefined4 local_4c;\n  undefined4 local_48;\n  undefined4 local_44;\n  undefined4 local_40;\n  QColor aQStack_3c [16];\n  int local_2c;\n  this = param_1 + 8;\n  local_2c = __stack_chk_guard;\n  QWidget::QWidget((QWidget *)param_1,param_2,0);\n  *param_1 = &PTR_LAB_000223b4_1_0002ad60;\n  param_1[2] = &PTR_DAT_0002ae3c;\n  QPixmap::QPixmap((QPixmap *)this);\n  *(undefined *)((int)param_1 + 0x31) = 0;\n  param_1[6] = 0;\n  *(undefined *)(param_1 + 7) = 0;\n  param_1[0xe] = &QArrayData::shared_null;\n  QGLFormat::defaultFormat();\n  bVar1 = SUB41(aQStack_54,0);\n  QGLFormat::setSampleBuffers(bVar1);\n  QGLFormat::setStencil(bVar1);\n  QGLFormat::setAlpha(bVar1);\n  QGLFormat::setAlphaBufferSize((int)aQStack_54);\n  QGLFormat::setDefaultFormat(aQStack_54);\n  param_1[0xd] = 0;\n  *(undefined *)(param_1 + 0xc) = 0;\n  QPixmap::QPixmap((QPixmap *)&local_4c,0x80,0x80);\n  uVar2 = param_1[0xb];\n  param_1[0xb] = local_40;\n  local_40 = uVar2;\n  QPixmap::_QPixmap((QPixmap *)&local_4c);\n  QColor::QColor(aQStack_3c,3);\n  QPixmap::fill((QColor *)this);\n  QPainter::QPainter(aQStack_50,(QPaintDevice *)this);\n  QColor::setRgb((int)aQStack_3c,0xe6,0xe6,0xe6);\n  local_4c = 0;\n  local_48 = 0;\n  local_44 = 0x3f;\n  local_40 = 0x3f;\n  QPainter::fillRect((QRect *)aQStack_50,(QColor *)&local_4c);\n  local_4c = 0x40;\n  local_44 = 0x7f;\n  local_40 = 0x7f;\n  local_48 = 0x40;\n  QPainter::fillRect((QRect *)aQStack_50,(QColor *)&local_4c);\n  QPainter::end();\n  QPainter::_QPainter(aQStack_50);\n  QGLFormat::_QGLFormat(aQStack_54);\n  if (local_2c == __stack_chk_guard) {\n    return param_1;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nArthurFrame::ArthurFrame(QWidget *parent)\n    : QWidget(parent)\n    , m_prefer_image(false)\n{\n#ifdef QT_OPENGL_SUPPORT\n    glw = 0;\n    m_use_opengl = false;\n    QGLFormat f = QGLFormat::defaultFormat();\n    f.setSampleBuffers(true);\n    f.setStencil(true);\n    f.setAlpha(true);\n    f.setAlphaBufferSize(8);\n    QGLFormat::setDefaultFormat(f);\n#endif\n    m_document = 0;\n    m_show_doc = false;\n    m_tile = QPixmap(128, 128);\n    m_tile.fill(Qt::white);\n    QPainter pt(&m_tile);\n    QColor color(230, 230, 230);\n    pt.fillRect(0, 0, 64, 64, color);\n    pt.fillRect(64, 64, 64, 64, color);\n    pt.end();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_00072dcc(undefined4 *param_1,int param_2,undefined4 *param_3)\n{\n  uint uVar1;\n  QRect aQStack_4c [16];\n  undefined4 local_3c;\n  undefined4 local_38;\n  undefined4 local_34;\n  undefined4 local_30;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  undefined2 uStack_20;\n  int local_1c;\n  local_1c = __stack_chk_guard;\n  QColor::invalidate();\n  if (*(int *)(param_2 + 0x28) != 0) {\n    local_3c = *param_3;\n    local_38 = param_3[1];\n    local_34 = local_3c;\n    local_30 = local_38;\n    QPixmap::copy(aQStack_4c);\n    QPixmap::toImage();\n    uVar1 = QImage::pixel((int)&local_3c,0);\n    QColor::QColor((QColor *)&local_2c,uVar1);\n    *param_1 = local_2c;\n    param_1[1] = local_28;\n    param_1[2] = uStack_24;\n    *(undefined2 *)(param_1 + 3) = uStack_20;\n    QImage::_QImage((QImage *)&local_3c);\n    QPixmap::_QPixmap((QPixmap *)aQStack_4c);\n  }\n  if (local_1c == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(param_1);\n}",
        "output": "```c\nvoid ColorPicker::pickColor(QColor &color, const QRect &rect, const QPixmap &pixmap)\n{\n    if (!rect.isEmpty()) {\n        QPixmap croppedPixmap = pixmap.copy(rect);\n        QImage image = croppedPixmap.toImage();\n        QRgb pixel = image.pixel(0, 0);\n        color = QColor(pixel);\n    }\n}\n```",
        "source_code": "QColor SidePanelWidget::grabPixmapColor(const QPoint& p)\n{\n    QColor c;\n    if (m_pixmap) {\n        QPixmap pixel = m_pixmap->copy(QRect(p, p));\n        c = pixel.toImage().pixel(0, 0);\n    }\n    return c;\n}",
        "parsed_output": "void ColorPicker::pickColor(QColor &color, const QRect &rect, const QPixmap &pixmap)\n{\n    if (!rect.isEmpty()) {\n        QPixmap croppedPixmap = pixmap.copy(rect);\n        QImage image = croppedPixmap.toImage();\n        QRgb pixel = image.pixel(0, 0);\n        color = QColor(pixel);\n    }\n}",
        "baseline_code_stripped": "void FUN_00072dcc(undefined4 *param_1,int param_2,undefined4 *param_3)\n{\n  uint uVar1;\n  QRect aQStack_4c [16];\n  undefined4 local_3c;\n  undefined4 local_38;\n  undefined4 local_34;\n  undefined4 local_30;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  undefined2 uStack_20;\n  int local_1c;\n  local_1c = __stack_chk_guard;\n  QColor::invalidate();\n  if (*(int *)(param_2 + 0x28) != 0) {\n    local_3c = *param_3;\n    local_38 = param_3[1];\n    local_34 = local_3c;\n    local_30 = local_38;\n    QPixmap::copy(aQStack_4c);\n    QPixmap::toImage();\n    uVar1 = QImage::pixel((int)&local_3c,0);\n    QColor::QColor((QColor *)&local_2c,uVar1);\n    *param_1 = local_2c;\n    param_1[1] = local_28;\n    param_1[2] = uStack_24;\n    *(undefined2 *)(param_1 + 3) = uStack_20;\n    QImage::_QImage((QImage *)&local_3c);\n    QPixmap::_QPixmap((QPixmap *)aQStack_4c);\n  }\n  if (local_1c == __stack_chk_guard) {\n    return;\n  }\n  __stack_chk_fail(param_1);\n}",
        "similarity_score_unixcoder": 0.8616024851799011,
        "similarity_score_baseline_stripped": 0.4989628791809082
    },
    {
        "func_name": "meth_QHttpPart_setRawHeader",
        "normed_func_sha256": "503417cc650e5607f07b1e6f41ec8513e53198c90648ddd575d7cd326b3a0b78",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined * FUN_0007e8b0(undefined4 param_1,undefined4 param_2)\n{\n  int iVar1;\n  undefined *puVar2;\n  int in_GS_OFFSET;\n  undefined4 local_30 [4];\n  undefined4 local_20;\n  QByteArray *local_1c;\n  undefined4 local_18;\n  undefined4 local_14;\n  int local_10;\n  undefined4 uStack_8;\n  uStack_8 = 0x7e8b6;\n  local_30[0] = param_1;\n  local_10 = *(int *)(in_GS_OFFSET + 0x14);\n  local_20 = 0;\n  local_18 = 0;\n  iVar1 = (**(code **)(DAT_000e68a8 + 0x140))\n                    (&local_20,param_2,&DAT_00098e7e,local_30,PTR_DAT_000e62bc,&local_1c,\n                     PTR_s_QByteArray_000e61e0,&local_14,&local_18);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_000e68a8 + 0x150))\n              (local_20,\"QHttpMultiPart\",\"setBoundary\",s_setBoundary_self__Union_QByteArr_000d9280);\n    puVar2 = (undefined *)0x0;\n  }\n  else {\n    QHttpMultiPart::setBoundary(local_1c);\n    (**(code **)(DAT_000e68a8 + 0x40))(local_14,PTR_s_QByteArray_000e61e0,local_18);\n    puVar2 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\n  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {\n    return puVar2;\n  }\n  FUN_00092c10();\n}\n\n Revised code:\nstatic PyObject *meth_QHttpMultiPart_setBoundary(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n\n    {\n        const  ::QByteArray* a0;\n        int a0State = 0;\n         ::QHttpMultiPart *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"BJ1\", &sipSelf, sipType_QHttpMultiPart, &sipCpp, sipType_QByteArray, &a0, &a0State))\n        {\n            sipCpp->setBoundary(*a0);\n            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    sipNoMethod(sipParseErr, sipName_QHttpMultiPart, sipName_setBoundary, doc_QHttpMultiPart_setBoundary);\n\n    return SIP_NULLPTR;\n}\n\n## Example:\n\n Input code:\nundefined * FUN_00165bd0(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined *puVar2;\n  long in_FS_OFFSET;\n  long local_50 [2];\n  undefined4 local_3c;\n  undefined8 local_38;\n  undefined8 local_30;\n  long *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  local_50[0] = param_1;\n  if ((param_1 == 0) || (iVar1 = (**(code **)(DAT_003db0d8 + 0x3a8))(param_1,param_2,0), iVar1 != 0)\n     ) {\n    local_3c = 0;\n    iVar1 = (**(code **)(DAT_003db0d8 + 0x280))\n                      (&local_38,param_2,&DAT_0019c2a6,local_50,PTR_DAT_003be560,&local_28,\n                       PTR_DAT_003be420,&local_30,&local_3c);\n    if (iVar1 == 0) goto LAB_00165d29;\n    QNetworkReply::ignoreSslErrorsImplementation((QList *)local_28);\n  }\n  else {\n    local_3c = 0;\n    iVar1 = (**(code **)(DAT_003db0d8 + 0x280))\n                      (&local_38,param_2,&DAT_0019c2a6,local_50,PTR_DAT_003be560,&local_28,\n                       PTR_DAT_003be420,&local_30,&local_3c);\n    if (iVar1 == 0) {\nLAB_00165d29:\n      (**(code **)(DAT_003db0d8 + 0x2a0))\n                (local_38,\"QNetworkReply\",\"ignoreSslErrorsImplementation\",\n                 s_ignoreSslErrorsImplementation_se_003c9d20);\n      puVar2 = (undefined *)0x0;\n      goto LAB_00165caf;\n    }\n    (**(code **)(*local_28 + 0x108))(local_28,local_30);\n  }\n  (**(code **)(DAT_003db0d8 + 0x80))(local_30,PTR_DAT_003be420,local_3c);\n  puVar2 = &_Py_NoneStruct;\n  __Py_NoneStruct = __Py_NoneStruct + 1;\nLAB_00165caf:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return puVar2;\n}\n\n Revised code:\nstatic PyObject *meth_QNetworkReply_ignoreSslErrorsImplementation(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));\n\n    {\n        const QList< ::QSslError>* a0;\n        int a0State = 0;\n         ::QNetworkReply *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"pJ1\", &sipSelf, sipType_QNetworkReply, &sipCpp, sipType_QList_0100QSslError, &a0, &a0State))\n        {\n            (sipSelfWasArg ? sipCpp-> ::QNetworkReply::ignoreSslErrorsImplementation(*a0) : sipCpp->ignoreSslErrorsImplementation(*a0));\n            sipReleaseType(const_cast<QList< ::QSslError> *>(a0), sipType_QList_0100QSslError, a0State);\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    sipNoMethod(sipParseErr, sipName_QNetworkReply, sipName_ignoreSslErrorsImplementation, doc_QNetworkReply_ignoreSslErrorsImplementation);\n\n    return SIP_NULLPTR;\n}\n\n## Example:\n\n Input code:\nundefined * FUN_0012f6b0(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined *puVar2;\n  long in_FS_OFFSET;\n  long local_50 [2];\n  undefined4 local_3c;\n  undefined8 local_38;\n  undefined8 local_30;\n  long *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  local_3c = 0;\n  local_50[0] = param_1;\n  iVar1 = (**(code **)(DAT_00154d78 + 0x280))\n                    (&local_38,param_2,&DAT_0013a90c,local_50,PTR_DAT_0014dd78,&local_28,\n                     PTR_s_QString_0014db10,&local_30,&local_3c);\n  if (iVar1 == 0) {\n    puVar2 = (undefined *)0x0;\n    (**(code **)(DAT_00154d78 + 0x2a0))\n              (local_38,\"QDesignerFormWindowInterface\",\"setAuthor\",s_setAuthor_self__str__001536b0);\n  }\n  else if (param_1 == 0) {\n    (**(code **)(DAT_00154d78 + 0x2a8))(\"QDesignerFormWindowInterface\",\"setAuthor\");\n    puVar2 = (undefined *)0x0;\n  }\n  else {\n    (**(code **)(*local_28 + 0x1e0))(local_28,local_30);\n    (**(code **)(DAT_00154d78 + 0x80))(local_30,PTR_s_QString_0014db10,local_3c);\n    puVar2 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar2;\n  }\n  __stack_chk_fail();\n}\n\n Revised code:\nstatic PyObject *sipDo_Atom_setPosition(PyObject *sipThisObj,PyObject *sipArgs)\n{\n\tsipThisType *sipThis;\n\tint sipArgsParsed = 0;\n\tif ((sipThis = sipGetThis(sipThisObj,&sipArgs,sipClass_Atom)) == NULL)\n\t\treturn NULL;\n\t{\n\t\tconst Vector3 * a0;\n\t\tPyObject *a0obj;\n\t\tif (sipParseArgs(&sipArgsParsed,sipArgs,\"I\",sipCanConvertTo_Vector3,&a0obj))\n\t\t{\n\t\t\tAtom *ptr;\n\t\t\tif ((ptr = (Atom *)sipGetCppPtr(sipThis,sipClass_Atom)) == NULL)\n\t\t\t\treturn NULL;\n\t\t\tint iserr = 0;\n\t\t\tsipConvertTo_Vector3(a0obj,(Vector3 **)&a0,1,&iserr);\n\t\t\tif (iserr)\n\t\t\t\treturn NULL;\n   try\n   {\n\t\t\tptr -> Atom::setPosition(* a0);\n   }\n   catch (...)\n    {\n      PyErr_SetString(PyExc_Exception, \"unknown\");\n      return NULL;\n\t\t}\n\t\t\tPy_INCREF(Py_None);\n\t\t\treturn Py_None;\n\t\t}\n\t}\n\tsipNoMethod(sipArgsParsed,sipName_BALL_Atom,sipName_BALL_setPosition);\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined * meth_QHttpPart_setRawHeader(undefined8 param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined *puVar3;\n  long in_FS_OFFSET;\n  undefined8 local_50;\n  undefined4 local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  QByteArray *local_38;\n  undefined8 local_30;\n  QByteArray *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = 0;\n  local_48 = 0;\n  local_44 = 0;\n  uVar2 = *(undefined8 *)(*(long *)(DAT_003bd558 + 0x40) + 0xb0);\n  local_50 = param_1;\n  iVar1 = (**(code **)(DAT_003bd560 + 0x1e8))\n                    (&local_40,param_2,&DAT_0018537b,&local_50,\n                     *(undefined8 *)(PTR_PTR_DAT_003a51e0 + 0xd0),&local_28,uVar2,&local_38,\n                     &local_48,uVar2,&local_30,&local_44);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_003bd560 + 0x208))\n              (local_40,\"QHttpPart\",\"setRawHeader\",s_QHttpPart_setRawHeader_QByteArra_003b6ca0);\n    puVar3 = (undefined *)0x0;\n  }\n  else {\n    uVar2 = PyEval_SaveThread();\n    QHttpPart::setRawHeader(local_28,local_38);\n    PyEval_RestoreThread(uVar2);\n    (**(code **)(DAT_003bd560 + 0x78))\n              (local_38,*(undefined8 *)(*(long *)(DAT_003bd558 + 0x40) + 0xb0),local_48);\n    (**(code **)(DAT_003bd560 + 0x78))\n              (local_30,*(undefined8 *)(*(long *)(DAT_003bd558 + 0x40) + 0xb0),local_44);\n    puVar3 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar3;\n  }\n  __stack_chk_fail();\n}",
        "output": "```c\nstatic PyObject *meth_QHttpPart_setRawHeader(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n\n    {\n        const ::QByteArray *a0;\n        const ::QByteArray *a1;\n        int a0State = 0;\n        int a1State = 0;\n        ::QHttpPart *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"BJ1J1\", &sipSelf, sipType_QHttpPart, &sipCpp, sipType_QByteArray, &a0, &a0State, sipType_QByteArray, &a1, &a1State))\n        {\n            PyThreadState *_save = PyEval_SaveThread();\n            sipCpp->setRawHeader(*a0, *a1);\n            PyEval_RestoreThread(_save);\n\n            sipReleaseType(const_cast< ::QByteArray *>(a0), sipType_QByteArray, a0State);\n            sipReleaseType(const_cast< ::QByteArray *>(a1), sipType_QByteArray, a1State);\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    sipNoMethod(sipParseErr, sipName_QHttpPart, sipName_setRawHeader, doc_QHttpPart_setRawHeader);\n\n    return SIP_NULLPTR;\n}\n```",
        "source_code": "static PyObject *meth_QHttpPart_setRawHeader(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = NULL;\n\n    {\n        const QByteArray* a0;\n        int a0State = 0;\n        const QByteArray* a1;\n        int a1State = 0;\n        QHttpPart *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"BJ1J1\", &sipSelf, sipType_QHttpPart, &sipCpp, sipType_QByteArray, &a0, &a0State, sipType_QByteArray, &a1, &a1State))\n        {\n            Py_BEGIN_ALLOW_THREADS\n            sipCpp->setRawHeader(*a0,*a1);\n            Py_END_ALLOW_THREADS\n            sipReleaseType(const_cast<QByteArray *>(a0),sipType_QByteArray,a0State);\n            sipReleaseType(const_cast<QByteArray *>(a1),sipType_QByteArray,a1State);\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    /* Raise an exception if the arguments couldn't be parsed. */\n    sipNoMethod(sipParseErr, sipName_QHttpPart, sipName_setRawHeader, doc_QHttpPart_setRawHeader);\n\n    return NULL;\n}",
        "parsed_output": "static PyObject *meth_QHttpPart_setRawHeader(PyObject *sipSelf, PyObject *sipArgs)\n{\n    PyObject *sipParseErr = SIP_NULLPTR;\n\n    {\n        const ::QByteArray *a0;\n        const ::QByteArray *a1;\n        int a0State = 0;\n        int a1State = 0;\n        ::QHttpPart *sipCpp;\n\n        if (sipParseArgs(&sipParseErr, sipArgs, \"BJ1J1\", &sipSelf, sipType_QHttpPart, &sipCpp, sipType_QByteArray, &a0, &a0State, sipType_QByteArray, &a1, &a1State))\n        {\n            PyThreadState *_save = PyEval_SaveThread();\n            sipCpp->setRawHeader(*a0, *a1);\n            PyEval_RestoreThread(_save);\n\n            sipReleaseType(const_cast< ::QByteArray *>(a0), sipType_QByteArray, a0State);\n            sipReleaseType(const_cast< ::QByteArray *>(a1), sipType_QByteArray, a1State);\n\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n\n    sipNoMethod(sipParseErr, sipName_QHttpPart, sipName_setRawHeader, doc_QHttpPart_setRawHeader);\n\n    return SIP_NULLPTR;\n}",
        "baseline_code_stripped": "undefined * meth_QHttpPart_setRawHeader(undefined8 param_1,undefined8 param_2)\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined *puVar3;\n  long in_FS_OFFSET;\n  undefined8 local_50;\n  undefined4 local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  QByteArray *local_38;\n  undefined8 local_30;\n  QByteArray *local_28;\n  long local_20;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = 0;\n  local_48 = 0;\n  local_44 = 0;\n  uVar2 = *(undefined8 *)(*(long *)(DAT_003bd558 + 0x40) + 0xb0);\n  local_50 = param_1;\n  iVar1 = (**(code **)(DAT_003bd560 + 0x1e8))\n                    (&local_40,param_2,&DAT_0018537b,&local_50,\n                     *(undefined8 *)(PTR_PTR_DAT_003a51e0 + 0xd0),&local_28,uVar2,&local_38,\n                     &local_48,uVar2,&local_30,&local_44);\n  if (iVar1 == 0) {\n    (**(code **)(DAT_003bd560 + 0x208))\n              (local_40,\"QHttpPart\",\"setRawHeader\",s_QHttpPart_setRawHeader_QByteArra_003b6ca0);\n    puVar3 = (undefined *)0x0;\n  }\n  else {\n    uVar2 = PyEval_SaveThread();\n    QHttpPart::setRawHeader(local_28,local_38);\n    PyEval_RestoreThread(uVar2);\n    (**(code **)(DAT_003bd560 + 0x78))\n              (local_38,*(undefined8 *)(*(long *)(DAT_003bd558 + 0x40) + 0xb0),local_48);\n    (**(code **)(DAT_003bd560 + 0x78))\n              (local_30,*(undefined8 *)(*(long *)(DAT_003bd558 + 0x40) + 0xb0),local_44);\n    puVar3 = &_Py_NoneStruct;\n    __Py_NoneStruct = __Py_NoneStruct + 1;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar3;\n  }\n  __stack_chk_fail();\n}",
        "similarity_score_unixcoder": 0.9767855405807495,
        "similarity_score_baseline_stripped": 0.6345498561859131
    },
    {
        "func_name": "UTF8FromUTF32Character",
        "normed_func_sha256": "1746e707e72c633e27792917341bd24c0689a9d21a68987b6cf464d8b6313218",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined4 FUN_0809f8b0(uint param_1,byte *param_2)\n{\n  byte bVar1;\n  bVar1 = (byte)param_1;\n  if (param_1 < 0x80) {\n    *param_2 = bVar1;\n    param_2[1] = 0;\n    return 1;\n  }\n  if (param_1 < 0x800) {\n    param_2[2] = 0;\n    param_2[1] = (bVar1 & 0x3f) + 0x80;\n    *param_2 = (char)(param_1 >> 6) - 0x40;\n    return 2;\n  }\n  if ((0x1fff < param_1 - 0xe000) && (0xd7ff < param_1)) {\n    param_2[4] = 0;\n    *param_2 = (char)(param_1 >> 0x12) - 0x10;\n    param_2[1] = (char)((param_1 & 0x3ffff) >> 0xc) + 0x80;\n    param_2[3] = (bVar1 & 0x3f) + 0x80;\n    param_2[2] = (char)((param_1 & 0xfff) >> 6) + 0x80;\n    return 4;\n  }\n  param_2[3] = 0;\n  *param_2 = (char)(param_1 >> 0xc) - 0x20;\n  param_2[2] = (bVar1 & 0x3f) + 0x80;\n  param_2[1] = (char)((param_1 & 0xfff) >> 6) + 0x80;\n  return 3;\n}\n\n Revised code:\nint\tucs_to_utf8 (u_32int_t key, unsigned char *utf8str, size_t utf8strsiz)\n{\n\tif (key <= 0x007F)\n\t{\n\t\tutf8str[0] = key;\n\t\tutf8str[1] = 0;\n\t\treturn 1;\n\t}\n\telse if (key <= 0x07FF)\n\t{\n\t\tutf8str[0] = key / 64 + 192;\n\t\tutf8str[1] = key % 64 + 128;\n\t\tutf8str[2] = 0;\n\t\treturn 2;\n\t}\n\telse if (key <= 0xD7FF || (key >= 0xE000 && key <= 0xFFFF))\n\t{\n\t\tutf8str[0] = key / 4096 + 224;\n\t\tutf8str[1] = (key % 4096) / 64 + 128;\n\t\tutf8str[2] = key % 64 + 128;\n\t\tutf8str[3] = 0;\n\t\treturn 3;\n\t}\n\telse\n\t{\n\t\tutf8str[0] = key / 262144 + 240;\n\t\tutf8str[1] = (key % 262144) / 4096 + 128;\n\t\tutf8str[2] = (key % 4096) / 64 + 128;\n\t\tutf8str[3] = key % 64 + 128;\n\t\tutf8str[4] = 0;\n\t\treturn 4;\n\t}\n}\n\n## Example:\n\n Input code:\nuint FUN_0010c110(long param_1,long param_2,uint *param_3,uint *param_4,uint *param_5)\n{\n  byte bVar1;\n  uint uVar2;\n  if ((param_1 == 0) || (param_2 == 0)) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = *(uint *)(param_2 + 8) & 0x80;\n    if (uVar2 != 0) {\n      uVar2 = 0;\n      if (param_3 != (uint *)0x0) {\n        *param_3 = *(uint *)(param_2 + 0xe0);\n        uVar2 = 0x80;\n      }\n      if (param_4 != (uint *)0x0) {\n        *param_4 = *(uint *)(param_2 + 0xe4);\n        uVar2 = 0x80;\n      }\n      if (param_5 != (uint *)0x0) {\n        bVar1 = *(byte *)(param_2 + 0xe8);\n        *param_5 = (uint)bVar1;\n        if (bVar1 == 1) {\n          if (param_3 != (uint *)0x0) {\n            *param_3 = (uint)(long)((double)(ulong)*param_3 * 0.0254 + 0.5);\n          }\n          if (param_4 != (uint *)0x0) {\n            *param_4 = (uint)(long)((double)(ulong)*param_4 * 0.0254 + 0.5);\n          }\n        }\n        return 0x80;\n      }\n    }\n  }\n  return uVar2;\n}\n\n Revised code:\npng_uint_32 PNGAPI\n__kimtoy__png_get_pHYs_dpi(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)\n{\n   png_uint_32 retval = 0;\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      png_debug1(1, \"in %s retrieval function\", \"pHYs\");\n\n      if (res_x != NULL)\n      {\n         *res_x = info_ptr->x_pixels_per_unit;\n         retval |= PNG_INFO_pHYs;\n      }\n\n      if (res_y != NULL)\n      {\n         *res_y = info_ptr->y_pixels_per_unit;\n         retval |= PNG_INFO_pHYs;\n      }\n\n      if (unit_type != NULL)\n      {\n         *unit_type = (int)info_ptr->phys_unit_type;\n         retval |= PNG_INFO_pHYs;\n\n         if (*unit_type == 1)\n         {\n            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);\n            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);\n         }\n      }\n   }\n\n   return (retval);\n}\n\n## Example:\n\n Input code:\nvoid FUN_00157c94(int param_1,uint *param_2,uint *param_3,uint *param_4,uint *param_5)\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  if ((*(char *)(param_1 + 0x31b5) == '\\0') || (*(char *)(param_1 + 0x31b6) == '\\0')) {\n    if ((int)((uint)*(byte *)(param_1 + 0x316c) << 0x19) < 0) {\n      *param_2 = (uint)*(byte *)(param_1 + 0x316f) << 8 | (uint)*(byte *)(param_1 + 0x3170) << 0x10\n                 | (uint)*(byte *)(param_1 + 0x316e) | (*(byte *)(param_1 + 0x316c) & 0xf) << 0x18;\n      param_2[1] = 0;\n      return;\n    }\n  }\n  else if ((int)((uint)*(byte *)(param_1 + 0x316c) << 0x19) < 0) {\n    uVar3 = (uint)*(byte *)(param_1 + 0x316f) << 8 | (uint)*(byte *)(param_1 + 0x3170) << 0x10 |\n            (uint)*(byte *)(param_1 + 0x316e) | (uint)*(byte *)(param_1 + 0x3175) << 0x18;\n    *param_2 = uVar3;\n    param_2[1] = (int)uVar3 >> 0x1f;\n    return;\n  }\n  *param_3 = (uint)*(ushort *)(param_1 + 0x316f);\n  *param_4 = *(byte *)(param_1 + 0x316c) & 0xf;\n  bVar1 = *(byte *)(param_1 + 0x316e);\n  *param_5 = (uint)bVar1;\n  iVar5 = *(int *)(param_1 + 0x314c);\n  uVar3 = *param_3;\n  uVar4 = *param_4;\n  iVar2 = *(int *)(param_1 + 0x3150);\n  param_2[1] = 0;\n  *param_2 = iVar2 * (iVar5 * uVar3 + uVar4) + (bVar1 - 1);\n  return;\n}\n\n Revised code:\nstatic void get_lbachs (struct ide_hdf *ide, uae_u64 *lbap, unsigned int *cyl, unsigned int *head, unsigned int *sec)\n{\n\tif (ide->lba48 && ide->lba48cmd && (ide->regs.ide_select & 0x40)) {\n\t\tuae_u64 lba;\n\t\tlba = (ide->regs.ide_hcyl << 16) | (ide->regs.ide_lcyl << 8) | ide->regs.ide_sector;\n\t\tlba |= ((uae_u64)(((ide->regs.ide_hcyl2 << 16) | (ide->regs.ide_lcyl2 << 8) | ide->regs.ide_sector2))) << 24;\n\t\t*lbap = lba;\n\t} else {\n\t\tif ((ide->regs.ide_select & 0x40) && ide->lba) {\n\t\t\t*lbap = ((ide->regs.ide_select & 15) << 24) | (ide->regs.ide_hcyl << 16) | (ide->regs.ide_lcyl << 8) | ide->regs.ide_sector;\n\t\t} else {\n\t\t\t*cyl = (ide->regs.ide_hcyl << 8) | ide->regs.ide_lcyl;\n\t\t\t*head = ide->regs.ide_select & 15;\n\t\t\t*sec = ide->regs.ide_sector;\n\t\t\t*lbap = (((uae_u64)(*cyl) * ide->hdhfd.heads + (*head)) * ide->hdhfd.secspertrack) + (*sec) - 1;\n\t\t}\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall FUN_0046cf70(int param_1,byte *param_2)\n{\n  byte bVar1;\n  byte bVar2;\n  byte bVar3;\n  if (param_1 < 0x80) {\n    *param_2 = (byte)param_1;\n    param_2[1] = 0;\n    return;\n  }\n  bVar2 = (byte)param_1 & 0x3f | 0x80;\n  bVar1 = (byte)(param_1 >> 6);\n  if (param_1 < 0x800) {\n    *param_2 = bVar1 | 0xc0;\n    param_2[1] = bVar2;\n    param_2[2] = 0;\n    return;\n  }\n  bVar1 = bVar1 & 0x3f | 0x80;\n  bVar3 = (byte)(param_1 >> 0xc);\n  if (param_1 < 0x10000) {\n    *param_2 = bVar3 | 0xe0;\n    param_2[1] = bVar1;\n    param_2[2] = bVar2;\n    param_2[3] = 0;\n    return;\n  }\n  *param_2 = (byte)(param_1 >> 0x12) | 0xf0;\n  param_2[1] = bVar3 & 0x3f | 0x80;\n  param_2[2] = bVar1;\n  param_2[3] = bVar2;\n  param_2[4] = 0;\n  return;\n}",
        "output": "```c\nvoid encode_utf8(int codepoint, unsigned char *output)\n{\n    if (codepoint < 0x80) {\n        output[0] = (unsigned char)codepoint;\n        output[1] = 0;\n    } else if (codepoint < 0x800) {\n        output[0] = (unsigned char)((codepoint >> 6) | 0xC0);\n        output[1] = (unsigned char)((codepoint & 0x3F) | 0x80);\n        output[2] = 0;\n    } else if (codepoint < 0x10000) {\n        output[0] = (unsigned char)((codepoint >> 12) | 0xE0);\n        output[1] = (unsigned char)(((codepoint >> 6) & 0x3F) | 0x80);\n        output[2] = (unsigned char)((codepoint & 0x3F) | 0x80);\n        output[3] = 0;\n    } else {\n        output[0] = (unsigned char)((codepoint >> 18) | 0xF0);\n        output[1] = (unsigned char)(((codepoint >> 12) & 0x3F) | 0x80);\n        output[2] = (unsigned char)(((codepoint >> 6) & 0x3F) | 0x80);\n        output[3] = (unsigned char)((codepoint & 0x3F) | 0x80);\n        output[4] = 0;\n    }\n}\n```",
        "source_code": "void UTF8FromUTF32Character(int uch, char *putf) {\n\tsize_t k = 0;\n\tif (uch < 0x80) {\n\t\tputf[k++] = static_cast<char>(uch);\n\t} else if (uch < 0x800) {\n\t\tputf[k++] = static_cast<char>(0xC0 | (uch >> 6));\n\t\tputf[k++] = static_cast<char>(0x80 | (uch & 0x3f));\n\t} else if (uch < 0x10000) {\n\t\tputf[k++] = static_cast<char>(0xE0 | (uch >> 12));\n\t\tputf[k++] = static_cast<char>(0x80 | ((uch >> 6) & 0x3f));\n\t\tputf[k++] = static_cast<char>(0x80 | (uch & 0x3f));\n\t} else {\n\t\tputf[k++] = static_cast<char>(0xF0 | (uch >> 18));\n\t\tputf[k++] = static_cast<char>(0x80 | ((uch >> 12) & 0x3f));\n\t\tputf[k++] = static_cast<char>(0x80 | ((uch >> 6) & 0x3f));\n\t\tputf[k++] = static_cast<char>(0x80 | (uch & 0x3f));\n\t}\n\tputf[k] = '\\0';\n}",
        "parsed_output": "void encode_utf8(int codepoint, unsigned char *output)\n{\n    if (codepoint < 0x80) {\n        output[0] = (unsigned char)codepoint;\n        output[1] = 0;\n    } else if (codepoint < 0x800) {\n        output[0] = (unsigned char)((codepoint >> 6) | 0xC0);\n        output[1] = (unsigned char)((codepoint & 0x3F) | 0x80);\n        output[2] = 0;\n    } else if (codepoint < 0x10000) {\n        output[0] = (unsigned char)((codepoint >> 12) | 0xE0);\n        output[1] = (unsigned char)(((codepoint >> 6) & 0x3F) | 0x80);\n        output[2] = (unsigned char)((codepoint & 0x3F) | 0x80);\n        output[3] = 0;\n    } else {\n        output[0] = (unsigned char)((codepoint >> 18) | 0xF0);\n        output[1] = (unsigned char)(((codepoint >> 12) & 0x3F) | 0x80);\n        output[2] = (unsigned char)(((codepoint >> 6) & 0x3F) | 0x80);\n        output[3] = (unsigned char)((codepoint & 0x3F) | 0x80);\n        output[4] = 0;\n    }\n}",
        "baseline_code_stripped": "void __fastcall FUN_0046cf70(int param_1,byte *param_2)\n{\n  byte bVar1;\n  byte bVar2;\n  byte bVar3;\n  if (param_1 < 0x80) {\n    *param_2 = (byte)param_1;\n    param_2[1] = 0;\n    return;\n  }\n  bVar2 = (byte)param_1 & 0x3f | 0x80;\n  bVar1 = (byte)(param_1 >> 6);\n  if (param_1 < 0x800) {\n    *param_2 = bVar1 | 0xc0;\n    param_2[1] = bVar2;\n    param_2[2] = 0;\n    return;\n  }\n  bVar1 = bVar1 & 0x3f | 0x80;\n  bVar3 = (byte)(param_1 >> 0xc);\n  if (param_1 < 0x10000) {\n    *param_2 = bVar3 | 0xe0;\n    param_2[1] = bVar1;\n    param_2[2] = bVar2;\n    param_2[3] = 0;\n    return;\n  }\n  *param_2 = (byte)(param_1 >> 0x12) | 0xf0;\n  param_2[1] = bVar3 & 0x3f | 0x80;\n  param_2[2] = bVar1;\n  param_2[3] = bVar2;\n  param_2[4] = 0;\n  return;\n}",
        "similarity_score_unixcoder": 0.8446399569511414,
        "similarity_score_baseline_stripped": 0.5491164922714233
    },
    {
        "func_name": "arv_gc_integer_get_min",
        "normed_func_sha256": "66db7c85dd71f6fd3325c116e2f4f5f14fed8d4d7fe193a9472759537081716f",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool FUN_00237470(long param_1,long param_2)\n{\n  long **pplVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long lVar5;\n  if (param_2 == 0) {\n    g_return_if_fail_warning(&DAT_0024cac1,\"vala_typeof_expression_real_check\",\"context != NULL\");\n    return false;\n  }\n  iVar2 = vala_code_node_get_checked();\n  if (iVar2 == 0) {\n    vala_code_node_set_checked(param_1,1);\n    uVar3 = vala_typeof_expression_get_type_reference(param_1);\n    vala_code_node_check(uVar3,param_2);\n    lVar4 = vala_code_context_get_analyzer(param_2);\n    vala_expression_set_value_type(param_1,*(undefined8 *)(lVar4 + 0xd0));\n    iVar2 = vala_code_context_get_profile(param_2);\n    if (iVar2 == 0) {\n      uVar3 = vala_typeof_expression_get_type_reference(param_1);\n      iVar2 = vala_data_type_has_type_arguments(uVar3);\n      if (iVar2 != 0) {\n        uVar3 = vala_code_node_get_source_reference(**(undefined8 **)(param_1 + 0x28));\n        vala_report_warning(uVar3,\"Type argument list without effect\");\n      }\n    }\n    pplVar1 = (long **)**(long ***)(param_1 + 0x28);\n    lVar4 = vala_array_type_get_type();\n    if (pplVar1 != (long **)0x0) {\n      if ((*pplVar1 == (long *)0x0) || (lVar4 != **pplVar1)) {\n        iVar2 = g_type_check_instance_is_a(pplVar1,lVar4);\n        if (iVar2 == 0) goto LAB_0023750a;\n      }\n      uVar3 = g_type_check_instance_cast(pplVar1,lVar4);\n      uVar3 = vala_array_type_get_element_type(uVar3);\n      lVar4 = vala_data_type_get_type_symbol(uVar3);\n      lVar5 = vala_code_context_get_analyzer(param_2);\n      lVar5 = vala_data_type_get_type_symbol(*(undefined8 *)(lVar5 + 0xc0));\n      if (lVar4 != lVar5) {\n        uVar3 = vala_code_node_get_source_reference(**(undefined8 **)(param_1 + 0x28));\n        vala_report_warning(uVar3,\n                            \"Arrays do not have a `GLib.Type\\', with the exception of `string[]\\'\");\n      }\n    }\n  }\nLAB_0023750a:\n  iVar2 = vala_code_node_get_error(param_1);\n  return iVar2 == 0;\n}\n\n Revised code:\nstatic gboolean\nvala_typeof_expression_real_check (ValaCodeNode* base,\n                                   ValaCodeContext* context)\n{\n\tValaTypeofExpression * self;\n\tgboolean _tmp0_;\n\tgboolean _tmp1_;\n\tValaDataType* _tmp4_;\n\tValaDataType* _tmp5_;\n\tValaSemanticAnalyzer* _tmp6_;\n\tValaSemanticAnalyzer* _tmp7_;\n\tValaDataType* _tmp8_;\n\tgboolean _tmp9_ = FALSE;\n\tValaProfile _tmp10_;\n\tValaProfile _tmp11_;\n\tgboolean _tmp17_ = FALSE;\n\tValaDataType* _tmp18_;\n\tgboolean _tmp32_;\n\tgboolean _tmp33_;\n\tgboolean result = FALSE;\n\tself = (ValaTypeofExpression*) base;\n\tg_return_val_if_fail (context != NULL, FALSE);\n\t_tmp0_ = vala_code_node_get_checked ((ValaCodeNode*) self);\n\t_tmp1_ = _tmp0_;\n\tif (_tmp1_) {\n\t\tgboolean _tmp2_;\n\t\tgboolean _tmp3_;\n\t\t_tmp2_ = vala_code_node_get_error ((ValaCodeNode*) self);\n\t\t_tmp3_ = _tmp2_;\n\t\tresult = !_tmp3_;\n\t\treturn result;\n\t}\n\tvala_code_node_set_checked ((ValaCodeNode*) self, TRUE);\n\t_tmp4_ = vala_typeof_expression_get_type_reference (self);\n\t_tmp5_ = _tmp4_;\n\tvala_code_node_check ((ValaCodeNode*) _tmp5_, context);\n\t_tmp6_ = vala_code_context_get_analyzer (context);\n\t_tmp7_ = _tmp6_;\n\t_tmp8_ = _tmp7_->type_type;\n\tvala_expression_set_value_type ((ValaExpression*) self, _tmp8_);\n\t_tmp10_ = vala_code_context_get_profile (context);\n\t_tmp11_ = _tmp10_;\n\tif (_tmp11_ == VALA_PROFILE_GOBJECT) {\n\t\tValaDataType* _tmp12_;\n\t\tValaDataType* _tmp13_;\n\t\t_tmp12_ = vala_typeof_expression_get_type_reference (self);\n\t\t_tmp13_ = _tmp12_;\n\t\t_tmp9_ = vala_data_type_has_type_arguments (_tmp13_);\n\t} else {\n\t\t_tmp9_ = FALSE;\n\t}\n\tif (_tmp9_) {\n\t\tValaDataType* _tmp14_;\n\t\tValaSourceReference* _tmp15_;\n\t\tValaSourceReference* _tmp16_;\n\t\t_tmp14_ = self->priv->_data_type;\n\t\t_tmp15_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp14_);\n\t\t_tmp16_ = _tmp15_;\n\t\tvala_report_warning (_tmp16_, \"Type argument list without effect\");\n\t}\n\t_tmp18_ = self->priv->_data_type;\n\tif (VALA_IS_ARRAY_TYPE (_tmp18_)) {\n\t\tValaDataType* _tmp19_;\n\t\tValaDataType* _tmp20_;\n\t\tValaDataType* _tmp21_;\n\t\tValaTypeSymbol* _tmp22_;\n\t\tValaTypeSymbol* _tmp23_;\n\t\tValaSemanticAnalyzer* _tmp24_;\n\t\tValaSemanticAnalyzer* _tmp25_;\n\t\tValaDataType* _tmp26_;\n\t\tValaTypeSymbol* _tmp27_;\n\t\tValaTypeSymbol* _tmp28_;\n\t\t_tmp19_ = self->priv->_data_type;\n\t\t_tmp20_ = vala_array_type_get_element_type (G_TYPE_CHECK_INSTANCE_CAST (_tmp19_, VALA_TYPE_ARRAY_TYPE, ValaArrayType));\n\t\t_tmp21_ = _tmp20_;\n\t\t_tmp22_ = vala_data_type_get_type_symbol (_tmp21_);\n\t\t_tmp23_ = _tmp22_;\n\t\t_tmp24_ = vala_code_context_get_analyzer (context);\n\t\t_tmp25_ = _tmp24_;\n\t\t_tmp26_ = _tmp25_->string_type;\n\t\t_tmp27_ = vala_data_type_get_type_symbol (_tmp26_);\n\t\t_tmp28_ = _tmp27_;\n\t\t_tmp17_ = _tmp23_ != _tmp28_;\n\t} else {\n\t\t_tmp17_ = FALSE;\n\t}\n\tif (_tmp17_) {\n\t\tValaDataType* _tmp29_;\n\t\tValaSourceReference* _tmp30_;\n\t\tValaSourceReference* _tmp31_;\n\t\t_tmp29_ = self->priv->_data_type;\n\t\t_tmp30_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp29_);\n\t\t_tmp31_ = _tmp30_;\n\t\tvala_report_warning (_tmp31_, \"Arrays do not have a `GLib.Type', with the exception of `string[]'\");\n\t}\n\t_tmp32_ = vala_code_node_get_error ((ValaCodeNode*) self);\n\t_tmp33_ = _tmp32_;\n\tresult = !_tmp33_;\n\treturn result;\n}\n\n## Example:\n\n Input code:\nundefined8 FUN_00158990(long param_1,undefined8 param_2)\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long **pplVar4;\n  pplVar4 = *(long ***)(param_1 + 0x20);\n  if (pplVar4 != (long **)0x0) {\n    lVar2 = gee_sorted_set_get_type();\n    if (((*pplVar4 == (long *)0x0) || (**pplVar4 != lVar2)) &&\n       (iVar1 = g_type_check_instance_is_a(pplVar4), iVar1 == 0)) {\n      pplVar4 = (long **)0x0;\n    }\n  }\n  if (pplVar4 == (long **)0x0) {\n    g_return_if_fail_warning(0,\"gee_sorted_set_floor\",\"self != NULL\");\n    return 0;\n  }\n  uVar3 = gee_sorted_set_get_type();\n  lVar2 = g_type_interface_peek(*pplVar4,uVar3);\n  uVar3 = (**(code **)(lVar2 + 0x50))(pplVar4,param_2);\n  return uVar3;\n}\n\n Revised code:\nstatic gpointer gee_read_only_sorted_set_real_floor (GeeSortedSet* base, gconstpointer element) {\n\tGeeReadOnlySortedSet * self;\n\tgpointer result = NULL;\n\tGeeCollection* _tmp0_;\n\tgconstpointer _tmp1_;\n\tgpointer _tmp2_ = NULL;\n\tself = (GeeReadOnlySortedSet*) base;\n\t_tmp0_ = ((GeeReadOnlyCollection*) self)->_collection;\n\t_tmp1_ = element;\n\t_tmp2_ = gee_sorted_set_floor (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, GEE_TYPE_SORTED_SET) ? ((GeeSortedSet*) _tmp0_) : NULL, _tmp1_);\n\tresult = _tmp2_;\n\treturn result;\n}\n\n## Example:\n\n Input code:\nvoid FUN_002de960(longlong **param_1,undefined8 param_2)\n{\n  longlong lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  longlong lStack_28;\n  lVar1 = FUN_001be580();\n  if ((param_1 != (longlong **)0x0) &&\n     (((*param_1 != (longlong *)0x0 && (**param_1 == lVar1)) ||\n      (lVar1 = g_type_check_instance_is_a(param_1,lVar1), lVar1 != 0)))) {\n    gtk_entry_get_text(*param_1[3]);\n    uVar2 = g_strdup();\n    lVar1 = FUN_001d0a00();\n    if (lVar1 == 0) {\n      uVar3 = FUN_001d8340(param_1,uVar2,param_2);\n    }\n    else {\n      uVar3 = 3;\n      if (*(int *)(param_1[3] + 1) == 0) {\n        uVar3 = 1;\n      }\n    }\n    FUN_001cb3a0(param_1,uVar3,param_2);\n    g_free(uVar2);\n    return;\n  }\n  g_return_if_fail_warning(lStack_28 + -0x1979d8,lStack_28 + -0x17d218,lStack_28 + -0x17ce40);\n  return;\n}\n\n Revised code:\nstatic void\ncomponents_validator_validate_entry (ComponentsValidator* self,\n                                     ComponentsValidatorTrigger reason)\n{\n\tgchar* value = NULL;\n\tGtkEntry* _tmp0_;\n\tconst gchar* _tmp1_;\n\tgchar* _tmp2_;\n\tComponentsValidatorValidity new_state = 0;\n\tComponentsValidatorValidity _tmp3_;\n\tconst gchar* _tmp4_;\n\tComponentsValidatorValidity _tmp8_;\n\tg_return_if_fail (COMPONENTS_IS_VALIDATOR (self));\n\t_tmp0_ = self->priv->_target;\n\t_tmp1_ = gtk_entry_get_text (_tmp0_);\n\t_tmp2_ = g_strdup (_tmp1_);\n\tvalue = _tmp2_;\n\t_tmp3_ = self->priv->_state;\n\tnew_state = _tmp3_;\n\t_tmp4_ = value;\n\tif (geary_string_is_empty_or_whitespace (_tmp4_)) {\n\t\tComponentsValidatorValidity _tmp5_ = 0;\n\t\tgboolean _tmp6_;\n\t\t_tmp6_ = self->priv->_is_required;\n\t\tif (_tmp6_) {\n\t\t\t_tmp5_ = COMPONENTS_VALIDATOR_VALIDITY_EMPTY;\n\t\t} else {\n\t\t\t_tmp5_ = COMPONENTS_VALIDATOR_VALIDITY_VALID;\n\t\t}\n\t\tnew_state = _tmp5_;\n\t} else {\n\t\tconst gchar* _tmp7_;\n\t\t_tmp7_ = value;\n\t\tnew_state = components_validator_do_validate (self, _tmp7_, reason);\n\t}\n\t_tmp8_ = new_state;\n\tcomponents_validator_update_state (self, _tmp8_, reason);\n\t_g_free0 (value);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nundefined8 arv_gc_integer_get_min(long **param_1,long *param_2)\n{\n  int iVar1;\n  undefined4 uVar2;\n  long lVar3;\n  undefined8 uVar4;\n  lVar3 = arv_gc_integer_get_type();\n  if (param_1 == (long **)0x0) {\nLAB_0012e130:\n    g_return_if_fail_warning(\"Aravis\",\"arv_gc_integer_get_min\",\"ARV_IS_GC_INTEGER (gc_integer)\");\n    uVar4 = 0;\n  }\n  else {\n    if ((*param_1 == (long *)0x0) || (**param_1 != lVar3)) {\n      iVar1 = g_type_check_instance_is_a(param_1);\n      if (iVar1 == 0) goto LAB_0012e130;\n    }\n    if ((param_2 != (long *)0x0) && (*param_2 != 0)) {\n      g_return_if_fail_warning(\"Aravis\",\"arv_gc_integer_get_min\",\"error == NULL || *error == NULL\");\n      return 0;\n    }\n    uVar4 = arv_gc_integer_get_type();\n    lVar3 = g_type_interface_peek(*param_1,uVar4);\n    if (*(code **)(lVar3 + 0x20) != (code *)0x0) {\n      uVar4 = (**(code **)(lVar3 + 0x20))(param_1,param_2);\n      return uVar4;\n    }\n    uVar4 = arv_gc_feature_node_get_type();\n    uVar4 = g_type_check_instance_cast(param_1,uVar4);\n    uVar4 = arv_gc_feature_node_get_name(uVar4);\n    uVar2 = arv_gc_error_quark();\n    g_set_error(param_2,uVar2,0,\"<Min> node not found for \\'%s\\'\",uVar4);\n    uVar4 = 0x8000000000000000;\n  }\n  return uVar4;\n}",
        "output": "```c\nstatic gint64\narv_gc_integer_get_min (ArvGcInteger *gc_integer, GError **error)\n{\n\tgint64 result = G_MININT64;\n\tg_return_val_if_fail (ARV_IS_GC_INTEGER (gc_integer), 0);\n\tg_return_val_if_fail (error == NULL || *error == NULL, 0);\n\n\tArvGcIntegerInterface *iface = ARV_GC_INTEGER_GET_IFACE (gc_integer);\n\n\tif (iface->get_min != NULL) {\n\t\tresult = iface->get_min (gc_integer, error);\n\t} else {\n\t\tconst gchar *name = arv_gc_feature_node_get_name (ARV_GC_FEATURE_NODE (gc_integer));\n\t\tg_set_error (error,\n\t\t             ARV_GC_ERROR,\n\t\t             0,\n\t\t             \"<Min> node not found for '%s'\",\n\t\t             name);\n\t}\n\n\treturn result;\n}\n```",
        "source_code": "gint64\narv_gc_integer_get_min (ArvGcInteger *gc_integer, GError **error)\n{\n\tArvGcIntegerInterface *integer_interface;\n\tg_return_val_if_fail (ARV_IS_GC_INTEGER (gc_integer), 0);\n\tg_return_val_if_fail (error == NULL || *error == NULL, 0);\n\tinteger_interface = ARV_GC_INTEGER_GET_INTERFACE (gc_integer);\n\tif (integer_interface->get_min != NULL)\n\t\treturn integer_interface->get_min (gc_integer, error);\n\tg_set_error (error, ARV_GC_ERROR, ARV_GC_ERROR_PROPERTY_NOT_DEFINED, \"<Min> node not found for '%s'\",\n\t\t     arv_gc_feature_node_get_name (ARV_GC_FEATURE_NODE (gc_integer)));\n\treturn G_MININT64;\n}",
        "parsed_output": "static gint64\narv_gc_integer_get_min (ArvGcInteger *gc_integer, GError **error)\n{\n\tgint64 result = G_MININT64;\n\tg_return_val_if_fail (ARV_IS_GC_INTEGER (gc_integer), 0);\n\tg_return_val_if_fail (error == NULL || *error == NULL, 0);\n\n\tArvGcIntegerInterface *iface = ARV_GC_INTEGER_GET_IFACE (gc_integer);\n\n\tif (iface->get_min != NULL) {\n\t\tresult = iface->get_min (gc_integer, error);\n\t} else {\n\t\tconst gchar *name = arv_gc_feature_node_get_name (ARV_GC_FEATURE_NODE (gc_integer));\n\t\tg_set_error (error,\n\t\t             ARV_GC_ERROR,\n\t\t             0,\n\t\t             \"<Min> node not found for '%s'\",\n\t\t             name);\n\t}\n\n\treturn result;\n}",
        "baseline_code_stripped": "undefined8 arv_gc_integer_get_min(long **param_1,long *param_2)\n{\n  int iVar1;\n  undefined4 uVar2;\n  long lVar3;\n  undefined8 uVar4;\n  lVar3 = arv_gc_integer_get_type();\n  if (param_1 == (long **)0x0) {\nLAB_0012e130:\n    g_return_if_fail_warning(\"Aravis\",\"arv_gc_integer_get_min\",\"ARV_IS_GC_INTEGER (gc_integer)\");\n    uVar4 = 0;\n  }\n  else {\n    if ((*param_1 == (long *)0x0) || (**param_1 != lVar3)) {\n      iVar1 = g_type_check_instance_is_a(param_1);\n      if (iVar1 == 0) goto LAB_0012e130;\n    }\n    if ((param_2 != (long *)0x0) && (*param_2 != 0)) {\n      g_return_if_fail_warning(\"Aravis\",\"arv_gc_integer_get_min\",\"error == NULL || *error == NULL\");\n      return 0;\n    }\n    uVar4 = arv_gc_integer_get_type();\n    lVar3 = g_type_interface_peek(*param_1,uVar4);\n    if (*(code **)(lVar3 + 0x20) != (code *)0x0) {\n      uVar4 = (**(code **)(lVar3 + 0x20))(param_1,param_2);\n      return uVar4;\n    }\n    uVar4 = arv_gc_feature_node_get_type();\n    uVar4 = g_type_check_instance_cast(param_1,uVar4);\n    uVar4 = arv_gc_feature_node_get_name(uVar4);\n    uVar2 = arv_gc_error_quark();\n    g_set_error(param_2,uVar2,0,\"<Min> node not found for \\'%s\\'\",uVar4);\n    uVar4 = 0x8000000000000000;\n  }\n  return uVar4;\n}",
        "similarity_score_unixcoder": 0.967740535736084,
        "similarity_score_baseline_stripped": 0.7515625953674316
    },
    {
        "func_name": "f_5499",
        "normed_func_sha256": "66e944bf44171c80612571c49154b43297880b0e636dbac57ffa76e8d15441ea",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid f_14189(int param_1,int *param_2)\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int aiStack_20 [4];\n  undefined auStack_10 [4];\n  undefined4 local_c;\n  local_c = __stack_chk_guard;\n  iVar1 = *param_2;\n  iVar2 = param_2[1];\n  if (param_1 < 4) {\n    iVar3 = 3;\n  }\n  else {\n    iVar3 = 0;\n  }\n  if (iVar3 < (int)(auStack_10 + -C_stack_limit) >> 2) {\n    if (param_1 < 4) {\n      param_2 = aiStack_20;\n    }\n    iVar3 = *(int *)(DAT_00213cdc + 4);\n    *param_2 = iVar3;\n    param_2[1] = *(int *)(iVar1 + 8);\n    param_2[2] = iVar2;\n    param_2[3] = *(int *)(iVar1 + 0xc);\n    (**(code **)(iVar3 + 4))(4);\n    halt_baddata();\n  }\n  C_save_and_reclaim(f_14189,2,param_2);\n}\n\n Revised code:\nstatic void C_ccall f_14189(C_word c,C_word *av){\nC_word tmp;\nC_word t0=av[0];\nC_word t1=av[1];\nC_word t2;\nC_word *a;\nif(C_unlikely(!C_demand(C_calculate_demand(0,c,3)))){\nC_save_and_reclaim((void *)f_14189,2,av);}\n/* compiler.scm:1651: foreign-type-check */\nt2=*((C_word*)lf[250]+1);{\nC_word *av2;\nif(c >= 4) {\n  av2=av; /* Re-use our own argvector */\n} else {\n  av2=C_alloc(4);\n}\nav2[0]=t2;\nav2[1]=((C_word*)t0)[2];\nav2[2]=t1;\nav2[3]=((C_word*)t0)[3];\n((C_proc)(void*)(*((C_word*)t2+1)))(4,av2);}}\n\n## Example:\n\n Input code:\nvoid f_11361(int param_1,int *param_2)\n{\n  int iVar1;\n  int iVar2;\n  int aiStack_38 [4];\n  undefined auStack_28 [4];\n  undefined4 local_24;\n  iVar2 = *param_2;\n  iVar1 = param_2[1];\n  local_24 = __stack_chk_guard;\n  if ((int)(uint)(param_1 < 2) < (int)(auStack_28 + -C_stack_limit) >> 2) {\n    C_mutate2(*(int *)(iVar2 + 8) + 4,*(undefined4 *)(DAT_00216c04 + 4));\n    C_mutate2(DAT_00216c04 + 4,*(undefined4 *)(*(int *)(iVar2 + 0xc) + 4));\n    if (param_1 < 2) {\n      param_2 = aiStack_38;\n    }\n    *param_2 = iVar1;\n    param_2[1] = 0x1e;\n    (**(code **)(iVar1 + 4))(2,param_2);\n    halt_baddata();\n  }\n  C_save_and_reclaim(f_11361,2,param_2);\n}\n\n Revised code:\nstatic void C_ccall f_11361(C_word c,C_word *av){\nC_word tmp;\nC_word t0=av[0];\nC_word t1=av[1];\nC_word t2;\nC_word t3;\nC_word t4;\nC_word *a;\nif(!C_demand(C_calculate_demand(0,c,1))){C_save_and_reclaim((void *)f_11361,2,av);}\nt2=C_mutate2(((C_word *)((C_word*)t0)[2])+1,*((C_word*)lf[344]+1));\nt3=C_mutate2((C_word*)lf[344]+1 /* (set! ##sys#syntax-context ...) */,((C_word*)((C_word*)t0)[3])[1]);\nt4=t1;{\nC_word *av2;\nif(c >= 2) {\n  av2=av; /* Re-use our own argvector */\n} else {\n  av2=C_alloc(2);\n}\nav2[0]=t4;\nav2[1]=C_SCHEME_UNDEFINED;\n((C_proc)(void*)(*((C_word*)t4+1)))(2,av2);}}\n\n## Example:\n\n Input code:\nvoid f_3417(int param_1,int *param_2)\n{\n  int iVar1;\n  int aiStack_40 [6];\n  undefined4 local_28;\n  code *local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  code *local_18;\n  undefined auStack_10 [4];\n  undefined4 local_c;\n  local_c = __stack_chk_guard;\n  if (param_1 < 7) {\n    iVar1 = 0xb;\n  }\n  else {\n    iVar1 = 5;\n  }\n  if ((int)(auStack_10 + -C_stack_limit) >> 2 <= iVar1) {\n    C_save_and_reclaim(f_3417,2,param_2);\n  }\n  local_28 = 0x24000002;\n  local_24 = f_3420;\n  local_20 = *(undefined4 *)(*param_2 + 8);\n  if (param_1 < 5) {\n    param_2 = aiStack_40;\n  }\n  local_1c = 0x24000001;\n  local_18 = f_4692;\n  iVar1 = *(int *)(DAT_0022b920 + 4);\n  *param_2 = iVar1;\n  param_2[1] = (int)&local_28;\n  param_2[4] = (int)&local_1c;\n  param_2[2] = DAT_0022bdc8;\n  param_2[3] = 0x11;\n  (**(code **)(iVar1 + 4))(5);\n  halt_baddata();\n}\n\n Revised code:\nstatic void C_ccall f_3417(C_word c,C_word *av){\nC_word tmp;\nC_word t0=av[0];\nC_word t1=av[1];\nC_word t2;\nC_word t3;\nC_word t4;\nC_word *a;\nif(C_unlikely(!C_demand(C_calculate_demand(5,c,6)))){\nC_save_and_reclaim((void *)f_3417,2,av);}\na=C_alloc(5);\nt2=(*a=C_CLOSURE_TYPE|2,a[1]=(C_word)f_3420,a[2]=((C_word*)t0)[2],tmp=(C_word)a,a+=3,tmp);\nt3=(*a=C_CLOSURE_TYPE|1,a[1]=(C_word)f_4692,tmp=(C_word)a,a+=2,tmp);\n/* c-platform.scm:847: rewrite */\nt4=*((C_word*)lf[56]+1);{\nC_word *av2;\nif(c >= 5) {\n  av2=av; /* Re-use our own argvector */\n} else {\n  av2=C_alloc(5);\n}\nav2[0]=t4;\nav2[1]=t2;\nav2[2]=lf[354];\nav2[3]=C_fix(8);\nav2[4]=t3;\n((C_proc)(void*)(*((C_word*)t4+1)))(5,av2);}}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid f_5499(int param_1,int *param_2)\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  int aiStack_28 [3];\n  undefined auStack_1c [12];\n  undefined auStack_10 [4];\n  undefined4 local_c;\n  local_c = __stack_chk_guard;\n  iVar1 = *param_2;\n  iVar3 = param_2[1];\n  puVar2 = auStack_10 + -C_stack_limit;\n  if (param_1 < 4) {\n    if (0xc < (int)puVar2) {\n      param_2 = aiStack_28;\n    }\n    if (puVar2 != (undefined *)0xc &&\n        (int)(auStack_1c + -C_stack_limit) < 0 == SBORROW4((int)puVar2,0xc)) {\nLAB_001a25a4:\n      *param_2 = 0;\n      param_2[1] = *(int *)(iVar1 + 8);\n      iVar1 = *(int *)(DAT_002206a0 + 4);\n      param_2[3] = iVar3;\n      param_2[2] = iVar1;\n      C_apply(4);\n    }\n  }\n  else if (0 < (int)puVar2) goto LAB_001a25a4;\n  C_save_and_reclaim(f_5499,2,param_2);\n}",
        "output": "```c\nstatic void C_ccall f_5499(C_word c, C_word *av) {\n    C_word tmp;\n    C_word t0 = av[0];\n    C_word t1 = av[1];\n    C_word t2;\n    C_word t3;\n    C_word *a;\n\n    if (C_unlikely(!C_demand(C_calculate_demand(0, c, 4)))) {\n        C_save_and_reclaim((void *)f_5499, 2, av);\n    }\n\n    t2 = ((C_word *)t0)[2];\n    t3 = t1;\n\n    {\n        C_word *av2;\n        if (c >= 4) {\n            av2 = av; /* Re-use our own argvector */\n        } else {\n            av2 = C_alloc(4);\n        }\n\n        av2[0] = C_fix(0);\n        av2[1] = ((C_word *)t2)[2];\n        av2[2] = *((C_word *)lf[123] + 1);\n        av2[3] = t3;\n\n        ((C_proc)(void *)(*((C_word *)lf[123] + 1)))(4, av2);\n    }\n}\n```",
        "source_code": "static void C_ccall f_5499(C_word c,C_word *av){\nC_word tmp;\nC_word t0=av[0];\nC_word t1=av[1];\nC_word t2;\nC_word *a;\nif(!C_demand(C_calculate_demand(0,c,3))){C_save_and_reclaim((void *)f_5499,2,av);}{\nC_word *av2;\nif(c >= 4) {\n  av2=av; /* Re-use our own argvector */\n} else {\n  av2=C_alloc(4);\n}\nav2[0]=0;\nav2[1]=((C_word*)t0)[2];\nav2[2]=*((C_word*)lf[1]+1);\nav2[3]=t1;\nC_apply(4,av2);}}",
        "parsed_output": "static void C_ccall f_5499(C_word c, C_word *av) {\n    C_word tmp;\n    C_word t0 = av[0];\n    C_word t1 = av[1];\n    C_word t2;\n    C_word t3;\n    C_word *a;\n\n    if (C_unlikely(!C_demand(C_calculate_demand(0, c, 4)))) {\n        C_save_and_reclaim((void *)f_5499, 2, av);\n    }\n\n    t2 = ((C_word *)t0)[2];\n    t3 = t1;\n\n    {\n        C_word *av2;\n        if (c >= 4) {\n            av2 = av; /* Re-use our own argvector */\n        } else {\n            av2 = C_alloc(4);\n        }\n\n        av2[0] = C_fix(0);\n        av2[1] = ((C_word *)t2)[2];\n        av2[2] = *((C_word *)lf[123] + 1);\n        av2[3] = t3;\n\n        ((C_proc)(void *)(*((C_word *)lf[123] + 1)))(4, av2);\n    }\n}",
        "baseline_code_stripped": "void f_5499(int param_1,int *param_2)\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  int aiStack_28 [3];\n  undefined auStack_1c [12];\n  undefined auStack_10 [4];\n  undefined4 local_c;\n  local_c = __stack_chk_guard;\n  iVar1 = *param_2;\n  iVar3 = param_2[1];\n  puVar2 = auStack_10 + -C_stack_limit;\n  if (param_1 < 4) {\n    if (0xc < (int)puVar2) {\n      param_2 = aiStack_28;\n    }\n    if (puVar2 != (undefined *)0xc &&\n        (int)(auStack_1c + -C_stack_limit) < 0 == SBORROW4((int)puVar2,0xc)) {\nLAB_001a25a4:\n      *param_2 = 0;\n      param_2[1] = *(int *)(iVar1 + 8);\n      iVar1 = *(int *)(DAT_002206a0 + 4);\n      param_2[3] = iVar3;\n      param_2[2] = iVar1;\n      C_apply(4);\n    }\n  }\n  else if (0 < (int)puVar2) goto LAB_001a25a4;\n  C_save_and_reclaim(f_5499,2,param_2);\n}",
        "similarity_score_unixcoder": 0.9327801465988159,
        "similarity_score_baseline_stripped": 0.6884806156158447
    },
    {
        "func_name": "add_scroll_tab",
        "normed_func_sha256": "41c13930b400388c6b32f66633af5f59ab55e1266c65831887b67df095986dcb",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nundefined4 FUN_0013038c(undefined4 param_1,int param_2,undefined4 param_3)\n{\n  undefined4 *puVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  uVar2 = FUN_001557ec(DAT_0020c370,*(undefined4 *)(param_2 + 4));\n  puVar1 = DAT_0020c370;\n  uVar3 = FUN_0012b080(*DAT_0020c370,0x38,4);\n  FUN_0017c6c8(uVar3,puVar1,uVar2,param_1,param_2,param_3);\n  FUN_0015bffc(DAT_0020c384,uVar3);\n  return uVar2;\n}\n\n Revised code:\nValue *Nucleus::createSelect(Value *C, Value *ifTrue, Value *ifFalse)\n{\n\tRR_DEBUG_INFO_UPDATE_LOC();\n\tASSERT(ifTrue->getType() == ifFalse->getType());\n\n\tauto result = ::function->makeVariable(ifTrue->getType());\n\tauto *select = Ice::InstSelect::create(::function, result, C, ifTrue, ifFalse);\n\t::basicBlock->appendInst(select);\n\n\treturn V(result);\n}\n\n## Example:\n\n Input code:\nvoid FUN_080aae0c(undefined *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n{\n  undefined4 uVar1;\n  undefined *puVar2;\n  *param_1 = 0x71;\n  param_1[1] = 0x4c;\n  uVar1 = FUN_080aa914(param_1 + 2,param_2);\n  uVar1 = FUN_080aa930(uVar1,param_3);\n  puVar2 = (undefined *)FUN_080aaa34(uVar1,param_4);\n  *puVar2 = 0;\n  return;\n}\n\n Revised code:\nstatic char *\npack_threadlist_request (pkt, startflag, threadcount, nextthread)\n     char *pkt;\n     int startflag;\n     int threadcount;\n     threadref *nextthread;\n{\n  *pkt++ = 'q';\t\t\t/* info query packet */\n  *pkt++ = 'L';\t\t\t/* Process LIST or threadLIST request */\n  pkt = pack_nibble (pkt, startflag);\t/* initflag 1 bytes */\n  pkt = pack_hex_byte (pkt, threadcount);\t/* threadcount 2 bytes */\n  pkt = pack_threadid (pkt, nextthread);\t/* 64 bit thread identifier */\n  *pkt = '\\0';\n  return pkt;\n}\n\n## Example:\n\n Input code:\nundefined4 * FUN_0806e420(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n{\n  undefined4 *puVar1;\n  undefined4 uVar2;\n  puVar1 = (undefined4 *)malloc(0x14);\n  puVar1[1] = 0;\n  *puVar1 = 0;\n  puVar1[2] = param_1;\n  puVar1[3] = param_2;\n  uVar2 = FUN_0806e550(param_3);\n  puVar1[4] = uVar2;\n  return puVar1;\n}\n\n Revised code:\nsraSpan *\nsraSpanCreate(int start, int end, const sraSpanList *subspan) {\n  sraSpan *item = (sraSpan*)malloc(sizeof(sraSpan));\n  item->_next = item->_prev = NULL;\n  item->start = start;\n  item->end = end;\n  item->subspan = sraSpanListDup(subspan);\n  return item;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid FUN_0806fd40(undefined4 param_1)\n{\n  undefined4 *puVar1;\n  undefined4 uVar2;\n  puVar1 = (undefined4 *)malloc(8);\n  uVar2 = FUN_08088b50(param_1);\n  *puVar1 = uVar2;\n  puVar1[1] = DAT_0809eca8;\n  DAT_0809eca8 = puVar1;\n  return;\n}",
        "output": "Node *createNode(int value) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode->data = processValue(value);\n    newNode->next = head;\n    head = newNode;\n}",
        "source_code": "static void\nadd_scroll_tab(item)\n    Char *item;\n{\n    struct scroll_tab_list *new_scroll;\n\n    new_scroll = (struct scroll_tab_list *) xmalloc((size_t)\n\t    sizeof(struct scroll_tab_list));\n    new_scroll->element = Strsave(item);\n    new_scroll->next = scroll_tab;\n    scroll_tab = new_scroll;\n}",
        "parsed_output": "Node *createNode(int value) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode->data = processValue(value);\n    newNode->next = head;\n    head = newNode;\n}",
        "baseline_code_stripped": "void FUN_0806fd40(undefined4 param_1)\n{\n  undefined4 *puVar1;\n  undefined4 uVar2;\n  puVar1 = (undefined4 *)malloc(8);\n  uVar2 = FUN_08088b50(param_1);\n  *puVar1 = uVar2;\n  puVar1[1] = DAT_0809eca8;\n  DAT_0809eca8 = puVar1;\n  return;\n}",
        "similarity_score_unixcoder": 0.4826661944389343,
        "similarity_score_baseline_stripped": 0.3374846279621124
    }
]